package com.android.server.am;

import android.annotation.OppoHook;
import android.annotation.OppoHook.OppoHookType;
import android.annotation.OppoHook.OppoRomType;
import android.app.ActivityManager;
import android.app.ActivityManager.ProcessErrorStateInfo;
import android.app.ActivityManager.RecentTaskInfo;
import android.app.ActivityManager.RunningAppProcessInfo;
import android.app.ActivityManager.RunningServiceInfo;
import android.app.ActivityManager.RunningTaskInfo;
import android.app.ActivityManager.StackId;
import android.app.ActivityManager.StackInfo;
import android.app.ActivityManager.TaskDescription;
import android.app.ActivityManager.TaskSnapshot;
import android.app.ActivityManager.TaskThumbnail;
import android.app.ActivityManager.TaskThumbnailInfo;
import android.app.ActivityManagerInternal;
import android.app.ActivityManagerInternal.SleepToken;
import android.app.ActivityOptions;
import android.app.ActivityThread;
import android.app.AlertDialog;
import android.app.AppGlobals;
import android.app.ApplicationErrorReport.CrashInfo;
import android.app.ApplicationErrorReport.ParcelableCrashInfo;
import android.app.ContentProviderHolder;
import android.app.Dialog;
import android.app.IActivityController;
import android.app.IActivityManager.Stub;
import android.app.IAppTask;
import android.app.IApplicationThread;
import android.app.IInstrumentationWatcher;
import android.app.INotificationManager;
import android.app.IOppoActivityManager;
import android.app.IOppoKinectActivityController;
import android.app.IProcessObserver;
import android.app.IServiceConnection;
import android.app.IStopUserCallback;
import android.app.ITaskStackListener;
import android.app.IUiAutomationConnection;
import android.app.IUidObserver;
import android.app.IUserSwitchObserver;
import android.app.Notification;
import android.app.Notification.Builder;
import android.app.NotificationManager;
import android.app.OppoThemeHelper;
import android.app.PendingIntent;
import android.app.PictureInPictureParams;
import android.app.ProfilerInfo;
import android.app.RemoteAction;
import android.app.WaitResult;
import android.app.assist.AssistContent;
import android.app.assist.AssistStructure;
import android.app.backup.IBackupManager;
import android.app.usage.UsageStatsManagerInternal;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.ContentProvider;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.content.IContentProvider;
import android.content.IIntentReceiver;
import android.content.IIntentSender;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.UriPermission;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.ConfigurationInfo;
import android.content.pm.IPackageDataObserver;
import android.content.pm.IPackageManager;
import android.content.pm.InstrumentationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.pm.PackageManagerInternal;
import android.content.pm.ParceledListSlice;
import android.content.pm.PathPermission;
import android.content.pm.ProviderInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.UserInfo;
import android.content.res.CompatibilityInfo;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.database.ContentObserver;
import android.graphics.Bitmap;
import android.graphics.Point;
import android.graphics.Rect;
import android.metrics.LogMaker;
import android.net.ConnectivityManager;
import android.net.NetworkPolicyManager;
import android.net.ProxyInfo;
import android.net.Uri;
import android.net.arp.OppoArpPeer;
import android.os.Binder;
import android.os.Build;
import android.os.Bundle;
import android.os.Debug;
import android.os.Debug.MemoryInfo;
import android.os.DropBoxManager;
import android.os.Environment;
import android.os.FactoryTest;
import android.os.FileObserver;
import android.os.FileUtils;
import android.os.Handler;
import android.os.IBinder;
import android.os.IBinder.DeathRecipient;
import android.os.IPermissionController;
import android.os.IProcessInfoService;
import android.os.IProgressListener;
import android.os.LocaleList;
import android.os.Looper;
import android.os.Message;
import android.os.Parcel;
import android.os.ParcelFileDescriptor;
import android.os.PersistableBundle;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.os.PowerManagerInternal;
import android.os.Process;
import android.os.Process.ProcessStartResult;
import android.os.RemoteCallbackList;
import android.os.RemoteException;
import android.os.ResultReceiver;
import android.os.ServiceManager;
import android.os.ShellCallback;
import android.os.StatFs;
import android.os.StrictMode;
import android.os.StrictMode.ThreadPolicy;
import android.os.StrictMode.ViolationInfo;
import android.os.SystemClock;
import android.os.SystemProperties;
import android.os.Trace;
import android.os.TransactionTooLargeException;
import android.os.UEventObserver;
import android.os.UEventObserver.UEvent;
import android.os.UpdateLock;
import android.os.UserHandle;
import android.os.UserManager;
import android.os.WorkSource;
import android.os.storage.IStorageManager;
import android.os.storage.StorageManager;
import android.os.storage.StorageManagerInternal;
import android.provider.Settings;
import android.provider.Settings.Global;
import android.provider.Settings.Secure;
import android.provider.Settings.System;
import android.service.voice.IVoiceInteractionSession;
import android.service.voice.VoiceInteractionManagerInternal;
import android.telecom.TelecomManager;
import android.text.TextUtils;
import android.util.ArrayMap;
import android.util.ArraySet;
import android.util.AtomicFile;
import android.util.BoostFramework;
import android.util.DebugUtils;
import android.util.DisplayMetrics;
import android.util.EventLog;
import android.util.Log;
import android.util.Pair;
import android.util.PrintWriterPrinter;
import android.util.SeempLog;
import android.util.Slog;
import android.util.SparseArray;
import android.util.SparseIntArray;
import android.util.TimeUtils;
import android.util.TimingsTraceLog;
import android.util.Xml;
import android.view.LayoutInflater;
import android.view.View;
import android.view.WindowManager;
import android.view.WindowManager.LayoutParams;
import com.android.internal.annotations.GuardedBy;
import com.android.internal.app.ActivityTrigger;
import com.android.internal.app.AssistUtils;
import com.android.internal.app.DumpHeapActivity;
import com.android.internal.app.IAppOpsCallback;
import com.android.internal.app.IAppOpsService;
import com.android.internal.app.IVoiceInteractor;
import com.android.internal.app.ProcessMap;
import com.android.internal.logging.MetricsLogger;
import com.android.internal.notification.SystemNotificationChannels;
import com.android.internal.os.BackgroundThread;
import com.android.internal.os.BatteryStatsImpl;
import com.android.internal.os.BatteryStatsImpl.BatteryCallback;
import com.android.internal.os.BatteryStatsImpl.Uid.Pkg.Serv;
import com.android.internal.os.BatteryStatsImpl.Uid.Proc;
import com.android.internal.os.IResultReceiver;
import com.android.internal.os.ProcessCpuTracker;
import com.android.internal.os.ProcessCpuTracker.Stats;
import com.android.internal.os.TransferPipe;
import com.android.internal.policy.IKeyguardDismissCallback;
import com.android.internal.util.ArrayUtils;
import com.android.internal.util.DumpUtils;
import com.android.internal.util.FastPrintWriter;
import com.android.internal.util.FastXmlSerializer;
import com.android.internal.util.MemInfoReader;
import com.android.internal.util.Preconditions;
import com.android.internal.util.XmlUtils;
import com.android.server.AgingCriticalEvent;
import com.android.server.AppOpsService;
import com.android.server.AttributeCache;
import com.android.server.ColorOSDeviceIdleHelper;
import com.android.server.IntentResolver;
import com.android.server.LocalServices;
import com.android.server.LocationManagerService;
import com.android.server.LockGuard;
import com.android.server.NetworkManagementInternal;
import com.android.server.OppoDynamicLogManager;
import com.android.server.RescueParty;
import com.android.server.ServiceThread;
import com.android.server.SystemConfig;
import com.android.server.SystemService;
import com.android.server.SystemServiceManager;
import com.android.server.ThreadPriorityBooster;
import com.android.server.UiThread;
import com.android.server.Watchdog;
import com.android.server.Watchdog.Monitor;
import com.android.server.am.UriPermission.PersistedTimeComparator;
import com.android.server.am.UriPermission.Snapshot;
import com.android.server.backup.RefactoredBackupManagerService;
import com.android.server.coloros.OppoListManager;
import com.android.server.display.OppoBrightUtils;
import com.android.server.face.FaceDaemonWrapper;
import com.android.server.firewall.IntentFirewall;
import com.android.server.firewall.IntentFirewall.AMSInterface;
import com.android.server.job.JobSchedulerInternal;
import com.android.server.job.JobSchedulerShellCommand;
import com.android.server.job.controllers.JobStatus;
import com.android.server.location.LocationFudger;
import com.android.server.neuron.NeuronSystemService;
import com.android.server.oppo.DumpObject;
import com.android.server.oppo.OppoJunkRecorder;
import com.android.server.pm.Installer;
import com.android.server.policy.PhoneWindowManager;
import com.android.server.secrecy.policy.DecryptTool;
import com.android.server.statusbar.StatusBarManagerInternal;
import com.android.server.vr.VrManagerInternal;
import com.android.server.wm.PinnedStackWindowController;
import com.android.server.wm.WindowManagerService;
import com.google.android.collect.Lists;
import com.google.android.collect.Maps;
import com.oppo.debug.ASSERT;
import com.oppo.hypnus.Hypnus;
import com.oppo.neuron.NeuronSystemManager;
import com.oppo.theme.OppoThemeUtil;
import dalvik.system.VMRuntime;
import java.io.BufferedOutputStream;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.lang.ref.WeakReference;
import java.nio.charset.StandardCharsets;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import libcore.io.IoUtils;
import libcore.util.EmptyArray;
import oppo.util.OppoMultiLauncherUtil;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.XmlSerializer;
import vendor.oppo.hardware.biometrics.fingerprint.V2_1.FingerprintAcquiredInfo;

public class ActivityManagerService extends Stub implements Monitor, BatteryCallback {
    public static final String ACTION_TRIGGER_IDLE = "com.android.server.ACTION_TRIGGER_IDLE";
    static final int ALLOW_FULL_ONLY = 2;
    static final int ALLOW_NON_FULL = 0;
    static final int ALLOW_NON_FULL_IN_PROFILE = 1;
    static final boolean ANIMATE = true;
    private static final long APP_DEXOPT_TIMEOUT = 20000;
    static final long APP_SWITCH_DELAY_TIME = 5000;
    private static final String ATTR_CREATED_TIME = "createdTime";
    private static final String ATTR_MODE_FLAGS = "modeFlags";
    private static final String ATTR_PREFIX = "prefix";
    private static final String ATTR_SOURCE_PKG = "sourcePkg";
    private static final String ATTR_SOURCE_USER_ID = "sourceUserId";
    private static final String ATTR_TARGET_PKG = "targetPkg";
    private static final String ATTR_TARGET_USER_ID = "targetUserId";
    private static final String ATTR_URI = "uri";
    private static final String ATTR_USER_HANDLE = "userHandle";
    static final long BATTERY_STATS_TIME = 1800000;
    static final int BROADCAST_BG_TIMEOUT = 60000;
    static final int BROADCAST_FG_TIMEOUT = 10000;
    static final int CANCEL_HEAVY_NOTIFICATION_MSG = 25;
    static final int CHECK_EXCESSIVE_POWER_USE_MSG = 27;
    static final int CLEAR_DNS_CACHE_MSG = 28;
    private static final String CMP_NAME_MM_SNS = "com.tencent.mm/com.tencent.mm.plugin.sns.ui.SnsTimeLineUI";
    private static final String CMP_NAME_MM_UI = "com.tencent.mm/com.tencent.mm.ui.LauncherUI";
    private static final String CMP_NAME_SCREENSHOT = "com.coloros.screenshot/com.coloros.screenshot.service.ScreenshotService";
    static final int COLLECT_PSS_BG_MSG = 1;
    static final int CONTENT_PROVIDER_PUBLISH_TIMEOUT = 10000;
    static final int CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG = 57;
    static final int CONTENT_PROVIDER_WAIT_TIMEOUT = 20000;
    static final int CONTINUE_USER_SWITCH_MSG = 35;
    private static final int CREATE_RESERVE_DELAY_TIME = 20000;
    private static final int DATA_MIN_SIZE = 16;
    private static final int DATA_PROTECT_WRITE_SIZE = 40;
    private static final String DATA_RESERVE_PATH = "/data/system/reserve.log";
    private static final boolean DBG_CUSTOMIZE = false;
    private static final boolean DBG_LIST_PARSE = false;
    public static boolean DEBUG_COLOROS_AMS = SystemProperties.getBoolean("persist.sys.assert.panic", false);
    public static boolean DEBUG_WECHAT = SystemProperties.getBoolean("sys.oppo.logkit.wechatdbg", true);
    public static final int DELAY_TIME_MILLSECOND = 1000;
    static final int DELETE_DUMPHEAP_MSG = 51;
    static final int DISMISS_DIALOG_UI_MSG = 48;
    static final int DISPATCH_OOM_ADJ_OBSERVER_MSG = 70;
    static final int DISPATCH_PENDING_INTENT_CANCEL_MSG = 67;
    static final int DISPATCH_PROCESSES_CHANGED_UI_MSG = 31;
    static final int DISPATCH_PROCESS_DIED_UI_MSG = 32;
    static final int DISPATCH_UIDS_CHANGED_UI_MSG = 53;
    static final int DO_PENDING_ACTIVITY_LAUNCHES_MSG = 21;
    static final int DROPBOX_MAX_SIZE = 1048576;
    static final long[] DUMP_MEM_BUCKETS = new long[]{5120, 7168, 10240, 15360, 20480, 30720, 40960, 81920, 122880, 163840, 204800, 256000, 307200, 358400, 409600, 512000, 614400, 819200, 1048576, 2097152, 5242880, 10485760, 20971520};
    static final int[] DUMP_MEM_OOM_ADJ = new int[]{JobSchedulerShellCommand.CMD_ERR_NO_PACKAGE, -900, -800, -700, 0, 100, 200, 300, 400, 500, 600, START_OPPO_SITE_MSG, 800, 900};
    static final String[] DUMP_MEM_OOM_COMPACT_LABEL = new String[]{"native", "sys", "pers", "persvc", "fore", "vis", "percept", "heavy", "backup", "servicea", "home", "prev", "serviceb", "cached"};
    static final String[] DUMP_MEM_OOM_LABEL = new String[]{"Native", "System", "Persistent", "Persistent Service", "Foreground", "Visible", "Perceptible", "Heavy Weight", "Backup", "A Services", "Home", "Previous", "B Services", "Cached"};
    static final String[] EMPTY_STRING_ARRAY = new String[0];
    static final int ENTER_ANIMATION_COMPLETE_MSG = 44;
    private static final String FEATURE_DISALLOW_APP_RUN_STR = "oppo.customize.function.disallow_app_run";
    static final int FINALIZE_PENDING_INTENT_MSG = 23;
    static final int FINISH_BOOTING_MSG = 45;
    static final int FINISH_WHEN_LOCKED_BEGIN = 1;
    static final int FINISH_WHEN_LOCKED_DOING = 2;
    static final int FINISH_WHEN_LOCKED_END = 0;
    static final int FIRST_ACTIVITY_STACK_MSG = 100;
    static final int FIRST_BROADCAST_QUEUE_MSG = 200;
    static final int FIRST_COMPAT_MODE_MSG = 300;
    static final int FIRST_SUPERVISOR_STACK_MSG = 100;
    static final int FOREGROUND_PROFILE_CHANGED_MSG = 52;
    static final int GC_BACKGROUND_PROCESSES_MSG = 5;
    static final int HANDLE_TRUST_STORAGE_UPDATE_MSG = 63;
    static final int IDLE_UIDS_MSG = 58;
    static final int IMMERSIVE_MODE_LOCK_MSG = 37;
    static final int INSTRUMENTATION_KEY_DISPATCHING_TIMEOUT = 60000;
    static final String INTENT_QUERY_EXTRA = "query";
    private static final String INTENT_REMOTE_BUGREPORT_FINISHED = "com.android.internal.intent.action.REMOTE_BUGREPORT_FINISHED";
    private static final String KEYGUARD_PROC_NAME = "com.android.keyguard";
    private static final String KEYGUARD_STARTPROC_TIMEOUT_ACTION = "android.intent.action.KEYGUARD_TIMEOUT";
    static final int KEY_DISPATCHING_TIMEOUT = 5000;
    static final int KILL_APPLICATION_MSG = 22;
    private static final int KSM_SHARED = 0;
    private static final int KSM_SHARING = 1;
    private static final int KSM_UNSHARED = 2;
    private static final int KSM_VOLATILE = 3;
    static final int LOG_STACK_STATE = 60;
    private static final int MAX_BUGREPORT_TITLE_SIZE = 50;
    private static final int MAX_DUP_SUPPRESSED_STACKS = 5000;
    static final int MAX_PERSISTED_URI_GRANTS = 128;
    private static final int MEMINFO_COMPACT_VERSION = 1;
    static final long MONITOR_CPU_MAX_TIME = 268435455;
    static final long MONITOR_CPU_MIN_TIME = 5000;
    static final boolean MONITOR_CPU_USAGE = true;
    static final boolean MONITOR_THREAD_CPU_USAGE = SystemProperties.getBoolean("persist.sys.assert.panic", false);
    static final int MY_PID = Process.myPid();
    private static final int NATIVE_DUMP_TIMEOUT_MS = 2000;
    private static final long NETWORK_ACCESS_TIMEOUT_DEFAULT_MS = 200;
    static final int NETWORK_OPTS_CHECK_MSG = 88;
    static final int NETWORK_STATE_BLOCK = 1;
    static final int NETWORK_STATE_NO_CHANGE = 0;
    static final int NETWORK_STATE_UNBLOCK = 2;
    static final int NOTIFY_CLEARTEXT_NETWORK_MSG = 49;
    static final int NOTIFY_VR_KEYGUARD_MSG = 74;
    static final int NOTIFY_VR_SLEEPING_MSG = 65;
    static final int NOT_ALLOWED_START_MSG = 600;
    public static final String OPPO_LAUNCHER = "com.oppo.launcher";
    static final int PENDING_ASSIST_EXTRAS_LONG_TIMEOUT = 2000;
    static final int PENDING_ASSIST_EXTRAS_TIMEOUT = 500;
    static final int PENDING_AUTOFILL_ASSIST_STRUCTURE_TIMEOUT = 2000;
    private static final int PERSISTENT_MASK = 9;
    static final int PERSIST_URI_GRANTS_MSG = 38;
    static final int POST_DUMP_HEAP_NOTIFICATION_MSG = 50;
    static final int POST_HEAVY_NOTIFICATION_MSG = 24;
    private static final int[] PROCESS_STATE_STATS_FORMAT = new int[]{32, 544, 10272};
    static final int PROC_START_TIMEOUT = 10000;
    static final int PROC_START_TIMEOUT_MSG = 20;
    static final int PROC_START_TIMEOUT_WITH_WRAPPER = 1200000;
    static final int PUSH_TEMP_WHITELIST_UI_MSG = 68;
    static final int REPORT_LOCKED_BOOT_COMPLETE_MSG = 64;
    static final int REPORT_MEM_USAGE_MSG = 33;
    static final int REPORT_TIME_TRACKER_MSG = 54;
    static final int REPORT_USER_SWITCH_COMPLETE_MSG = 55;
    static final int REPORT_USER_SWITCH_MSG = 34;
    static final int REQUEST_ALL_PSS_MSG = 39;
    static final int RESERVED_BYTES_PER_LOGCAT_LINE = 100;
    private static final int RESERVE_FILE_SIZE = 64;
    static final int RESET_SLEEP_CHECK_FLAG_MSG = 400;
    static final int SEND_LOCALE_TO_MOUNT_DAEMON_MSG = 47;
    static final int SERVICE_FOREGROUND_CRASH_MSG = 69;
    static final int SERVICE_FOREGROUND_TIMEOUT_MSG = 66;
    static final int SERVICE_TIMEOUT_MSG = 12;
    static final int SHOW_ACTIVITY_BEHIND_KEYGUARD_MSG = 420;
    static final int SHOW_COMPAT_MODE_DIALOG_UI_MSG = 30;
    static final int SHOW_ERROR_UI_MSG = 1;
    static final int SHOW_FACTORY_ERROR_UI_MSG = 3;
    static final int SHOW_FINGERPRINT_ERROR_UI_MSG = 15;
    static final int SHOW_NOT_ALLOW_DIALOG_MSG = 410;
    static final int SHOW_NOT_RESPONDING_UI_MSG = 2;
    static final int SHOW_STRICT_MODE_VIOLATION_UI_MSG = 26;
    static final int SHOW_UID_ERROR_UI_MSG = 14;
    static final int SHOW_UNSUPPORTED_DISPLAY_SIZE_DIALOG_MSG = 62;
    static final int SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG = 56;
    static final int START_CHOOSER_ACTIVITY_MSG = 500;
    static final int START_FORCESTOP_MSG = 511;
    static final int START_OPPO_SITE_MSG = 700;
    static final int START_PROFILES_MSG = 40;
    static final int START_USER_SWITCH_FG_MSG = 712;
    static final int START_USER_SWITCH_UI_MSG = 46;
    static final int STOCK_PM_FLAGS = 1024;
    private static final String SYSTEMUI_PROC_NAME = "com.android.systemui";
    static final String SYSTEM_DEBUGGABLE = "ro.debuggable";
    static final int SYSTEM_USER_CURRENT_MSG = 43;
    static final int SYSTEM_USER_START_MSG = 42;
    static final int SYSTEM_USER_UNLOCK_MSG = 59;
    private static final String TAG = "ActivityManager";
    private static final String TAG_BACKUP = (TAG + ActivityManagerDebugConfig.POSTFIX_BACKUP);
    private static final String TAG_BROADCAST = (TAG + ActivityManagerDebugConfig.POSTFIX_BROADCAST);
    private static final String TAG_CLEANUP = (TAG + ActivityManagerDebugConfig.POSTFIX_CLEANUP);
    private static final String TAG_CONFIGURATION = (TAG + ActivityManagerDebugConfig.POSTFIX_CONFIGURATION);
    private static final String TAG_FOCUS = (TAG + ActivityManagerDebugConfig.POSTFIX_FOCUS);
    private static final String TAG_IMMERSIVE = (TAG + ActivityManagerDebugConfig.POSTFIX_IMMERSIVE);
    private static final String TAG_LOCKTASK = (TAG + ActivityManagerDebugConfig.POSTFIX_LOCKTASK);
    private static final String TAG_LRU = (TAG + ActivityManagerDebugConfig.POSTFIX_LRU);
    private static final String TAG_MU = (TAG + "_MU");
    private static final String TAG_NETWORK = (TAG + "_Network");
    private static final String TAG_OOM_ADJ = (TAG + ActivityManagerDebugConfig.POSTFIX_OOM_ADJ);
    private static final String TAG_POWER = (TAG + ActivityManagerDebugConfig.POSTFIX_POWER);
    private static final String TAG_PROCESSES = (TAG + ActivityManagerDebugConfig.POSTFIX_PROCESSES);
    private static final String TAG_PROCESS_OBSERVERS = (TAG + ActivityManagerDebugConfig.POSTFIX_PROCESS_OBSERVERS);
    private static final String TAG_PROVIDER = (TAG + ActivityManagerDebugConfig.POSTFIX_PROVIDER);
    private static final String TAG_PSS = (TAG + ActivityManagerDebugConfig.POSTFIX_PSS);
    private static final String TAG_RECENTS = (TAG + ActivityManagerDebugConfig.POSTFIX_RECENTS);
    private static final String TAG_SERVICE = (TAG + ActivityManagerDebugConfig.POSTFIX_SERVICE);
    private static final String TAG_STACK = (TAG + ActivityManagerDebugConfig.POSTFIX_STACK);
    private static final String TAG_SWITCH = (TAG + ActivityManagerDebugConfig.POSTFIX_SWITCH);
    private static final String TAG_UID_OBSERVERS = (TAG + ActivityManagerDebugConfig.POSTFIX_UID_OBSERVERS);
    private static final String TAG_URI_GRANT = "uri-grant";
    private static final String TAG_URI_GRANTS = "uri-grants";
    private static final String TAG_URI_PERMISSION = (TAG + ActivityManagerDebugConfig.POSTFIX_URI_PERMISSION);
    private static final String TAG_VISIBILITY = (TAG + ActivityManagerDebugConfig.POSTFIX_VISIBILITY);
    static final boolean TAKE_FULLSCREEN_SCREENSHOTS = true;
    private static final String TENCENT_NAME = "com.tencent.mm";
    public static final int TOP_APP_PRIORITY_BOOST = -10;
    static final int UPDATE_CONFIGURATION_MSG = 4;
    static final int UPDATE_HTTP_PROXY_MSG = 29;
    static final int UPDATE_TIME_PREFERENCE_MSG = 41;
    static final int UPDATE_TIME_ZONE = 13;
    private static final String UPLOAD_BATTERYSTATS_RESET = "batterystats_reset";
    private static final String UPLOAD_LOGTAG = "20089";
    static final int USER_SWITCH_TIMEOUT_MSG = 36;
    static final boolean VALIDATE_UID_STATES = true;
    static final int VR_MODE_CHANGE_MSG = 61;
    static final int WAIT_FOR_DEBUGGER_UI_MSG = 6;
    static final ActivityTrigger mActivityTrigger = new ActivityTrigger();
    static final boolean mEnableNetOpts = SystemProperties.getBoolean("persist.vendor.qti.netopts.enable", false);
    public static boolean mIsPerfLockAcquired = false;
    public static BoostFramework mPerf = null;
    public static BoostFramework mPerfServiceStartHint = null;
    @GuardedBy("ActivityManagerService.class")
    private static SimpleDateFormat sAnrFileDateFormat;
    private static final ThreadLocal<Identity> sCallerIdentity = new ThreadLocal();
    static KillHandler sKillHandler = null;
    static ServiceThread sKillThread = null;
    private static String sTheRealBuildSerial = Shell.NIGHT_MODE_STR_UNKNOWN;
    private static ThreadPriorityBooster sThreadPriorityBooster = new ThreadPriorityBooster(-2, 6);
    private final String CUSTOMIZE_LIST_PATH;
    final int GL_ES_VERSION;
    private final int MAX_NUM_NOT_SHOW;
    private boolean bInReport;
    File dataDir;
    private boolean dexStart;
    final ArrayList<ActiveInstrumentation> mActiveInstrumentation;
    int mActiveNetType;
    ProcessChangeItem[] mActiveProcessChanges;
    ChangeItem[] mActiveUidChanges;
    final SparseArray<UidRecord> mActiveUids;
    final ActivityStarter mActivityStarter;
    int mAdjSeq;
    boolean mAllowLowerMemLevel;
    private final HashSet<Integer> mAlreadyLoggedViolatedStacks;
    boolean mAlwaysFinishActivities;
    HashMap<String, IBinder> mAppBindArgs;
    final AppErrors mAppErrors;
    final AppOpsService mAppOpsService;
    long mAppSwitchesAllowedTime;
    AssistUtils mAssistUtils;
    final SparseArray<ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>>> mAssociations;
    final ArrayList<ProcessChangeItem> mAvailProcessChanges;
    final ArrayList<ChangeItem> mAvailUidChanges;
    int mBServiceAppThreshold;
    int[] mBackgroundAppIdWhitelist;
    ArraySet<String> mBackgroundLaunchBroadcasts;
    String mBackupAppName;
    BackupRecord mBackupTarget;
    final BatteryStatsService mBatteryStatsService;
    BroadcastQueue mBgBroadcastQueue;
    final Handler mBgHandler;
    private boolean mBinderTransactionTrackingEnabled;
    @GuardedBy("this")
    boolean mBootAnimationComplete;
    boolean mBooted;
    @GuardedBy("this")
    boolean mBooting;
    final BroadcastQueue[] mBroadcastQueues;
    final ServiceThread mBroadcastThread;
    @GuardedBy("this")
    boolean mCallFinishBooting;
    @GuardedBy("this")
    boolean mCheckedForSetup;
    CompatModeDialog mCompatModeDialog;
    final CompatModePackages mCompatModePackages;
    private int mConfigurationSeq;
    ConnectivityManager mConnectivityManager;
    final ActivityManagerConstants mConstants;
    final Context mContext;
    IActivityController mController;
    boolean mControllerIsAMonkey;
    CoreSettingsObserver mCoreSettingsObserver;
    private final Runnable mCreateDataReserveFile;
    private AppTimeTracker mCurAppTimeTracker;
    BroadcastStats mCurBroadcastStats;
    OomAdjObserver mCurOomAdjObserver;
    int mCurOomAdjUid;
    private String mCurResumedPackage;
    private int mCurResumedUid;
    private List<String> mCustomizeList;
    String mDebugApp;
    boolean mDebugTransient;
    int[] mDeviceIdleTempWhitelist;
    int[] mDeviceIdleWhitelist;
    String mDeviceOwnerName;
    private HashMap<Integer, Long> mDexOptTimeMap;
    private AlertDialog mDialogForDisallow;
    boolean mDidAppSwitch;
    private List<String> mDisallowedRuningAppList;
    private Object mDisallowedRuningAppListLock;
    boolean mEnableBServicePropagation;
    @OppoHook(level = OppoHookType.NEW_FIELD, note = "Jianhua.Lin@Plf.SDK, 2017-08-22 : Add for EAP collects app error info", property = OppoRomType.ROM)
    private String mErrorPkgName;
    @OppoHook(level = OppoHookType.NEW_FIELD, note = "Jianhua.Lin@Plf.SDK, 2017-08-22 : Add for EAP collects app error info", property = OppoRomType.ROM)
    private long mErrorTime;
    volatile int mFactoryTest;
    BroadcastQueue mFgBroadcastQueue;
    private OppoProcessWhiteListUtils mFileUtils;
    private int mFinishBroadcastCount;
    public int mFinishWhenLockedState;
    FontScaleSettingObserver mFontScaleSettingObserver;
    boolean mForceResizableActivities;
    final ProcessMap<ArrayList<ProcessRecord>> mForegroundPackages;
    boolean mFullPssPending;
    float mFullscreenThumbnailScale;
    private final AtomicFile mGrantFile;
    @GuardedBy("this")
    private final SparseArray<ArrayMap<GrantUri, UriPermission>> mGrantedUriPermissions;
    final MainHandler mHandler;
    final ServiceThread mHandlerThread;
    boolean mHasRecents;
    ProcessRecord mHeavyWeightProcess;
    ProcessRecord mHomeProcess;
    private Hypnus mHyp;
    boolean mIgnoreSleepCheckLater;
    final SparseArray<ImportanceToken> mImportantProcesses;
    private final Injector mInjector;
    private Installer mInstaller;
    final InstrumentationReporter mInstrumentationReporter;
    public final IntentFirewall mIntentFirewall;
    final HashMap<Key, WeakReference<PendingIntentRecord>> mIntentSenderRecords;
    HashMap<String, IBinder> mIsolatedAppBindArgs;
    final SparseArray<ProcessRecord> mIsolatedProcesses;
    private final KeyguardController mKeyguardController;
    String mLastANRState;
    ActivityInfo mLastAddedTaskActivity;
    ComponentName mLastAddedTaskComponent;
    int mLastAddedTaskUid;
    BroadcastStats mLastBroadcastStats;
    final AtomicLong mLastCpuTime;
    long mLastFullPssTime;
    long mLastIdleTime;
    long mLastMemUsageReportTime;
    int mLastMemoryLevel;
    int mLastNumProcesses;
    long mLastPowerCheckUptime;
    private ActivityRecord mLastResumedActivity;
    private String mLastStartProcessPkgName;
    private long mLastStartProcessTime;
    long mLastWriteTime;
    @GuardedBy("this")
    boolean mLaunchWarningShown;
    final ArrayList<ContentProviderRecord> mLaunchingProviders;
    private UEventObserver mLmkObserver;
    com.android.server.DeviceIdleController.LocalService mLocalDeviceIdleController;
    PowerManagerInternal mLocalPowerManager;
    SparseArray<String[]> mLockTaskPackages;
    long mLowRamStartTime;
    long mLowRamTimeSinceLastIdle;
    int mLruProcessActivityStart;
    int mLruProcessServiceStart;
    final ArrayList<ProcessRecord> mLruProcesses;
    int mLruSeq;
    String mMemWatchDumpFile;
    int mMemWatchDumpPid;
    String mMemWatchDumpProcName;
    int mMemWatchDumpUid;
    final ProcessMap<Pair<Long, String>> mMemWatchProcesses;
    int mMinBServiceAgingTime;
    String mNativeDebuggingApp;
    Object mNetLock;
    int mNewNumAServiceProcs;
    int mNewNumServiceProcs;
    int mNextIsolatedProcessUid;
    private final File mNotAllowAppFilename;
    NeuronSystemService mNs;
    int mNumCachedHiddenProcs;
    int mNumNonCachedProcs;
    int mNumServiceProcs;
    volatile boolean mOnBattery;
    OppoActivityControlerScheduler mOppoActivityControlerScheduler;
    IOppoKinectActivityController mOppoKinectController;
    String mOrigDebugApp;
    boolean mOrigWaitForDebugger;
    PackageManagerInternal mPackageManagerInt;
    final ArrayList<PendingAssistExtras> mPendingAssistExtras;
    final ArrayList<ProcessChangeItem> mPendingProcessChanges;
    final ArrayList<ProcessRecord> mPendingPssProcesses;
    final SparseArray<PendingTempWhitelist> mPendingTempWhitelist;
    final ArrayList<ChangeItem> mPendingUidChanges;
    final boolean mPermissionReviewRequired;
    final ArrayList<ProcessRecord> mPersistentStartingProcesses;
    final SparseArray<ProcessRecord> mPidsSelfLocked;
    ProcessRecord mPreviousProcess;
    long mPreviousProcessVisibleTime;
    @GuardedBy("this")
    long mProcStateSeqCounter;
    final CountDownLatch mProcessCpuInitLatch;
    final AtomicBoolean mProcessCpuMutexFree;
    final Thread mProcessCpuThread;
    final ProcessCpuTracker mProcessCpuTracker;
    final ProcessList mProcessList;
    final ProcessMap<ProcessRecord> mProcessNames;
    final RemoteCallbackList<IProcessObserver> mProcessObservers;
    private final long[] mProcessStateStatsLongs;
    final ProcessStatsService mProcessStats;
    final ArrayList<ProcessRecord> mProcessesOnHold;
    volatile boolean mProcessesReady;
    final ArrayList<ProcessRecord> mProcessesToGc;
    String mProfileApp;
    ProcessRecord mProfileProc;
    int mProfileType;
    ProfilerInfo mProfilerInfo;
    final ProviderMap mProviderMap;
    final IntentResolver<BroadcastFilter, BroadcastFilter> mReceiverResolver;
    final RecentTasks mRecentTasks;
    final HashMap<IBinder, ReceiverList> mRegisteredReceivers;
    final ArrayList<ProcessRecord> mRemovedProcesses;
    IVoiceInteractionSession mRunningVoice;
    boolean mSafeMode;
    final ActiveServices mServices;
    private boolean mShowDialogs;
    boolean mShuttingDown;
    private boolean mSimulateBindBlockedCase;
    private boolean mSleeping;
    private ActivityRecord mSplitActivity;
    public final ActivityStackSupervisor mStackSupervisor;
    final SparseArray<ArrayMap<String, ArrayList<Intent>>> mStickyBroadcasts;
    private final StringBuilder mStrictModeBuffer;
    final StringBuilder mStringBuilder;
    private String[] mSupportedSystemLocales;
    boolean mSupportsFreeformWindowManagement;
    boolean mSupportsLeanbackOnly;
    boolean mSupportsMultiDisplay;
    boolean mSupportsMultiWindow;
    boolean mSupportsPictureInPicture;
    boolean mSupportsSplitScreenMultiWindow;
    boolean mSuppressResizeConfigChanges;
    private final File mSystemDir;
    volatile boolean mSystemReady;
    SystemServiceManager mSystemServiceManager;
    final ActivityThread mSystemThread;
    final TaskChangeNotificationController mTaskChangeNotificationController;
    private Configuration mTempConfig;
    boolean mTestPssMode;
    int mThumbnailHeight;
    int mThumbnailWidth;
    private final ArraySet<BroadcastQueue> mTmpBroadcastQueue;
    final long[] mTmpLong;
    private final UpdateConfigurationResult mTmpUpdateConfigurationResult;
    String mTopAction;
    ComponentName mTopComponent;
    String mTopData;
    int mTopProcessState;
    String mTrackAllocationApp;
    boolean mTrackingAssociations;
    final Context mUiContext;
    final Handler mUiHandler;
    final RemoteCallbackList<IUidObserver> mUidObservers;
    UnsupportedDisplaySizeDialog mUnsupportedDisplaySizeDialog;
    final UpdateLock mUpdateLock;
    UsageStatsManagerInternal mUsageStatsService;
    private boolean mUseFifoUiScheduling;
    final UserController mUserController;
    private boolean mUserIsMonkey;
    final SparseArray<UidRecord> mValidateUids;
    private int mViSessionId;
    WakeLock mVoiceWakeLock;
    int mVr2dDisplayId;
    private final VrController mVrController;
    boolean mWaitForDebugger;
    long mWaitForNetworkTimeoutMs;
    private int mWakefulness;
    WindowManagerService mWindowManager;
    private volatile int mWtfClusterCount;
    private volatile long mWtfClusterStart;
    private List<String> splitBack;

    public static class Injector {
        private NetworkManagementInternal mNmi;

        public Context getContext() {
            return null;
        }

        public AppOpsService getAppOpsService(File file, Handler handler) {
            return new AppOpsService(file, handler);
        }

        public Handler getUiHandler(ActivityManagerService service) {
            service.getClass();
            return new UiHandler();
        }

        public boolean isNetworkRestrictedForUid(int uid) {
            if (ensureHasNetworkManagementInternal()) {
                return this.mNmi.isNetworkRestrictedForUid(uid);
            }
            return false;
        }

        private boolean ensureHasNetworkManagementInternal() {
            if (this.mNmi == null) {
                this.mNmi = (NetworkManagementInternal) LocalServices.getService(NetworkManagementInternal.class);
            }
            return this.mNmi != null;
        }
    }

    class IntentFirewallInterface implements AMSInterface {
        IntentFirewallInterface() {
        }

        public int checkComponentPermission(String permission, int pid, int uid, int owningUid, boolean exported) {
            return ActivityManagerService.this.checkComponentPermission(permission, pid, uid, owningUid, exported);
        }

        public Object getAMSLock() {
            return ActivityManagerService.this;
        }
    }

    final class KillHandler extends Handler {
        static final int KILL_PROCESS_GROUP_MSG = 4000;

        public KillHandler(Looper looper) {
            super(looper, null, true);
        }

        public void handleMessage(Message msg) {
            switch (msg.what) {
                case KILL_PROCESS_GROUP_MSG /*4000*/:
                    Trace.traceBegin(64, "killProcessGroup");
                    Process.killProcessGroup(msg.arg1, msg.arg2);
                    Trace.traceEnd(64);
                    return;
                default:
                    super.handleMessage(msg);
                    return;
            }
        }
    }

    public static final class Lifecycle extends SystemService {
        private final ActivityManagerService mService;

        public Lifecycle(Context context) {
            super(context);
            this.mService = new OppoActivityManagerService(context);
        }

        public void onStart() {
            this.mService.start();
        }

        public void onCleanupUser(int userId) {
            this.mService.mBatteryStatsService.onCleanupUser(userId);
        }

        public ActivityManagerService getService() {
            return this.mService;
        }
    }

    final class LocalService extends ActivityManagerInternal {
        LocalService() {
        }

        public void grantUriPermissionFromIntent(int callingUid, String targetPkg, Intent intent, int targetUserId) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.grantUriPermissionFromIntentLocked(callingUid, targetPkg, intent, null, targetUserId);
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public String checkContentProviderAccess(String authority, int userId) {
            return ActivityManagerService.this.checkContentProviderAccess(authority, userId);
        }

        public void onWakefulnessChanged(int wakefulness) {
            ActivityManagerService.this.onWakefulnessChanged(wakefulness);
        }

        public int startIsolatedProcess(String entryPoint, String[] entryPointArgs, String processName, String abiOverride, int uid, Runnable crashHandler) {
            return ActivityManagerService.this.startIsolatedProcess(entryPoint, entryPointArgs, processName, abiOverride, uid, crashHandler);
        }

        public SleepToken acquireSleepToken(String tag, int displayId) {
            Preconditions.checkNotNull(tag);
            return ActivityManagerService.this.acquireSleepToken(tag, displayId);
        }

        public ComponentName getHomeActivityForUser(int userId) {
            ComponentName componentName = null;
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityRecord homeActivity = ActivityManagerService.this.mStackSupervisor.getHomeActivityForUser(userId);
                    if (homeActivity != null) {
                        componentName = homeActivity.realActivity;
                    }
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            return componentName;
        }

        public void onUserRemoved(int userId) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.onUserStoppedLocked(userId);
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            ActivityManagerService.this.mBatteryStatsService.onUserRemoved(userId);
        }

        public void onLocalVoiceInteractionStarted(IBinder activity, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.onLocalVoiceInteractionStartedLocked(activity, voiceSession, voiceInteractor);
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public void notifyAppTransitionStarting(SparseIntArray reasons, long timestamp) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mStackSupervisor.mActivityMetricsLogger.notifyTransitionStarting(reasons, timestamp);
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public void notifyAppTransitionFinished() {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mStackSupervisor.notifyAppTransitionDone();
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public void notifyAppTransitionCancelled() {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mStackSupervisor.notifyAppTransitionDone();
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public List<IBinder> getTopVisibleActivities() {
            List<IBinder> topVisibleActivities;
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    topVisibleActivities = ActivityManagerService.this.mStackSupervisor.getTopVisibleActivities();
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            return topVisibleActivities;
        }

        public void notifyDockedStackMinimizedChanged(boolean minimized) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mStackSupervisor.setDockedStackMinimized(minimized);
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public void killForegroundAppsForUser(int userHandle) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ArrayList<ProcessRecord> procs = new ArrayList();
                    int NP = ActivityManagerService.this.mProcessNames.getMap().size();
                    for (int ip = 0; ip < NP; ip++) {
                        SparseArray<ProcessRecord> apps = (SparseArray) ActivityManagerService.this.mProcessNames.getMap().valueAt(ip);
                        int NA = apps.size();
                        for (int ia = 0; ia < NA; ia++) {
                            ProcessRecord app = (ProcessRecord) apps.valueAt(ia);
                            if (!app.persistent) {
                                if (app.removed) {
                                    procs.add(app);
                                } else if (app.userId == userHandle && app.foregroundActivities) {
                                    app.removed = true;
                                    procs.add(app);
                                }
                            }
                        }
                    }
                    int N = procs.size();
                    for (int i = 0; i < N; i++) {
                        ActivityManagerService.this.removeProcessLocked((ProcessRecord) procs.get(i), false, true, "kill all fg");
                    }
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public void setPendingIntentWhitelistDuration(IIntentSender target, IBinder whitelistToken, long duration) {
            if (target instanceof PendingIntentRecord) {
                synchronized (ActivityManagerService.this) {
                    try {
                        ActivityManagerService.boostPriorityForLockedSection();
                        ((PendingIntentRecord) target).setWhitelistDurationLocked(whitelistToken, duration);
                    } finally {
                        ActivityManagerService.resetPriorityAfterLockedSection();
                    }
                }
                return;
            }
            Slog.w(ActivityManagerService.TAG, "markAsSentFromNotification(): not a PendingIntentRecord: " + target);
        }

        public void setDeviceIdleWhitelist(int[] appids) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mDeviceIdleWhitelist = appids;
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public void updateDeviceIdleTempWhitelist(int[] appids, int changingAppId, boolean adding) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mDeviceIdleTempWhitelist = appids;
                    ActivityManagerService.this.setAppIdTempWhitelistStateLocked(changingAppId, adding);
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public void updatePersistentConfigurationForUser(Configuration values, int userId) {
            Preconditions.checkNotNull(values, "Configuration must not be null");
            Preconditions.checkArgumentNonnegative(userId, "userId " + userId + " not supported");
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.updateConfigurationLocked(values, null, false, true, userId, false);
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public int startActivitiesAsPackage(String packageName, int userId, Intent[] intents, Bundle bOptions) {
            int startActivitiesInPackage;
            Preconditions.checkNotNull(intents, "intents");
            String[] resolvedTypes = new String[intents.length];
            for (int i = 0; i < intents.length; i++) {
                resolvedTypes[i] = intents[i].resolveTypeIfNeeded(ActivityManagerService.this.mContext.getContentResolver());
            }
            int packageUid = 0;
            try {
                packageUid = AppGlobals.getPackageManager().getPackageUid(packageName, 268435456, userId);
            } catch (RemoteException e) {
            }
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    startActivitiesInPackage = ActivityManagerService.this.startActivitiesInPackage(packageUid, packageName, intents, resolvedTypes, null, bOptions, userId);
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            return startActivitiesInPackage;
        }

        public int getUidProcessState(int uid) {
            return ActivityManagerService.this.getUidState(uid);
        }

        public void notifyKeyguardFlagsChanged(Runnable callback) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    boolean wasTransitionSet = ActivityManagerService.this.mWindowManager.getPendingAppTransition() != 0;
                    if (!wasTransitionSet) {
                        ActivityManagerService.this.mWindowManager.prepareAppTransition(0, false);
                    }
                    ActivityManagerService.this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                    if (!wasTransitionSet) {
                        ActivityManagerService.this.mWindowManager.executeAppTransition();
                    }
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            if (callback != null) {
                callback.run();
            }
        }

        public boolean isSystemReady() {
            return ActivityManagerService.this.mSystemReady;
        }

        public void notifyKeyguardTrustedChanged() {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    if (ActivityManagerService.this.mKeyguardController.isKeyguardShowing(0)) {
                        ActivityManagerService.this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                    }
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        /* JADX WARNING: inconsistent code. */
        /* Code decompiled incorrectly, please refer to instructions dump. */
        public void setHasOverlayUi(int pid, boolean hasOverlayUi) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    synchronized (ActivityManagerService.this.mPidsSelfLocked) {
                        ProcessRecord pr = (ProcessRecord) ActivityManagerService.this.mPidsSelfLocked.get(pid);
                        if (pr == null) {
                            Slog.w(ActivityManagerService.TAG, "setHasOverlayUi called on unknown pid: " + pid);
                        }
                    }
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        /* JADX WARNING: inconsistent code. */
        /* Code decompiled incorrectly, please refer to instructions dump. */
        public void notifyNetworkPolicyRulesUpdated(int uid, long procStateSeq) {
            if (ActivityManagerDebugConfig.DEBUG_NETWORK) {
                Slog.d(ActivityManagerService.TAG_NETWORK, "Got update from NPMS for uid: " + uid + " seq: " + procStateSeq);
            }
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    UidRecord record = (UidRecord) ActivityManagerService.this.mActiveUids.get(uid);
                    if (record == null) {
                        if (ActivityManagerDebugConfig.DEBUG_NETWORK) {
                            Slog.d(ActivityManagerService.TAG_NETWORK, "No active uidRecord for uid: " + uid + " procStateSeq: " + procStateSeq);
                        }
                    }
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public void setVr2dDisplayId(int vr2dDisplayId) {
            if (ActivityManagerDebugConfig.DEBUG_STACK) {
                Slog.d(ActivityManagerService.TAG, "setVr2dDisplayId called for: " + vr2dDisplayId);
            }
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mVr2dDisplayId = vr2dDisplayId;
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public void saveANRState(String reason) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    StringWriter sw = new StringWriter();
                    PrintWriter pw = new FastPrintWriter(sw, false, 1024);
                    pw.println("  ANR time: " + DateFormat.getDateTimeInstance().format(new Date()));
                    if (reason != null) {
                        pw.println("  Reason: " + reason);
                    }
                    pw.println();
                    ActivityManagerService.this.mActivityStarter.dump(pw, "  ", null);
                    pw.println();
                    pw.println("-------------------------------------------------------------------------------");
                    ActivityManagerService.this.dumpActivitiesLocked(null, pw, null, 0, true, false, null, "");
                    pw.println();
                    pw.close();
                    ActivityManagerService.this.mLastANRState = sw.toString();
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public void clearSavedANRState() {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mLastANRState = null;
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }

        public void setFocusedActivity(IBinder token) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityRecord r = ActivityRecord.forTokenLocked(token);
                    if (r == null) {
                        throw new IllegalArgumentException("setFocusedActivity: No activity record matching token=" + token);
                    }
                    if (ActivityManagerService.this.mStackSupervisor.moveFocusableActivityStackToFrontLocked(r, "setFocusedActivity")) {
                        ActivityManagerService.this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
                    }
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }
    }

    final class MainHandler extends Handler {
        public MainHandler(Looper looper) {
            super(looper, null, true);
        }

        public void handleMessage(Message msg) {
            int i;
            ProcessRecord r;
            ProcessRecord app;
            String text;
            INotificationManager inm;
            int uid;
            int userId;
            switch (msg.what) {
                case 4:
                    System.putConfigurationForUser(ActivityManagerService.this.mContext.getContentResolver(), (Configuration) msg.obj, msg.arg1);
                    break;
                case 5:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.performAppGcsIfAppropriateLocked();
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 12:
                    ProcessRecord pr = msg.obj;
                    Message nmsg;
                    if (pr == null || !pr.isWaitingPermissionChoice) {
                        if (!ActivityManagerService.this.isDoingDexopt(pr != null ? pr.uid : 0)) {
                            ActivityManagerService.this.mServices.serviceTimeout((ProcessRecord) msg.obj);
                            break;
                        }
                        nmsg = ActivityManagerService.this.mHandler.obtainMessage(12);
                        nmsg.obj = msg.obj;
                        ActivityManagerService.this.mHandler.sendMessageDelayed(nmsg, ActivityManagerService.APP_DEXOPT_TIMEOUT);
                        return;
                    }
                    nmsg = ActivityManagerService.this.mHandler.obtainMessage(12);
                    nmsg.obj = msg.obj;
                    ActivityManagerService.this.mHandler.sendMessageDelayed(nmsg, ActivityManagerService.APP_DEXOPT_TIMEOUT);
                    return;
                case 13:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            for (i = ActivityManagerService.this.mLruProcesses.size() - 1; i >= 0; i--) {
                                r = (ProcessRecord) ActivityManagerService.this.mLruProcesses.get(i);
                                if (r.thread != null) {
                                    r.thread.updateTimeZone();
                                }
                            }
                        } catch (RemoteException e) {
                            Slog.w(ActivityManagerService.TAG, "Failed to update time zone for: " + r.info.processName);
                        } catch (Throwable th) {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    break;
                case 20:
                    app = msg.obj;
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.processStartTimedOutLocked(app);
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 21:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.mActivityStarter.doPendingActivityLaunchesLocked(true);
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 22:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            Bundle bundle = msg.obj;
                            ActivityManagerService.this.forceStopPackageLocked(bundle.getString("pkg"), msg.arg1, false, false, true, false, false, msg.arg2, bundle.getString(PhoneWindowManager.SYSTEM_DIALOG_REASON_KEY));
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 23:
                    ((PendingIntentRecord) msg.obj).completeFinalize();
                    break;
                case 24:
                    INotificationManager inm2 = NotificationManager.getService();
                    if (inm2 != null) {
                        ActivityRecord root = msg.obj;
                        ProcessRecord process = root.app;
                        if (process != null) {
                            try {
                                text = ActivityManagerService.this.mContext.getString(17040000, new Object[]{ActivityManagerService.this.mContext.createPackageContext(process.info.packageName, 0).getApplicationInfo().loadLabel(ActivityManagerService.this.mContext.createPackageContext(process.info.packageName, 0).getPackageManager())});
                                try {
                                    inm2.enqueueNotificationWithTag("android", "android", null, 11, new Builder(ActivityManagerService.this.mContext.createPackageContext(process.info.packageName, 0), SystemNotificationChannels.DEVELOPER).setSmallIcon(17303429).setWhen(0).setOngoing(true).setTicker(text).setColor(ActivityManagerService.this.mContext.getColor(17170763)).setContentTitle(text).setContentText(ActivityManagerService.this.mContext.getText(17040001)).setContentIntent(PendingIntent.getActivityAsUser(ActivityManagerService.this.mContext, 0, root.intent, 268435456, null, new UserHandle(root.userId))).build(), root.userId);
                                    break;
                                } catch (Throwable e2) {
                                    Slog.w(ActivityManagerService.TAG, "Error showing notification for heavy-weight app", e2);
                                    break;
                                } catch (RemoteException e3) {
                                    break;
                                }
                            } catch (Throwable e4) {
                                Slog.w(ActivityManagerService.TAG, "Unable to create context for heavy notification", e4);
                                break;
                            }
                        }
                        return;
                    }
                    return;
                case 25:
                    inm = NotificationManager.getService();
                    if (inm != null) {
                        try {
                            inm.cancelNotificationWithTag("android", null, 11, msg.arg1);
                            break;
                        } catch (Throwable e22) {
                            Slog.w(ActivityManagerService.TAG, "Error canceling notification for service", e22);
                            break;
                        } catch (RemoteException e5) {
                            break;
                        }
                    }
                    return;
                case 27:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.checkExcessivePowerUsageLocked();
                            removeMessages(27);
                            sendMessageDelayed(obtainMessage(27), ActivityManagerService.this.mConstants.POWER_CHECK_INTERVAL);
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 28:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            for (i = ActivityManagerService.this.mLruProcesses.size() - 1; i >= 0; i--) {
                                r = (ProcessRecord) ActivityManagerService.this.mLruProcesses.get(i);
                                if (r.thread != null) {
                                    r.thread.clearDnsCache();
                                }
                            }
                        } catch (RemoteException e6) {
                            Slog.w(ActivityManagerService.TAG, "Failed to clear dns cache for: " + r.info.processName);
                        } catch (Throwable th2) {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    break;
                case 29:
                    ProxyInfo proxy = msg.obj;
                    String host = "";
                    String port = "";
                    String exclList = "";
                    Uri pacFileUrl = Uri.EMPTY;
                    if (proxy != null) {
                        host = proxy.getHost();
                        port = Integer.toString(proxy.getPort());
                        exclList = proxy.getExclusionListAsString();
                        pacFileUrl = proxy.getPacFileUrl();
                    }
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            for (i = ActivityManagerService.this.mLruProcesses.size() - 1; i >= 0; i--) {
                                r = (ProcessRecord) ActivityManagerService.this.mLruProcesses.get(i);
                                if (r.thread != null) {
                                    r.thread.setHttpProxy(host, port, exclList, pacFileUrl);
                                }
                            }
                        } catch (RemoteException e7) {
                            Slog.w(ActivityManagerService.TAG, "Failed to update http proxy for: " + r.info.processName);
                        } catch (Throwable th3) {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    break;
                case 33:
                    final ArrayList<ProcessMemInfo> arrayList = msg.obj;
                    new Thread() {
                        public void run() {
                            ActivityManagerService.this.reportMemUsage(arrayList);
                        }
                    }.start();
                    break;
                case 34:
                    ActivityManagerService.this.mUserController.dispatchUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                    break;
                case 35:
                    ActivityManagerService.this.mUserController.continueUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                    break;
                case 36:
                    ActivityManagerService.this.mUserController.timeoutUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                    break;
                case 37:
                    boolean nextState = msg.arg1 != 0;
                    if (ActivityManagerService.this.mUpdateLock.isHeld() != nextState) {
                        if (ActivityManagerDebugConfig.DEBUG_IMMERSIVE) {
                            Slog.d(ActivityManagerService.TAG_IMMERSIVE, "Applying new update lock state '" + nextState + "' for " + ((ActivityRecord) msg.obj));
                        }
                        if (!nextState) {
                            ActivityManagerService.this.mUpdateLock.release();
                            break;
                        } else {
                            ActivityManagerService.this.mUpdateLock.acquire();
                            break;
                        }
                    }
                    break;
                case 38:
                    ActivityManagerService.this.writeGrantedUriPermissions();
                    break;
                case 39:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, false);
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 40:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.mUserController.startProfilesLocked();
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 41:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            for (i = ActivityManagerService.this.mLruProcesses.size() - 1; i >= 0; i--) {
                                r = (ProcessRecord) ActivityManagerService.this.mLruProcesses.get(i);
                                if (r.thread != null) {
                                    r.thread.updateTimePrefs(msg.arg1);
                                }
                            }
                        } catch (RemoteException e8) {
                            Slog.w(ActivityManagerService.TAG, "Failed to update preferences for: " + r.info.processName);
                        } catch (Throwable th4) {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    break;
                case 42:
                    ActivityManagerService.this.mBatteryStatsService.noteEvent(32775, Integer.toString(msg.arg1), msg.arg1);
                    ActivityManagerService.this.mSystemServiceManager.startUser(msg.arg1);
                    break;
                case 43:
                    ActivityManagerService.this.mBatteryStatsService.noteEvent(16392, Integer.toString(msg.arg2), msg.arg2);
                    ActivityManagerService.this.mBatteryStatsService.noteEvent(32776, Integer.toString(msg.arg1), msg.arg1);
                    ActivityManagerService.this.mSystemServiceManager.switchUser(msg.arg1);
                    break;
                case 44:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityRecord r2 = ActivityRecord.forTokenLocked((IBinder) msg.obj);
                            if (!(r2 == null || r2.app == null || r2.app.thread == null)) {
                                try {
                                    r2.app.thread.scheduleEnterAnimationComplete(r2.appToken);
                                } catch (RemoteException e9) {
                                }
                            }
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case ActivityManagerService.FINISH_BOOTING_MSG /*45*/:
                    if (msg.arg1 != 0) {
                        Trace.traceBegin(64, "FinishBooting");
                        ActivityManagerService.this.finishBooting();
                        Trace.traceEnd(64);
                    }
                    if (msg.arg2 != 0) {
                        ActivityManagerService.this.enableScreenAfterBoot();
                        break;
                    }
                    break;
                case 47:
                    try {
                        Locale l = msg.obj;
                        IStorageManager storageManager = IStorageManager.Stub.asInterface(ServiceManager.getService(OppoProcessManager.RESUME_REASON_MOUNT_STR));
                        Log.d(ActivityManagerService.TAG, "Storing locale " + l.toLanguageTag() + " for decryption UI");
                        storageManager.setField("SystemLocale", l.toLanguageTag());
                        break;
                    } catch (Throwable e10) {
                        Log.e(ActivityManagerService.TAG, "Error storing locale for decryption UI", e10);
                        break;
                    }
                case 49:
                    uid = msg.arg1;
                    byte[] firstPacket = (byte[]) msg.obj;
                    synchronized (ActivityManagerService.this.mPidsSelfLocked) {
                        for (i = 0; i < ActivityManagerService.this.mPidsSelfLocked.size(); i++) {
                            ProcessRecord p = (ProcessRecord) ActivityManagerService.this.mPidsSelfLocked.valueAt(i);
                            if (p.uid == uid) {
                                try {
                                    p.thread.notifyCleartextNetwork(firstPacket);
                                } catch (RemoteException e11) {
                                }
                            }
                        }
                    }
                case HdmiCecKeycode.CEC_KEYCODE_PREVIOUS_CHANNEL /*50*/:
                    String procName;
                    long memLimit;
                    String reportPackage;
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            procName = ActivityManagerService.this.mMemWatchDumpProcName;
                            uid = ActivityManagerService.this.mMemWatchDumpUid;
                            Pair<Long, String> val = (Pair) ActivityManagerService.this.mMemWatchProcesses.get(procName, uid);
                            if (val == null) {
                                val = (Pair) ActivityManagerService.this.mMemWatchProcesses.get(procName, 0);
                            }
                            if (val != null) {
                                memLimit = ((Long) val.first).longValue();
                                reportPackage = (String) val.second;
                            } else {
                                memLimit = 0;
                                reportPackage = null;
                            }
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    if (procName != null) {
                        if (ActivityManagerDebugConfig.DEBUG_PSS) {
                            Slog.d(ActivityManagerService.TAG_PSS, "Showing dump heap notification from " + procName + "/" + uid);
                        }
                        inm = NotificationManager.getService();
                        if (inm != null) {
                            text = ActivityManagerService.this.mContext.getString(17039806, new Object[]{procName});
                            Intent deleteIntent = new Intent();
                            deleteIntent.setAction("com.android.server.am.DELETE_DUMPHEAP");
                            Intent intent = new Intent();
                            intent.setClassName("android", DumpHeapActivity.class.getName());
                            intent.putExtra("process", procName);
                            intent.putExtra("size", memLimit);
                            if (reportPackage != null) {
                                intent.putExtra("direct_launch", reportPackage);
                            }
                            userId = UserHandle.getUserId(uid);
                            try {
                                inm.enqueueNotificationWithTag("android", "android", null, 12, new Builder(ActivityManagerService.this.mContext, SystemNotificationChannels.DEVELOPER).setSmallIcon(17303429).setWhen(0).setOngoing(true).setAutoCancel(true).setTicker(text).setColor(ActivityManagerService.this.mContext.getColor(17170763)).setContentTitle(text).setContentText(ActivityManagerService.this.mContext.getText(17039807)).setContentIntent(PendingIntent.getActivityAsUser(ActivityManagerService.this.mContext, 0, intent, 268435456, null, new UserHandle(userId))).setDeleteIntent(PendingIntent.getBroadcastAsUser(ActivityManagerService.this.mContext, 0, deleteIntent, 0, UserHandle.SYSTEM)).build(), userId);
                                break;
                            } catch (Throwable e222) {
                                Slog.w(ActivityManagerService.TAG, "Error showing notification for dump heap", e222);
                                break;
                            } catch (RemoteException e12) {
                                break;
                            }
                        }
                        return;
                    }
                    return;
                case 51:
                    ActivityManagerService.this.revokeUriPermission(ActivityThread.currentActivityThread().getApplicationThread(), null, DumpHeapActivity.JAVA_URI, 3, UserHandle.myUserId());
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.mMemWatchDumpFile = null;
                            ActivityManagerService.this.mMemWatchDumpProcName = null;
                            ActivityManagerService.this.mMemWatchDumpPid = -1;
                            ActivityManagerService.this.mMemWatchDumpUid = -1;
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 52:
                    ActivityManagerService.this.mUserController.dispatchForegroundProfileChanged(msg.arg1);
                    break;
                case 54:
                    msg.obj.deliverResult(ActivityManagerService.this.mContext);
                    break;
                case 55:
                    ActivityManagerService.this.mUserController.dispatchUserSwitchComplete(msg.arg1);
                    break;
                case 56:
                    try {
                        msg.obj.shutdown();
                    } catch (RemoteException e13) {
                        Slog.w(ActivityManagerService.TAG, "Error shutting down UiAutomationConnection");
                    }
                    ActivityManagerService.this.mUserIsMonkey = false;
                    break;
                case 57:
                    app = (ProcessRecord) msg.obj;
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.processContentProviderPublishTimedOutLocked(app);
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 58:
                    ActivityManagerService.this.idleUids();
                    break;
                case 59:
                    userId = msg.arg1;
                    ActivityManagerService.this.mSystemServiceManager.unlockUser(userId);
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.mRecentTasks.loadUserRecentsLocked(userId);
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    if (userId == 0) {
                        ActivityManagerService.this.startPersistentApps(DumpState.DUMP_DOMAIN_PREFERRED);
                    }
                    ActivityManagerService.this.installEncryptionUnawareProviders(userId);
                    ActivityManagerService.this.mUserController.finishUserUnlocked((UserState) msg.obj);
                    break;
                case 61:
                    if (ActivityManagerService.this.mVrController.onVrModeChanged((ActivityRecord) msg.obj)) {
                        synchronized (ActivityManagerService.this) {
                            try {
                                ActivityManagerService.boostPriorityForLockedSection();
                                boolean disableNonVrUi = ActivityManagerService.this.mVrController.shouldDisableNonVrUiLocked();
                                ActivityManagerService.this.mWindowManager.disableNonVrUi(disableNonVrUi);
                                if (disableNonVrUi && ((PinnedActivityStack) ActivityManagerService.this.mStackSupervisor.getStack(4)) != null) {
                                    ActivityManagerService.this.mStackSupervisor.removeStackLocked(4);
                                }
                            } finally {
                                ActivityManagerService.resetPriorityAfterLockedSection();
                            }
                        }
                        break;
                    }
                    return;
                case 63:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            for (i = ActivityManagerService.this.mLruProcesses.size() - 1; i >= 0; i--) {
                                r = (ProcessRecord) ActivityManagerService.this.mLruProcesses.get(i);
                                if (r.thread != null) {
                                    r.thread.handleTrustStorageUpdate();
                                }
                            }
                        } catch (RemoteException e14) {
                            Slog.w(ActivityManagerService.TAG, "Failed to handle trust storage update for: " + r.info.processName);
                        } catch (Throwable th5) {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    break;
                case 64:
                    ActivityManagerService.this.mUserController.dispatchLockedBootComplete(msg.arg1);
                    break;
                case 65:
                    ActivityManagerService.this.notifyVrManagerOfSleepState(msg.arg1 != 0);
                    break;
                case 66:
                    ActivityManagerService.this.mServices.serviceForegroundTimeout((ServiceRecord) msg.obj);
                    break;
                case 67:
                    RemoteCallbackList<IResultReceiver> callbacks = msg.obj;
                    int N = callbacks.beginBroadcast();
                    for (i = 0; i < N; i++) {
                        try {
                            ((IResultReceiver) callbacks.getBroadcastItem(i)).send(0, null);
                        } catch (RemoteException e15) {
                        }
                    }
                    callbacks.finishBroadcast();
                    break;
                case 69:
                    ActivityManagerService.this.mServices.serviceForegroundCrash((ProcessRecord) msg.obj);
                    break;
                case 74:
                    ActivityManagerService.this.notifyVrManagerOfKeyguardState(msg.arg1 != 0);
                    break;
                case ActivityManagerService.NETWORK_OPTS_CHECK_MSG /*88*/:
                    String packageName = msg.obj;
                    if (msg.arg1 == 0 && ActivityManagerService.mActivityTrigger != null) {
                        synchronized (ActivityManagerService.this.mNetLock) {
                            if (ActivityManagerService.this.mActiveNetType >= 0) {
                                ActivityManagerService.mActivityTrigger.activityMiscTrigger(2, packageName, ActivityManagerService.this.mActiveNetType, 0);
                                return;
                            }
                        }
                    }
                    if (ActivityManagerService.mActivityTrigger != null) {
                        ActivityManagerService.mActivityTrigger.activityMiscTrigger(2, packageName, -1, 1);
                        break;
                    }
                    break;
                case 400:
                    Slog.d(ActivityManagerService.TAG, "reset mIgnoreSleepCheckLater");
                    ActivityManagerService.this.mIgnoreSleepCheckLater = false;
                    break;
                case ActivityManagerService.SHOW_ACTIVITY_BEHIND_KEYGUARD_MSG /*420*/:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.mFinishWhenLockedState = 2;
                            ActivityRecord topRunning = ActivityManagerService.this.mStackSupervisor.getFocusedStack().topRunningActivityLocked();
                            if (!(topRunning == null || (topRunning.shortComponentName.equals("com.coloros.ocrscanner/.camera.CameraActivity") ^ 1) == 0)) {
                                ActivityManagerService.this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                            }
                            ActivityManagerService.this.mFinishWhenLockedState = 0;
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 500:
                    Intent in = msg.obj;
                    in.addFlags(1024);
                    ActivityManagerService.this.mContext.startActivity(Intent.createChooser(in, null).addFlags(67109376), null);
                    break;
                case ActivityManagerService.START_FORCESTOP_MSG /*511*/:
                    String localPkg = msg.obj;
                    ArraySet<Integer> pidsSet = ActivityManagerService.this.getPidsForPackage(localPkg);
                    ActivityRecord mFocusedActivity = ActivityManagerService.this.mStackSupervisor.getResumedActivityLocked();
                    if (!(mFocusedActivity == null || localPkg == null)) {
                        if ((localPkg.equals(mFocusedActivity.packageName) ^ 1) != 0 && ActivityManagerService.OPPO_LAUNCHER.equals(mFocusedActivity.packageName)) {
                            if (!OppoSplitWindowAppReader.isInBackStopFilterList(ActivityManagerService.this.mContext, localPkg, pidsSet, msg.arg1)) {
                                Slog.d(ActivityManagerService.TAG, "pkgName: " + localPkg + " userId: " + msg.arg1 + " killed for back_key");
                                ActivityManagerService.this.forceStopPackage(localPkg, msg.arg1);
                                break;
                            }
                        }
                    }
                    break;
                case ActivityManagerService.START_OPPO_SITE_MSG /*700*/:
                    String in2 = msg.obj;
                    Intent intent2 = new Intent("android.intent.action.WEB_SEARCH");
                    intent2.addFlags(268435456);
                    intent2.putExtra(ActivityManagerService.INTENT_QUERY_EXTRA, in2);
                    ActivityManagerService.this.mContext.startActivity(intent2);
                    break;
                case ActivityManagerService.START_USER_SWITCH_FG_MSG /*712*/:
                    ActivityManagerService.this.mUserController.startUserInForeground(msg.arg1);
                    break;
            }
        }
    }

    static final class ProcessChangeItem {
        static final int CHANGE_ACTIVITIES = 1;
        int changes;
        boolean foregroundActivities;
        int pid;
        int processState;
        int uid;

        ProcessChangeItem() {
        }
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "WangLan@Plf.Framework, modify for permission intercept", property = OppoRomType.OPPO)
    final class UiHandler extends Handler {
        public UiHandler() {
            super(UiThread.get().getLooper(), null, true);
        }

        /* JADX WARNING: inconsistent code. */
        /* Code decompiled incorrectly, please refer to instructions dump. */
        public void handleMessage(Message msg) {
            Dialog d;
            AlertDialog d2;
            ActivityRecord ar;
            switch (msg.what) {
                case 1:
                    ActivityManagerService.this.mAppErrors.handleShowAppErrorUi(msg);
                    ActivityManagerService.this.ensureBootCompleted();
                    break;
                case 2:
                    ActivityManagerService.this.mAppErrors.handleShowAnrUi(msg);
                    ActivityManagerService.this.ensureBootCompleted();
                    break;
                case 3:
                    new FactoryErrorDialog(ActivityManagerService.this.mUiContext, msg.getData().getCharSequence("msg")).show();
                    ActivityManagerService.this.ensureBootCompleted();
                    break;
                case 6:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ProcessRecord app = msg.obj;
                            if (msg.arg1 != 0) {
                                if (!app.waitedForDebugger) {
                                    d = new AppWaitingForDebuggerDialog(ActivityManagerService.this, ActivityManagerService.this.mUiContext, app);
                                    app.waitDialog = d;
                                    app.waitedForDebugger = true;
                                    d.show();
                                }
                            } else if (app.waitDialog != null) {
                                app.waitDialog.dismiss();
                                app.waitDialog = null;
                            }
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 14:
                    if (ActivityManagerService.this.mShowDialogs) {
                        d2 = new BaseErrorDialog(ActivityManagerService.this.mUiContext);
                        d2.getWindow().setType(2010);
                        d2.setCancelable(false);
                        d2.setTitle(ActivityManagerService.this.mUiContext.getText(17039483));
                        d2.setMessage(ActivityManagerService.this.mUiContext.getText(17040951));
                        d2.setButton(-1, ActivityManagerService.this.mUiContext.getText(17039370), obtainMessage(48, d2));
                        d2.show();
                        break;
                    }
                    break;
                case 15:
                    if (ActivityManagerService.this.mShowDialogs) {
                        d2 = new BaseErrorDialog(ActivityManagerService.this.mUiContext);
                        d2.getWindow().setType(2010);
                        d2.setCancelable(false);
                        d2.setTitle(ActivityManagerService.this.mUiContext.getText(17039483));
                        d2.setMessage(ActivityManagerService.this.mUiContext.getText(17040950));
                        d2.setButton(-1, ActivityManagerService.this.mUiContext.getText(17039370), obtainMessage(48, d2));
                        d2.show();
                        break;
                    }
                    break;
                case 26:
                    HashMap<String, Object> data = msg.obj;
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ProcessRecord proc = (ProcessRecord) data.get("app");
                            if (proc != null) {
                                if (proc.crashDialog == null) {
                                    AppErrorResult res = (AppErrorResult) data.get("result");
                                    if (ActivityManagerService.this.mShowDialogs && (ActivityManagerService.this.mSleeping ^ 1) != 0 && (ActivityManagerService.this.mShuttingDown ^ 1) != 0) {
                                        d = new StrictModeViolationDialog(ActivityManagerService.this.mUiContext, ActivityManagerService.this, res, proc);
                                        d.show();
                                        proc.crashDialog = d;
                                        break;
                                    }
                                    res.set(0);
                                    break;
                                }
                                Slog.e(ActivityManagerService.TAG, "App already has strict mode dialog: " + proc);
                                ActivityManagerService.resetPriorityAfterLockedSection();
                                return;
                            }
                            Slog.e(ActivityManagerService.TAG, "App not found when showing strict mode dialog.");
                            break;
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 30:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ar = msg.obj;
                            if (ActivityManagerService.this.mCompatModeDialog != null) {
                                if (!ActivityManagerService.this.mCompatModeDialog.mAppInfo.packageName.equals(ar.info.applicationInfo.packageName)) {
                                    ActivityManagerService.this.mCompatModeDialog.dismiss();
                                    ActivityManagerService.this.mCompatModeDialog = null;
                                    break;
                                }
                            }
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 31:
                    ActivityManagerService.this.dispatchProcessesChanged();
                    break;
                case 32:
                    ActivityManagerService.this.dispatchProcessDied(msg.arg1, msg.arg2);
                    break;
                case 46:
                    ActivityManagerService.this.mUserController.showUserSwitchDialog((Pair) msg.obj);
                    break;
                case 48:
                    ((Dialog) msg.obj).dismiss();
                    break;
                case 53:
                    ActivityManagerService.this.dispatchUidsChanged();
                    break;
                case ActivityManagerService.SHOW_UNSUPPORTED_DISPLAY_SIZE_DIALOG_MSG /*62*/:
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ar = (ActivityRecord) msg.obj;
                            if (ActivityManagerService.this.mUnsupportedDisplaySizeDialog != null) {
                                ActivityManagerService.this.mUnsupportedDisplaySizeDialog.dismiss();
                                ActivityManagerService.this.mUnsupportedDisplaySizeDialog = null;
                            }
                            if (ar != null && ActivityManagerService.this.mCompatModePackages.getPackageNotifyUnsupportedZoomLocked(ar.packageName)) {
                                ActivityManagerService.this.mUnsupportedDisplaySizeDialog = new UnsupportedDisplaySizeDialog(ActivityManagerService.this, ActivityManagerService.this.mUiContext, ar.info.applicationInfo);
                                ActivityManagerService.this.mUnsupportedDisplaySizeDialog.show();
                            }
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                    break;
                case 68:
                    ActivityManagerService.this.pushTempWhitelist();
                    break;
                case 70:
                    ActivityManagerService.this.dispatchOomAdjObserver((String) msg.obj);
                    break;
                case ActivityManagerService.SHOW_NOT_ALLOW_DIALOG_MSG /*410*/:
                    if (ActivityManagerService.this.mDialogForDisallow == null) {
                        ActivityManagerService.this.mDialogForDisallow = new BaseErrorDialog(ActivityManagerService.this.mUiContext);
                        ActivityManagerService.this.mDialogForDisallow.setCancelable(false);
                        ActivityManagerService.this.mDialogForDisallow.setMessage(ActivityManagerService.this.mUiContext.getText(17040363));
                        ActivityManagerService.this.mDialogForDisallow.setButton(-1, ActivityManagerService.this.mUiContext.getText(17039370), obtainMessage(48, ActivityManagerService.this.mDialogForDisallow));
                    }
                    if (!ActivityManagerService.this.mDialogForDisallow.isShowing()) {
                        ActivityManagerService.this.mDialogForDisallow.show();
                        break;
                    }
                    break;
                case 600:
                    if (ActivityManagerService.this.mShowDialogs) {
                        String packageName = msg.obj;
                        if (packageName != null) {
                            OppoAppStartupManager.getInstance().handleAppStartForbidden(packageName);
                        }
                        if (OppoAppStartupManager.getInstance().getDialogTitleText() == null || OppoAppStartupManager.getInstance().getDialogContentText() == null || OppoAppStartupManager.getInstance().getDialogButtonText() == null) {
                            d = new BaseErrorDialog(ActivityManagerService.this.mUiContext);
                            d.show();
                            if (d != null) {
                                d.dismiss();
                            }
                        } else {
                            AlertDialog dialog = new AlertDialog.Builder(ActivityManagerService.this.mContext, 201523207).create();
                            dialog.getWindow().setType(2003);
                            dialog.setCancelable(false);
                            dialog.setTitle(OppoAppStartupManager.getInstance().getDialogTitleText());
                            dialog.setMessage(OppoAppStartupManager.getInstance().getDialogContentText());
                            dialog.setButton(-1, OppoAppStartupManager.getInstance().getDialogButtonText(), obtainMessage(48, dialog));
                            dialog.show();
                        }
                        OppoAppStartupManager.getInstance().resetDialogShowText();
                        break;
                    }
                    break;
            }
        }
    }

    private static final class UpdateConfigurationResult {
        boolean activityRelaunched;
        int changes;

        /* synthetic */ UpdateConfigurationResult(UpdateConfigurationResult -this0) {
            this();
        }

        private UpdateConfigurationResult() {
        }

        void reset() {
            this.changes = 0;
            this.activityRelaunched = false;
        }
    }

    abstract class ImportanceToken implements DeathRecipient {
        final int pid;
        final String reason;
        final IBinder token;

        ImportanceToken(int _pid, IBinder _token, String _reason) {
            this.pid = _pid;
            this.token = _token;
            this.reason = _reason;
        }

        public String toString() {
            return "ImportanceToken { " + Integer.toHexString(System.identityHashCode(this)) + " " + this.reason + " " + this.pid + " " + this.token + " }";
        }
    }

    private final class AppDeathRecipient implements DeathRecipient {
        final ProcessRecord mApp;
        final IApplicationThread mAppThread;
        final int mPid;

        AppDeathRecipient(ProcessRecord app, int pid, IApplicationThread thread) {
            this.mApp = app;
            this.mPid = pid;
            this.mAppThread = thread;
        }

        public void binderDied() {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.appDiedLocked(this.mApp, this.mPid, this.mAppThread, true);
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
        }
    }

    class AppTaskImpl extends IAppTask.Stub {
        private int mCallingUid;
        private int mTaskId;

        public AppTaskImpl(int taskId, int callingUid) {
            this.mTaskId = taskId;
            this.mCallingUid = callingUid;
        }

        private void checkCaller() {
            if (this.mCallingUid != Binder.getCallingUid()) {
                throw new SecurityException("Caller " + this.mCallingUid + " does not match caller of getAppTasks(): " + Binder.getCallingUid());
            }
        }

        public void finishAndRemoveTask() {
            checkCaller();
            synchronized (ActivityManagerService.this) {
                long origId;
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    origId = Binder.clearCallingIdentity();
                    if (ActivityManagerService.this.mStackSupervisor.removeTaskByIdLocked(this.mTaskId, false, true)) {
                        Binder.restoreCallingIdentity(origId);
                    } else {
                        throw new IllegalArgumentException("Unable to find task ID " + this.mTaskId);
                    }
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        public RecentTaskInfo getTaskInfo() {
            RecentTaskInfo -wrap0;
            checkCaller();
            synchronized (ActivityManagerService.this) {
                long origId;
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    origId = Binder.clearCallingIdentity();
                    TaskRecord tr = ActivityManagerService.this.mStackSupervisor.anyTaskForIdLocked(this.mTaskId);
                    if (tr == null) {
                        throw new IllegalArgumentException("Unable to find task ID " + this.mTaskId);
                    }
                    -wrap0 = ActivityManagerService.this.createRecentTaskInfoFromTaskRecord(tr);
                    Binder.restoreCallingIdentity(origId);
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
            return -wrap0;
        }

        public void moveToFront() {
            checkCaller();
            long origId = Binder.clearCallingIdentity();
            try {
                synchronized (this) {
                    ActivityManagerService.this.mStackSupervisor.startActivityFromRecentsInner(this.mTaskId, null);
                }
            } finally {
                Binder.restoreCallingIdentity(origId);
            }
        }

        public int startActivity(IBinder whoThread, String callingPackage, Intent intent, String resolvedType, Bundle bOptions) {
            TaskRecord tr;
            IApplicationThread appThread;
            checkCaller();
            int callingUser = UserHandle.getCallingUserId();
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    tr = ActivityManagerService.this.mStackSupervisor.anyTaskForIdLocked(this.mTaskId);
                    if (tr == null) {
                        throw new IllegalArgumentException("Unable to find task ID " + this.mTaskId);
                    }
                    appThread = IApplicationThread.Stub.asInterface(whoThread);
                    if (appThread == null) {
                        throw new IllegalArgumentException("Bad app thread " + appThread);
                    }
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            return ActivityManagerService.this.mActivityStarter.startActivityMayWait(appThread, -1, callingPackage, intent, resolvedType, null, null, null, null, 0, 0, null, null, null, bOptions, false, callingUser, tr, "AppTaskImpl");
        }

        public void setExcludeFromRecents(boolean exclude) {
            checkCaller();
            synchronized (ActivityManagerService.this) {
                long origId;
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    origId = Binder.clearCallingIdentity();
                    TaskRecord tr = ActivityManagerService.this.mStackSupervisor.anyTaskForIdLocked(this.mTaskId);
                    if (tr == null) {
                        throw new IllegalArgumentException("Unable to find task ID " + this.mTaskId);
                    }
                    Intent intent = tr.getBaseIntent();
                    if (exclude) {
                        intent.addFlags(DumpState.DUMP_VOLUMES);
                    } else {
                        intent.setFlags(intent.getFlags() & -8388609);
                    }
                    Binder.restoreCallingIdentity(origId);
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }
    }

    static final class Association {
        int mCount;
        int mLastState = 19;
        long mLastStateUptime;
        int mNesting;
        final String mSourceProcess;
        final int mSourceUid;
        long mStartTime;
        long[] mStateTimes = new long[19];
        final ComponentName mTargetComponent;
        final String mTargetProcess;
        final int mTargetUid;
        long mTime;

        Association(int sourceUid, String sourceProcess, int targetUid, ComponentName targetComponent, String targetProcess) {
            this.mSourceUid = sourceUid;
            this.mSourceProcess = sourceProcess;
            this.mTargetUid = targetUid;
            this.mTargetComponent = targetComponent;
            this.mTargetProcess = targetProcess;
        }
    }

    static class CpuBinder extends Binder {
        ActivityManagerService mActivityManagerService;

        CpuBinder(ActivityManagerService activityManagerService) {
            this.mActivityManagerService = activityManagerService;
        }

        protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
            if (DumpUtils.checkDumpAndUsageStatsPermission(this.mActivityManagerService.mContext, "cpuinfo", pw)) {
                synchronized (this.mActivityManagerService.mProcessCpuTracker) {
                    pw.print(this.mActivityManagerService.mProcessCpuTracker.printCurrentLoad());
                    pw.print(this.mActivityManagerService.mProcessCpuTracker.printCurrentState(SystemClock.uptimeMillis()));
                }
            }
        }
    }

    static class DbBinder extends Binder {
        ActivityManagerService mActivityManagerService;

        DbBinder(ActivityManagerService activityManagerService) {
            this.mActivityManagerService = activityManagerService;
        }

        protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
            if (DumpUtils.checkDumpAndUsageStatsPermission(this.mActivityManagerService.mContext, "dbinfo", pw)) {
                this.mActivityManagerService.dumpDbInfo(fd, pw, args);
            }
        }
    }

    private class DebugActionThread extends Thread {
        private static final int MAX_COUNT_FOR_TRACE = 4;
        private static final String STR_FILE_PATH_ACT_CUR = "data/system/dropbox/act_top_cur.txt";
        private static final String STR_FILE_PATH_ACT_PRE = "data/system/dropbox/act_top_pre.txt";
        private static final String STR_FILE_PATH_WMS_CUR = "data/system/dropbox/wms_top_cur.txt";
        private static final String STR_FILE_PATH_WMS_PRE = "data/system/dropbox/wms_top_pre.txt";
        private static final String STR_PROC_NAME_WECHATPUSH = "com.tencent.mm:push";
        private static final String STR_PROC_NAME_WECHATUI = "com.tencent.mm";
        static final String STR_WECHAT_DEBUG_TRACE_PREFIX = "traces_wechat_dbg_";
        private DebugTraceManager mDebugTraceManager = null;
        private final ActivityManagerService mService;

        public DebugActionThread(ActivityManagerService service) {
            super("DbgAction");
            this.mService = service;
        }

        public void run() {
            debugActionImplWhenScreenshot();
        }

        private void debugActionImplWhenScreenshot() {
            if (ServiceManager.getService("dropbox") == null) {
                Slog.d(ActivityManagerService.TAG, "debugActionImplWhenScreenshot, dropbox not ready");
                return;
            }
            Slog.d(ActivityManagerService.TAG, "debugActionImplWhenScreenshot...");
            dumpCurTopActivityInfo();
            dumpCurTopAppWindowsInfo();
            dumpCurTopAppBacktrace();
        }

        /* JADX WARNING: inconsistent code. */
        /* Code decompiled incorrectly, please refer to instructions dump. */
        private void dumpCurTopActivityInfo() {
            Exception exce;
            Throwable th;
            FileOutputStream fdOut = null;
            try {
                Writer stringWriter = new StringWriter();
                try {
                    File curTopActFile = new File(STR_FILE_PATH_ACT_CUR);
                    if (curTopActFile.exists()) {
                        File file = new File(STR_FILE_PATH_ACT_PRE);
                        if (file.exists()) {
                            file.delete();
                        }
                        Slog.d(ActivityManagerService.TAG, "renameRes:" + curTopActFile.renameTo(file));
                    } else {
                        curTopActFile.createNewFile();
                    }
                    FileOutputStream fileOutputStream = new FileOutputStream(curTopActFile);
                    try {
                        Slog.d(ActivityManagerService.TAG, "debugActionImplWhenScreenshot:dumpActRes " + ActivityManagerService.this.dumpActivity(fileOutputStream.getFD(), new PrintWriter(stringWriter), "top", new String[]{"top"}, 1, false, true, true));
                        SystemClock.sleep(ActivityManagerService.NETWORK_ACCESS_TIMEOUT_DEFAULT_MS);
                        if (fileOutputStream != null) {
                            try {
                                fileOutputStream.close();
                            } catch (Exception e) {
                                Slog.e(ActivityManagerService.TAG, "last colse fdOut failed.", e);
                            }
                        }
                        fdOut = fileOutputStream;
                    } catch (Exception e2) {
                        exce = e2;
                        fdOut = fileOutputStream;
                        try {
                            Slog.w(ActivityManagerService.TAG, "debugActionImplWhenScreenshot failed:", exce);
                            if (fdOut != null) {
                                try {
                                    fdOut.close();
                                } catch (Exception e3) {
                                    Slog.e(ActivityManagerService.TAG, "last colse fdOut failed.", e3);
                                }
                            }
                        } catch (Throwable th2) {
                            th = th2;
                            if (fdOut != null) {
                                try {
                                    fdOut.close();
                                } catch (Exception e32) {
                                    Slog.e(ActivityManagerService.TAG, "last colse fdOut failed.", e32);
                                }
                            }
                            throw th;
                        }
                    } catch (Throwable th3) {
                        th = th3;
                        fdOut = fileOutputStream;
                        if (fdOut != null) {
                            try {
                                fdOut.close();
                            } catch (Exception e322) {
                                Slog.e(ActivityManagerService.TAG, "last colse fdOut failed.", e322);
                            }
                        }
                        throw th;
                    }
                } catch (Exception e4) {
                    Slog.e(ActivityManagerService.TAG, "create failed.");
                    if (fdOut != null) {
                        try {
                            fdOut.close();
                        } catch (Exception e3222) {
                            Slog.e(ActivityManagerService.TAG, "last colse fdOut failed.", e3222);
                        }
                    }
                }
            } catch (Exception e5) {
                exce = e5;
                Slog.w(ActivityManagerService.TAG, "debugActionImplWhenScreenshot failed:", exce);
                if (fdOut != null) {
                    try {
                        fdOut.close();
                    } catch (Exception e32222) {
                        Slog.e(ActivityManagerService.TAG, "last colse fdOut failed.", e32222);
                    }
                }
            }
        }

        private void dumpCurTopAppBacktrace() {
            String tracesName;
            ArrayList targetPids = new ArrayList(4);
            synchronized (this.mService) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    int processCount = 0;
                    for (int i = this.mService.mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = (ProcessRecord) this.mService.mLruProcesses.get(i);
                        if (!(r == null || r.thread == null)) {
                            int pid = r.pid;
                            if (r.uid > 1000 && pid > 0 && pid != ActivityManagerService.MY_PID) {
                                String processName = r.processName;
                                if (STR_PROC_NAME_WECHATUI.equals(processName) || STR_PROC_NAME_WECHATPUSH.equals(processName)) {
                                    if (processCount > 4) {
                                        break;
                                    }
                                    targetPids.add(Integer.valueOf(pid));
                                    processCount++;
                                }
                            }
                        }
                    }
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            File tracesFile = ActivityManagerService.dumpStackTraces(false, targetPids, null, null, null);
            if (tracesFile != null) {
                tracesName = STR_WECHAT_DEBUG_TRACE_PREFIX + new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss-SSS").format(new Date()) + ".txt";
                File renameFile = new File("data/anr/" + tracesName);
                tracesFile.renameTo(renameFile);
                ASSERT.copyAnr(renameFile.getPath(), tracesName);
            }
            SystemClock.sleep(2000);
            File tracesFileAfter = ActivityManagerService.dumpStackTraces(false, targetPids, null, null, null);
            if (tracesFileAfter != null) {
                tracesName = STR_WECHAT_DEBUG_TRACE_PREFIX + new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss-SSS").format(new Date()) + ".txt";
                File renameAfterFile = new File("data/anr/" + tracesName);
                tracesFileAfter.renameTo(renameAfterFile);
                ASSERT.copyAnr(renameAfterFile.getPath(), tracesName);
            }
            SystemClock.sleep(4000);
            if (this.mDebugTraceManager == null) {
                this.mDebugTraceManager = new DebugTraceManager();
            }
            this.mDebugTraceManager.clearOldDebugTraceFiles();
        }

        /* JADX WARNING: inconsistent code. */
        /* Code decompiled incorrectly, please refer to instructions dump. */
        private void dumpCurTopAppWindowsInfo() {
            Exception exce;
            Throwable th;
            if (ActivityManagerService.this.mWindowManager != null) {
                FileOutputStream fdOut = null;
                try {
                    FileOutputStream fdOut2;
                    Writer stringWriter = new StringWriter();
                    try {
                        File curWmsFile = new File(STR_FILE_PATH_WMS_CUR);
                        if (curWmsFile.exists()) {
                            File file = new File(STR_FILE_PATH_WMS_PRE);
                            if (file.exists()) {
                                file.delete();
                            }
                            Slog.d(ActivityManagerService.TAG, "renameRes:" + curWmsFile.renameTo(file));
                        } else {
                            curWmsFile.createNewFile();
                        }
                        fdOut2 = new FileOutputStream(curWmsFile);
                    } catch (Exception e) {
                        Slog.e(ActivityManagerService.TAG, "create failed.");
                        if (fdOut != null) {
                            try {
                                fdOut.close();
                            } catch (Exception e2) {
                                Slog.e(ActivityManagerService.TAG, "last colse fdOut failed.", e2);
                            }
                        }
                        return;
                    }
                    try {
                        FileDescriptor fileFd = fdOut2.getFD();
                        ActivityManagerService.this.mWindowManager.dump(fileFd, new PrintWriter(stringWriter), new String[]{"windows"});
                        SystemClock.sleep(100);
                        String dumpResStr = stringWriter.toString();
                        if (!(dumpResStr == null || (dumpResStr.isEmpty() ^ 1) == 0)) {
                            BufferedWriter destBuffWriter = null;
                            try {
                                FileWriter destFileWriter = new FileWriter(fileFd);
                                try {
                                    BufferedWriter destBuffWriter2 = new BufferedWriter(destFileWriter);
                                    try {
                                        destBuffWriter2.write(dumpResStr);
                                        destBuffWriter2.flush();
                                        destBuffWriter2.close();
                                    } catch (IOException e3) {
                                        destBuffWriter = destBuffWriter2;
                                        FileWriter fileWriter = destFileWriter;
                                        Slog.w(ActivityManagerService.TAG, "destFileOpStream IO failed.");
                                        if (destBuffWriter != null) {
                                            try {
                                                destBuffWriter.close();
                                            } catch (IOException e4) {
                                                Slog.w(ActivityManagerService.TAG, "destFileOpStream close failed.");
                                            }
                                        }
                                        if (fdOut2 != null) {
                                            try {
                                                fdOut2.close();
                                            } catch (Exception e22) {
                                                Slog.e(ActivityManagerService.TAG, "last colse fdOut failed.", e22);
                                            }
                                        }
                                        return;
                                    }
                                } catch (IOException e5) {
                                    Slog.w(ActivityManagerService.TAG, "destFileOpStream IO failed.");
                                    if (destBuffWriter != null) {
                                        try {
                                            destBuffWriter.close();
                                        } catch (IOException e42) {
                                            Slog.w(ActivityManagerService.TAG, "destFileOpStream close failed.");
                                        }
                                    }
                                    if (fdOut2 != null) {
                                        try {
                                            fdOut2.close();
                                        } catch (Exception e222) {
                                            Slog.e(ActivityManagerService.TAG, "last colse fdOut failed.", e222);
                                        }
                                    }
                                    return;
                                }
                            } catch (IOException e6) {
                                Slog.w(ActivityManagerService.TAG, "destFileOpStream IO failed.");
                                if (destBuffWriter != null) {
                                    try {
                                        destBuffWriter.close();
                                    } catch (IOException e422) {
                                        Slog.w(ActivityManagerService.TAG, "destFileOpStream close failed.");
                                    }
                                }
                                if (fdOut2 != null) {
                                    try {
                                        fdOut2.close();
                                    } catch (Exception e2222) {
                                        Slog.e(ActivityManagerService.TAG, "last colse fdOut failed.", e2222);
                                    }
                                }
                                return;
                            }
                        }
                        if (fdOut2 != null) {
                            try {
                                fdOut2.close();
                            } catch (Exception e22222) {
                                Slog.e(ActivityManagerService.TAG, "last colse fdOut failed.", e22222);
                            }
                        }
                        fdOut = fdOut2;
                    } catch (Exception e7) {
                        exce = e7;
                        fdOut = fdOut2;
                    } catch (Throwable th2) {
                        th = th2;
                        fdOut = fdOut2;
                        if (fdOut != null) {
                            try {
                                fdOut.close();
                            } catch (Exception e222222) {
                                Slog.e(ActivityManagerService.TAG, "last colse fdOut failed.", e222222);
                            }
                        }
                        throw th;
                    }
                } catch (Exception e8) {
                    exce = e8;
                    try {
                        Slog.w(ActivityManagerService.TAG, "debugActionImplWhenScreenshot failed:", exce);
                        if (fdOut != null) {
                            try {
                                fdOut.close();
                            } catch (Exception e2222222) {
                                Slog.e(ActivityManagerService.TAG, "last colse fdOut failed.", e2222222);
                            }
                        }
                    } catch (Throwable th3) {
                        th = th3;
                        if (fdOut != null) {
                            try {
                                fdOut.close();
                            } catch (Exception e22222222) {
                                Slog.e(ActivityManagerService.TAG, "last colse fdOut failed.", e22222222);
                            }
                        }
                        throw th;
                    }
                }
            }
        }
    }

    private class DebugTraceManager {
        private static final int MAX_FILE_COUT_TO_CHECK = 10;
        private static final int MAX_FILE_COUT_TO_KEEP = 6;

        public void clearOldDebugTraceFiles() {
            File anrFilesDir = new File("data/anr");
            if (anrFilesDir.exists()) {
                String[] fileList = anrFilesDir.list(new FilenameFilter() {
                    public boolean accept(File dir, String name) {
                        if (name == null || (name.isEmpty() ^ 1) == 0 || !name.startsWith("traces_wechat_dbg_")) {
                            return false;
                        }
                        return true;
                    }
                });
                if (fileList != null && fileList.length > 10) {
                    int listLength = fileList.length;
                    FileComparePair[] fileComparePairs = new FileComparePair[listLength];
                    for (int index = 0; index < listLength; index++) {
                        FileComparePair filePair = new FileComparePair();
                        filePair.setFile(new File("data/anr/" + fileList[index]));
                        fileComparePairs[index] = filePair;
                    }
                    Arrays.sort(fileComparePairs);
                    for (int delIndex = 6; delIndex < listLength; delIndex++) {
                        File delFile = fileComparePairs[delIndex].file;
                        if (delFile != null && delFile.exists()) {
                            try {
                                Slog.d(ActivityManagerService.TAG, "del old file:" + delFile.getPath());
                                delFile.delete();
                            } catch (Exception e) {
                                Slog.w(ActivityManagerService.TAG, "delte failed." + delFile);
                            }
                        }
                    }
                }
            }
        }
    }

    @Deprecated
    public static class DumpStackFileObserver extends FileObserver {
        private static final int TRACE_DUMP_TIMEOUT_MS = 10000;
        private boolean mClosed;
        private final String mTracesPath;

        public DumpStackFileObserver(String tracesPath) {
            super(tracesPath, 8);
            this.mTracesPath = tracesPath;
        }

        public synchronized void onEvent(int event, String path) {
            this.mClosed = true;
            notify();
        }

        public long dumpWithTimeout(int pid, long timeout) {
            Process.sendSignal(pid, 3);
            long start = SystemClock.elapsedRealtime();
            long waitTime = Math.min(timeout, 10000);
            synchronized (this) {
                try {
                    wait(waitTime);
                } catch (InterruptedException e) {
                    Slog.wtf(ActivityManagerService.TAG, e);
                }
            }
            long timeWaited = SystemClock.elapsedRealtime() - start;
            if (timeWaited >= timeout) {
                return timeWaited;
            }
            if (!this.mClosed) {
                Slog.w(ActivityManagerService.TAG, "Didn't see close of " + this.mTracesPath + " for pid " + pid + ". Attempting native stack collection.");
                int i = pid;
                Debug.dumpNativeBacktraceToFileTimeout(i, this.mTracesPath, (int) (Math.min(2000, timeout - timeWaited) / 1000));
            }
            long end = SystemClock.elapsedRealtime();
            this.mClosed = false;
            return end - start;
        }
    }

    private class FileComparePair implements Comparable {
        public File file = null;
        public long lastModifiedTime = 0;

        public void setFile(File comparFile) {
            if (comparFile != null && (comparFile.exists() ^ 1) == 0) {
                this.file = comparFile;
                this.lastModifiedTime = this.file.lastModified();
            }
        }

        public int compareTo(Object o) {
            long otherTime = ((FileComparePair) o).lastModifiedTime;
            if (this.lastModifiedTime > otherTime) {
                return -1;
            }
            return this.lastModifiedTime == otherTime ? 0 : 1;
        }
    }

    private final class FontScaleSettingObserver extends ContentObserver {
        private final Uri mFontScaleUri = System.getUriFor("font_scale");

        public FontScaleSettingObserver() {
            super(ActivityManagerService.this.mHandler);
            ActivityManagerService.this.mContext.getContentResolver().registerContentObserver(this.mFontScaleUri, false, this, -1);
        }

        public void onChange(boolean selfChange, Uri uri, int userId) {
            if (this.mFontScaleUri.equals(uri)) {
                ActivityManagerService.this.updateFontScaleIfNeeded(userId);
            }
        }
    }

    public static class GrantUri {
        public boolean prefix;
        public final int sourceUserId;
        public final Uri uri;

        public GrantUri(int sourceUserId, Uri uri, boolean prefix) {
            this.sourceUserId = sourceUserId;
            this.uri = uri;
            this.prefix = prefix;
        }

        public int hashCode() {
            return ((((this.sourceUserId + 31) * 31) + this.uri.hashCode()) * 31) + (this.prefix ? 1231 : 1237);
        }

        public boolean equals(Object o) {
            boolean z = false;
            if (!(o instanceof GrantUri)) {
                return false;
            }
            GrantUri other = (GrantUri) o;
            if (this.uri.equals(other.uri) && this.sourceUserId == other.sourceUserId && this.prefix == other.prefix) {
                z = true;
            }
            return z;
        }

        public String toString() {
            String result = this.uri.toString() + " [user " + this.sourceUserId + "]";
            if (this.prefix) {
                return result + " [prefix]";
            }
            return result;
        }

        public String toSafeString() {
            String result = this.uri.toSafeString() + " [user " + this.sourceUserId + "]";
            if (this.prefix) {
                return result + " [prefix]";
            }
            return result;
        }

        public static GrantUri resolve(int defaultSourceUserHandle, Uri uri) {
            return new GrantUri(ContentProvider.getUserIdFromUri(uri, defaultSourceUserHandle), ContentProvider.getUriWithoutUserId(uri), false);
        }
    }

    static class GraphicsBinder extends Binder {
        ActivityManagerService mActivityManagerService;

        GraphicsBinder(ActivityManagerService activityManagerService) {
            this.mActivityManagerService = activityManagerService;
        }

        protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
            if (DumpUtils.checkDumpAndUsageStatsPermission(this.mActivityManagerService.mContext, "gfxinfo", pw)) {
                this.mActivityManagerService.dumpGraphicsHardwareUsage(fd, pw, args);
            }
        }
    }

    private class Identity {
        public final int pid;
        public final IBinder token;
        public final int uid;

        Identity(IBinder _token, int _pid, int _uid) {
            this.token = _token;
            this.pid = _pid;
            this.uid = _uid;
        }
    }

    static class ItemMatcher {
        boolean all = true;
        ArrayList<ComponentName> components;
        ArrayList<Integer> objects;
        ArrayList<String> strings;

        ItemMatcher() {
        }

        void build(String name) {
            ComponentName componentName = ComponentName.unflattenFromString(name);
            if (componentName != null) {
                if (this.components == null) {
                    this.components = new ArrayList();
                }
                this.components.add(componentName);
                this.all = false;
                return;
            }
            try {
                int objectId = Integer.parseInt(name, 16);
                if (this.objects == null) {
                    this.objects = new ArrayList();
                }
                this.objects.add(Integer.valueOf(objectId));
                this.all = false;
            } catch (RuntimeException e) {
                if (this.strings == null) {
                    this.strings = new ArrayList();
                }
                this.strings.add(name);
                this.all = false;
            }
        }

        int build(String[] args, int opti) {
            while (opti < args.length) {
                String name = args[opti];
                if ("--".equals(name)) {
                    return opti + 1;
                }
                build(name);
                opti++;
            }
            return opti;
        }

        boolean match(Object object, ComponentName comp) {
            if (this.all) {
                return true;
            }
            int i;
            if (this.components != null) {
                for (i = 0; i < this.components.size(); i++) {
                    if (((ComponentName) this.components.get(i)).equals(comp)) {
                        return true;
                    }
                }
            }
            if (this.objects != null) {
                for (i = 0; i < this.objects.size(); i++) {
                    if (System.identityHashCode(object) == ((Integer) this.objects.get(i)).intValue()) {
                        return true;
                    }
                }
            }
            if (this.strings != null) {
                String flat = comp.flattenToString();
                for (i = 0; i < this.strings.size(); i++) {
                    if (flat.contains((CharSequence) this.strings.get(i))) {
                        return true;
                    }
                }
            }
            return false;
        }
    }

    static class MemBinder extends Binder {
        ActivityManagerService mActivityManagerService;

        MemBinder(ActivityManagerService activityManagerService) {
            this.mActivityManagerService = activityManagerService;
        }

        protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
            if (DumpUtils.checkDumpAndUsageStatsPermission(this.mActivityManagerService.mContext, "meminfo", pw)) {
                this.mActivityManagerService.dumpApplicationMemoryUsage(fd, pw, "  ", args, false, null);
            }
        }
    }

    static final class MemItem {
        final boolean hasActivities;
        final int id;
        final boolean isProc = false;
        final String label;
        final long pss;
        final String shortLabel;
        ArrayList<MemItem> subitems;
        final long swapPss;

        public MemItem(String _label, String _shortLabel, long _pss, long _swapPss, int _id, boolean _hasActivities) {
            this.label = _label;
            this.shortLabel = _shortLabel;
            this.pss = _pss;
            this.swapPss = _swapPss;
            this.id = _id;
            this.hasActivities = _hasActivities;
        }

        public MemItem(String _label, String _shortLabel, long _pss, long _swapPss, int _id) {
            this.label = _label;
            this.shortLabel = _shortLabel;
            this.pss = _pss;
            this.swapPss = _swapPss;
            this.id = _id;
            this.hasActivities = false;
        }
    }

    static class NeededUriGrants extends ArrayList<GrantUri> {
        final int flags;
        final String targetPkg;
        final int targetUid;

        NeededUriGrants(String targetPkg, int targetUid, int flags) {
            this.targetPkg = targetPkg;
            this.targetUid = targetUid;
            this.flags = flags;
        }
    }

    interface OomAdjObserver {
        void onOomAdjMessage(String str);
    }

    public class PendingAssistExtras extends Binder implements Runnable {
        public final ActivityRecord activity;
        public AssistContent content = null;
        public final Bundle extras;
        public boolean haveResult = false;
        public final String hint;
        public final Intent intent;
        public boolean isHome;
        public final IResultReceiver receiver;
        public Bundle receiverExtras;
        public Bundle result = null;
        public AssistStructure structure = null;
        public final int userHandle;

        public PendingAssistExtras(ActivityRecord _activity, Bundle _extras, Intent _intent, String _hint, IResultReceiver _receiver, Bundle _receiverExtras, int _userHandle) {
            this.activity = _activity;
            this.extras = _extras;
            this.intent = _intent;
            this.hint = _hint;
            this.receiver = _receiver;
            this.receiverExtras = _receiverExtras;
            this.userHandle = _userHandle;
        }

        public void run() {
            Slog.w(ActivityManagerService.TAG, "getAssistContextExtras failed: timeout retrieving from " + this.activity);
            synchronized (this) {
                this.haveResult = true;
                notifyAll();
            }
            ActivityManagerService.this.pendingAssistExtrasTimedOut(this);
        }
    }

    static final class PendingTempWhitelist {
        final long duration;
        final String tag;
        final int targetUid;

        PendingTempWhitelist(int _targetUid, long _duration, String _tag) {
            this.targetUid = _targetUid;
            this.duration = _duration;
            this.tag = _tag;
        }
    }

    static class PermissionController extends IPermissionController.Stub {
        ActivityManagerService mActivityManagerService;

        PermissionController(ActivityManagerService activityManagerService) {
            this.mActivityManagerService = activityManagerService;
        }

        @OppoHook(level = OppoHookType.CHANGE_CODE, note = "WangLan@Plf.Framework, modify for permission intercept", property = OppoRomType.OPPO)
        public boolean checkPermission(String permission, int pid, int uid) {
            boolean z = true;
            int newUid = uid;
            if (UserHandle.getUserId(uid) == OppoMultiAppManager.USER_ID) {
                newUid = UserHandle.getUid(this.mActivityManagerService.mUserController.getCurrentUserIdLocked(), UserHandle.getAppId(uid));
                Slog.d(ActivityManagerService.TAG, "multi app: checkPermission uid from " + uid + " to " + newUid);
            }
            if (Binder.getCallingUid() < 10000) {
                if (permission.startsWith(OppoPermissionConstants.PERMISSION_SEND_SMS)) {
                    permission = OppoPermissionConstants.PERMISSION_SEND_SMS;
                } else if (permission.startsWith(OppoPermissionConstants.PERMISSION_CALL_PHONE)) {
                    permission = OppoPermissionConstants.PERMISSION_CALL_PHONE;
                }
                if (this.mActivityManagerService.checkPermission(permission, pid, newUid) != 0) {
                    z = false;
                }
                return z;
            }
            if (OppoPermissionCallback.checkOppoPermission(permission, pid, newUid, this.mActivityManagerService) != 0) {
                z = false;
            }
            return z;
        }

        public String[] getPackagesForUid(int uid) {
            return this.mActivityManagerService.mContext.getPackageManager().getPackagesForUid(uid);
        }

        public boolean isRuntimePermission(String permission) {
            boolean z = true;
            try {
                if ((this.mActivityManagerService.mContext.getPackageManager().getPermissionInfo(permission, 0).protectionLevel & 15) != 1) {
                    z = false;
                }
                return z;
            } catch (NameNotFoundException nnfe) {
                Slog.e(ActivityManagerService.TAG, "No such permission: " + permission, nnfe);
                return false;
            }
        }
    }

    static class ProcessInfoService extends IProcessInfoService.Stub {
        final ActivityManagerService mActivityManagerService;

        ProcessInfoService(ActivityManagerService activityManagerService) {
            this.mActivityManagerService = activityManagerService;
        }

        public void getProcessStatesFromPids(int[] pids, int[] states) {
            this.mActivityManagerService.getProcessStatesAndOomScoresForPIDs(pids, states, null);
        }

        public void getProcessStatesAndOomScoresFromPids(int[] pids, int[] states, int[] scores) {
            this.mActivityManagerService.getProcessStatesAndOomScoresForPIDs(pids, states, scores);
        }
    }

    static final class UidObserverRegistration {
        final int cutpoint;
        final SparseIntArray lastProcStates;
        final String pkg;
        final int uid;
        final int which;

        UidObserverRegistration(int _uid, String _pkg, int _which, int _cutpoint) {
            this.uid = _uid;
            this.pkg = _pkg;
            this.which = _which;
            this.cutpoint = _cutpoint;
            if (this.cutpoint >= 0) {
                this.lastProcStates = new SparseIntArray();
            } else {
                this.lastProcStates = null;
            }
        }
    }

    BroadcastQueue broadcastQueueForIntent(Intent intent) {
        boolean isFg = (intent.getFlags() & 268435456) != 0;
        if (ActivityManagerDebugConfig.DEBUG_BROADCAST_BACKGROUND) {
            Slog.i(TAG_BROADCAST, "Broadcast intent " + intent + " on " + (isFg ? "foreground" : "background") + " queue");
        }
        return isFg ? this.mFgBroadcastQueue : this.mBgBroadcastQueue;
    }

    ReceiverRecord broadcastRecordForNotOrderReceiverLocked(IBinder receiver, int hasCode) {
        for (BroadcastQueue queue : this.mBroadcastQueues) {
            ReceiverRecord mReceiverRecord = queue.getMatchingNotOrderedReceiver(receiver, hasCode);
            if (mReceiverRecord != null) {
                return mReceiverRecord;
            }
        }
        return null;
    }

    public boolean canShowErrorDialogs() {
        int i = 0;
        if (!this.mShowDialogs || (this.mSleeping ^ 1) == 0 || (this.mShuttingDown ^ 1) == 0 || (this.mKeyguardController.isKeyguardShowing(0) ^ 1) == 0) {
            return false;
        }
        if (UserManager.isDeviceInDemoMode(this.mContext)) {
            i = this.mUserController.getCurrentUser().isDemo();
        }
        return i ^ 1;
    }

    static void boostPriorityForLockedSection() {
        sThreadPriorityBooster.boost();
    }

    static void resetPriorityAfterLockedSection() {
        sThreadPriorityBooster.reset();
    }

    Configuration getGlobalConfiguration() {
        return this.mStackSupervisor.getConfiguration();
    }

    public void setSystemProcess() {
        try {
            ServiceManager.addService(OppoAppStartupManager.TYPE_ACTIVITY, this, true);
            ServiceManager.addService("procstats", this.mProcessStats);
            ServiceManager.addService("meminfo", new MemBinder(this));
            ServiceManager.addService("gfxinfo", new GraphicsBinder(this));
            ServiceManager.addService("dbinfo", new DbBinder(this));
            ServiceManager.addService("cpuinfo", new CpuBinder(this));
            ServiceManager.addService("permission", new PermissionController(this));
            ServiceManager.addService("processinfo", new ProcessInfoService(this));
            ApplicationInfo info = this.mContext.getPackageManager().getApplicationInfo("android", 1049600);
            this.mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0);
                    app.persistent = true;
                    app.pid = MY_PID;
                    app.maxAdj = -900;
                    app.makeActive(this.mSystemThread.getApplicationThread(), this.mProcessStats);
                    synchronized (this.mPidsSelfLocked) {
                        this.mPidsSelfLocked.put(app.pid, app);
                    }
                    updateLruProcessLocked(app, false, null);
                    updateOomAdjLocked();
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        } catch (NameNotFoundException e) {
            throw new RuntimeException("Unable to find android system package", e);
        }
    }

    public void setWindowManager(WindowManagerService wm) {
        this.mWindowManager = wm;
        this.mStackSupervisor.setWindowManager(wm);
        this.mActivityStarter.setWindowManager(wm);
    }

    public void setUsageStatsManager(UsageStatsManagerInternal usageStatsManager) {
        this.mUsageStatsService = usageStatsManager;
    }

    public void startObservingNativeCrashes() {
        new NativeCrashListener(this).start();
    }

    public IAppOpsService getAppOpsService() {
        return this.mAppOpsService;
    }

    public ActivityManagerService(Injector injector) {
        this.mHyp = null;
        this.dexStart = false;
        this.mActiveNetType = -1;
        this.mNetLock = new Object();
        this.mInstrumentationReporter = new InstrumentationReporter();
        this.mActiveInstrumentation = new ArrayList();
        this.mShowDialogs = true;
        this.mFileUtils = null;
        this.mVr2dDisplayId = -1;
        this.mUseFifoUiScheduling = false;
        this.mIgnoreSleepCheckLater = false;
        this.mBroadcastQueues = new BroadcastQueue[4];
        this.MAX_NUM_NOT_SHOW = 100;
        this.mLockTaskPackages = new SparseArray();
        this.mLastStartProcessTime = 0;
        this.mLastStartProcessPkgName = "";
        this.mFinishWhenLockedState = 0;
        this.mPendingAssistExtras = new ArrayList();
        this.mProcessList = new ProcessList();
        this.mProcessNames = new ProcessMap();
        this.mIsolatedProcesses = new SparseArray();
        this.mNextIsolatedProcessUid = 0;
        this.mHeavyWeightProcess = null;
        this.mBackgroundAppIdWhitelist = new int[]{FingerprintAcquiredInfo.ACQUIRED_ALREADY_ENROLLED};
        this.mPidsSelfLocked = new SparseArray();
        this.mImportantProcesses = new SparseArray();
        this.mProcessesOnHold = new ArrayList();
        this.mPersistentStartingProcesses = new ArrayList();
        this.mRemovedProcesses = new ArrayList();
        this.mLruProcesses = new ArrayList();
        this.mLruProcessActivityStart = 0;
        this.mLruProcessServiceStart = 0;
        this.mProcessesToGc = new ArrayList();
        this.mPendingPssProcesses = new ArrayList();
        this.mBinderTransactionTrackingEnabled = false;
        this.mLastFullPssTime = SystemClock.uptimeMillis();
        this.mFullPssPending = false;
        this.mActiveUids = new SparseArray();
        this.mValidateUids = new SparseArray();
        this.mIntentSenderRecords = new HashMap();
        this.mAlreadyLoggedViolatedStacks = new HashSet();
        this.mStrictModeBuffer = new StringBuilder();
        this.mRegisteredReceivers = new HashMap();
        this.mReceiverResolver = new IntentResolver<BroadcastFilter, BroadcastFilter>() {
            protected boolean allowFilterResult(BroadcastFilter filter, List<BroadcastFilter> dest) {
                IBinder target = filter.receiverList.receiver.asBinder();
                for (int i = dest.size() - 1; i >= 0; i--) {
                    if (((BroadcastFilter) dest.get(i)).receiverList.receiver.asBinder() == target) {
                        return false;
                    }
                }
                return true;
            }

            protected BroadcastFilter newResult(BroadcastFilter filter, int match, int userId) {
                if (userId == -1 || filter.owningUserId == -1 || userId == filter.owningUserId) {
                    return (BroadcastFilter) super.newResult(filter, match, userId);
                }
                return null;
            }

            protected BroadcastFilter[] newArray(int size) {
                return new BroadcastFilter[size];
            }

            protected boolean isPackageForFilter(String packageName, BroadcastFilter filter) {
                return packageName.equals(filter.packageName);
            }
        };
        this.mStickyBroadcasts = new SparseArray();
        this.mAssociations = new SparseArray();
        this.mBackupAppName = null;
        this.mBackupTarget = null;
        this.mLaunchingProviders = new ArrayList();
        this.mGrantedUriPermissions = new SparseArray();
        this.mDeviceIdleWhitelist = new int[0];
        this.mDeviceIdleTempWhitelist = new int[0];
        this.mPendingTempWhitelist = new SparseArray();
        this.mNs = null;
        this.mTempConfig = new Configuration();
        this.mTmpUpdateConfigurationResult = new UpdateConfigurationResult();
        this.mStringBuilder = new StringBuilder(256);
        this.mTopAction = "android.intent.action.MAIN";
        this.mProcessesReady = false;
        this.mSystemReady = false;
        this.mOnBattery = false;
        this.mBooting = false;
        this.mCallFinishBooting = false;
        this.mBootAnimationComplete = false;
        this.mLaunchWarningShown = false;
        this.mCheckedForSetup = false;
        this.mSleeping = false;
        this.mTopProcessState = 2;
        this.mWakefulness = 1;
        this.mShuttingDown = false;
        this.mAdjSeq = 0;
        this.mLruSeq = 0;
        this.mNumNonCachedProcs = 0;
        this.mNumCachedHiddenProcs = 0;
        this.mNumServiceProcs = 0;
        this.mNewNumAServiceProcs = 0;
        this.mNewNumServiceProcs = 0;
        this.mAllowLowerMemLevel = false;
        this.mLastMemoryLevel = 0;
        this.mLastIdleTime = SystemClock.uptimeMillis();
        this.mLowRamTimeSinceLastIdle = 0;
        this.mLowRamStartTime = 0;
        this.mCurResumedPackage = null;
        this.mCurResumedUid = -1;
        this.mForegroundPackages = new ProcessMap();
        this.mTestPssMode = false;
        this.mDebugApp = null;
        this.mWaitForDebugger = false;
        this.mDebugTransient = false;
        this.mOrigDebugApp = null;
        this.mOrigWaitForDebugger = false;
        this.mAlwaysFinishActivities = false;
        this.mController = null;
        this.mOppoKinectController = null;
        this.mControllerIsAMonkey = false;
        this.mProfileApp = null;
        this.mProfileProc = null;
        this.mProfilerInfo = null;
        this.mProfileType = 0;
        this.mMemWatchProcesses = new ProcessMap();
        this.mTrackAllocationApp = null;
        this.mNativeDebuggingApp = null;
        this.mTmpLong = new long[2];
        this.mTmpBroadcastQueue = new ArraySet();
        this.mProcStateSeqCounter = 0;
        this.mProcessObservers = new RemoteCallbackList();
        this.mActiveProcessChanges = new ProcessChangeItem[5];
        this.mPendingProcessChanges = new ArrayList();
        this.mAvailProcessChanges = new ArrayList();
        this.mUidObservers = new RemoteCallbackList();
        this.mActiveUidChanges = new ChangeItem[5];
        this.mPendingUidChanges = new ArrayList();
        this.mAvailUidChanges = new ArrayList();
        this.mProcessCpuTracker = new ProcessCpuTracker(MONITOR_THREAD_CPU_USAGE);
        this.mLastCpuTime = new AtomicLong(0);
        this.mProcessCpuMutexFree = new AtomicBoolean(true);
        this.mProcessCpuInitLatch = new CountDownLatch(1);
        this.mLastWriteTime = 0;
        this.mUpdateLock = new UpdateLock("immersive");
        this.mBooted = false;
        this.mOppoActivityControlerScheduler = null;
        this.mLastMemUsageReportTime = 0;
        this.mMinBServiceAgingTime = SystemProperties.getInt("ro.vendor.qti.sys.fw.bservice_age", OppoArpPeer.ARP_DUP_RESPONSE_TIMEOUT);
        this.mBServiceAppThreshold = SystemProperties.getInt("ro.vendor.qti.sys.fw.bservice_limit", 5);
        this.mEnableBServicePropagation = SystemProperties.getBoolean("ro.vendor.qti.sys.fw.bservice_enable", false);
        this.mFinishBroadcastCount = 0;
        this.mSimulateBindBlockedCase = SystemProperties.getBoolean("persist.simulatebindblocked", false);
        this.mViSessionId = 1000;
        this.mBgHandler = new Handler(BackgroundThread.getHandler().getLooper()) {
            public void handleMessage(Message msg) {
                int num;
                long[] tmp;
                ProcessRecord proc;
                int i;
                int pid;
                switch (msg.what) {
                    case 1:
                        long start = SystemClock.uptimeMillis();
                        MemInfoReader memInfoReader = null;
                        synchronized (ActivityManagerService.this) {
                            try {
                                ActivityManagerService.boostPriorityForLockedSection();
                                if (ActivityManagerService.this.mFullPssPending) {
                                    ActivityManagerService.this.mFullPssPending = false;
                                    memInfoReader = new MemInfoReader();
                                }
                            } finally {
                                ActivityManagerService.resetPriorityAfterLockedSection();
                            }
                        }
                        if (memInfoReader != null) {
                            List<Stats> stats;
                            ActivityManagerService.this.updateCpuStatsNow();
                            long nativeTotalPss = 0;
                            synchronized (ActivityManagerService.this.mProcessCpuTracker) {
                                stats = ActivityManagerService.this.mProcessCpuTracker.getStats(-$Lambda$njIALZ9XLXuT-vhmazyQkVX7Z0U.$INST$0);
                            }
                            int N = stats.size();
                            for (int j = 0; j < N; j++) {
                                synchronized (ActivityManagerService.this.mPidsSelfLocked) {
                                    if (ActivityManagerService.this.mPidsSelfLocked.indexOfKey(((Stats) stats.get(j)).pid) >= 0) {
                                    } else {
                                        nativeTotalPss += Debug.getPss(((Stats) stats.get(j)).pid, null, null);
                                    }
                                }
                            }
                            memInfoReader.readMemInfo();
                            synchronized (ActivityManagerService.this) {
                                try {
                                    ActivityManagerService.boostPriorityForLockedSection();
                                    if (ActivityManagerDebugConfig.DEBUG_PSS) {
                                        Slog.d(ActivityManagerService.TAG_PSS, "Collected native and kernel memory in " + (SystemClock.uptimeMillis() - start) + "ms");
                                    }
                                    long cachedKb = memInfoReader.getCachedSizeKb();
                                    long freeKb = memInfoReader.getFreeSizeKb();
                                    long zramKb = memInfoReader.getZramTotalSizeKb();
                                    long kernelKb = memInfoReader.getKernelUsedSizeKb();
                                    EventLogTags.writeAmMeminfo(1024 * cachedKb, 1024 * freeKb, 1024 * zramKb, 1024 * kernelKb, 1024 * nativeTotalPss);
                                    ActivityManagerService.this.mProcessStats.addSysMemUsageLocked(cachedKb, freeKb, zramKb, kernelKb, nativeTotalPss);
                                } finally {
                                    ActivityManagerService.resetPriorityAfterLockedSection();
                                }
                            }
                        }
                        num = 0;
                        tmp = new long[2];
                        while (true) {
                            synchronized (ActivityManagerService.this) {
                                try {
                                    ActivityManagerService.boostPriorityForLockedSection();
                                    if (ActivityManagerService.this.mPendingPssProcesses.size() > 0) {
                                        proc = (ProcessRecord) ActivityManagerService.this.mPendingPssProcesses.remove(0);
                                        i = proc.pssProcState;
                                        long j2 = proc.lastPssTime;
                                        if (proc.thread != null && i == proc.setProcState && 1000 + j2 < SystemClock.uptimeMillis()) {
                                            pid = proc.pid;
                                            break;
                                        }
                                        proc = null;
                                        pid = 0;
                                        break;
                                    }
                                    if (ActivityManagerService.this.mTestPssMode || ActivityManagerDebugConfig.DEBUG_PSS) {
                                        Slog.d(ActivityManagerService.TAG_PSS, "Collected PSS of " + num + " processes in " + (SystemClock.uptimeMillis() - start) + "ms");
                                    }
                                    ActivityManagerService.this.mPendingPssProcesses.clear();
                                    ActivityManagerService.resetPriorityAfterLockedSection();
                                    return;
                                } finally {
                                    ActivityManagerService.resetPriorityAfterLockedSection();
                                }
                            }
                        }
                        break;
                    default:
                        return;
                }
                if (proc != null) {
                    long pss = Debug.getPss(pid, tmp, null);
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            if (pss != 0 && proc.thread != null && proc.setProcState == i && proc.pid == pid && proc.lastPssTime == j2) {
                                num++;
                                ActivityManagerService.this.recordPssSampleLocked(proc, i, pss, tmp[0], tmp[1], SystemClock.uptimeMillis());
                            }
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                }
            }

            static /* synthetic */ boolean lambda$-com_android_server_am_ActivityManagerService$2_122461(Stats st) {
                return st.vsize > 0 && st.uid < 10000;
            }
        };
        this.mDexOptTimeMap = new HashMap();
        this.mProcessStateStatsLongs = new long[1];
        this.bInReport = false;
        this.mLmkObserver = new UEventObserver() {
            public void onUEvent(UEvent event) {
                Slog.d(ActivityManagerService.TAG, "lowmemorykiller uevent: " + event);
                if (!ActivityManagerService.this.bInReport) {
                    new Thread(new Runnable() {
                        public void run() {
                            ArrayList<ProcessMemInfo> memInfos;
                            ActivityManagerService.this.bInReport = true;
                            synchronized (ActivityManagerService.this) {
                                try {
                                    ActivityManagerService.boostPriorityForLockedSection();
                                    memInfos = new ArrayList(ActivityManagerService.this.mLruProcesses.size());
                                    for (int i = ActivityManagerService.this.mLruProcesses.size() - 1; i >= 0; i--) {
                                        ProcessRecord rec = (ProcessRecord) ActivityManagerService.this.mLruProcesses.get(i);
                                        if (rec.thread != null) {
                                            memInfos.add(new ProcessMemInfo(rec.processName, rec.pid, rec.setAdj, rec.setProcState, rec.adjType, rec.makeAdjReason()));
                                        }
                                    }
                                } finally {
                                    ActivityManagerService.resetPriorityAfterLockedSection();
                                }
                            }
                            try {
                                ActivityManagerService.this.reportLowmemStats(memInfos);
                                ActivityManagerService.this.bInReport = false;
                            } catch (Exception e) {
                                ActivityManagerService.this.bInReport = false;
                                Slog.e(ActivityManagerService.TAG, "Exception when lowmemorykiller reportLowmemStats!", e);
                            }
                        }
                    }).start();
                }
            }
        };
        this.mSupportedSystemLocales = null;
        this.mDisallowedRuningAppList = new ArrayList();
        this.mDisallowedRuningAppListLock = new Object();
        this.dataDir = Environment.getDataDirectory();
        this.mSystemDir = new File(this.dataDir, "system");
        this.mNotAllowAppFilename = new File(this.mSystemDir, "not_allow_packages.xml");
        this.CUSTOMIZE_LIST_PATH = "/system/etc/oppo_customize_whitelist.xml";
        this.mCustomizeList = new ArrayList();
        this.mDialogForDisallow = null;
        this.mCreateDataReserveFile = new Runnable() {
            public void run() {
                Slog.d(ActivityManagerService.TAG, "run create reserve file");
                ActivityManagerService.this.oppoCreateFileInData();
            }
        };
        this.splitBack = Arrays.asList(new String[]{TENCENT_NAME, "com.tencent.mobileqq"});
        this.mSplitActivity = null;
        this.mInjector = injector;
        this.mContext = this.mInjector.getContext();
        this.mUiContext = null;
        this.GL_ES_VERSION = 0;
        this.mActivityStarter = null;
        this.mAppErrors = null;
        this.mAppOpsService = this.mInjector.getAppOpsService(null, null);
        this.mBatteryStatsService = null;
        this.mCompatModePackages = null;
        this.mConstants = null;
        this.mGrantFile = null;
        this.mHandler = null;
        this.mHandlerThread = null;
        this.mBroadcastThread = null;
        this.mIntentFirewall = null;
        this.mKeyguardController = null;
        this.mPermissionReviewRequired = false;
        this.mProcessCpuThread = null;
        this.mProcessStats = null;
        this.mProviderMap = null;
        this.mRecentTasks = null;
        this.mServices = null;
        this.mStackSupervisor = null;
        this.mSystemThread = null;
        this.mTaskChangeNotificationController = null;
        this.mUiHandler = injector.getUiHandler(null);
        this.mUserController = null;
        this.mVrController = null;
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "WangLan@Plf.Framework : Modify for permission intercept and BPM", property = OppoRomType.OPPO)
    public ActivityManagerService(Context systemContext) {
        boolean z;
        this.mHyp = null;
        this.dexStart = false;
        this.mActiveNetType = -1;
        this.mNetLock = new Object();
        this.mInstrumentationReporter = new InstrumentationReporter();
        this.mActiveInstrumentation = new ArrayList();
        this.mShowDialogs = true;
        this.mFileUtils = null;
        this.mVr2dDisplayId = -1;
        this.mUseFifoUiScheduling = false;
        this.mIgnoreSleepCheckLater = false;
        this.mBroadcastQueues = new BroadcastQueue[4];
        this.MAX_NUM_NOT_SHOW = 100;
        this.mLockTaskPackages = new SparseArray();
        this.mLastStartProcessTime = 0;
        this.mLastStartProcessPkgName = "";
        this.mFinishWhenLockedState = 0;
        this.mPendingAssistExtras = new ArrayList();
        this.mProcessList = new ProcessList();
        this.mProcessNames = new ProcessMap();
        this.mIsolatedProcesses = new SparseArray();
        this.mNextIsolatedProcessUid = 0;
        this.mHeavyWeightProcess = null;
        this.mBackgroundAppIdWhitelist = new int[]{FingerprintAcquiredInfo.ACQUIRED_ALREADY_ENROLLED};
        this.mPidsSelfLocked = new SparseArray();
        this.mImportantProcesses = new SparseArray();
        this.mProcessesOnHold = new ArrayList();
        this.mPersistentStartingProcesses = new ArrayList();
        this.mRemovedProcesses = new ArrayList();
        this.mLruProcesses = new ArrayList();
        this.mLruProcessActivityStart = 0;
        this.mLruProcessServiceStart = 0;
        this.mProcessesToGc = new ArrayList();
        this.mPendingPssProcesses = new ArrayList();
        this.mBinderTransactionTrackingEnabled = false;
        this.mLastFullPssTime = SystemClock.uptimeMillis();
        this.mFullPssPending = false;
        this.mActiveUids = new SparseArray();
        this.mValidateUids = new SparseArray();
        this.mIntentSenderRecords = new HashMap();
        this.mAlreadyLoggedViolatedStacks = new HashSet();
        this.mStrictModeBuffer = new StringBuilder();
        this.mRegisteredReceivers = new HashMap();
        this.mReceiverResolver = /* anonymous class already generated */;
        this.mStickyBroadcasts = new SparseArray();
        this.mAssociations = new SparseArray();
        this.mBackupAppName = null;
        this.mBackupTarget = null;
        this.mLaunchingProviders = new ArrayList();
        this.mGrantedUriPermissions = new SparseArray();
        this.mDeviceIdleWhitelist = new int[0];
        this.mDeviceIdleTempWhitelist = new int[0];
        this.mPendingTempWhitelist = new SparseArray();
        this.mNs = null;
        this.mTempConfig = new Configuration();
        this.mTmpUpdateConfigurationResult = new UpdateConfigurationResult();
        this.mStringBuilder = new StringBuilder(256);
        this.mTopAction = "android.intent.action.MAIN";
        this.mProcessesReady = false;
        this.mSystemReady = false;
        this.mOnBattery = false;
        this.mBooting = false;
        this.mCallFinishBooting = false;
        this.mBootAnimationComplete = false;
        this.mLaunchWarningShown = false;
        this.mCheckedForSetup = false;
        this.mSleeping = false;
        this.mTopProcessState = 2;
        this.mWakefulness = 1;
        this.mShuttingDown = false;
        this.mAdjSeq = 0;
        this.mLruSeq = 0;
        this.mNumNonCachedProcs = 0;
        this.mNumCachedHiddenProcs = 0;
        this.mNumServiceProcs = 0;
        this.mNewNumAServiceProcs = 0;
        this.mNewNumServiceProcs = 0;
        this.mAllowLowerMemLevel = false;
        this.mLastMemoryLevel = 0;
        this.mLastIdleTime = SystemClock.uptimeMillis();
        this.mLowRamTimeSinceLastIdle = 0;
        this.mLowRamStartTime = 0;
        this.mCurResumedPackage = null;
        this.mCurResumedUid = -1;
        this.mForegroundPackages = new ProcessMap();
        this.mTestPssMode = false;
        this.mDebugApp = null;
        this.mWaitForDebugger = false;
        this.mDebugTransient = false;
        this.mOrigDebugApp = null;
        this.mOrigWaitForDebugger = false;
        this.mAlwaysFinishActivities = false;
        this.mController = null;
        this.mOppoKinectController = null;
        this.mControllerIsAMonkey = false;
        this.mProfileApp = null;
        this.mProfileProc = null;
        this.mProfilerInfo = null;
        this.mProfileType = 0;
        this.mMemWatchProcesses = new ProcessMap();
        this.mTrackAllocationApp = null;
        this.mNativeDebuggingApp = null;
        this.mTmpLong = new long[2];
        this.mTmpBroadcastQueue = new ArraySet();
        this.mProcStateSeqCounter = 0;
        this.mProcessObservers = new RemoteCallbackList();
        this.mActiveProcessChanges = new ProcessChangeItem[5];
        this.mPendingProcessChanges = new ArrayList();
        this.mAvailProcessChanges = new ArrayList();
        this.mUidObservers = new RemoteCallbackList();
        this.mActiveUidChanges = new ChangeItem[5];
        this.mPendingUidChanges = new ArrayList();
        this.mAvailUidChanges = new ArrayList();
        this.mProcessCpuTracker = new ProcessCpuTracker(MONITOR_THREAD_CPU_USAGE);
        this.mLastCpuTime = new AtomicLong(0);
        this.mProcessCpuMutexFree = new AtomicBoolean(true);
        this.mProcessCpuInitLatch = new CountDownLatch(1);
        this.mLastWriteTime = 0;
        this.mUpdateLock = new UpdateLock("immersive");
        this.mBooted = false;
        this.mOppoActivityControlerScheduler = null;
        this.mLastMemUsageReportTime = 0;
        this.mMinBServiceAgingTime = SystemProperties.getInt("ro.vendor.qti.sys.fw.bservice_age", OppoArpPeer.ARP_DUP_RESPONSE_TIMEOUT);
        this.mBServiceAppThreshold = SystemProperties.getInt("ro.vendor.qti.sys.fw.bservice_limit", 5);
        this.mEnableBServicePropagation = SystemProperties.getBoolean("ro.vendor.qti.sys.fw.bservice_enable", false);
        this.mFinishBroadcastCount = 0;
        this.mSimulateBindBlockedCase = SystemProperties.getBoolean("persist.simulatebindblocked", false);
        this.mViSessionId = 1000;
        this.mBgHandler = /* anonymous class already generated */;
        this.mDexOptTimeMap = new HashMap();
        this.mProcessStateStatsLongs = new long[1];
        this.bInReport = false;
        this.mLmkObserver = /* anonymous class already generated */;
        this.mSupportedSystemLocales = null;
        this.mDisallowedRuningAppList = new ArrayList();
        this.mDisallowedRuningAppListLock = new Object();
        this.dataDir = Environment.getDataDirectory();
        this.mSystemDir = new File(this.dataDir, "system");
        this.mNotAllowAppFilename = new File(this.mSystemDir, "not_allow_packages.xml");
        this.CUSTOMIZE_LIST_PATH = "/system/etc/oppo_customize_whitelist.xml";
        this.mCustomizeList = new ArrayList();
        this.mDialogForDisallow = null;
        this.mCreateDataReserveFile = /* anonymous class already generated */;
        this.splitBack = Arrays.asList(new String[]{TENCENT_NAME, "com.tencent.mobileqq"});
        this.mSplitActivity = null;
        LockGuard.installLock((Object) this, 6);
        this.mInjector = new Injector();
        this.mContext = systemContext;
        this.mFactoryTest = FactoryTest.getMode();
        this.mSystemThread = ActivityThread.currentActivityThread();
        this.mUiContext = this.mSystemThread.getSystemUiContext();
        Slog.i(TAG, "Memory class: " + ActivityManager.staticGetMemoryClass());
        this.mPermissionReviewRequired = this.mContext.getResources().getBoolean(17956992);
        this.mHandlerThread = new ServiceThread(TAG, -2, false);
        this.mHandlerThread.start();
        this.mHandler = new MainHandler(this.mHandlerThread.getLooper());
        this.mUiHandler = this.mInjector.getUiHandler(this);
        if (NeuronSystemManager.isEnable()) {
            this.mNs = new NeuronSystemService(this.mContext);
        }
        this.mBroadcastThread = new ServiceThread("BroadcastQueue", -2, false);
        this.mBroadcastThread.start();
        this.mConstants = new ActivityManagerConstants(this, this.mHandler);
        if (sKillHandler == null) {
            sKillThread = new ServiceThread(TAG + ":kill", 10, true);
            sKillThread.start();
            sKillHandler = new KillHandler(sKillThread.getLooper());
        }
        this.mFgBroadcastQueue = new BroadcastQueue(this, this.mBroadcastThread, "foreground", 10000, false);
        this.mBgBroadcastQueue = new BroadcastQueue(this, this.mBroadcastThread, "background", 60000, false);
        this.mBroadcastQueues[0] = this.mFgBroadcastQueue;
        this.mBroadcastQueues[1] = this.mBgBroadcastQueue;
        OppoBroadcastManager.getInstance(this);
        this.mServices = new ActiveServices(this);
        this.mProviderMap = new ProviderMap(this);
        this.mAppErrors = new AppErrors(this.mUiContext, this);
        File systemDir = new File(Environment.getDataDirectory(), "system");
        systemDir.mkdirs();
        this.mBatteryStatsService = new BatteryStatsService(systemContext, systemDir, this.mHandler);
        this.mBatteryStatsService.getActiveStatistics().readLocked();
        this.mBatteryStatsService.scheduleWriteToDisk();
        if (ActivityManagerDebugConfig.DEBUG_POWER) {
            z = true;
        } else {
            z = this.mBatteryStatsService.getActiveStatistics().getIsOnBattery();
        }
        this.mOnBattery = z;
        this.mBatteryStatsService.getActiveStatistics().setCallback(this);
        this.mProcessStats = new ProcessStatsService(this, new File(systemDir, "procstats"));
        this.mAppOpsService = this.mInjector.getAppOpsService(new File(systemDir, "appops.xml"), this.mHandler);
        this.mAppOpsService.startWatchingMode(63, null, new IAppOpsCallback.Stub() {
            public void opChanged(int op, int uid, String packageName) {
                if (op == 63 && packageName != null && ActivityManagerService.this.mAppOpsService.checkOperation(op, uid, packageName) != 0) {
                    ActivityManagerService.this.runInBackgroundDisabled(uid);
                }
            }
        });
        this.mGrantFile = new AtomicFile(new File(systemDir, "urigrants.xml"));
        this.mUserController = new UserController(this);
        this.mVrController = new VrController(this);
        this.GL_ES_VERSION = SystemProperties.getInt("ro.opengles.version", 0);
        if (SystemProperties.getInt("sys.use_fifo_ui", 0) != 0) {
            this.mUseFifoUiScheduling = true;
        }
        this.mTrackingAssociations = LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("debug.track-associations"));
        this.mTempConfig.setToDefaults();
        this.mTempConfig.setLocales(LocaleList.getDefault());
        this.mTempConfig.seq = 1;
        this.mConfigurationSeq = 1;
        this.mStackSupervisor = createStackSupervisor();
        this.mStackSupervisor.onConfigurationChanged(this.mTempConfig);
        this.mKeyguardController = this.mStackSupervisor.mKeyguardController;
        this.mCompatModePackages = new CompatModePackages(this, systemDir, this.mHandler);
        this.mIntentFirewall = new IntentFirewall(new IntentFirewallInterface(), this.mHandler);
        this.mTaskChangeNotificationController = new TaskChangeNotificationController(this, this.mStackSupervisor, this.mHandler);
        this.mActivityStarter = new ActivityStarter(this, this.mStackSupervisor);
        this.mRecentTasks = new RecentTasks(this, this.mStackSupervisor);
        this.mProcessCpuThread = new Thread("CpuTracker") {
            public void run() {
                synchronized (ActivityManagerService.this.mProcessCpuTracker) {
                    ActivityManagerService.this.mProcessCpuInitLatch.countDown();
                    ActivityManagerService.this.mProcessCpuTracker.init();
                }
                while (true) {
                    try {
                        synchronized (this) {
                            long now = SystemClock.uptimeMillis();
                            long nextCpuDelay = (ActivityManagerService.this.mLastCpuTime.get() + ActivityManagerService.MONITOR_CPU_MAX_TIME) - now;
                            long nextWriteDelay = (ActivityManagerService.this.mLastWriteTime + 1800000) - now;
                            if (nextWriteDelay < nextCpuDelay) {
                                nextCpuDelay = nextWriteDelay;
                            }
                            if (nextCpuDelay > 0) {
                                ActivityManagerService.this.mProcessCpuMutexFree.set(true);
                                wait(nextCpuDelay);
                            }
                        }
                    } catch (InterruptedException e) {
                    }
                    try {
                        ActivityManagerService.this.updateCpuStatsNow();
                    } catch (Exception e2) {
                        Slog.e(ActivityManagerService.TAG, "Unexpected exception collecting process stats", e2);
                    }
                }
            }
        };
        Watchdog.getInstance().addMonitor(this);
        Watchdog.getInstance().addThread(this.mHandler);
        OppoProcessManagerHelper.init(this);
        OppoMultiAppManagerUtil.getInstance().init(this.mContext);
        OppoMultiLauncherUtil.getInstance().initAms((IOppoActivityManager) this);
        this.mCustomizeList = loadCustomizeWhiteList("/system/etc/oppo_customize_whitelist.xml");
        new Thread(new Runnable() {
            public void run() {
                ActivityManagerService.this.readDisallowAppListFile();
            }
        }).start();
    }

    protected ActivityStackSupervisor createStackSupervisor() {
        return new ActivityStackSupervisor(this, this.mHandler.getLooper());
    }

    public void setSystemServiceManager(SystemServiceManager mgr) {
        this.mSystemServiceManager = mgr;
    }

    public void setInstaller(Installer installer) {
        this.mInstaller = installer;
    }

    private void start() {
        Process.removeAllProcessGroups();
        this.mProcessCpuThread.start();
        this.mBatteryStatsService.publish();
        this.mAppOpsService.publish(this.mContext);
        Slog.d("AppOps", "AppOpsService published");
        LocalServices.addService(ActivityManagerInternal.class, new LocalService());
        try {
            this.mProcessCpuInitLatch.await();
            if (this.mNs != null) {
                this.mNs.publish(this);
            }
        } catch (InterruptedException e) {
            Slog.wtf(TAG, "Interrupted wait during start", e);
            Thread.currentThread().interrupt();
            throw new IllegalStateException("Interrupted wait during start");
        }
    }

    void onUserStoppedLocked(int userId) {
        this.mRecentTasks.unloadUserDataFromMemoryLocked(userId);
    }

    public void initPowerManagement() {
        this.mStackSupervisor.initPowerManagement();
        this.mBatteryStatsService.initPowerManagement();
        this.mLocalPowerManager = (PowerManagerInternal) LocalServices.getService(PowerManagerInternal.class);
        this.mVoiceWakeLock = ((PowerManager) this.mContext.getSystemService("power")).newWakeLock(1, "*voice*");
        this.mVoiceWakeLock.setReferenceCounted(false);
    }

    private ArraySet<String> getBackgroundLaunchBroadcasts() {
        if (this.mBackgroundLaunchBroadcasts == null) {
            this.mBackgroundLaunchBroadcasts = SystemConfig.getInstance().getAllowImplicitBroadcasts();
        }
        return this.mBackgroundLaunchBroadcasts;
    }

    public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
        if (code == 1599295570) {
            ProcessRecord app;
            boolean callingFromJunk = false;
            int callingPid = Binder.getCallingPid();
            ArrayList<ProcessRecord> procList = new ArrayList();
            ArrayList<IBinder> procs = new ArrayList();
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    int NP = this.mProcessNames.getMap().size();
                    for (int ip = 0; ip < NP; ip++) {
                        SparseArray<ProcessRecord> apps = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
                        int NA = apps.size();
                        for (int ia = 0; ia < NA; ia++) {
                            app = (ProcessRecord) apps.valueAt(ia);
                            if (app.thread != null) {
                                procs.add(app.thread.asBinder());
                                if (app.pid == callingPid && app.processName != null && app.processName.equals("com.coloros.oppoguardelf")) {
                                    callingFromJunk = true;
                                }
                                procList.add(app);
                            }
                        }
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            int N = procs.size();
            for (int i = 0; i < N; i++) {
                Parcel data2 = Parcel.obtain();
                boolean isSkip = false;
                try {
                    app = (ProcessRecord) procList.get(i);
                    if (app.uid > 10000) {
                        if (callingFromJunk) {
                            isSkip = true;
                        } else {
                            OppoProcessManagerHelper.resumeProcessForSystemCall(app);
                        }
                    }
                    if (!isSkip) {
                        ((IBinder) procs.get(i)).transact(1599295570, data2, null, 1);
                    }
                } catch (RemoteException e) {
                }
                data2.recycle();
            }
        }
        try {
            return super.onTransact(code, data, reply, flags);
        } catch (RuntimeException e2) {
            if (!(e2 instanceof SecurityException)) {
                Slog.wtf(TAG, "Activity Manager Crash. UID:" + Binder.getCallingUid() + " PID:" + Binder.getCallingPid() + " TRANS:" + code, e2);
            }
            throw e2;
        }
    }

    void updateCpuStats() {
        if (this.mLastCpuTime.get() < SystemClock.uptimeMillis() - FaceDaemonWrapper.TIMEOUT_FACED_BINDERCALL_CHECK && this.mProcessCpuMutexFree.compareAndSet(true, false)) {
            synchronized (this.mProcessCpuThread) {
                this.mProcessCpuThread.notify();
            }
        }
    }

    void updateCpuStatsNow() {
        synchronized (this.mProcessCpuTracker) {
            this.mProcessCpuMutexFree.set(false);
            long now = SystemClock.uptimeMillis();
            boolean haveNewCpuStats = false;
            if (this.mLastCpuTime.get() < now - FaceDaemonWrapper.TIMEOUT_FACED_BINDERCALL_CHECK) {
                this.mLastCpuTime.set(now);
                this.mProcessCpuTracker.update();
                if (this.mProcessCpuTracker.hasGoodLastStats()) {
                    haveNewCpuStats = true;
                    if ("true".equals(SystemProperties.get("events.cpu"))) {
                        int user = this.mProcessCpuTracker.getLastUserTime();
                        int system = this.mProcessCpuTracker.getLastSystemTime();
                        int iowait = this.mProcessCpuTracker.getLastIoWaitTime();
                        int irq = this.mProcessCpuTracker.getLastIrqTime();
                        int softIrq = this.mProcessCpuTracker.getLastSoftIrqTime();
                        int total = ((((user + system) + iowait) + irq) + softIrq) + this.mProcessCpuTracker.getLastIdleTime();
                        if (total == 0) {
                            total = 1;
                        }
                        EventLog.writeEvent(EventLogTags.CPU, new Object[]{Integer.valueOf((((((user + system) + iowait) + irq) + softIrq) * 100) / total), Integer.valueOf((user * 100) / total), Integer.valueOf((system * 100) / total), Integer.valueOf((iowait * 100) / total), Integer.valueOf((irq * 100) / total), Integer.valueOf((softIrq * 100) / total)});
                    }
                }
            }
            BatteryStatsImpl bstats = this.mBatteryStatsService.getActiveStatistics();
            synchronized (bstats) {
                synchronized (this.mPidsSelfLocked) {
                    if (haveNewCpuStats) {
                        if (bstats.startAddingCpuLocked()) {
                            int totalUTime = 0;
                            int totalSTime = 0;
                            int N = this.mProcessCpuTracker.countStats();
                            for (int i = 0; i < N; i++) {
                                Stats st = this.mProcessCpuTracker.getStats(i);
                                if (st.working) {
                                    ProcessRecord pr = (ProcessRecord) this.mPidsSelfLocked.get(st.pid);
                                    totalUTime += st.rel_utime;
                                    totalSTime += st.rel_stime;
                                    Proc ps;
                                    if (pr != null) {
                                        ps = pr.curProcBatteryStats;
                                        if (ps == null || (ps.isActive() ^ 1) != 0) {
                                            ps = bstats.getProcessStatsLocked(pr.info.uid, pr.processName);
                                            pr.curProcBatteryStats = ps;
                                        }
                                        ps.addCpuTimeLocked(st.rel_utime, st.rel_stime);
                                        pr.curCpuTime += (long) (st.rel_utime + st.rel_stime);
                                        if (pr.lastCpuTime == 0) {
                                            pr.lastCpuTime = pr.curCpuTime;
                                        }
                                    } else {
                                        ps = st.batteryStats;
                                        if (ps == null || (ps.isActive() ^ 1) != 0) {
                                            ps = bstats.getProcessStatsLocked(bstats.mapUid(st.uid), st.name);
                                            st.batteryStats = ps;
                                        }
                                        ps.addCpuTimeLocked(st.rel_utime, st.rel_stime);
                                    }
                                }
                            }
                            bstats.finishAddingCpuLocked(totalUTime, totalSTime, this.mProcessCpuTracker.getLastUserTime(), this.mProcessCpuTracker.getLastSystemTime(), this.mProcessCpuTracker.getLastIoWaitTime(), this.mProcessCpuTracker.getLastIrqTime(), this.mProcessCpuTracker.getLastSoftIrqTime(), this.mProcessCpuTracker.getLastIdleTime());
                        }
                    }
                }
                if (this.mLastWriteTime < now - 1800000) {
                    this.mLastWriteTime = now;
                    this.mBatteryStatsService.scheduleWriteToDisk();
                }
            }
        }
    }

    public void batteryNeedsCpuUpdate() {
        new Thread(new Runnable() {
            public void run() {
                ActivityManagerService.this.updateCpuStatsNow();
            }
        }).start();
    }

    public void batteryPowerChanged(boolean onBattery) {
        updateCpuStatsNow();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    if (ActivityManagerDebugConfig.DEBUG_POWER) {
                        onBattery = true;
                    }
                    this.mOnBattery = onBattery;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void batterySendBroadcast(Intent intent) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, -1, null, false, false, -1, 1000, -1);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private HashMap<String, IBinder> getCommonServicesLocked(boolean isolated) {
        if (isolated) {
            if (this.mIsolatedAppBindArgs == null) {
                this.mIsolatedAppBindArgs = new HashMap();
                this.mIsolatedAppBindArgs.put("package", ServiceManager.getService("package"));
            }
            return this.mIsolatedAppBindArgs;
        }
        if (this.mAppBindArgs == null) {
            this.mAppBindArgs = new HashMap();
            this.mAppBindArgs.put("package", ServiceManager.getService("package"));
            this.mAppBindArgs.put(OppoProcessManager.RESUME_REASON_VISIBLE_WINDOW_STR, ServiceManager.getService(OppoProcessManager.RESUME_REASON_VISIBLE_WINDOW_STR));
            this.mAppBindArgs.put("alarm", ServiceManager.getService("alarm"));
        }
        return this.mAppBindArgs;
    }

    private final void networkOptsCheck(int flag, String packageName) {
        this.mHandler.sendMessage(this.mHandler.obtainMessage(NETWORK_OPTS_CHECK_MSG, flag, 0, packageName));
    }

    void setResumedActivityUncheckLocked(ActivityRecord r, String reason) {
        if (ActivityManagerDebugConfig.DEBUG_FOCUS) {
            Slog.d(TAG_FOCUS, "mLastResumedActivity:" + this.mLastResumedActivity + " r " + r + " reason " + reason);
        }
        TaskRecord task = r.getTask();
        if (!task.isApplicationTask()) {
            r.appTimeTracker = null;
        } else if (this.mCurAppTimeTracker != r.appTimeTracker) {
            if (this.mCurAppTimeTracker != null) {
                this.mCurAppTimeTracker.stop();
                this.mHandler.obtainMessage(54, this.mCurAppTimeTracker).sendToTarget();
                this.mStackSupervisor.clearOtherAppTimeTrackers(r.appTimeTracker);
                this.mCurAppTimeTracker = null;
            }
            if (r.appTimeTracker != null) {
                this.mCurAppTimeTracker = r.appTimeTracker;
                startTimeTrackingFocusedActivityLocked();
            }
        } else {
            startTimeTrackingFocusedActivityLocked();
        }
        if (task.voiceInteractor != null) {
            startRunningVoiceLocked(task.voiceSession, r.info.applicationInfo.uid);
        } else {
            finishRunningVoiceLocked();
            if (this.mLastResumedActivity != null) {
                IVoiceInteractionSession session;
                TaskRecord lastResumedActivityTask = this.mLastResumedActivity.getTask();
                if (lastResumedActivityTask == null || lastResumedActivityTask.voiceSession == null) {
                    session = this.mLastResumedActivity.voiceSession;
                } else {
                    session = lastResumedActivityTask.voiceSession;
                }
                if (session != null) {
                    finishVoiceTask(session);
                }
            }
        }
        if (!(this.mLastResumedActivity == null || r.userId == this.mLastResumedActivity.userId)) {
            this.mHandler.removeMessages(52);
            this.mHandler.obtainMessage(52, r.userId, 0).sendToTarget();
        }
        this.mLastResumedActivity = r;
        this.mWindowManager.setFocusedApp(r.appToken, true);
        applyUpdateLockStateLocked(r);
        applyUpdateVrModeLocked(r);
        EventLogTags.writeAmSetResumedActivity(r == null ? -1 : r.userId, r == null ? "NULL" : r.shortComponentName, reason);
    }

    public void setFocusedStack(int stackId) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "setFocusedStack()");
        if (ActivityManagerDebugConfig.DEBUG_FOCUS) {
            Slog.d(TAG_FOCUS, "setFocusedStack: stackId=" + stackId);
        }
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityStack stack = this.mStackSupervisor.getStack(stackId);
                if (stack == null) {
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(callingId);
                    return;
                }
                if (this.mStackSupervisor.moveFocusableActivityStackToFrontLocked(stack.topRunningActivityLocked(), "setFocusedStack")) {
                    this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
                }
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(callingId);
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public void setFocusedTask(int taskId) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "setFocusedTask()");
        if (ActivityManagerDebugConfig.DEBUG_FOCUS) {
            Slog.d(TAG_FOCUS, "setFocusedTask: taskId=" + taskId);
        }
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task == null) {
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(callingId);
                    return;
                }
                if (this.mStackSupervisor.moveFocusableActivityStackToFrontLocked(task.topRunningActivityLocked(), "setFocusedTask")) {
                    this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
                }
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(callingId);
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public void registerTaskStackListener(ITaskStackListener listener) throws RemoteException {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "registerTaskStackListener()");
        this.mTaskChangeNotificationController.registerTaskStackListener(listener);
    }

    public void unregisterTaskStackListener(ITaskStackListener listener) throws RemoteException {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "unregisterTaskStackListener()");
        this.mTaskChangeNotificationController.unregisterTaskStackListener(listener);
    }

    public void notifyActivityDrawn(IBinder token) {
        if (ActivityManagerDebugConfig.DEBUG_VISIBILITY) {
            Slog.d(TAG_VISIBILITY, "notifyActivityDrawn: token=" + token);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = this.mStackSupervisor.isInAnyStackLocked(token);
                if (r != null) {
                    r.getStack().notifyActivityDrawnLocked(r);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    final void applyUpdateLockStateLocked(ActivityRecord r) {
        int i;
        boolean nextState = r != null ? r.immersive : false;
        MainHandler mainHandler = this.mHandler;
        MainHandler mainHandler2 = this.mHandler;
        if (nextState) {
            i = 1;
        } else {
            i = 0;
        }
        mainHandler.sendMessage(mainHandler2.obtainMessage(37, i, 0, r));
    }

    final void applyUpdateVrModeLocked(ActivityRecord r) {
        if (r.requestedVrComponent != null && r.getStackId() >= 8) {
            Slog.i(TAG, "Moving " + r.shortComponentName + " from stack " + r.getStackId() + " to main stack for VR");
            moveTaskToStack(r.getTask().taskId, 1, true);
        }
        this.mHandler.sendMessage(this.mHandler.obtainMessage(61, 0, 0, r));
    }

    private void sendNotifyVrManagerOfSleepState(boolean isSleeping) {
        int i;
        MainHandler mainHandler = this.mHandler;
        MainHandler mainHandler2 = this.mHandler;
        if (isSleeping) {
            i = 1;
        } else {
            i = 0;
        }
        mainHandler.sendMessage(mainHandler2.obtainMessage(65, i, 0));
    }

    private void notifyVrManagerOfSleepState(boolean isSleeping) {
        VrManagerInternal vrService = (VrManagerInternal) LocalServices.getService(VrManagerInternal.class);
        if (vrService != null) {
            vrService.onSleepStateChanged(isSleeping);
        }
    }

    private void sendNotifyVrManagerOfKeyguardState(boolean isShowing) {
        int i;
        MainHandler mainHandler = this.mHandler;
        MainHandler mainHandler2 = this.mHandler;
        if (isShowing) {
            i = 1;
        } else {
            i = 0;
        }
        mainHandler.sendMessage(mainHandler2.obtainMessage(74, i, 0));
    }

    private void notifyVrManagerOfKeyguardState(boolean isShowing) {
        VrManagerInternal vrService = (VrManagerInternal) LocalServices.getService(VrManagerInternal.class);
        if (vrService != null) {
            vrService.onKeyguardStateChanged(isShowing);
        }
    }

    final void showAskCompatModeDialogLocked(ActivityRecord r) {
        Message msg = Message.obtain();
        msg.what = 30;
        if (r.getTask().askedCompatMode) {
            r = null;
        }
        msg.obj = r;
        this.mUiHandler.sendMessage(msg);
    }

    final void showUnsupportedZoomDialogIfNeededLocked(ActivityRecord r) {
        Configuration globalConfig = getGlobalConfiguration();
        if (globalConfig.densityDpi != DisplayMetrics.DENSITY_DEVICE_STABLE && r.appInfo.requiresSmallestWidthDp > globalConfig.smallestScreenWidthDp) {
            Message msg = Message.obtain();
            msg.what = SHOW_UNSUPPORTED_DISPLAY_SIZE_DIALOG_MSG;
            msg.obj = r;
            this.mUiHandler.sendMessage(msg);
        }
    }

    private int updateLruProcessInternalLocked(ProcessRecord app, long now, int index, String what, Object obj, ProcessRecord srcApp) {
        app.lastActivityTime = now;
        if (app.activities.size() > 0) {
            return index;
        }
        int lrui = this.mLruProcesses.lastIndexOf(app);
        if (lrui < 0) {
            Slog.wtf(TAG, "Adding dependent process " + app + " not on LRU list: " + what + " " + obj + " from " + srcApp);
            return index;
        } else if (lrui >= index || lrui >= this.mLruProcessActivityStart) {
            return index;
        } else {
            this.mLruProcesses.remove(lrui);
            if (index > 0) {
                index--;
            }
            if (ActivityManagerDebugConfig.DEBUG_LRU) {
                Slog.d(TAG_LRU, "Moving dep from " + lrui + " to " + index + " in LRU list: " + app);
            }
            this.mLruProcesses.add(index, app);
            return index;
        }
    }

    static void killProcessGroup(int uid, int pid) {
        if (sKillHandler != null) {
            sKillHandler.sendMessage(sKillHandler.obtainMessage(4000, uid, pid));
            return;
        }
        Slog.w(TAG, "Asked to kill process group before system bringup!");
        Process.killProcessGroup(uid, pid);
    }

    final void removeLruProcessLocked(ProcessRecord app) {
        int lrui = this.mLruProcesses.lastIndexOf(app);
        if (lrui >= 0) {
            if (!app.killed) {
                Slog.wtfStack(TAG, "Removing process that hasn't been killed: " + app);
                Process.killProcessQuiet(app.pid);
                killProcessGroup(app.uid, app.pid);
            }
            if (lrui <= this.mLruProcessActivityStart) {
                this.mLruProcessActivityStart--;
            }
            if (lrui <= this.mLruProcessServiceStart) {
                this.mLruProcessServiceStart--;
            }
            this.mLruProcesses.remove(lrui);
        }
    }

    final void updateLruProcessLocked(ProcessRecord app, boolean activityChange, ProcessRecord client) {
        boolean hasActivity;
        if (app.activities.size() > 0 || app.hasClientActivities) {
            hasActivity = true;
        } else {
            hasActivity = app.treatLikeActivity;
        }
        if (activityChange || !hasActivity) {
            int N;
            this.mLruSeq++;
            long now = SystemClock.uptimeMillis();
            app.lastActivityTime = now;
            if (hasActivity) {
                N = this.mLruProcesses.size();
                if (N > 0 && this.mLruProcesses.get(N - 1) == app) {
                    if (ActivityManagerDebugConfig.DEBUG_LRU) {
                        Slog.d(TAG_LRU, "Not moving, already top activity: " + app);
                    }
                    if (this.mHyp == null) {
                        this.mHyp = Hypnus.getHypnus();
                    }
                    if (!(app.hasClientActivities || this.mHyp == null)) {
                        this.mHyp.hypnusSetScene(app.pid, app.processName);
                    }
                    return;
                }
            } else if (this.mLruProcessServiceStart > 0 && this.mLruProcesses.get(this.mLruProcessServiceStart - 1) == app) {
                if (ActivityManagerDebugConfig.DEBUG_LRU) {
                    Slog.d(TAG_LRU, "Not moving, already top other: " + app);
                }
                return;
            }
            int lrui = this.mLruProcesses.lastIndexOf(app);
            if (!app.persistent || lrui < 0) {
                int nextIndex;
                int j;
                if (lrui >= 0) {
                    if (lrui < this.mLruProcessActivityStart) {
                        this.mLruProcessActivityStart--;
                    }
                    if (lrui < this.mLruProcessServiceStart) {
                        this.mLruProcessServiceStart--;
                    }
                    this.mLruProcesses.remove(lrui);
                }
                if (hasActivity) {
                    N = this.mLruProcesses.size();
                    if (app.activities.size() != 0 || this.mLruProcessActivityStart >= N - 1) {
                        if (ActivityManagerDebugConfig.DEBUG_LRU) {
                            Slog.d(TAG_LRU, "Adding to top of LRU activity list: " + app);
                        }
                        this.mLruProcesses.add(app);
                        if (this.mHyp == null) {
                            this.mHyp = Hypnus.getHypnus();
                        }
                        if (this.mHyp != null) {
                            this.mHyp.hypnusSetScene(app.pid, app.processName);
                        }
                    } else {
                        if (ActivityManagerDebugConfig.DEBUG_LRU) {
                            Slog.d(TAG_LRU, "Adding to second-top of LRU activity list: " + app);
                        }
                        this.mLruProcesses.add(N - 1, app);
                        int uid = app.info.uid;
                        int i = N - 2;
                        while (i > this.mLruProcessActivityStart && ((ProcessRecord) this.mLruProcesses.get(i)).info.uid == uid) {
                            if (((ProcessRecord) this.mLruProcesses.get(i - 1)).info.uid != uid) {
                                if (ActivityManagerDebugConfig.DEBUG_LRU) {
                                    Slog.d(TAG_LRU, "Pushing uid " + uid + " swapping at " + i + ": " + this.mLruProcesses.get(i) + " : " + this.mLruProcesses.get(i - 1));
                                }
                                ProcessRecord tmp = (ProcessRecord) this.mLruProcesses.get(i);
                                this.mLruProcesses.set(i, (ProcessRecord) this.mLruProcesses.get(i - 1));
                                this.mLruProcesses.set(i - 1, tmp);
                                i--;
                            }
                            i--;
                        }
                    }
                    nextIndex = this.mLruProcessServiceStart;
                } else {
                    int index = this.mLruProcessServiceStart;
                    if (client != null) {
                        int clientIndex = this.mLruProcesses.lastIndexOf(client);
                        if (ActivityManagerDebugConfig.DEBUG_LRU && clientIndex < 0) {
                            Slog.d(TAG_LRU, "Unknown client " + client + " when updating " + app);
                        }
                        if (clientIndex <= lrui) {
                            clientIndex = lrui;
                        }
                        if (clientIndex >= 0 && index > clientIndex) {
                            index = clientIndex;
                        }
                    }
                    if (ActivityManagerDebugConfig.DEBUG_LRU) {
                        Slog.d(TAG_LRU, "Adding at " + index + " of LRU list: " + app);
                    }
                    this.mLruProcesses.add(index, app);
                    nextIndex = index - 1;
                    this.mLruProcessActivityStart++;
                    this.mLruProcessServiceStart++;
                }
                for (j = app.connections.size() - 1; j >= 0; j--) {
                    ConnectionRecord cr = (ConnectionRecord) app.connections.valueAt(j);
                    if (!(cr.binding == null || (cr.serviceDead ^ 1) == 0 || cr.binding.service == null || cr.binding.service.app == null || cr.binding.service.app.lruSeq == this.mLruSeq || (cr.binding.service.app.persistent ^ 1) == 0)) {
                        nextIndex = updateLruProcessInternalLocked(cr.binding.service.app, now, nextIndex, "service connection", cr, app);
                    }
                }
                for (j = app.conProviders.size() - 1; j >= 0; j--) {
                    ContentProviderRecord cpr = ((ContentProviderConnection) app.conProviders.get(j)).provider;
                    if (!(cpr.proc == null || cpr.proc.lruSeq == this.mLruSeq || (cpr.proc.persistent ^ 1) == 0)) {
                        nextIndex = updateLruProcessInternalLocked(cpr.proc, now, nextIndex, "provider reference", cpr, app);
                    }
                }
                return;
            }
            if (ActivityManagerDebugConfig.DEBUG_LRU) {
                Slog.d(TAG_LRU, "Not moving, persistent: " + app);
            }
        }
    }

    final ProcessRecord getProcessRecordLocked(String processName, int uid, boolean keepIfLarge) {
        if (ActivityManagerDebugConfig.DEBUG_SWITCH) {
            Slog.v(TAG_SWITCH, "processName: " + processName + " uid " + uid + " keepIfLarge " + keepIfLarge);
        }
        if (uid == 1000) {
            SparseArray<ProcessRecord> procs = (SparseArray) this.mProcessNames.getMap().get(processName);
            if (ActivityManagerDebugConfig.DEBUG_SWITCH) {
                Slog.v(TAG_SWITCH, "procs: " + procs);
            }
            if (procs == null) {
                return null;
            }
            int procCount = procs.size();
            int i = 0;
            while (i < procCount) {
                int procUid = procs.keyAt(i);
                if (UserHandle.isApp(procUid) || (UserHandle.isSameUser(procUid, uid) ^ 1) != 0) {
                    if (ActivityManagerDebugConfig.DEBUG_SWITCH) {
                        Slog.v(TAG_SWITCH, "procUid: " + procUid);
                    }
                    i++;
                } else {
                    if (ActivityManagerDebugConfig.DEBUG_SWITCH) {
                        Slog.v(TAG_SWITCH, "i: " + i + " proc " + procs.valueAt(i));
                    }
                    return (ProcessRecord) procs.valueAt(i);
                }
            }
        }
        ProcessRecord proc = (ProcessRecord) this.mProcessNames.get(processName, uid);
        if (!(proc == null || (keepIfLarge ^ 1) == 0 || this.mLastMemoryLevel <= 0 || proc.setProcState < 17 || (TENCENT_NAME.equals(proc.processName) ^ 1) == 0)) {
            if (ActivityManagerDebugConfig.DEBUG_PSS) {
                Slog.d(TAG_PSS, "May not keep " + proc + ": pss=" + proc.lastCachedPss);
            }
            if (proc.lastCachedPss >= this.mProcessList.getCachedRestoreThresholdKb()) {
                if (proc.baseProcessTracker != null) {
                    proc.baseProcessTracker.reportCachedKill(proc.pkgList, proc.lastCachedPss);
                }
                proc.kill(Long.toString(proc.lastCachedPss) + "k from cached", true);
            }
        }
        return proc;
    }

    void notifyPackageUse(String packageName, int reason) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                getPackageManagerInternalLocked().notifyPackageUse(packageName, reason);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    boolean isNextTransitionForward() {
        int transit = this.mWindowManager.getPendingAppTransition();
        if (transit == 6 || transit == 8 || transit == 10) {
            return true;
        }
        return false;
    }

    int startIsolatedProcess(String entryPoint, String[] entryPointArgs, String processName, String abiOverride, int uid, Runnable crashHandler) {
        int i;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ApplicationInfo info = new ApplicationInfo();
                info.uid = 1000;
                info.processName = processName;
                info.className = entryPoint;
                info.packageName = "android";
                info.seInfoUser = ":complete";
                ProcessRecord proc = startProcessLocked(processName, info, false, 0, "", null, true, true, uid, true, abiOverride, entryPoint, entryPointArgs, crashHandler, null);
                i = proc != null ? proc.pid : 0;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return i;
    }

    final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) {
        return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType, hostingName, allowWhileBooting, isolated, 0, keepIfLarge, null, null, null, null, null);
    }

    final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge, ActivityRecord r) {
        return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType, hostingName, allowWhileBooting, isolated, 0, keepIfLarge, null, null, null, null, r);
    }

    final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler, ActivityRecord r) {
        long startTime = SystemClock.elapsedRealtime();
        if (hostingType != null) {
            if (!(!hostingType.equals("broadcast") || info == null || info.sourceDir == null || new File(info.sourceDir).exists())) {
                Slog.d(TAG, "don't start process:" + processName + ", because apk file isn't exists! apkfile is " + info.sourceDir);
                return null;
            }
        }
        boolean openTraceLog = false;
        if (processName != null && "com.coloros.safecenter:clear_filter".equals(processName)) {
            Slog.d(TAG, "start process:" + processName + ", hostType:" + hostingType + ", beDead:" + knownToBeDead + ", isolated:" + isolated + ", flag:" + intentFlags);
            openTraceLog = true;
        }
        if (!isAutoStartAllowed(info.uid, info.packageName) && ("service".equals(hostingType) || "content provider".equals(hostingType))) {
            return null;
        }
        ProcessRecord app;
        if (isolated) {
            app = null;
        } else {
            app = getProcessRecordLocked(processName, info.uid, keepIfLarge);
            checkTime(startTime, "startProcess: after getProcessRecord");
            if (openTraceLog) {
                Slog.d(TAG, "trace proc, app:" + app + ", uid:" + info.uid);
            }
            if ((intentFlags & 4) == 0) {
                if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                    Slog.v(TAG, "Clearing bad process: " + info.uid + "/" + info.processName);
                }
                this.mAppErrors.resetProcessCrashTimeLocked(info);
                if (this.mAppErrors.isBadProcessLocked(info)) {
                    EventLog.writeEvent(EventLogTags.AM_PROC_GOOD, new Object[]{Integer.valueOf(UserHandle.getUserId(info.uid)), Integer.valueOf(info.uid), info.processName});
                    this.mAppErrors.clearBadProcessLocked(info);
                    if (app != null) {
                        app.bad = false;
                    }
                }
            } else if (this.mAppErrors.isBadProcessLocked(info)) {
                if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                    Slog.v(TAG, "Bad process: " + info.uid + "/" + info.processName);
                }
                return null;
            }
        }
        if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
            Slog.v(TAG_PROCESSES, "startProcess: name=" + processName + " app=" + app + " knownToBeDead=" + knownToBeDead + " thread=" + (app != null ? app.thread : null) + " pid=" + (app != null ? app.pid : -1));
        }
        if (app != null && app.pid > 0) {
            if ((knownToBeDead || (app.killed ^ 1) == 0) && app.thread != null) {
                if (ActivityManagerDebugConfig.DEBUG_PROCESSES || ActivityManagerDebugConfig.DEBUG_CLEANUP) {
                    Slog.v(TAG_PROCESSES, "App died: " + app);
                }
                checkTime(startTime, "startProcess: bad proc running, killing");
                killProcessGroup(app.uid, app.pid);
                handleAppDiedLocked(app, true, true);
                checkTime(startTime, "startProcess: done killing old proc");
            } else {
                if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                    Slog.v(TAG_PROCESSES, "App already running: " + app);
                }
                app.addPackage(info.packageName, info.versionCode, this.mProcessStats);
                checkTime(startTime, "startProcess: done, added package to proc");
                return app;
            }
        }
        String hostingNameStr = hostingName != null ? hostingName.flattenToShortString() : null;
        if (app == null) {
            checkTime(startTime, "startProcess: creating new process record");
            app = newProcessRecordLocked(info, processName, isolated, isolatedUid);
            if (app == null) {
                Slog.w(TAG, "Failed making new process record for " + processName + "/" + info.uid + " isolated=" + isolated);
                return null;
            }
            app.crashHandler = crashHandler;
            checkTime(startTime, "startProcess: done creating new process record");
        } else {
            app.addPackage(info.packageName, info.versionCode, this.mProcessStats);
            checkTime(startTime, "startProcess: added package to existing proc");
        }
        if (this.mProcessesReady || (isAllowedWhileBooting(info) ^ 1) == 0 || (allowWhileBooting ^ 1) == 0) {
            OppoCrashClearManager.getInstance().collectCrashInfo(app, hostingType, r);
            checkTime(startTime, "startProcess: stepping in to startProcess");
            if (!(r == null || r.callingPkg == null)) {
                app.callingPkg = r.callingPkg;
            }
            startProcessLocked(app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);
            checkTime(startTime, "startProcess: done starting proc!");
            if (app.pid == 0) {
                app = null;
            }
            return app;
        }
        if (!this.mProcessesOnHold.contains(app)) {
            this.mProcessesOnHold.add(app);
        }
        if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
            Slog.v(TAG_PROCESSES, "System not ready, putting on hold: " + app);
        }
        checkTime(startTime, "startProcess: returning with proc on hold");
        return app;
    }

    boolean isAllowedWhileBooting(ApplicationInfo ai) {
        return (ai.flags & 8) != 0;
    }

    private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) {
        startProcessLocked(app, hostingType, hostingNameStr, null, null, null);
    }

    private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
        long startTime = SystemClock.elapsedRealtime();
        if (app.pid > 0 && app.pid != MY_PID) {
            checkTime(startTime, "startProcess: removing from pids map");
            synchronized (this.mPidsSelfLocked) {
                this.mPidsSelfLocked.remove(app.pid);
                this.mHandler.removeMessages(20, app);
            }
            checkTime(startTime, "startProcess: done removing from pids map");
            app.setPid(0);
        }
        if (ActivityManagerDebugConfig.DEBUG_PROCESSES && this.mProcessesOnHold.contains(app)) {
            Slog.v(TAG_PROCESSES, "startProcessLocked removing on hold: " + app);
        }
        this.mProcessesOnHold.remove(app);
        checkTime(startTime, "startProcess: starting to update cpu stats");
        updateCpuStats();
        checkTime(startTime, "startProcess: done updating cpu stats");
        if (hostingType.equals(OppoAppStartupManager.TYPE_ACTIVITY)) {
            OppoAbnormalAppManager.getInstance().setPackageUnRestricted(app.info.packageName);
        }
        ThreadPolicy oldPolicy;
        try {
            int len;
            int[] newgids;
            int n;
            ProcessStartResult startResult;
            ProcessRecord oldApp;
            AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, UserHandle.getUserId(app.uid));
            int uid = app.uid;
            int[] gids = null;
            int mountExternal = 0;
            if (!app.isolated) {
                checkTime(startTime, "startProcess: getting gids from package manager");
                int[] permGids = AppGlobals.getPackageManager().getPackageGids(app.info.packageName, 268435456, app.userId);
                mountExternal = ((StorageManagerInternal) LocalServices.getService(StorageManagerInternal.class)).getExternalStorageMountMode(uid, app.info.packageName);
                if (ArrayUtils.isEmpty(permGids)) {
                    gids = new int[3];
                } else {
                    gids = new int[(permGids.length + 3)];
                    System.arraycopy(permGids, 0, gids, 3, permGids.length);
                }
                gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
                gids[1] = UserHandle.getCacheAppGid(UserHandle.getAppId(uid));
                gids[2] = UserHandle.getUserGid(UserHandle.getUserId(uid));
            }
            checkTime(startTime, "startProcess: building args");
            if (this.mFactoryTest != 0) {
                if (this.mFactoryTest == 1 && this.mTopComponent != null && app.processName.equals(this.mTopComponent.getPackageName())) {
                    uid = 0;
                }
                if (this.mFactoryTest == 2 && (app.info.flags & 16) != 0) {
                    uid = 0;
                }
            }
            int debugFlags = 0;
            if ((app.info.flags & 2) != 0) {
                debugFlags = (1 | 256) | 2;
            }
            if ((app.info.privateFlags & DumpState.DUMP_DOMAIN_PREFERRED) != 0) {
                debugFlags |= 1;
            }
            if ((app.info.flags & 16384) != 0 || this.mSafeMode) {
                debugFlags |= 8;
            }
            if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("debug.checkjni"))) {
                debugFlags |= 2;
            }
            if ("true".equals(SystemProperties.get("debug.generate-debug-info"))) {
                debugFlags |= 32;
            }
            if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("debug.jni.logging"))) {
                debugFlags |= 16;
            }
            if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("debug.assert"))) {
                debugFlags |= 4;
            }
            if (this.mNativeDebuggingApp != null && this.mNativeDebuggingApp.equals(app.processName)) {
                debugFlags = ((debugFlags | 64) | 32) | 128;
                this.mNativeDebuggingApp = null;
            }
            String invokeWith = null;
            if ((app.info.flags & 2) != 0) {
                String wrapperFileName = app.info.nativeLibraryDir + "/wrap.sh";
                oldPolicy = StrictMode.allowThreadDiskReads();
                if (new File(wrapperFileName).exists()) {
                    invokeWith = "/system/bin/logwrapper " + wrapperFileName;
                }
                StrictMode.setThreadPolicy(oldPolicy);
            }
            String requiredAbi = abiOverride != null ? abiOverride : app.info.primaryCpuAbi;
            if (requiredAbi == null) {
                requiredAbi = Build.SUPPORTED_ABIS[0];
            }
            String instructionSet = null;
            if (app.info.primaryCpuAbi != null) {
                instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);
            }
            app.gids = gids;
            app.requiredAbi = requiredAbi;
            app.instructionSet = instructionSet;
            if (app.info.packageName != null && app.userId == OppoMultiAppManager.USER_ID && OppoMultiAppManagerUtil.getInstance().isMultiApp(app.info.packageName)) {
                len = gids.length;
                newgids = new int[(len + 1)];
                for (n = 0; n < len; n++) {
                    newgids[n] = gids[n];
                }
                newgids[len] = 9997;
                gids = newgids;
            }
            if (app.userId == 0 && gids != null && gids.length > 0) {
                len = gids.length;
                newgids = new int[(len + 1)];
                for (n = 0; n < len; n++) {
                    newgids[n] = gids[n];
                }
                newgids[len] = 99909997;
                gids = newgids;
            }
            if (TextUtils.isEmpty(app.info.seInfoUser)) {
                Slog.wtf(TAG, "SELinux tag not defined", new IllegalStateException("SELinux tag not defined for " + app.info.packageName + " (uid " + app.uid + ")"));
            }
            String seInfo = app.info.seInfo + (TextUtils.isEmpty(app.info.seInfoUser) ? "" : app.info.seInfoUser);
            boolean isActivityProcess = entryPoint == null;
            if (entryPoint == null) {
                entryPoint = "android.app.ActivityThread";
            }
            Trace.traceBegin(64, "Start proc: " + app.processName);
            checkTime(startTime, "startProcess: asking zygote to start proc");
            if (hostingType.equals("webview_service")) {
                startResult = Process.startWebView(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, null, entryPointArgs);
            } else {
                startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, entryPointArgs);
            }
            checkTime(startTime, "startProcess: returned from zygote!");
            Trace.traceEnd(64);
            this.mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);
            checkTime(startTime, "startProcess: done updating battery stats");
            Object[] objArr = new Object[6];
            objArr[0] = Integer.valueOf(UserHandle.getUserId(uid));
            objArr[1] = Integer.valueOf(startResult.pid);
            objArr[2] = Integer.valueOf(uid);
            objArr[3] = app.processName;
            objArr[4] = hostingType;
            objArr[5] = hostingNameStr != null ? hostingNameStr : "";
            EventLog.writeEvent(EventLogTags.AM_PROC_START, objArr);
            OppoAppStartupManager.getInstance().collectAppStartInfo(app, hostingNameStr, hostingType);
            OppoAppStartupManager.getInstance().appStartupMonitor(app, hostingType);
            try {
                AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid, seInfo, app.info.sourceDir, startResult.pid);
            } catch (RemoteException e) {
            }
            if (app.persistent) {
                Watchdog.getInstance().processStarted(app.processName, startResult.pid);
            }
            checkTime(startTime, "startProcess: building log message");
            StringBuilder buf = this.mStringBuilder;
            buf.setLength(0);
            buf.append("Start proc ");
            buf.append(startResult.pid);
            buf.append(':');
            buf.append(app.processName);
            buf.append('/');
            UserHandle.formatUid(buf, uid);
            if (!isActivityProcess) {
                buf.append(" [");
                buf.append(entryPoint);
                buf.append("]");
            }
            buf.append(" for ");
            buf.append(hostingType);
            if (hostingNameStr != null) {
                buf.append(" ");
                buf.append(hostingNameStr);
            }
            if (SystemClock.uptimeMillis() - this.mLastStartProcessTime >= 500 || !this.mLastStartProcessPkgName.equals(app.processName)) {
                Slog.i(TAG, buf.toString());
            } else {
                Slog.i(TAG, buf.toString(), new Throwable());
            }
            this.mLastStartProcessPkgName = app.processName;
            this.mLastStartProcessTime = startTime;
            if (hostingType.equals(OppoAppStartupManager.TYPE_ACTIVITY)) {
                if (mPerf == null) {
                    mPerf = new BoostFramework();
                }
                if (mPerf != null) {
                    mPerf.perfHint(4225, app.processName, -1, 3);
                    mIsPerfLockAcquired = true;
                }
            }
            if (mPerfServiceStartHint == null) {
                mPerfServiceStartHint = new BoostFramework();
            }
            if (mPerfServiceStartHint != null) {
                mPerfServiceStartHint.perfHint(4225, app.processName, -1, 100);
            }
            app.setPid(startResult.pid);
            app.usingWrapper = startResult.usingWrapper;
            app.removed = false;
            app.killed = false;
            app.killedByAm = false;
            app.killedInInitStatus = false;
            checkTime(startTime, "startProcess: starting to update pids map");
            synchronized (this.mPidsSelfLocked) {
                oldApp = (ProcessRecord) this.mPidsSelfLocked.get(startResult.pid);
            }
            if (!(oldApp == null || (app.isolated ^ 1) == 0)) {
                Slog.w(TAG, "Reusing pid " + startResult.pid + " while app is still mapped to it");
                cleanUpApplicationRecordLocked(oldApp, false, false, -1, true);
            }
            synchronized (this.mPidsSelfLocked) {
                this.mPidsSelfLocked.put(startResult.pid, app);
                if (isActivityProcess) {
                    Message msg = this.mHandler.obtainMessage(20);
                    msg.obj = app;
                    this.mHandler.sendMessageDelayed(msg, (long) (startResult.usingWrapper ? PROC_START_TIMEOUT_WITH_WRAPPER : 10000));
                }
            }
            checkTime(startTime, "startProcess: done updating pids map");
            if (mActivityTrigger != null && (OppoAppStartupManager.TYPE_ACTIVITY.equals(hostingType) || "service".equals(hostingType))) {
                mActivityTrigger.activityMiscTrigger(1, app.processName, startResult.pid, 0);
            }
            OppoAbnormalAppManager.getInstance().handleStartAppInfo(app, hostingType);
        } catch (RemoteException e2) {
            throw e2.rethrowAsRuntimeException();
        } catch (RemoteException e22) {
            throw e22.rethrowAsRuntimeException();
        } catch (Throwable e3) {
            Slog.e(TAG, "Failure starting process " + app.processName, e3);
            forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false, false, true, false, false, UserHandle.getUserId(app.userId), "start failure");
        } catch (Throwable th) {
            StrictMode.setThreadPolicy(oldPolicy);
        }
    }

    void updateUsageStats(ActivityRecord component, boolean resumed) {
        if (ActivityManagerDebugConfig.DEBUG_SWITCH) {
            Slog.d(TAG_SWITCH, "updateUsageStats: comp=" + component + "res=" + resumed);
        }
        BatteryStatsImpl stats = this.mBatteryStatsService.getActiveStatistics();
        if (resumed) {
            if (this.mUsageStatsService != null) {
                this.mUsageStatsService.reportEvent(component.realActivity, component.userId, 1);
            }
            synchronized (stats) {
                stats.noteActivityResumedLocked(component.app.uid);
            }
        }
        if (this.mUsageStatsService != null) {
            this.mUsageStatsService.reportEvent(component.realActivity, component.userId, 2);
        }
        synchronized (stats) {
            stats.noteActivityPausedLocked(component.app.uid);
        }
    }

    Intent getHomeIntent() {
        Uri uri = null;
        String str = this.mTopAction;
        if (this.mTopData != null) {
            uri = Uri.parse(this.mTopData);
        }
        Intent intent = new Intent(str, uri);
        intent.setComponent(this.mTopComponent);
        intent.addFlags(256);
        if (this.mFactoryTest != 1) {
            intent.addCategory("android.intent.category.HOME");
        }
        return intent;
    }

    boolean startHomeActivityLocked(int userId, String reason) {
        if (this.mFactoryTest == 1 && this.mTopAction == null) {
            return false;
        }
        Intent intent = getHomeIntent();
        ActivityInfo aInfo = resolveActivityInfo(intent, 1024, userId);
        if (aInfo != null) {
            intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));
            ActivityInfo aInfo2 = new ActivityInfo(aInfo);
            aInfo2.applicationInfo = getAppInfoForUser(aInfo2.applicationInfo, userId);
            ProcessRecord app = getProcessRecordLocked(aInfo2.processName, aInfo2.applicationInfo.uid, true);
            if (app == null || app.instr == null) {
                intent.setFlags(intent.getFlags() | 268435456);
                this.mActivityStarter.startHomeActivityLocked(intent, aInfo2, reason + ":" + userId + ":" + UserHandle.getUserId(aInfo2.applicationInfo.uid));
                aInfo = aInfo2;
            }
        } else {
            Slog.wtf(TAG, "No home screen found for " + intent, new Throwable());
        }
        return true;
    }

    private ActivityInfo resolveActivityInfo(Intent intent, int flags, int userId) {
        ComponentName comp = intent.getComponent();
        if (comp != null) {
            try {
                return AppGlobals.getPackageManager().getActivityInfo(comp, flags, userId);
            } catch (RemoteException e) {
                return null;
            }
        }
        ResolveInfo info = AppGlobals.getPackageManager().resolveIntent(intent, intent.resolveTypeIfNeeded(this.mContext.getContentResolver()), flags, userId);
        if (info != null) {
            return info.activityInfo;
        }
        return null;
    }

    void startSetupActivityLocked() {
        if (!this.mCheckedForSetup) {
            ContentResolver resolver = this.mContext.getContentResolver();
            if (this.mFactoryTest != 1) {
                if (Global.getInt(resolver, "device_provisioned", 0) != 0) {
                    this.mCheckedForSetup = true;
                    Intent intent = new Intent("android.intent.action.UPGRADE_SETUP");
                    List<ResolveInfo> ris = this.mContext.getPackageManager().queryIntentActivities(intent, 1048704);
                    if (!ris.isEmpty()) {
                        String vers;
                        ResolveInfo ri = (ResolveInfo) ris.get(0);
                        if (ri.activityInfo.metaData != null) {
                            vers = ri.activityInfo.metaData.getString("android.SETUP_VERSION");
                        } else {
                            vers = null;
                        }
                        if (vers == null && ri.activityInfo.applicationInfo.metaData != null) {
                            vers = ri.activityInfo.applicationInfo.metaData.getString("android.SETUP_VERSION");
                        }
                        String lastVers = Secure.getString(resolver, "last_setup_shown");
                        if (!(vers == null || (vers.equals(lastVers) ^ 1) == 0)) {
                            intent.setFlags(268435456);
                            intent.setComponent(new ComponentName(ri.activityInfo.packageName, ri.activityInfo.name));
                            this.mActivityStarter.startActivityLocked(null, intent, null, null, ri.activityInfo, null, null, null, null, null, 0, 0, 0, null, 0, 0, 0, null, false, false, null, null, "startSetupActivity");
                        }
                    }
                }
            }
        }
    }

    CompatibilityInfo compatibilityInfoForPackageLocked(ApplicationInfo ai) {
        return this.mCompatModePackages.compatibilityInfoForPackageLocked(ai);
    }

    void enforceNotIsolatedCaller(String caller) {
        if (UserHandle.isIsolated(Binder.getCallingUid())) {
            throw new SecurityException("Isolated process not allowed to call " + caller);
        }
    }

    void enforceShellRestriction(String restriction, int userHandle) {
        if (Binder.getCallingUid() != OppoArpPeer.ARP_FIRST_RESPONSE_TIMEOUT) {
            return;
        }
        if (userHandle < 0 || this.mUserController.hasUserRestriction(restriction, userHandle)) {
            throw new SecurityException("Shell does not have permission to access user " + userHandle);
        }
    }

    public int getFrontActivityScreenCompatMode() {
        int frontActivityScreenCompatModeLocked;
        enforceNotIsolatedCaller("getFrontActivityScreenCompatMode");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                frontActivityScreenCompatModeLocked = this.mCompatModePackages.getFrontActivityScreenCompatModeLocked();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return frontActivityScreenCompatModeLocked;
    }

    public void setFrontActivityScreenCompatMode(int mode) {
        enforceCallingPermission("android.permission.SET_SCREEN_COMPATIBILITY", "setFrontActivityScreenCompatMode");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mCompatModePackages.setFrontActivityScreenCompatModeLocked(mode);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public int getPackageScreenCompatMode(String packageName) {
        int packageScreenCompatModeLocked;
        enforceNotIsolatedCaller("getPackageScreenCompatMode");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                packageScreenCompatModeLocked = this.mCompatModePackages.getPackageScreenCompatModeLocked(packageName);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return packageScreenCompatModeLocked;
    }

    public void setPackageScreenCompatMode(String packageName, int mode) {
        enforceCallingPermission("android.permission.SET_SCREEN_COMPATIBILITY", "setPackageScreenCompatMode");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mCompatModePackages.setPackageScreenCompatModeLocked(packageName, mode);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public boolean getPackageAskScreenCompat(String packageName) {
        boolean packageAskCompatModeLocked;
        enforceNotIsolatedCaller("getPackageAskScreenCompat");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                packageAskCompatModeLocked = this.mCompatModePackages.getPackageAskCompatModeLocked(packageName);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return packageAskCompatModeLocked;
    }

    public void setPackageAskScreenCompat(String packageName, boolean ask) {
        enforceCallingPermission("android.permission.SET_SCREEN_COMPATIBILITY", "setPackageAskScreenCompat");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mCompatModePackages.setPackageAskCompatModeLocked(packageName, ask);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private boolean hasUsageStatsPermission(String callingPackage) {
        boolean z = true;
        int mode = this.mAppOpsService.checkOperation(43, Binder.getCallingUid(), callingPackage);
        if (mode == 3) {
            if (checkCallingPermission("android.permission.PACKAGE_USAGE_STATS") != 0) {
                z = false;
            }
            return z;
        }
        if (mode != 0) {
            z = false;
        }
        return z;
    }

    public int getPackageProcessState(String packageName, String callingPackage) {
        if (!hasUsageStatsPermission(callingPackage)) {
            enforceCallingPermission("android.permission.PACKAGE_USAGE_STATS", "getPackageProcessState");
        }
        int procState = 18;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                    ProcessRecord proc = (ProcessRecord) this.mLruProcesses.get(i);
                    if (procState > proc.setProcState && (proc.pkgList.containsKey(packageName) || (proc.pkgDeps != null && proc.pkgDeps.contains(packageName)))) {
                        procState = proc.setProcState;
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return procState;
    }

    public boolean setProcessMemoryTrimLevel(String process, int userId, int level) throws RemoteException {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ProcessRecord app = findProcessLocked(process, userId, "setProcessMemoryTrimLevel");
                if (app == null) {
                    throw new IllegalArgumentException("Unknown process: " + process);
                } else if (app.thread == null) {
                    throw new IllegalArgumentException("Process has no app thread");
                } else if (app.trimMemoryLevel >= level) {
                    throw new IllegalArgumentException("Unable to set a higher trim level than current level");
                } else if (level < 20 || app.curProcState > 6) {
                    app.thread.scheduleTrimMemory(level);
                    app.trimMemoryLevel = level;
                } else {
                    throw new IllegalArgumentException("Unable to set a background trim level on a foreground process");
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return true;
    }

    private void dispatchProcessesChanged() {
        synchronized (this) {
            try {
                int j;
                boostPriorityForLockedSection();
                int N = this.mPendingProcessChanges.size();
                if (this.mActiveProcessChanges.length < N) {
                    this.mActiveProcessChanges = new ProcessChangeItem[N];
                }
                this.mPendingProcessChanges.toArray(this.mActiveProcessChanges);
                this.mPendingProcessChanges.clear();
                if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                    Slog.i(TAG_PROCESS_OBSERVERS, "*** Delivering " + N + " process changes");
                }
                int i = this.mProcessObservers.beginBroadcast();
                while (i > 0) {
                    i--;
                    IProcessObserver observer = (IProcessObserver) this.mProcessObservers.getBroadcastItem(i);
                    if (observer != null) {
                        j = 0;
                        while (j < N) {
                            try {
                                ProcessChangeItem item = this.mActiveProcessChanges[j];
                                if ((item.changes & 1) != 0) {
                                    if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                                        Slog.i(TAG_PROCESS_OBSERVERS, "ACTIVITIES CHANGED pid=" + item.pid + " uid=" + item.uid + ": " + item.foregroundActivities);
                                    }
                                    observer.onForegroundActivitiesChanged(item.pid, item.uid, item.foregroundActivities);
                                }
                                j++;
                            } catch (RemoteException e) {
                            }
                        }
                    }
                }
                this.mProcessObservers.finishBroadcast();
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        for (j = 0; j < N; j++) {
                            this.mAvailProcessChanges.add(this.mActiveProcessChanges[j]);
                        }
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private void dispatchProcessDied(int pid, int uid) {
        int i = this.mProcessObservers.beginBroadcast();
        while (i > 0) {
            i--;
            IProcessObserver observer = (IProcessObserver) this.mProcessObservers.getBroadcastItem(i);
            if (observer != null) {
                try {
                    observer.onProcessDied(pid, uid);
                } catch (RemoteException e) {
                }
            }
        }
        this.mProcessObservers.finishBroadcast();
    }

    void dispatchUidsChanged() {
        synchronized (this) {
            try {
                int i;
                int j;
                boostPriorityForLockedSection();
                int N = this.mPendingUidChanges.size();
                if (this.mActiveUidChanges.length < N) {
                    this.mActiveUidChanges = new ChangeItem[N];
                }
                for (i = 0; i < N; i++) {
                    ChangeItem change = (ChangeItem) this.mPendingUidChanges.get(i);
                    this.mActiveUidChanges[i] = change;
                    if (change.uidRecord != null) {
                        change.uidRecord.pendingChange = null;
                        change.uidRecord = null;
                    }
                }
                this.mPendingUidChanges.clear();
                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                    Slog.i(TAG_UID_OBSERVERS, "*** Delivering " + N + " uid changes");
                }
                i = this.mUidObservers.beginBroadcast();
                while (i > 0) {
                    i--;
                    dispatchUidsChangedForObserver((IUidObserver) this.mUidObservers.getBroadcastItem(i), (UidObserverRegistration) this.mUidObservers.getBroadcastCookie(i), N);
                }
                this.mUidObservers.finishBroadcast();
                if (this.mUidObservers.getRegisteredCallbackCount() > 0) {
                    for (j = 0; j < N; j++) {
                        ChangeItem item = this.mActiveUidChanges[j];
                        if ((item.change & 1) != 0) {
                            this.mValidateUids.remove(item.uid);
                        } else {
                            UidRecord validateUid = (UidRecord) this.mValidateUids.get(item.uid);
                            if (validateUid == null) {
                                validateUid = new UidRecord(item.uid);
                                this.mValidateUids.put(item.uid, validateUid);
                            }
                            if ((item.change & 2) != 0) {
                                validateUid.idle = true;
                            } else if ((item.change & 4) != 0) {
                                validateUid.idle = false;
                            }
                            int i2 = item.processState;
                            validateUid.setProcState = i2;
                            validateUid.curProcState = i2;
                            validateUid.lastDispatchedProcStateSeq = item.procStateSeq;
                        }
                    }
                }
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        for (j = 0; j < N; j++) {
                            this.mAvailUidChanges.add(this.mActiveUidChanges[j]);
                        }
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private void dispatchUidsChangedForObserver(IUidObserver observer, UidObserverRegistration reg, int changesSize) {
        if (observer != null) {
            int j = 0;
            while (j < changesSize) {
                try {
                    ChangeItem item = this.mActiveUidChanges[j];
                    int change = item.change;
                    if (change != 0 || (reg.which & 1) != 0) {
                        if ((change & 2) != 0) {
                            if ((reg.which & 4) != 0) {
                                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                                    Slog.i(TAG_UID_OBSERVERS, "UID idle uid=" + item.uid);
                                }
                                observer.onUidIdle(item.uid, item.ephemeral);
                            }
                        } else if (!((change & 4) == 0 || (reg.which & 8) == 0)) {
                            if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                                Slog.i(TAG_UID_OBSERVERS, "UID active uid=" + item.uid);
                            }
                            observer.onUidActive(item.uid);
                        }
                        if ((reg.which & 16) != 0) {
                            if ((change & 8) != 0) {
                                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                                    Slog.i(TAG_UID_OBSERVERS, "UID cached uid=" + item.uid);
                                }
                                observer.onUidCachedChanged(item.uid, true);
                            } else if ((change & 16) != 0) {
                                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                                    Slog.i(TAG_UID_OBSERVERS, "UID active uid=" + item.uid);
                                }
                                observer.onUidCachedChanged(item.uid, false);
                            }
                        }
                        if ((change & 1) != 0) {
                            if ((reg.which & 2) != 0) {
                                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                                    Slog.i(TAG_UID_OBSERVERS, "UID gone uid=" + item.uid);
                                }
                                observer.onUidGone(item.uid, item.ephemeral);
                            }
                            if (reg.lastProcStates != null) {
                                reg.lastProcStates.delete(item.uid);
                            }
                        } else if ((reg.which & 1) != 0) {
                            if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                                Slog.i(TAG_UID_OBSERVERS, "UID CHANGED uid=" + item.uid + ": " + item.processState);
                            }
                            boolean doReport = true;
                            if (reg.cutpoint >= 0) {
                                int lastState = reg.lastProcStates.get(item.uid, -1);
                                if (lastState != -1) {
                                    doReport = (lastState <= reg.cutpoint) != (item.processState <= reg.cutpoint);
                                } else {
                                    doReport = item.processState != 18;
                                }
                            }
                            if (doReport) {
                                if (reg.lastProcStates != null) {
                                    reg.lastProcStates.put(item.uid, item.processState);
                                }
                                observer.onUidStateChanged(item.uid, item.processState, item.procStateSeq);
                            }
                        }
                    }
                    j++;
                } catch (RemoteException e) {
                }
            }
        }
    }

    void dispatchOomAdjObserver(String msg) {
        OomAdjObserver observer;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                observer = this.mCurOomAdjObserver;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        if (observer != null) {
            observer.onOomAdjMessage(msg);
        }
    }

    void setOomAdjObserver(int uid, OomAdjObserver observer) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mCurOomAdjUid = uid;
                this.mCurOomAdjObserver = observer;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    void clearOomAdjObserver() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mCurOomAdjUid = -1;
                this.mCurOomAdjObserver = null;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    void reportOomAdjMessageLocked(String tag, String msg) {
        Slog.d(tag, msg);
        if (this.mCurOomAdjObserver != null) {
            this.mUiHandler.obtainMessage(70, msg).sendToTarget();
        }
    }

    public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {
        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());
    }

    public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller("startActivity");
        userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "startActivity", null);
        return this.mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, bOptions, false, userId, null, "startActivityAsUser");
    }

    public final int startActivityAsCaller(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, boolean ignoreTargetSecurity, int userId) {
        ActivityRecord sourceRecord;
        int targetUid;
        String targetPackage;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (resultTo == null) {
                    throw new SecurityException("Must be called from an activity");
                }
                sourceRecord = this.mStackSupervisor.isInAnyStackLocked(resultTo);
                if (sourceRecord == null) {
                    throw new SecurityException("Called with bad activity token: " + resultTo);
                } else if (!sourceRecord.info.packageName.equals("android")) {
                    throw new SecurityException("Must be called from an activity that is declared in the android package");
                } else if (sourceRecord.app == null) {
                    throw new SecurityException("Called without a process attached to activity");
                } else if (UserHandle.getAppId(sourceRecord.app.uid) == 1000 || sourceRecord.app.uid == sourceRecord.launchedFromUid) {
                    if (ignoreTargetSecurity) {
                        if (intent.getComponent() == null) {
                            throw new SecurityException("Component must be specified with ignoreTargetSecurity");
                        } else if (intent.getSelector() != null) {
                            throw new SecurityException("Selector not allowed with ignoreTargetSecurity");
                        }
                    }
                    targetUid = sourceRecord.launchedFromUid;
                    targetPackage = sourceRecord.launchedFromPackage;
                } else {
                    throw new SecurityException("Calling activity in uid " + sourceRecord.app.uid + " must be system uid or original calling uid " + sourceRecord.launchedFromUid);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        if (userId == -10000) {
            userId = UserHandle.getUserId(sourceRecord.app.uid);
        }
        try {
            return this.mActivityStarter.startActivityMayWait(null, targetUid, targetPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, null, null, null, bOptions, ignoreTargetSecurity, userId, null, "startActivityAsCaller");
        } catch (SecurityException e) {
            throw e;
        }
    }

    public final WaitResult startActivityAndWait(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller("startActivityAndWait");
        userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "startActivityAndWait", null);
        WaitResult res = new WaitResult();
        this.mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, res, null, bOptions, false, userId, null, "startActivityAndWait");
        return res;
    }

    public final int startActivityWithConfig(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, Configuration config, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller("startActivityWithConfig");
        userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "startActivityWithConfig", null);
        return this.mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, null, null, config, bOptions, false, userId, null, "startActivityWithConfig");
    }

    public int startActivityIntentSender(IApplicationThread caller, IIntentSender target, IBinder whitelistToken, Intent fillInIntent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle bOptions) throws TransactionTooLargeException {
        enforceNotIsolatedCaller("startActivityIntentSender");
        if (fillInIntent != null && fillInIntent.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        } else if (target instanceof PendingIntentRecord) {
            PendingIntentRecord pir = (PendingIntentRecord) target;
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    ActivityStack stack = getFocusedStack();
                    if (stack.mResumedActivity != null && stack.mResumedActivity.info.applicationInfo.uid == Binder.getCallingUid()) {
                        this.mAppSwitchesAllowedTime = 0;
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return pir.sendInner(0, fillInIntent, resolvedType, whitelistToken, null, null, resultTo, resultWho, requestCode, flagsMask, flagsValues, bOptions);
        } else {
            throw new IllegalArgumentException("Bad PendingIntent object");
        }
    }

    public int startVoiceActivity(String callingPackage, int callingPid, int callingUid, Intent intent, String resolvedType, IVoiceInteractionSession session, IVoiceInteractor interactor, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
        if (checkCallingPermission("android.permission.BIND_VOICE_INTERACTION") != 0) {
            String msg = "Permission Denial: startVoiceActivity() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.BIND_VOICE_INTERACTION";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        } else if (session == null || interactor == null) {
            throw new NullPointerException("null session or interactor");
        } else {
            userId = this.mUserController.handleIncomingUser(callingPid, callingUid, userId, false, 2, "startVoiceActivity", null);
            return this.mActivityStarter.startActivityMayWait(null, callingUid, callingPackage, intent, resolvedType, session, interactor, null, null, 0, startFlags, profilerInfo, null, null, bOptions, false, userId, null, "startVoiceActivity");
        }
    }

    public int startAssistantActivity(String callingPackage, int callingPid, int callingUid, Intent intent, String resolvedType, Bundle bOptions, int userId) {
        if (checkCallingPermission("android.permission.BIND_VOICE_INTERACTION") != 0) {
            String msg = "Permission Denial: startAssistantActivity() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.BIND_VOICE_INTERACTION";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        userId = this.mUserController.handleIncomingUser(callingPid, callingUid, userId, false, 2, "startAssistantActivity", null);
        return this.mActivityStarter.startActivityMayWait(null, callingUid, callingPackage, intent, resolvedType, null, null, null, null, 0, 0, null, null, null, bOptions, false, userId, null, "startAssistantActivity");
    }

    public void startLocalVoiceInteraction(IBinder callingActivity, Bundle options) throws RemoteException {
        Slog.i(TAG, "Activity tried to startVoiceInteraction");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord activity = getFocusedStack().topActivity();
                if (ActivityRecord.forTokenLocked(callingActivity) != activity) {
                    throw new SecurityException("Only focused activity can call startVoiceInteraction");
                }
                if (this.mRunningVoice == null && activity.getTask().voiceSession == null) {
                    if (activity.voiceSession == null) {
                        if (activity.pendingVoiceInteractionStart) {
                            Slog.w(TAG, "Pending start of voice interaction already.");
                            resetPriorityAfterLockedSection();
                            return;
                        }
                        activity.pendingVoiceInteractionStart = true;
                        resetPriorityAfterLockedSection();
                        ((VoiceInteractionManagerInternal) LocalServices.getService(VoiceInteractionManagerInternal.class)).startLocalVoiceInteraction(callingActivity, options);
                        return;
                    }
                }
                Slog.w(TAG, "Already in a voice interaction, cannot start new voice interaction");
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void stopLocalVoiceInteraction(IBinder callingActivity) throws RemoteException {
        ((VoiceInteractionManagerInternal) LocalServices.getService(VoiceInteractionManagerInternal.class)).stopLocalVoiceInteraction(callingActivity);
    }

    public boolean supportsLocalVoiceInteraction() throws RemoteException {
        return ((VoiceInteractionManagerInternal) LocalServices.getService(VoiceInteractionManagerInternal.class)).supportsLocalVoiceInteraction();
    }

    void onLocalVoiceInteractionStartedLocked(IBinder activity, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor) {
        ActivityRecord activityToCallback = ActivityRecord.forTokenLocked(activity);
        if (activityToCallback != null) {
            activityToCallback.setVoiceSessionLocked(voiceSession);
            long token;
            try {
                activityToCallback.app.thread.scheduleLocalVoiceInteractionStarted(activity, voiceInteractor);
                token = Binder.clearCallingIdentity();
                startRunningVoiceLocked(voiceSession, activityToCallback.appInfo.uid);
                Binder.restoreCallingIdentity(token);
            } catch (RemoteException e) {
                activityToCallback.clearVoiceSessionLocked();
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(token);
            }
        }
    }

    public void setVoiceKeepAwake(IVoiceInteractionSession session, boolean keepAwake) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (this.mRunningVoice != null && this.mRunningVoice.asBinder() == session.asBinder()) {
                    if (keepAwake) {
                        this.mVoiceWakeLock.acquire();
                    } else {
                        this.mVoiceWakeLock.release();
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public boolean startNextMatchingActivity(IBinder callingActivity, Intent intent, Bundle bOptions) {
        Throwable th;
        if (intent == null || !intent.hasFileDescriptors()) {
            ActivityOptions options = ActivityOptions.fromBundle(bOptions);
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    ActivityRecord r = ActivityRecord.isInStackLocked(callingActivity);
                    if (r == null) {
                        ActivityOptions.abort(options);
                        resetPriorityAfterLockedSection();
                        return false;
                    } else if (r.app == null || r.app.thread == null) {
                        ActivityOptions.abort(options);
                        resetPriorityAfterLockedSection();
                        return false;
                    } else {
                        Intent intent2 = new Intent(intent);
                        try {
                            intent2.setDataAndType(r.intent.getData(), r.intent.getType());
                            intent2.setComponent(null);
                            boolean debug = (intent2.getFlags() & 8) != 0;
                            ActivityInfo aInfo = null;
                            try {
                                List<ResolveInfo> resolves = AppGlobals.getPackageManager().queryIntentActivities(intent2, r.resolvedType, 66560, UserHandle.getCallingUserId()).getList();
                                int N = resolves != null ? resolves.size() : 0;
                                for (int i = 0; i < N; i++) {
                                    ResolveInfo rInfo = (ResolveInfo) resolves.get(i);
                                    if (rInfo.activityInfo.packageName.equals(r.packageName) && rInfo.activityInfo.name.equals(r.info.name)) {
                                        i++;
                                        if (i < N) {
                                            aInfo = ((ResolveInfo) resolves.get(i)).activityInfo;
                                        }
                                        if (debug) {
                                            String str;
                                            Slog.v(TAG, "Next matching activity: found current " + r.packageName + "/" + r.info.name);
                                            String str2 = TAG;
                                            StringBuilder append = new StringBuilder().append("Next matching activity: next is ");
                                            if (aInfo == null) {
                                                str = "null";
                                            } else {
                                                str = aInfo.packageName + "/" + aInfo.name;
                                            }
                                            Slog.v(str2, append.append(str).toString());
                                        }
                                        if (aInfo != null) {
                                            ActivityOptions.abort(options);
                                            if (debug) {
                                                Slog.d(TAG, "Next matching activity: nothing found");
                                            }
                                            resetPriorityAfterLockedSection();
                                            return false;
                                        }
                                        intent2.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));
                                        intent2.setFlags(intent2.getFlags() & -503316481);
                                        boolean wasFinishing = r.finishing;
                                        r.finishing = true;
                                        ActivityRecord resultTo = r.resultTo;
                                        String resultWho = r.resultWho;
                                        int requestCode = r.requestCode;
                                        r.resultTo = null;
                                        if (resultTo != null) {
                                            resultTo.removeResultsLocked(r, resultWho, requestCode);
                                        }
                                        long origId = Binder.clearCallingIdentity();
                                        int res = this.mActivityStarter.startActivityLocked(r.app.thread, intent2, null, r.resolvedType, aInfo, null, null, null, resultTo != null ? resultTo.appToken : null, resultWho, requestCode, -1, r.launchedFromUid, r.launchedFromPackage, -1, r.launchedFromUid, 0, options, false, false, null, null, "startNextMatchingActivity");
                                        Binder.restoreCallingIdentity(origId);
                                        r.finishing = wasFinishing;
                                        if (res != 0) {
                                            resetPriorityAfterLockedSection();
                                            return false;
                                        }
                                        resetPriorityAfterLockedSection();
                                        return true;
                                    }
                                }
                            } catch (RemoteException e) {
                            }
                            if (aInfo != null) {
                                intent2.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));
                                intent2.setFlags(intent2.getFlags() & -503316481);
                                boolean wasFinishing2 = r.finishing;
                                r.finishing = true;
                                ActivityRecord resultTo2 = r.resultTo;
                                String resultWho2 = r.resultWho;
                                int requestCode2 = r.requestCode;
                                r.resultTo = null;
                                if (resultTo2 != null) {
                                    resultTo2.removeResultsLocked(r, resultWho2, requestCode2);
                                }
                                long origId2 = Binder.clearCallingIdentity();
                                int res2 = this.mActivityStarter.startActivityLocked(r.app.thread, intent2, null, r.resolvedType, aInfo, null, null, null, resultTo2 != null ? resultTo2.appToken : null, resultWho2, requestCode2, -1, r.launchedFromUid, r.launchedFromPackage, -1, r.launchedFromUid, 0, options, false, false, null, null, "startNextMatchingActivity");
                                Binder.restoreCallingIdentity(origId2);
                                r.finishing = wasFinishing2;
                                if (res2 != 0) {
                                    resetPriorityAfterLockedSection();
                                    return false;
                                }
                                resetPriorityAfterLockedSection();
                                return true;
                            }
                            ActivityOptions.abort(options);
                            if (debug) {
                                Slog.d(TAG, "Next matching activity: nothing found");
                            }
                            resetPriorityAfterLockedSection();
                            return false;
                        } catch (Throwable th2) {
                            th = th2;
                            intent = intent2;
                            resetPriorityAfterLockedSection();
                            throw th;
                        }
                    }
                } catch (Throwable th3) {
                    th = th3;
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            }
        }
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }

    public final int startActivityFromRecents(int taskId, Bundle bOptions) {
        if (checkCallingPermission("android.permission.START_TASKS_FROM_RECENTS") != 0) {
            String msg = "Permission Denial: startActivityFromRecents called without android.permission.START_TASKS_FROM_RECENTS";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        long origId = Binder.clearCallingIdentity();
        try {
            int startActivityFromRecentsInner;
            synchronized (this) {
                boostPriorityForLockedSection();
                startActivityFromRecentsInner = this.mStackSupervisor.startActivityFromRecentsInner(taskId, bOptions);
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(origId);
            return startActivityFromRecentsInner;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public final int startActivityForFreeform(Intent intent, Bundle bOptions, int userId, String callPkg) {
        int result = -1;
        if (ActivityManagerDebugConfig.DEBUG_STACK) {
            Slog.v(TAG_STACK, "startActivityForFreeform: intent = " + intent + " callPkg = " + callPkg + " userId = " + userId);
        }
        if (OppoFreeFormManagerService.getInstance().isSupportFreeform()) {
            enforceCallingPermission("oppo.permission.OPPO_COMPONENT_SAFE", "startActivityForFreeform");
            long origId = Binder.clearCallingIdentity();
            try {
                synchronized (this) {
                    boostPriorityForLockedSection();
                    int callPid = Binder.getCallingPid();
                    int callUid = Binder.getCallingUid();
                    if (!getSupportsFreeformWindowManagement()) {
                        setSupportsFreeformWindowManagement(true);
                    }
                    if (ActivityManagerDebugConfig.DEBUG_STACK) {
                        Slog.v(TAG_STACK, "startActivityForFreeform: intent = " + intent);
                    }
                    result = this.mStackSupervisor.startActivityForFreeform(intent, bOptions, userId, callUid, callPkg);
                }
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(origId);
            }
        }
        return result;
    }

    final int startActivityInPackage(int uid, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, Bundle bOptions, int userId, TaskRecord inTask, String reason) {
        return this.mActivityStarter.startActivityMayWait(null, uid, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, null, null, null, bOptions, false, this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "startActivityInPackage", null), inTask, reason);
    }

    public final int startActivities(IApplicationThread caller, String callingPackage, Intent[] intents, String[] resolvedTypes, IBinder resultTo, Bundle bOptions, int userId) {
        String reason = "startActivities";
        enforceNotIsolatedCaller("startActivities");
        userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "startActivities", null);
        return this.mActivityStarter.startActivities(caller, -1, callingPackage, intents, resolvedTypes, resultTo, bOptions, userId, "startActivities");
    }

    final int startActivitiesInPackage(int uid, String callingPackage, Intent[] intents, String[] resolvedTypes, IBinder resultTo, Bundle bOptions, int userId) {
        String reason = "startActivityInPackage";
        userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "startActivityInPackage", null);
        return this.mActivityStarter.startActivities(null, uid, callingPackage, intents, resolvedTypes, resultTo, bOptions, userId, "startActivityInPackage");
    }

    public void reportActivityFullyDrawn(IBinder token, boolean restoredFromBundle) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                } else {
                    r.reportFullyDrawnLocked(restoredFromBundle);
                    resetPriorityAfterLockedSection();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void setRequestedOrientation(IBinder token, int requestedOrientation) {
        if (ActivityManagerDebugConfig.DEBUG_AMS) {
            int callingPid = Binder.getCallingPid();
            Slog.v(TAG, "Requested  Orientation call pid " + callingPid + " call Uid " + Binder.getCallingUid() + " requestedOrientation " + requestedOrientation);
        }
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (ActivityManagerDebugConfig.DEBUG_AMS) {
                    Slog.v(TAG, "Requested  Orientation r " + r);
                }
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                origId = Binder.clearCallingIdentity();
                r.setRequestedOrientation(requestedOrientation);
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public int getRequestedOrientation(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    int requestedOrientation = r.getRequestedOrientation();
                    resetPriorityAfterLockedSection();
                    return requestedOrientation;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return -1;
    }

    public final void requestActivityRelaunch(IBinder token) {
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                origId = Binder.clearCallingIdentity();
                r.forceNewConfig = true;
                r.ensureActivityConfigurationLocked(0, true);
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public final boolean finishActivity(IBinder token, int resultCode, Intent resultData, int finishTask) {
        if (resultData == null || !resultData.hasFileDescriptors()) {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return true;
                }
                TaskRecord tr = r.getTask();
                ActivityRecord rootR = tr.getRootActivity();
                if (rootR == null) {
                    Slog.w(TAG, "Finishing task with all activities already finished");
                }
                if (tr.mLockTaskAuth != 4 && rootR == r && this.mStackSupervisor.isLastLockedTask(tr)) {
                    Slog.i(TAG, "Not finishing task in lock task mode");
                    this.mStackSupervisor.showLockTaskToast();
                    resetPriorityAfterLockedSection();
                    return false;
                }
                boolean res;
                try {
                    if (this.mController != null) {
                        ActivityRecord next = r.getStack().topRunningActivityLocked(token, 0);
                        if (next != null) {
                            boolean resumeOK = true;
                            if (this.mOppoActivityControlerScheduler != null) {
                                resumeOK = this.mOppoActivityControlerScheduler.scheduleActivityResuming(next.packageName);
                            } else {
                                resumeOK = this.mController.activityResuming(next.packageName);
                            }
                            if (!resumeOK) {
                                Slog.i(TAG, "Not finishing activity because controller resumed");
                                resetPriorityAfterLockedSection();
                                return false;
                            }
                        }
                    }
                } catch (RemoteException e) {
                    if (this.mOppoActivityControlerScheduler != null) {
                        this.mOppoActivityControlerScheduler.exitRunningScheduler();
                        this.mOppoActivityControlerScheduler = null;
                    }
                    this.mController = null;
                    Watchdog.getInstance().setActivityController(null);
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                }
                long origId = Binder.clearCallingIdentity();
                boolean finishWithRootActivity = finishTask == 1;
                r.mFinishFromClose = finishTask == 2;
                if (finishTask == 2 || (finishWithRootActivity && r == rootR)) {
                    res = this.mStackSupervisor.removeTaskByIdLocked(tr.taskId, false, finishWithRootActivity);
                    if (!res) {
                        Slog.i(TAG, "Removing task failed to finish activity");
                    }
                } else {
                    res = tr.getStack().requestFinishActivityLocked(token, resultCode, resultData, "app-request", true);
                    if (!res) {
                        Slog.i(TAG, "Failed to finish by app-request");
                    }
                }
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
                return res;
            }
        }
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }

    public final void finishHeavyWeightApp() {
        if (checkCallingPermission("android.permission.FORCE_STOP_PACKAGES") != 0) {
            String msg = "Permission Denial: finishHeavyWeightApp() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.FORCE_STOP_PACKAGES";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (this.mHeavyWeightProcess == null) {
                } else {
                    ArrayList<ActivityRecord> activities = new ArrayList(this.mHeavyWeightProcess.activities);
                    for (int i = 0; i < activities.size(); i++) {
                        ActivityRecord r = (ActivityRecord) activities.get(i);
                        if (!r.finishing && r.isInStackLocked()) {
                            r.getStack().finishActivityLocked(r, 0, null, "finish-heavy", true);
                        }
                    }
                    this.mHandler.sendMessage(this.mHandler.obtainMessage(25, this.mHeavyWeightProcess.userId, 0));
                    this.mHeavyWeightProcess = null;
                    resetPriorityAfterLockedSection();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void crashApplication(int uid, int initialPid, String packageName, int userId, String message) {
        if (checkCallingPermission("android.permission.FORCE_STOP_PACKAGES") != 0) {
            String msg = "Permission Denial: crashApplication() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.FORCE_STOP_PACKAGES";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mAppErrors.scheduleAppCrashLocked(uid, initialPid, packageName, userId, message);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public final void finishSubActivity(IBinder token, String resultWho, int requestCode) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    r.getStack().finishSubActivityLocked(r, resultWho, requestCode);
                }
                Binder.restoreCallingIdentity(origId);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public boolean finishActivityAffinity(IBinder token) {
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                origId = Binder.clearCallingIdentity();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return false;
                }
                TaskRecord task = r.getTask();
                if (task.mLockTaskAuth != 4 && this.mStackSupervisor.isLastLockedTask(task) && task.getRootActivity() == r) {
                    this.mStackSupervisor.showLockTaskToast();
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return false;
                }
                boolean finishActivityAffinityLocked = task.getStack().finishActivityAffinityLocked(r);
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
                return finishActivityAffinityLocked;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void finishVoiceTask(IVoiceInteractionSession session) {
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                origId = Binder.clearCallingIdentity();
                this.mStackSupervisor.finishVoiceTask(session);
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public boolean releaseActivityInstance(IBinder token) {
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                origId = Binder.clearCallingIdentity();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return false;
                }
                boolean safelyDestroyActivityLocked = r.getStack().safelyDestroyActivityLocked(r, "app-req");
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
                return safelyDestroyActivityLocked;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void releaseSomeActivities(IApplicationThread appInt) {
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                origId = Binder.clearCallingIdentity();
                this.mStackSupervisor.releaseSomeActivitiesLocked(getRecordForAppLocked(appInt), "low-mem");
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public boolean willActivityBeVisible(IBinder token) {
        boolean willActivityBeVisibleLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                if (stack != null) {
                    willActivityBeVisibleLocked = stack.willActivityBeVisibleLocked(token);
                } else {
                    resetPriorityAfterLockedSection();
                    return false;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return willActivityBeVisibleLocked;
    }

    public void overridePendingTransition(IBinder token, String packageName, int enterAnim, int exitAnim) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord self = ActivityRecord.isInStackLocked(token);
                if (self == null) {
                } else {
                    long origId = Binder.clearCallingIdentity();
                    if (self.state == ActivityState.RESUMED || self.state == ActivityState.PAUSING) {
                        this.mWindowManager.overridePendingAppTransition(packageName, enterAnim, exitAnim, null);
                    }
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private final void handleAppDiedLocked(ProcessRecord app, boolean restarting, boolean allowRestart) {
        int pid = app.pid;
        if (!(cleanUpApplicationRecordLocked(app, restarting, allowRestart, -1, false) || (restarting ^ 1) == 0)) {
            removeLruProcessLocked(app);
            if (pid > 0) {
                ProcessList.remove(pid);
            }
        }
        if (this.mProfileProc == app) {
            clearProfilerLocked();
        }
        boolean hasVisibleActivities = this.mStackSupervisor.handleAppDiedLocked(app);
        OppoFreeFormManagerService.getInstance().handleParentDied(pid);
        app.activities.clear();
        if (app.instr != null) {
            Slog.w(TAG, "Crash of app " + app.processName + " running instrumentation " + app.instr.mClass);
            Bundle info = new Bundle();
            info.putString("shortMsg", "Process crashed.");
            finishInstrumentationLocked(app, 0, info);
        }
        if (OppoAbnormalAppManager.getInstance().validRestartProcess(app)) {
            Slog.i(OppoAbnormalAppManager.TAG, "UL restart for activity " + app + " : is R");
            return;
        }
        this.mWindowManager.deferSurfaceLayout();
        if (!restarting && hasVisibleActivities) {
            try {
                if ((this.mStackSupervisor.resumeFocusedStackTopActivityLocked() ^ 1) != 0) {
                    this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                }
            } catch (Throwable th) {
                this.mWindowManager.continueSurfaceLayout();
            }
        }
        this.mWindowManager.continueSurfaceLayout();
    }

    private final int getLRURecordIndexForAppLocked(IApplicationThread thread) {
        IBinder threadBinder = thread.asBinder();
        for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord rec = (ProcessRecord) this.mLruProcesses.get(i);
            if (rec.thread != null && rec.thread.asBinder() == threadBinder) {
                return i;
            }
        }
        return -1;
    }

    final ProcessRecord getRecordForAppLocked(IApplicationThread thread) {
        if (thread == null) {
            return null;
        }
        int appIndex = getLRURecordIndexForAppLocked(thread);
        if (appIndex >= 0) {
            return (ProcessRecord) this.mLruProcesses.get(appIndex);
        }
        IBinder threadBinder = thread.asBinder();
        ArrayMap<String, SparseArray<ProcessRecord>> pmap = this.mProcessNames.getMap();
        for (int i = pmap.size() - 1; i >= 0; i--) {
            SparseArray<ProcessRecord> procs = (SparseArray) pmap.valueAt(i);
            int j = procs.size() - 1;
            while (j >= 0) {
                ProcessRecord proc = (ProcessRecord) procs.valueAt(j);
                if (proc.thread == null || proc.thread.asBinder() != threadBinder) {
                    j--;
                } else {
                    Slog.wtf(TAG, "getRecordForApp: exists in name list but not in LRU list: " + proc);
                    return proc;
                }
            }
        }
        return null;
    }

    final void doLowMemReportIfNeededLocked(ProcessRecord dyingProc) {
        int i;
        ProcessRecord rec;
        boolean haveBg = false;
        for (i = this.mLruProcesses.size() - 1; i >= 0; i--) {
            rec = (ProcessRecord) this.mLruProcesses.get(i);
            if (rec.thread != null && rec.setProcState >= 15) {
                haveBg = true;
                break;
            }
        }
        if (!haveBg) {
            long now;
            boolean doReport = LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
            if (doReport) {
                now = SystemClock.uptimeMillis();
                if (now < this.mLastMemUsageReportTime + RefactoredBackupManagerService.TIMEOUT_FULL_BACKUP_INTERVAL) {
                    doReport = false;
                } else {
                    this.mLastMemUsageReportTime = now;
                }
            }
            ArrayList memInfos = doReport ? new ArrayList(this.mLruProcesses.size()) : null;
            EventLog.writeEvent(EventLogTags.AM_LOW_MEMORY, this.mLruProcesses.size());
            now = SystemClock.uptimeMillis();
            for (i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                rec = (ProcessRecord) this.mLruProcesses.get(i);
                if (!(rec == dyingProc || rec.thread == null)) {
                    if (doReport) {
                        memInfos.add(new ProcessMemInfo(rec.processName, rec.pid, rec.setAdj, rec.setProcState, rec.adjType, rec.makeAdjReason()));
                    }
                    if (rec.lastLowMemory + this.mConstants.GC_MIN_INTERVAL <= now) {
                        if (rec.setAdj <= 400) {
                            rec.lastRequestedGc = 0;
                        } else {
                            rec.lastRequestedGc = rec.lastLowMemory;
                        }
                        rec.reportLowMemory = true;
                        rec.lastLowMemory = now;
                        this.mProcessesToGc.remove(rec);
                        addProcessToGcListLocked(rec);
                    }
                }
            }
            if (doReport) {
                this.mHandler.sendMessage(this.mHandler.obtainMessage(33, memInfos));
            }
            scheduleAppGcsLocked();
        }
    }

    final void appDiedLocked(ProcessRecord app) {
        appDiedLocked(app, app.pid, app.thread, false);
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    final void appDiedLocked(ProcessRecord app, int pid, IApplicationThread thread, boolean fromBinderDied) {
        synchronized (this.mPidsSelfLocked) {
            ProcessRecord curProc = (ProcessRecord) this.mPidsSelfLocked.get(pid);
            if (curProc != app) {
                Slog.w(TAG, "Spurious death for " + app + ", curProc for " + pid + ": " + curProc);
            }
        }
    }

    public static File dumpStackTraces(boolean clearTraces, ArrayList<Integer> firstPids, ProcessCpuTracker processCpuTracker, SparseArray<Boolean> lastPids, ArrayList<Integer> nativePids) {
        if (Watchdog.getInstance().getLastTimeWatchdogHappen()) {
            Slog.i(TAG, "Skip the stacktraces of ANR because watchdog happened");
            return null;
        }
        File tracesFile;
        ArrayList extraPids = null;
        if (processCpuTracker != null) {
            processCpuTracker.init();
            try {
                Thread.sleep(NETWORK_ACCESS_TIMEOUT_DEFAULT_MS);
            } catch (InterruptedException e) {
            }
            processCpuTracker.update();
            int N = processCpuTracker.countWorkingStats();
            extraPids = new ArrayList();
            for (int i = 0; i < N && extraPids.size() < 5; i++) {
                Stats stats = processCpuTracker.getWorkingStats(i);
                if (lastPids.indexOfKey(stats.pid) >= 0) {
                    if (ActivityManagerDebugConfig.DEBUG_ANR) {
                        Slog.d(TAG, "Collecting stacks for extra pid " + stats.pid);
                    }
                    extraPids.add(Integer.valueOf(stats.pid));
                } else if (ActivityManagerDebugConfig.DEBUG_ANR) {
                    Slog.d(TAG, "Skipping next CPU consuming process, not a java proc: " + stats.pid);
                }
            }
        }
        boolean useTombstonedForJavaTraces = false;
        String tracesDirProp = SystemProperties.get("dalvik.vm.stack-trace-dir", "");
        if (tracesDirProp.isEmpty()) {
            String globalTracesPath = SystemProperties.get("dalvik.vm.stack-trace-file", null);
            if (globalTracesPath.isEmpty()) {
                Slog.w(TAG, "dumpStackTraces: no trace path configured");
                return null;
            }
            tracesFile = new File(globalTracesPath);
            if (clearTraces) {
                try {
                    if (tracesFile.exists()) {
                        tracesFile.delete();
                    }
                } catch (IOException e2) {
                    Slog.w(TAG, "Unable to prepare ANR traces file: " + tracesFile, e2);
                    return null;
                }
            }
            tracesFile.createNewFile();
            FileUtils.setPermissions(globalTracesPath, 438, -1, -1);
        } else {
            File tracesDir = new File(tracesDirProp);
            maybePruneOldTraces(tracesDir);
            tracesFile = createAnrDumpFile(tracesDir);
            if (tracesFile == null) {
                return null;
            }
            useTombstonedForJavaTraces = true;
        }
        dumpStackTraces(tracesFile.getAbsolutePath(), (ArrayList) firstPids, (ArrayList) nativePids, extraPids, useTombstonedForJavaTraces);
        return tracesFile;
    }

    private static synchronized File createAnrDumpFile(File tracesDir) {
        synchronized (ActivityManagerService.class) {
            try {
                boostPriorityForLockedSection();
                if (sAnrFileDateFormat == null) {
                    sAnrFileDateFormat = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss-SSS");
                }
                File anrFile = new File(tracesDir, "anr_" + sAnrFileDateFormat.format(new Date()));
                if (anrFile.createNewFile()) {
                    FileUtils.setPermissions(anrFile.getAbsolutePath(), 384, -1, -1);
                    resetPriorityAfterLockedSection();
                    return anrFile;
                }
                Slog.w(TAG, "Unable to create ANR dump file: createNewFile failed");
            } catch (IOException ioe) {
                Slog.w(TAG, "Exception creating ANR dump file:", ioe);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
        return null;
    }

    private static void maybePruneOldTraces(File tracesDir) {
        long now = System.currentTimeMillis();
        File[] traceFiles = tracesDir.listFiles();
        if (traceFiles != null) {
            for (File file : traceFiles) {
                if (now - file.lastModified() > 86400000 && !file.delete()) {
                    Slog.w(TAG, "Unable to prune stale trace file: " + file);
                }
            }
        }
    }

    private static long dumpJavaTracesTombstoned(int pid, String fileName, long timeoutMs) {
        long timeStart = SystemClock.elapsedRealtime();
        if (!Debug.dumpJavaBacktraceToFileTimeout(pid, fileName, (int) (timeoutMs / 1000))) {
            Debug.dumpNativeBacktraceToFileTimeout(pid, fileName, 2);
        }
        return SystemClock.elapsedRealtime() - timeStart;
    }

    private static void dumpStackTraces(String tracesFile, ArrayList<Integer> firstPids, ArrayList<Integer> nativePids, ArrayList<Integer> extraPids, boolean useTombstonedForJavaTraces) {
        DumpStackFileObserver observer;
        long timeTaken;
        int pid;
        if (useTombstonedForJavaTraces) {
            observer = null;
        } else {
            observer = new DumpStackFileObserver(tracesFile);
        }
        long remainingTime = APP_DEXOPT_TIMEOUT;
        if (observer != null) {
            try {
                observer.startWatching();
            } catch (Throwable th) {
                if (observer != null) {
                    observer.stopWatching();
                }
            }
        }
        if (firstPids != null) {
            int num = firstPids.size();
            for (int i = 0; i < num; i++) {
                if (ActivityManagerDebugConfig.DEBUG_ANR) {
                    Slog.d(TAG, "Collecting stacks for pid " + firstPids.get(i));
                }
                if (useTombstonedForJavaTraces) {
                    timeTaken = dumpJavaTracesTombstoned(((Integer) firstPids.get(i)).intValue(), tracesFile, remainingTime);
                } else {
                    timeTaken = observer.dumpWithTimeout(((Integer) firstPids.get(i)).intValue(), remainingTime);
                }
                remainingTime -= timeTaken;
                if (remainingTime <= 0) {
                    Slog.e(TAG, "Aborting stack trace dump (current firstPid=" + firstPids.get(i) + "); deadline exceeded.");
                    if (observer != null) {
                        observer.stopWatching();
                    }
                    return;
                }
                if (ActivityManagerDebugConfig.DEBUG_ANR) {
                    Slog.d(TAG, "Done with pid " + firstPids.get(i) + " in " + timeTaken + "ms");
                }
            }
        }
        SystemClock.sleep(1000);
        if (nativePids != null) {
            for (Integer intValue : nativePids) {
                pid = intValue.intValue();
                if (ActivityManagerDebugConfig.DEBUG_ANR) {
                    Slog.d(TAG, "Collecting stacks for native pid " + pid);
                }
                long nativeDumpTimeoutMs = Math.min(2000, remainingTime);
                long start = SystemClock.elapsedRealtime();
                Debug.dumpNativeBacktraceToFileTimeout(pid, tracesFile, (int) (nativeDumpTimeoutMs / 1000));
                timeTaken = SystemClock.elapsedRealtime() - start;
                remainingTime -= timeTaken;
                if (remainingTime <= 0) {
                    Slog.e(TAG, "Aborting stack trace dump (current native pid=" + pid + "); deadline exceeded.");
                    if (observer != null) {
                        observer.stopWatching();
                    }
                    return;
                } else if (ActivityManagerDebugConfig.DEBUG_ANR) {
                    Slog.d(TAG, "Done with native pid " + pid + " in " + timeTaken + "ms");
                }
            }
        }
        if (extraPids != null) {
            for (Integer intValue2 : extraPids) {
                pid = intValue2.intValue();
                if (ActivityManagerDebugConfig.DEBUG_ANR) {
                    Slog.d(TAG, "Collecting stacks for extra pid " + pid);
                }
                if (useTombstonedForJavaTraces) {
                    timeTaken = dumpJavaTracesTombstoned(pid, tracesFile, remainingTime);
                } else {
                    timeTaken = observer.dumpWithTimeout(pid, remainingTime);
                }
                remainingTime -= timeTaken;
                if (remainingTime <= 0) {
                    Slog.e(TAG, "Aborting stack trace dump (current extra pid=" + pid + "); deadline exceeded.");
                    if (observer != null) {
                        observer.stopWatching();
                    }
                    return;
                } else if (ActivityManagerDebugConfig.DEBUG_ANR) {
                    Slog.d(TAG, "Done with extra pid " + pid + " in " + timeTaken + "ms");
                }
            }
        }
        if (observer != null) {
            observer.stopWatching();
        }
    }

    final void logAppTooSlow(ProcessRecord app, long startTime, String msg) {
    }

    final void showLaunchWarningLocked(final ActivityRecord cur, final ActivityRecord next) {
        if (!this.mLaunchWarningShown) {
            this.mLaunchWarningShown = true;
            this.mUiHandler.post(new Runnable() {
                public void run() {
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            final Dialog d = new LaunchWarningWindow(ActivityManagerService.this.mContext, cur, next);
                            d.show();
                            ActivityManagerService.this.mUiHandler.postDelayed(new Runnable() {
                                public void run() {
                                    synchronized (ActivityManagerService.this) {
                                        try {
                                            ActivityManagerService.boostPriorityForLockedSection();
                                            d.dismiss();
                                            ActivityManagerService.this.mLaunchWarningShown = false;
                                        } finally {
                                            ActivityManagerService.resetPriorityAfterLockedSection();
                                        }
                                    }
                                }
                            }, 4000);
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                }
            });
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean clearApplicationUserData(String packageName, IPackageDataObserver observer, int userId) {
        IPackageManager pm;
        enforceNotIsolatedCaller("clearApplicationUserData");
        int uid = Binder.getCallingUid();
        if (uid == OppoArpPeer.ARP_FIRST_RESPONSE_TIMEOUT) {
            this.mFileUtils = OppoProcessWhiteListUtils.getInstance();
            if (!this.mFileUtils.isSupportClearSystemAppData()) {
                pm = AppGlobals.getPackageManager();
                try {
                    ApplicationInfo info = pm.getApplicationInfo(packageName, 0, UserHandle.getCallingUserId());
                    boolean isCtsRunning = pm.isClosedSuperFirewall();
                    if (!(info == null || (info.flags & 1) == 0 || (isCtsRunning ^ 1) == 0)) {
                        Slog.d(TAG, "this is system app not support adb clear user data!!!");
                        throw new SecurityException("adb clearing user data is forbidden.");
                    }
                } catch (RemoteException e) {
                }
            }
            if (packageName != null && this.mFileUtils.isClearDataWhiteApp(packageName)) {
                Slog.d(TAG, "this is not support adb clear pkg data: " + packageName);
                throw new SecurityException("adb clearing user data is forbidden.");
            }
        }
        int pid = Binder.getCallingPid();
        int resolvedUserId = this.mUserController.handleIncomingUser(pid, uid, userId, false, 2, "clearApplicationUserData", null);
        long callingId = Binder.clearCallingIdentity();
        try {
            pm = AppGlobals.getPackageManager();
            synchronized (this) {
                boostPriorityForLockedSection();
                if (getPackageManagerInternalLocked().isPackageDataProtected(resolvedUserId, packageName)) {
                    throw new SecurityException("Cannot clear data for a protected package: " + packageName);
                }
                boolean clearingOwnUidData;
                boolean hasInstantMetadata;
                int isUninstalledAppWithoutInstantMetadata;
                boolean isInstantApp;
                boolean canAccessInstantApps;
                ApplicationInfo applicationInfo = null;
                try {
                    applicationInfo = pm.getApplicationInfo(packageName, 8192, resolvedUserId);
                } catch (RemoteException e2) {
                }
                ApplicationInfo appInfo = applicationInfo;
                if (appInfo != null) {
                    if (appInfo.uid == uid) {
                        clearingOwnUidData = true;
                        if (!clearingOwnUidData || checkComponentPermission("android.permission.CLEAR_APP_USER_DATA", pid, uid, -1, true) == 0) {
                            hasInstantMetadata = getPackageManagerInternalLocked().hasInstantApplicationMetadata(packageName, resolvedUserId);
                            isUninstalledAppWithoutInstantMetadata = appInfo != null ? hasInstantMetadata ^ 1 : 0;
                            if (appInfo == null && appInfo.isInstantApp()) {
                                isInstantApp = true;
                            } else {
                                isInstantApp = hasInstantMetadata;
                            }
                            canAccessInstantApps = checkComponentPermission("android.permission.ACCESS_INSTANT_APPS", pid, uid, -1, true) != 0;
                            if (isUninstalledAppWithoutInstantMetadata == 0 || (isInstantApp && (canAccessInstantApps ^ 1) != 0)) {
                                Slog.w(TAG, "Invalid packageName: " + packageName);
                                if (observer != null) {
                                    try {
                                        observer.onRemoveCompleted(packageName, false);
                                    } catch (RemoteException e3) {
                                        Slog.i(TAG, "Observer no longer exists.");
                                    }
                                }
                                resetPriorityAfterLockedSection();
                                Binder.restoreCallingIdentity(callingId);
                                return false;
                            } else if (appInfo != null) {
                                forceStopPackageLocked(packageName, appInfo.uid, "clear data");
                                for (int i = this.mRecentTasks.size() - 1; i >= 0; i--) {
                                    TaskRecord tr = (TaskRecord) this.mRecentTasks.get(i);
                                    String taskPackageName = tr.getBaseIntent().getComponent().getPackageName();
                                    if (tr.userId == resolvedUserId && taskPackageName.equals(packageName)) {
                                        this.mStackSupervisor.removeTaskByIdLocked(tr.taskId, false, true);
                                    }
                                }
                            }
                        } else {
                            throw new SecurityException("PID " + pid + " does not have permission " + "android.permission.CLEAR_APP_USER_DATA" + " to clear data" + " of package " + packageName);
                        }
                    }
                }
                clearingOwnUidData = false;
                if (clearingOwnUidData) {
                }
                hasInstantMetadata = getPackageManagerInternalLocked().hasInstantApplicationMetadata(packageName, resolvedUserId);
                if (appInfo != null) {
                }
                if (appInfo == null) {
                }
                isInstantApp = hasInstantMetadata;
                if (checkComponentPermission("android.permission.ACCESS_INSTANT_APPS", pid, uid, -1, true) != 0) {
                }
                if (isUninstalledAppWithoutInstantMetadata == 0) {
                }
                Slog.w(TAG, "Invalid packageName: " + packageName);
                if (observer != null) {
                    try {
                        observer.onRemoveCompleted(packageName, false);
                    } catch (RemoteException e32) {
                        Slog.i(TAG, "Observer no longer exists.");
                    }
                }
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(callingId);
                return false;
            }
            Binder.restoreCallingIdentity(callingId);
            return true;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public void killBackgroundProcesses(String packageName, int userId) {
        if (checkCallingPermission("android.permission.KILL_BACKGROUND_PROCESSES") == 0 || checkCallingPermission("android.permission.RESTART_PACKAGES") == 0) {
            IPackageManager pm = AppGlobals.getPackageManager();
            String callingPkg = null;
            try {
                callingPkg = pm.getNameForUid(Binder.getCallingUid());
            } catch (RemoteException e) {
            }
            this.mFileUtils = OppoProcessWhiteListUtils.getInstance();
            if (this.mFileUtils.getProcessWhiteList().contains(packageName) && Binder.getCallingUid() != 1000 && !this.mFileUtils.getAuthorizedProcessList().contains(callingPkg)) {
                Slog.v(TAG, packageName + " won't killed by " + callingPkg);
                return;
            } else if (!OppoListManager.getInstance().getStageProtectList().contains(packageName) || this.mFileUtils.getAuthorizedProcessList().contains(callingPkg)) {
                if (DEBUG_COLOROS_AMS) {
                    Slog.v(TAG, "killBackground: " + packageName + " is called by " + callingPkg);
                }
                userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, true, 2, "killBackgroundProcesses", null);
                long callingId = Binder.clearCallingIdentity();
                try {
                    synchronized (this) {
                        boostPriorityForLockedSection();
                        int appId = -1;
                        try {
                            appId = UserHandle.getAppId(pm.getPackageUid(packageName, 268435456, userId));
                        } catch (RemoteException e2) {
                        }
                        if (appId == -1) {
                            Slog.w(TAG, "Invalid packageName: " + packageName);
                            resetPriorityAfterLockedSection();
                            Binder.restoreCallingIdentity(callingId);
                            return;
                        }
                        killPackageProcessesLocked(packageName, appId, userId, 500, false, true, true, false, "kill background");
                        resetPriorityAfterLockedSection();
                        Binder.restoreCallingIdentity(callingId);
                        return;
                    }
                } catch (Throwable th) {
                    Binder.restoreCallingIdentity(callingId);
                }
            } else {
                Slog.v(TAG, packageName + " being protected, won't killed by " + callingPkg);
                return;
            }
        }
        String msg = "Permission Denial: killBackgroundProcesses() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.KILL_BACKGROUND_PROCESSES";
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }

    public void killAllBackgroundProcesses() {
        if (checkCallingPermission("android.permission.KILL_BACKGROUND_PROCESSES") != 0) {
            String msg = "Permission Denial: killAllBackgroundProcesses() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.KILL_BACKGROUND_PROCESSES";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ArrayList<ProcessRecord> procs = new ArrayList();
                int NP = this.mProcessNames.getMap().size();
                for (int ip = 0; ip < NP; ip++) {
                    SparseArray<ProcessRecord> apps = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
                    int NA = apps.size();
                    for (int ia = 0; ia < NA; ia++) {
                        ProcessRecord app = (ProcessRecord) apps.valueAt(ia);
                        if (!app.persistent) {
                            if (app.removed) {
                                procs.add(app);
                            } else if (app.setAdj >= 900) {
                                app.removed = true;
                                procs.add(app);
                            }
                        }
                    }
                }
                int N = procs.size();
                for (int i = 0; i < N; i++) {
                    removeProcessLocked((ProcessRecord) procs.get(i), false, true, "kill all background");
                }
                this.mAllowLowerMemLevel = true;
                updateOomAdjLocked();
                doLowMemReportIfNeededLocked(null);
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(callingId);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private void killAllBackgroundProcessesExcept(int minTargetSdk, int maxProcState) {
        if (checkCallingPermission("android.permission.KILL_BACKGROUND_PROCESSES") != 0) {
            String msg = "Permission Denial: killAllBackgroundProcessesExcept() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.KILL_BACKGROUND_PROCESSES";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ArrayList<ProcessRecord> procs = new ArrayList();
                int NP = this.mProcessNames.getMap().size();
                for (int ip = 0; ip < NP; ip++) {
                    SparseArray<ProcessRecord> apps = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
                    int NA = apps.size();
                    for (int ia = 0; ia < NA; ia++) {
                        ProcessRecord app = (ProcessRecord) apps.valueAt(ia);
                        if (app.removed) {
                            procs.add(app);
                        } else if ((minTargetSdk < 0 || app.info.targetSdkVersion < minTargetSdk) && (maxProcState < 0 || app.setProcState > maxProcState)) {
                            app.removed = true;
                            procs.add(app);
                        }
                    }
                }
                int N = procs.size();
                for (int i = 0; i < N; i++) {
                    removeProcessLocked((ProcessRecord) procs.get(i), false, true, "kill all background except");
                }
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(callingId);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public void forceStopPackage(String packageName, int userId) {
        if (checkCallingPermission("android.permission.FORCE_STOP_PACKAGES") != 0) {
            String msg = "Permission Denial: forceStopPackage() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.FORCE_STOP_PACKAGES";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        } else if (this.mContext.getPackageManager().hasSystemFeature("oppo.customize.function.forbid_stop_app", 0) && (checkWhiteList(packageName) || checkProtectAppList(packageName))) {
            Slog.d(TAG, "current app is not allowed to killed!");
        } else {
            int callingPid = Binder.getCallingPid();
            userId = this.mUserController.handleIncomingUser(callingPid, Binder.getCallingUid(), userId, true, 2, "forceStopPackage", null);
            long callingId = Binder.clearCallingIdentity();
            try {
                IPackageManager pm = AppGlobals.getPackageManager();
                synchronized (this) {
                    boostPriorityForLockedSection();
                    for (int user : userId == -1 ? this.mUserController.getUsers() : new int[]{userId}) {
                        int pkgUid = -1;
                        try {
                            pkgUid = pm.getPackageUid(packageName, 268435456, user);
                        } catch (RemoteException e) {
                        }
                        if (pkgUid == -1) {
                            Slog.w(TAG, "Invalid packageName: " + packageName);
                        } else {
                            try {
                                pm.setPackageStoppedState(packageName, true, user);
                            } catch (RemoteException e2) {
                            } catch (IllegalArgumentException e3) {
                                Slog.w(TAG, "Failed trying to unstop package " + packageName + ": " + e3);
                            }
                            if (this.mUserController.isUserRunningLocked(user, 0)) {
                                forceStopPackageLocked(packageName, pkgUid, "from pid " + callingPid);
                                finishForceStopPackageLocked(packageName, pkgUid);
                            }
                        }
                    }
                }
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(callingId);
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(callingId);
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void addPackageDependency(String packageName) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (Binder.getCallingPid() == Process.myPid()) {
                } else {
                    ProcessRecord proc;
                    synchronized (this.mPidsSelfLocked) {
                        proc = (ProcessRecord) this.mPidsSelfLocked.get(Binder.getCallingPid());
                    }
                    if (proc != null) {
                        if (proc.pkgDeps == null) {
                            proc.pkgDeps = new ArraySet(1);
                        }
                        proc.pkgDeps.add(packageName);
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void killApplication(String pkg, int appId, int userId, String reason) {
        if (pkg != null) {
            if (appId < 0) {
                Slog.w(TAG, "Invalid appid specified for pkg : " + pkg);
                return;
            }
            int callerUid = Binder.getCallingUid();
            if (UserHandle.getAppId(callerUid) == 1000) {
                Message msg = this.mHandler.obtainMessage(22);
                msg.arg1 = appId;
                msg.arg2 = userId;
                Bundle bundle = new Bundle();
                bundle.putString("pkg", pkg);
                bundle.putString(PhoneWindowManager.SYSTEM_DIALOG_REASON_KEY, reason);
                msg.obj = bundle;
                this.mHandler.sendMessage(msg);
                return;
            }
            throw new SecurityException(callerUid + " cannot kill pkg: " + pkg);
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void closeSystemDialogs(String reason) {
        enforceNotIsolatedCaller("closeSystemDialogs");
        int pid = Binder.getCallingPid();
        int uid = Binder.getCallingUid();
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (uid >= 10000) {
                        ProcessRecord proc;
                        synchronized (this.mPidsSelfLocked) {
                            proc = (ProcessRecord) this.mPidsSelfLocked.get(pid);
                        }
                        if (proc.curRawAdj > 200) {
                            Slog.w(TAG, "Ignoring closeSystemDialogs " + reason + " from background process " + proc);
                        }
                    }
                    closeSystemDialogsLocked(reason);
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    void closeSystemDialogsLocked(String reason) {
        Intent intent = new Intent("android.intent.action.CLOSE_SYSTEM_DIALOGS");
        intent.addFlags(1342177280);
        if (reason != null) {
            intent.putExtra(PhoneWindowManager.SYSTEM_DIALOG_REASON_KEY, reason);
        }
        this.mWindowManager.closeSystemDialogs(reason);
        this.mStackSupervisor.closeSystemDialogsLocked();
        broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, -1, null, false, false, -1, 1000, -1);
    }

    public MemoryInfo[] getProcessMemoryInfo(int[] pids) {
        enforceNotIsolatedCaller("getProcessMemoryInfo");
        MemoryInfo[] infos = new MemoryInfo[pids.length];
        for (int i = pids.length - 1; i >= 0; i--) {
            synchronized (this) {
                try {
                    ProcessRecord processRecord;
                    boostPriorityForLockedSection();
                    synchronized (this.mPidsSelfLocked) {
                        processRecord = (ProcessRecord) this.mPidsSelfLocked.get(pids[i]);
                        int oomAdj = processRecord != null ? processRecord.setAdj : 0;
                    }
                    infos[i] = new MemoryInfo();
                    Debug.getMemoryInfo(pids[i], infos[i]);
                    if (processRecord != null) {
                        synchronized (this) {
                            try {
                                boostPriorityForLockedSection();
                                if (processRecord.thread != null && processRecord.setAdj == oomAdj) {
                                    processRecord.baseProcessTracker.addPss((long) infos[i].getTotalPss(), (long) infos[i].getTotalUss(), false, processRecord.pkgList);
                                }
                            } finally {
                                resetPriorityAfterLockedSection();
                            }
                        }
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        }
        return infos;
    }

    public long[] getProcessPss(int[] pids) {
        enforceNotIsolatedCaller("getProcessPss");
        long[] pss = new long[pids.length];
        for (int i = pids.length - 1; i >= 0; i--) {
            synchronized (this) {
                try {
                    ProcessRecord processRecord;
                    boostPriorityForLockedSection();
                    synchronized (this.mPidsSelfLocked) {
                        processRecord = (ProcessRecord) this.mPidsSelfLocked.get(pids[i]);
                        int oomAdj = processRecord != null ? processRecord.setAdj : 0;
                    }
                    long[] tmpUss = new long[]{Debug.getPss(pids[i], tmpUss, null)};
                    if (processRecord != null) {
                        synchronized (this) {
                            try {
                                boostPriorityForLockedSection();
                                if (processRecord.thread != null && processRecord.setAdj == oomAdj) {
                                    processRecord.baseProcessTracker.addPss(pss[i], tmpUss[0], false, processRecord.pkgList);
                                }
                            } finally {
                                resetPriorityAfterLockedSection();
                            }
                        }
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        }
        return pss;
    }

    public void killApplicationProcess(String processName, int uid) {
        if (processName != null) {
            int callerUid = Binder.getCallingUid();
            boolean isArmyControler = false;
            if (this.mContext.getPackageManager().hasSystemFeature("oppo.customize.function.killprocess")) {
                try {
                    String[] callerPkgs = AppGlobals.getPackageManager().getPackagesForUid(callerUid);
                    if (callerPkgs != null && callerPkgs.length > 0) {
                        for (String pkgName : callerPkgs) {
                            if (checkWhiteList(pkgName)) {
                                isArmyControler = true;
                                break;
                            }
                        }
                    }
                } catch (RemoteException e) {
                    Slog.e(TAG, "getPackagesForUid failed for uid:" + callerUid, e);
                }
            }
            if (callerUid == 1000 || isArmyControler) {
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        ProcessRecord app = getProcessRecordLocked(processName, uid, true);
                        if (app == null || app.thread == null) {
                            Slog.w(TAG, "Process/uid not found attempting kill of " + processName + " / " + uid);
                        } else {
                            try {
                                app.thread.scheduleSuicide();
                            } catch (RemoteException e2) {
                            }
                        }
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
                return;
            }
            throw new SecurityException(callerUid + " cannot kill app process: " + processName);
        }
    }

    private void forceStopPackageLocked(String packageName, int uid, String reason) {
        forceStopPackageLocked(packageName, UserHandle.getAppId(uid), false, false, true, false, false, UserHandle.getUserId(uid), reason);
    }

    private void finishForceStopPackageLocked(String packageName, int uid) {
        Intent intent = new Intent("android.intent.action.PACKAGE_RESTARTED", Uri.fromParts("package", packageName, null));
        if (!this.mProcessesReady) {
            intent.addFlags(1342177280);
        }
        intent.putExtra("android.intent.extra.UID", uid);
        intent.putExtra("android.intent.extra.user_handle", UserHandle.getUserId(uid));
        broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, -1, null, false, false, MY_PID, 1000, UserHandle.getUserId(uid));
    }

    private final boolean killPackageProcessesLocked(String packageName, int appId, int userId, int minOomAdj, boolean callerWillRestart, boolean allowRestart, boolean doit, boolean evenPersistent, String reason) {
        ArrayList<ProcessRecord> procs = new ArrayList();
        int NP = this.mProcessNames.getMap().size();
        for (int ip = 0; ip < NP; ip++) {
            SparseArray<ProcessRecord> apps = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
            int NA = apps.size();
            for (int ia = 0; ia < NA; ia++) {
                ProcessRecord app = (ProcessRecord) apps.valueAt(ia);
                if (!app.persistent || (evenPersistent ^ 1) == 0) {
                    if (app.removed) {
                        if (doit) {
                            procs.add(app);
                        }
                    } else if (app.setAdj < minOomAdj) {
                        continue;
                    } else {
                        if (packageName == null) {
                            if (userId != -1) {
                                if (app.userId != userId) {
                                    continue;
                                }
                            }
                            if (appId >= 0 && UserHandle.getAppId(app.uid) != appId) {
                            }
                        } else {
                            boolean isDep;
                            if (app.pkgDeps != null) {
                                isDep = app.pkgDeps.contains(packageName);
                            } else {
                                isDep = false;
                            }
                            if (isDep && isColorSpecial(app) && UserHandle.getAppId(app.uid) != appId) {
                                Slog.v(TAG, "processName = " + app.processName + " isDep = " + isDep + " packageName = " + packageName);
                            } else {
                                if (!isDep) {
                                    if (UserHandle.getAppId(app.uid) != appId) {
                                        continue;
                                    }
                                }
                                if (userId != -1) {
                                    if (app.userId != userId) {
                                        continue;
                                    }
                                }
                                if (!(app.pkgList.containsKey(packageName) || (isDep ^ 1) == 0)) {
                                }
                            }
                        }
                        if (!doit) {
                            return true;
                        }
                        app.removed = true;
                        procs.add(app);
                    }
                }
            }
        }
        int N = procs.size();
        for (int i = 0; i < N; i++) {
            removeProcessLocked((ProcessRecord) procs.get(i), callerWillRestart, allowRestart, reason);
        }
        updateOomAdjLocked();
        return N > 0;
    }

    private boolean isColorSpecial(ProcessRecord app) {
        if ((app.info.flags & 1) != 0) {
            return true;
        }
        return false;
    }

    private void cleanupDisabledPackageComponentsLocked(String packageName, int userId, boolean killProcess, String[] changedClasses) {
        Set<String> disabledClasses = null;
        boolean packageDisabled = false;
        IPackageManager pm = AppGlobals.getPackageManager();
        if (changedClasses != null) {
            int i;
            Set disabledClasses2;
            for (i = changedClasses.length - 1; i >= 0; i--) {
                String changedClass = changedClasses[i];
                int enabled;
                if (changedClass.equals(packageName)) {
                    try {
                        enabled = pm.getApplicationEnabledSetting(packageName, userId != -1 ? userId : 0);
                        packageDisabled = enabled != 1 ? enabled != 0 : false;
                        if (packageDisabled) {
                            disabledClasses2 = null;
                            break;
                        }
                    } catch (Exception e) {
                        return;
                    }
                }
                try {
                    enabled = pm.getComponentEnabledSetting(new ComponentName(packageName, changedClass), userId != -1 ? userId : 0);
                    if (!(enabled == 1 || enabled == 0)) {
                        if (disabledClasses == null) {
                            disabledClasses = new ArraySet(changedClasses.length);
                        }
                        disabledClasses.add(changedClass);
                    }
                } catch (Exception e2) {
                    return;
                }
            }
            if (packageDisabled || disabledClasses2 != null) {
                if (this.mStackSupervisor.finishDisabledPackageActivitiesLocked(packageName, disabledClasses2, true, false, userId) && this.mBooted) {
                    this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
                    this.mStackSupervisor.scheduleIdleLocked();
                }
                cleanupDisabledPackageTasksLocked(packageName, disabledClasses2, userId);
                this.mServices.bringDownDisabledPackageServicesLocked(packageName, disabledClasses2, userId, false, killProcess, true);
                ArrayList providers = new ArrayList();
                this.mProviderMap.collectPackageProvidersLocked(packageName, disabledClasses2, true, false, userId, providers);
                for (i = providers.size() - 1; i >= 0; i--) {
                    removeDyingProviderLocked(null, (ContentProviderRecord) providers.get(i), true);
                }
                for (i = this.mBroadcastQueues.length - 1; i >= 0; i--) {
                    this.mBroadcastQueues[i].cleanupDisabledPackageReceiversLocked(packageName, disabledClasses2, userId, true);
                }
            }
        }
    }

    final boolean clearBroadcastQueueForUserLocked(int userId) {
        boolean didSomething = false;
        for (int i = this.mBroadcastQueues.length - 1; i >= 0; i--) {
            didSomething |= this.mBroadcastQueues[i].cleanupDisabledPackageReceiversLocked(null, null, userId, true);
        }
        return didSomething;
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "Jun.Zhang@Plf.Framework, add for oppo input policy exceptionZhiYong.Lin@Plf.Framework, add for clean the residual process", property = OppoRomType.ROM)
    final boolean forceStopPackageLocked(String packageName, int appId, boolean callerWillRestart, boolean purgeCache, boolean doit, boolean evenPersistent, boolean uninstalling, int userId, String reason) {
        int i;
        if (userId == -1 && packageName == null) {
            Slog.w(TAG, "Can't force stop all processes of all users, that is insane!");
        }
        if (appId < 0 && packageName != null) {
            try {
                appId = UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(packageName, 268435456, 0));
            } catch (RemoteException e) {
            }
        }
        if (doit) {
            if (packageName != null) {
                Slog.i(TAG, "Force stopping " + packageName + " appid=" + appId + " user=" + userId + ": " + reason);
            } else {
                Slog.i(TAG, "Force stopping u" + userId + ": " + reason);
            }
            OppoExtraActivityManagerService.setKeyLockModeNormal(this.mContext, packageName, this.mSystemReady);
            this.mAppErrors.resetProcessCrashTimeLocked(packageName == null, appId, userId);
        }
        boolean didSomething = killPackageProcessesLocked(packageName, appId, userId, -10000, callerWillRestart, true, doit, evenPersistent, packageName == null ? "stop user " + userId : "stop " + packageName) | this.mActivityStarter.clearPendingActivityLaunchesLocked(packageName);
        if (this.mStackSupervisor.finishDisabledPackageActivitiesLocked(packageName, null, doit, evenPersistent, userId)) {
            if (!doit) {
                return true;
            }
            didSomething = true;
        }
        if (this.mServices.bringDownDisabledPackageServicesLocked(packageName, null, userId, evenPersistent, true, doit)) {
            if (!doit) {
                return true;
            }
            didSomething = true;
        }
        if (packageName == null) {
            this.mStickyBroadcasts.remove(userId);
        }
        ArrayList providers = new ArrayList();
        if (this.mProviderMap.collectPackageProvidersLocked(packageName, null, doit, evenPersistent, userId, providers)) {
            if (!doit) {
                return true;
            }
            didSomething = true;
        }
        for (i = providers.size() - 1; i >= 0; i--) {
            removeDyingProviderLocked(null, (ContentProviderRecord) providers.get(i), true);
        }
        removeUriPermissionsForPackageLocked(packageName, userId, false);
        if (doit) {
            for (i = this.mBroadcastQueues.length - 1; i >= 0; i--) {
                didSomething |= this.mBroadcastQueues[i].cleanupDisabledPackageReceiversLocked(packageName, null, userId, doit);
            }
        }
        if ((packageName == null || uninstalling) && this.mIntentSenderRecords.size() > 0) {
            Iterator<WeakReference<PendingIntentRecord>> it = this.mIntentSenderRecords.values().iterator();
            while (it.hasNext()) {
                WeakReference<PendingIntentRecord> wpir = (WeakReference) it.next();
                if (wpir == null) {
                    it.remove();
                } else {
                    PendingIntentRecord pir = (PendingIntentRecord) wpir.get();
                    if (pir == null) {
                        it.remove();
                    } else {
                        if (packageName == null) {
                            if (pir.key.userId != userId) {
                                continue;
                            }
                        } else if (UserHandle.getAppId(pir.uid) == appId && (userId == -1 || pir.key.userId == userId)) {
                            if (!pir.key.packageName.equals(packageName)) {
                            }
                        }
                        if (!doit) {
                            return true;
                        }
                        int didSomething2 = 1;
                        it.remove();
                        makeIntentSenderCanceledLocked(pir);
                        if (!(pir.key.activity == null || pir.key.activity.pendingResults == null)) {
                            pir.key.activity.pendingResults.remove(pir.ref);
                        }
                    }
                }
            }
        }
        if (doit) {
            if (purgeCache && packageName != null) {
                AttributeCache ac = AttributeCache.instance();
                if (ac != null) {
                    ac.removePackage(packageName);
                }
            }
            if (this.mBooted) {
                this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
                this.mStackSupervisor.scheduleIdleLocked();
            }
        }
        if (didSomething && NeuronSystemManager.isEnable()) {
            ContentValues contentValues = new ContentValues();
            contentValues.put("pkgname", packageName);
            contentValues.put(PhoneWindowManager.SYSTEM_DIALOG_REASON_KEY, reason);
            contentValues.put("date", Long.valueOf(System.currentTimeMillis()));
            this.mNs.publishEvent(2, contentValues);
        }
        return didSomething;
    }

    private final ProcessRecord removeProcessNameLocked(String name, int uid) {
        return removeProcessNameLocked(name, uid, null);
    }

    private final ProcessRecord removeProcessNameLocked(String name, int uid, ProcessRecord expecting) {
        ProcessRecord old = (ProcessRecord) this.mProcessNames.get(name, uid);
        if (expecting == null || old == expecting) {
            this.mProcessNames.remove(name, uid);
        }
        if (!(old == null || old.uidRecord == null)) {
            UidRecord uidRecord = old.uidRecord;
            uidRecord.numProcs--;
            if (old.uidRecord.numProcs == 0) {
                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                    Slog.i(TAG_UID_OBSERVERS, "No more processes in " + old.uidRecord);
                }
                enqueueUidChangeLocked(old.uidRecord, -1, 1);
                EventLogTags.writeAmUidStopped(uid);
                this.mActiveUids.remove(uid);
                noteUidProcessState(uid, 18);
            }
            old.uidRecord = null;
        }
        this.mIsolatedProcesses.remove(uid);
        return old;
    }

    private final void addProcessNameLocked(ProcessRecord proc) {
        ProcessRecord old = removeProcessNameLocked(proc.processName, proc.uid);
        if (old == proc && proc.persistent) {
            Slog.w(TAG, "Re-adding persistent process " + proc);
        } else if (old != null) {
            Slog.wtf(TAG, "Already have existing proc " + old + " when adding " + proc);
        }
        UidRecord uidRec = (UidRecord) this.mActiveUids.get(proc.uid);
        if (uidRec == null) {
            uidRec = new UidRecord(proc.uid);
            if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                Slog.i(TAG_UID_OBSERVERS, "Creating new process uid: " + uidRec);
            }
            if (Arrays.binarySearch(this.mDeviceIdleTempWhitelist, UserHandle.getAppId(proc.uid)) >= 0 || this.mPendingTempWhitelist.indexOfKey(proc.uid) >= 0) {
                uidRec.curWhitelist = true;
                uidRec.setWhitelist = true;
            }
            uidRec.updateHasInternetPermission();
            this.mActiveUids.put(proc.uid, uidRec);
            EventLogTags.writeAmUidRunning(uidRec.uid);
            noteUidProcessState(uidRec.uid, uidRec.curProcState);
        }
        proc.uidRecord = uidRec;
        proc.renderThreadTid = 0;
        uidRec.numProcs++;
        this.mProcessNames.put(proc.processName, proc.uid, proc);
        if (proc.isolated) {
            this.mIsolatedProcesses.put(proc.uid, proc);
        }
    }

    boolean removeProcessLocked(ProcessRecord app, boolean callerWillRestart, boolean allowRestart, String reason) {
        String name = app.processName;
        int uid = app.uid;
        if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
            Slog.d(TAG_PROCESSES, "Force removing proc " + app.toShortString() + " (" + name + "/" + uid + ")");
        }
        if (((ProcessRecord) this.mProcessNames.get(name, uid)) != app) {
            Slog.w(TAG, "Ignoring remove of inactive process: " + app);
            return false;
        }
        removeProcessNameLocked(name, uid);
        if (this.mHeavyWeightProcess == app) {
            this.mHandler.sendMessage(this.mHandler.obtainMessage(25, this.mHeavyWeightProcess.userId, 0));
            this.mHeavyWeightProcess = null;
        }
        boolean needRestart = false;
        if (app.pid <= 0 || app.pid == MY_PID) {
            this.mRemovedProcesses.add(app);
        } else {
            int pid = app.pid;
            synchronized (this.mPidsSelfLocked) {
                this.mPidsSelfLocked.remove(pid);
                this.mHandler.removeMessages(20, app);
            }
            this.mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);
            boolean willRestart = false;
            if (app.persistent && (app.isolated ^ 1) != 0) {
                if (callerWillRestart) {
                    needRestart = true;
                } else {
                    willRestart = true;
                }
            }
            if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get("oppo.clear.running", "0"))) {
                app.oppoClearProcess(reason, true);
            } else {
                app.kill(reason, true);
            }
            if (app.isolated) {
                this.mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);
                getPackageManagerInternalLocked().removeIsolatedUid(app.uid);
            }
            handleAppDiedLocked(app, willRestart, allowRestart);
            if (willRestart) {
                removeLruProcessLocked(app);
                addAppLocked(app.info, null, false, null);
            }
        }
        return needRestart;
    }

    private final void processContentProviderPublishTimedOutLocked(ProcessRecord app) {
        cleanupAppInLaunchingProvidersLocked(app, true);
        removeProcessLocked(app, false, true, "timeout publishing content providers");
    }

    private final void processStartTimedOutLocked(final ProcessRecord app) {
        int pid = app.pid;
        boolean gone = false;
        synchronized (this.mPidsSelfLocked) {
            ProcessRecord knownApp = (ProcessRecord) this.mPidsSelfLocked.get(pid);
            if (knownApp != null && knownApp.thread == null) {
                this.mPidsSelfLocked.remove(pid);
                gone = true;
            }
        }
        if (gone) {
            Slog.w(TAG, "Process " + app + " failed to attach");
            EventLog.writeEvent(EventLogTags.AM_PROCESS_START_TIMEOUT, new Object[]{Integer.valueOf(app.userId), Integer.valueOf(pid), Integer.valueOf(app.uid), app.processName});
            removeProcessNameLocked(app.processName, app.uid);
            if (this.mHeavyWeightProcess == app) {
                this.mHandler.sendMessage(this.mHandler.obtainMessage(25, this.mHeavyWeightProcess.userId, 0));
                this.mHeavyWeightProcess = null;
            }
            this.mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);
            cleanupAppInLaunchingProvidersLocked(app, true);
            this.mServices.processStartTimedOutLocked(app);
            app.kill("start timeout", true);
            if (app.isolated) {
                this.mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);
            }
            removeLruProcessLocked(app);
            if (this.mBackupTarget != null && this.mBackupTarget.app.pid == pid) {
                Slog.w(TAG, "Unattached app died before backup, skipping");
                this.mHandler.post(new Runnable() {
                    public void run() {
                        try {
                            IBackupManager.Stub.asInterface(ServiceManager.getService("backup")).agentDisconnected(app.info.packageName);
                        } catch (RemoteException e) {
                        }
                    }
                });
            }
            if (isPendingBroadcastProcessLocked(pid)) {
                Slog.w(TAG, "Unattached app died before broadcast acknowledged, skipping");
                skipPendingBroadcastLocked(pid);
            }
            restartAfterStartTimeout(app.processName);
            return;
        }
        Slog.w(TAG, "Spurious process start timeout - pid not known for " + app);
    }

    private final boolean attachApplicationLocked(IApplicationThread thread, int pid) {
        ProcessRecord app;
        long startTime = SystemClock.uptimeMillis();
        if (pid == MY_PID || pid < 0) {
            app = null;
        } else {
            synchronized (this.mPidsSelfLocked) {
                app = (ProcessRecord) this.mPidsSelfLocked.get(pid);
            }
        }
        if (app == null) {
            Slog.w(TAG, "No pending application record for pid " + pid + " (IApplicationThread " + thread + "); dropping process");
            EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS, pid);
            if (pid <= 0 || pid == MY_PID) {
                try {
                    thread.scheduleExit();
                } catch (Exception e) {
                }
            } else {
                Process.killProcessQuiet(pid);
            }
            return false;
        }
        if (app.thread != null) {
            handleAppDiedLocked(app, true, true);
        }
        String processName = app.processName;
        try {
            AppDeathRecipient appDeathRecipient = new AppDeathRecipient(app, pid, thread);
            thread.asBinder().linkToDeath(appDeathRecipient, 0);
            app.deathRecipient = appDeathRecipient;
            EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, new Object[]{Integer.valueOf(app.userId), Integer.valueOf(app.pid), app.processName});
            app.makeActive(thread, this.mProcessStats);
            app.verifiedAdj = -10000;
            app.setAdj = -10000;
            app.curAdj = -10000;
            app.setSchedGroup = 1;
            app.curSchedGroup = 1;
            app.forcingToImportant = null;
            updateProcessForegroundLocked(app, false, false);
            app.hasShownUi = false;
            app.debugging = false;
            app.cached = false;
            app.killedByAm = false;
            app.killed = false;
            app.unlocked = StorageManager.isUserKeyUnlocked(app.userId);
            this.mHandler.removeMessages(20, app);
            int normalMode = !this.mProcessesReady ? isAllowedWhileBooting(app.info) : 1;
            List providers = normalMode != 0 ? generateApplicationProvidersLocked(app) : null;
            if (providers != null && checkAppInLaunchingProvidersLocked(app)) {
                Message msg = this.mHandler.obtainMessage(57);
                msg.obj = app;
                this.mHandler.sendMessageDelayed(msg, 10000);
            }
            checkTime(startTime, "attachApplicationLocked: before bindApplication");
            if (normalMode == 0) {
                Slog.i(TAG, "Launching preboot mode app: " + app);
            }
            int testMode = 0;
            try {
                if (this.mDebugApp != null && this.mDebugApp.equals(processName)) {
                    if (this.mWaitForDebugger) {
                        testMode = 2;
                    } else {
                        testMode = 1;
                    }
                    app.debugging = true;
                    if (this.mDebugTransient) {
                        this.mDebugApp = this.mOrigDebugApp;
                        this.mWaitForDebugger = this.mOrigWaitForDebugger;
                    }
                }
                ProfilerInfo profilerInfo = null;
                String agent = null;
                if (this.mProfileApp != null && this.mProfileApp.equals(processName)) {
                    this.mProfileProc = app;
                    profilerInfo = (this.mProfilerInfo == null || this.mProfilerInfo.profileFile == null) ? null : new ProfilerInfo(this.mProfilerInfo);
                    agent = this.mProfilerInfo != null ? this.mProfilerInfo.agent : null;
                } else if (!(app.instr == null || app.instr.mProfileFile == null)) {
                    profilerInfo = new ProfilerInfo(app.instr.mProfileFile, null, 0, false, false, null);
                }
                boolean enableTrackAllocation = false;
                if (this.mTrackAllocationApp != null && this.mTrackAllocationApp.equals(processName)) {
                    enableTrackAllocation = true;
                    this.mTrackAllocationApp = null;
                }
                boolean isRestrictedBackupMode = false;
                if (this.mBackupTarget != null && this.mBackupAppName.equals(processName)) {
                    isRestrictedBackupMode = this.mBackupTarget.appInfo.uid >= 10000 ? (this.mBackupTarget.backupMode == 2 || this.mBackupTarget.backupMode == 3) ? true : this.mBackupTarget.backupMode == 1 : false;
                    if (ActivityManagerDebugConfig.DEBUG_PROVIDER || ActivityManagerDebugConfig.DEBUG_AMS) {
                        Slog.d(TAG_PROVIDER, "isRestrictedBackupMode " + isRestrictedBackupMode + " processName " + processName);
                    }
                }
                if (app.instr != null) {
                    notifyPackageUse(app.instr.mClass.getPackageName(), 7);
                }
                if (ActivityManagerDebugConfig.DEBUG_CONFIGURATION) {
                    Slog.v(TAG_CONFIGURATION, "Binding proc " + processName + " with config " + getGlobalConfiguration());
                }
                ApplicationInfo appInfo = app.instr != null ? app.instr.mTargetInfo : app.info;
                app.compat = compatibilityInfoForPackageLocked(appInfo);
                if (!(profilerInfo == null || profilerInfo.profileFd == null)) {
                    profilerInfo.profileFd = profilerInfo.profileFd.dup();
                }
                String buildSerial = appInfo.targetSandboxVersion < 2 ? sTheRealBuildSerial : Shell.NIGHT_MODE_STR_UNKNOWN;
                if (this.mActiveInstrumentation.size() > 0 && app.instr == null) {
                    for (int i = this.mActiveInstrumentation.size() - 1; i >= 0 && app.instr == null; i--) {
                        ActiveInstrumentation aInstr = (ActiveInstrumentation) this.mActiveInstrumentation.get(i);
                        if (!aInstr.mFinished && aInstr.mTargetInfo.uid == app.uid) {
                            if (aInstr.mTargetProcesses.length != 0) {
                                for (String proc : aInstr.mTargetProcesses) {
                                    if (proc.equals(app.processName)) {
                                        app.instr = aInstr;
                                        aInstr.mRunningProcesses.add(app);
                                        break;
                                    }
                                }
                            } else if (aInstr.mTargetInfo.packageName.equals(app.info.packageName)) {
                                app.instr = aInstr;
                                aInstr.mRunningProcesses.add(app);
                            }
                        }
                    }
                }
                if (agent != null) {
                    thread.attachAgent(agent);
                }
                checkTime(startTime, "attachApplicationLocked: immediately before bindApplication");
                this.mStackSupervisor.mActivityMetricsLogger.notifyBindApplication(app);
                if (app.killed || app.killedInInitStatus) {
                    Slog.w(TAG, "app has been killed, we skip call bindApplication and return, app:" + app + " app.killed:" + app.killed + " app.killedInInitStatus:" + app.killedInInitStatus);
                    return false;
                }
                if (app.instr != null) {
                    thread.bindApplication(processName, appInfo, providers, app.instr.mClass, profilerInfo, app.instr.mArguments, app.instr.mWatcher, app.instr.mUiAutomationConnection, testMode, this.mBinderTransactionTrackingEnabled, enableTrackAllocation, !isRestrictedBackupMode ? normalMode ^ 1 : true, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), this.mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial);
                } else {
                    thread.bindApplication(processName, appInfo, providers, null, profilerInfo, null, null, null, testMode, this.mBinderTransactionTrackingEnabled, enableTrackAllocation, !isRestrictedBackupMode ? normalMode ^ 1 : true, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), this.mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial);
                }
                checkTime(startTime, "attachApplicationLocked: immediately after bindApplication");
                updateLruProcessLocked(app, false, null);
                checkTime(startTime, "attachApplicationLocked: after updateLruProcessLocked");
                long uptimeMillis = SystemClock.uptimeMillis();
                app.lastLowMemory = uptimeMillis;
                app.lastRequestedGc = uptimeMillis;
                if (isImportantPersistProc(processName)) {
                    Slog.i(TAG, "attachApplicationLocked for proc:" + processName + " with pid:" + app.pid);
                }
                this.mPersistentStartingProcesses.remove(app);
                if (ActivityManagerDebugConfig.DEBUG_PROCESSES && this.mProcessesOnHold.contains(app)) {
                    Slog.v(TAG_PROCESSES, "Attach application locked removing on hold: " + app);
                }
                this.mProcessesOnHold.remove(app);
                boolean badApp = false;
                boolean didSomething = false;
                if (normalMode != 0) {
                    try {
                        if (this.mStackSupervisor.attachApplicationLocked(app)) {
                            didSomething = true;
                        }
                    } catch (Throwable e2) {
                        Slog.wtf(TAG, "Exception thrown launching activities in " + app, e2);
                        badApp = true;
                    }
                }
                if (!badApp) {
                    try {
                        if (ActivityManagerDebugConfig.DEBUG_SERVICE) {
                            Slog.v(TAG, "mServices.attachApplicationLocked app " + app + " thread=" + thread.asBinder() + " pid=" + pid);
                        }
                        didSomething |= this.mServices.attachApplicationLocked(app, processName);
                        checkTime(startTime, "attachApplicationLocked: after mServices.attachApplicationLocked");
                    } catch (Throwable e22) {
                        Slog.wtf(TAG, "Exception thrown starting services in " + app, e22);
                        badApp = true;
                    }
                }
                if (!badApp && isPendingBroadcastProcessLocked(pid)) {
                    try {
                        if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                            Slog.v(TAG, "sendPendingBroadcastsLocked app " + app + " thread=" + thread.asBinder() + " pid=" + pid);
                        }
                        didSomething |= sendPendingBroadcastsLocked(app);
                        checkTime(startTime, "attachApplicationLocked: after sendPendingBroadcastsLocked");
                    } catch (Throwable e222) {
                        Slog.v(TAG, "Exception thrown dispatching broadcasts in " + app, e222);
                        badApp = true;
                    }
                }
                if (!(badApp || this.mBackupTarget == null || this.mBackupTarget.app != app)) {
                    if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
                        Slog.v(TAG_BACKUP, "New app is backup target, launching agent for " + app);
                    }
                    notifyPackageUse(this.mBackupTarget.appInfo.packageName, 5);
                    try {
                        thread.scheduleCreateBackupAgent(this.mBackupTarget.appInfo, compatibilityInfoForPackageLocked(this.mBackupTarget.appInfo), this.mBackupTarget.backupMode);
                    } catch (Throwable e2222) {
                        Slog.wtf(TAG, "Exception thrown creating backup agent in " + app, e2222);
                        badApp = true;
                    }
                }
                if (badApp) {
                    app.kill("error during init", true);
                    handleAppDiedLocked(app, false, true);
                    return false;
                }
                if (!didSomething) {
                    updateOomAdjLocked();
                    checkTime(startTime, "attachApplicationLocked: after updateOomAdjLocked");
                }
                return true;
            } catch (Throwable e22222) {
                Slog.wtf(TAG, "Exception thrown during bind of " + app, e22222);
                app.resetPackageList(this.mProcessStats);
                app.unlinkDeathRecipient();
                startProcessLocked(app, "bind fail", processName);
                return false;
            }
        } catch (RemoteException e3) {
            app.resetPackageList(this.mProcessStats);
            startProcessLocked(app, "link fail", processName);
            return false;
        }
    }

    public final void attachApplication(IApplicationThread thread) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int callingPid = Binder.getCallingPid();
                long origId = Binder.clearCallingIdentity();
                attachApplicationLocked(thread, callingPid);
                Binder.restoreCallingIdentity(origId);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) {
        long origId = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (ActivityRecord.getStackLocked(token) != null) {
                    ActivityRecord r = this.mStackSupervisor.activityIdleInternalLocked(token, false, false, config);
                    if (stopProfiling && this.mProfileProc == r.app && this.mProfilerInfo != null) {
                        clearProfilerLocked();
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        Binder.restoreCallingIdentity(origId);
    }

    void postFinishBooting(boolean finishBooting, boolean enableScreen) {
        int i;
        int i2 = 1;
        MainHandler mainHandler = this.mHandler;
        MainHandler mainHandler2 = this.mHandler;
        if (finishBooting) {
            i = 1;
        } else {
            i = 0;
        }
        if (!enableScreen) {
            i2 = 0;
        }
        mainHandler.sendMessage(mainHandler2.obtainMessage(FINISH_BOOTING_MSG, i, i2));
    }

    void enableScreenAfterBoot() {
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_ENABLE_SCREEN, SystemClock.uptimeMillis());
        this.mWindowManager.enableScreenAfterBoot();
        NeuronSystemService.recordBootPhase("ENABLE_SCREEN", SystemClock.uptimeMillis());
        if (this.mNs != null) {
            this.mNs.writeBootPhaseToDb();
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                updateEventDispatchingLocked();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void showBootMessage(CharSequence msg, boolean always) {
        if (Binder.getCallingUid() != Process.myUid()) {
            throw new SecurityException();
        } else if (this.mWindowManager != null) {
            this.mWindowManager.showBootMessage(msg, always);
        }
    }

    public void keyguardGoingAway(int flags) {
        enforceNotIsolatedCaller("keyguardGoingAway");
        long token = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                this.mKeyguardController.keyguardGoingAway(flags);
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(token);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(token);
        }
    }

    boolean isKeyguardLocked() {
        return this.mKeyguardController.isKeyguardLocked();
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    final void finishBooting() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (this.mBootAnimationComplete) {
                    this.mCallFinishBooting = false;
                } else {
                    this.mCallFinishBooting = true;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        this.mStackSupervisor.createPreloadStack();
        OppoMultiAppManager.getInstance().setAms(this);
        return;
        return;
        completedIsas.add(instructionSet);
        int i++;
    }

    private boolean isDoingDexopt(int uid) {
        if (uid <= 0) {
            return false;
        }
        boolean isDoingDexoptLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                isDoingDexoptLocked = isDoingDexoptLocked(uid);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return isDoingDexoptLocked;
    }

    private boolean isDoingDexoptLocked(int uid) {
        if (this.mDexOptTimeMap == null || !this.mDexOptTimeMap.containsKey(Integer.valueOf(uid))) {
            return false;
        }
        long lastDexoptTime = ((Long) this.mDexOptTimeMap.get(Integer.valueOf(uid))).longValue();
        long tmp = System.currentTimeMillis() - lastDexoptTime;
        Slog.w(TAG, "isDoingDexoptLocked, lastDexoptTime = " + lastDexoptTime + ", cost = " + tmp + " ms");
        if (tmp < APP_DEXOPT_TIMEOUT) {
            return true;
        }
        return false;
    }

    public void appDexOpt(boolean start) {
        int uid = Binder.getCallingUid();
        if (Binder.getCallingUid() >= 10000) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (start) {
                        appDexOptAddLocked(uid);
                    } else {
                        appDexOptRemoveLocked(uid);
                    }
                    if (this.mHyp == null) {
                        this.mHyp = Hypnus.getHypnus();
                    }
                    if (start) {
                        this.dexStart = true;
                        this.mHyp.hypnusSetAction(15, 20000);
                    } else if (this.dexStart) {
                        this.dexStart = false;
                        this.mHyp.hypnusSetAction(15, 0);
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        }
    }

    private void appDexOptRemoveLocked(int uid) {
        if (this.mDexOptTimeMap != null && this.mDexOptTimeMap.containsKey(Integer.valueOf(uid))) {
            this.mDexOptTimeMap.remove(Integer.valueOf(uid));
            if (ActivityManagerDebugConfig.DEBUG_AMS) {
                Slog.w(TAG, "Finish dexopt: " + uid);
            }
        }
    }

    private void appDexOptAddLocked(int uid) {
        if (this.mDexOptTimeMap != null) {
            this.mDexOptTimeMap.remove(Integer.valueOf(uid));
            if (ActivityManagerDebugConfig.DEBUG_AMS) {
                Slog.w(TAG, "Start dexopt: " + uid);
            }
            this.mDexOptTimeMap.put(Integer.valueOf(uid), Long.valueOf(System.currentTimeMillis()));
        }
    }

    private void noticeHypnusBootCompleted() {
        if (this.mHyp == null) {
            this.mHyp = Hypnus.getHypnus();
        }
        if (this.mHyp != null) {
            this.mHyp.hypnusSendBootComplete();
            this.mHyp.hypnusSetAction(12, OppoBrightUtils.HIGH_BRIGHTNESS_MAX_LUX);
        }
    }

    public void bootAnimationComplete() {
        boolean callFinishBooting;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                callFinishBooting = this.mCallFinishBooting;
                this.mBootAnimationComplete = true;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        if (callFinishBooting) {
            Trace.traceBegin(64, "FinishBooting");
            finishBooting();
            Trace.traceEnd(64);
        }
    }

    public void reportJunkFromApp(String type, String packageName, String content, boolean forcePersist) {
        if (forcePersist) {
            OppoJunkRecorder.getInstance().forcePersist(System.currentTimeMillis());
        } else {
            OppoJunkRecorder.getInstance().reportJunkEvent(type, packageName, content);
        }
    }

    final void ensureBootCompleted() {
        boolean booting;
        boolean enableScreen;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                booting = this.mBooting;
                this.mBooting = false;
                enableScreen = this.mBooted ^ 1;
                this.mBooted = true;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        if (booting) {
            Trace.traceBegin(64, "FinishBooting");
            finishBooting();
            Trace.traceEnd(64);
        }
        if (enableScreen) {
            enableScreenAfterBoot();
        }
    }

    public final void activityResumed(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord.activityResumedLocked(token);
                this.mWindowManager.notifyAppResumedFinished(token);
                ActivityRecord r = ActivityRecord.forTokenLocked(token);
                if (!(r == null || r.app == null || r.app.info == null)) {
                    OppoAppStartInfo crashCount = (OppoAppStartInfo) OppoCrashClearManager.getInstance().mProcessCrashCount.get(r.app.info.processName);
                    if (crashCount != null) {
                        crashCount.setFirstStartTime(-1);
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        Binder.restoreCallingIdentity(origId);
    }

    public final void activityPaused(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                if (stack != null) {
                    stack.activityPausedLocked(token, false);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        Binder.restoreCallingIdentity(origId);
    }

    public final void activityStopped(IBinder token, Bundle icicle, PersistableBundle persistentState, CharSequence description) {
        if (icicle == null || !icicle.hasFileDescriptors()) {
            long origId = Binder.clearCallingIdentity();
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    ActivityRecord r = ActivityRecord.isInStackLocked(token);
                    if (r != null) {
                        r.activityStoppedLocked(icicle, persistentState, description);
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            trimApplications();
            Binder.restoreCallingIdentity(origId);
            return;
        }
        throw new IllegalArgumentException("File descriptors passed in Bundle");
    }

    public final void activityDestroyed(IBinder token) {
        if (ActivityManagerDebugConfig.DEBUG_SWITCH) {
            Slog.v(TAG_SWITCH, "ACTIVITY DESTROYED: " + token);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                if (stack != null) {
                    stack.activityDestroyedLocked(token, "activityDestroyed");
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public final void activityRelaunched(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mStackSupervisor.activityRelaunchedLocked(token);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        Binder.restoreCallingIdentity(origId);
    }

    public void reportSizeConfigurations(IBinder token, int[] horizontalSizeConfiguration, int[] verticalSizeConfigurations, int[] smallestSizeConfigurations) {
        if (ActivityManagerDebugConfig.DEBUG_CONFIGURATION) {
            Slog.v(TAG, "Report configuration: " + token + " " + horizontalSizeConfiguration + " " + verticalSizeConfigurations);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord record = ActivityRecord.isInStackLocked(token);
                if (record == null) {
                    throw new IllegalArgumentException("reportSizeConfigurations: ActivityRecord not found for: " + token);
                }
                record.setSizeConfigurations(horizontalSizeConfiguration, verticalSizeConfigurations, smallestSizeConfigurations);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public final void notifyLaunchTaskBehindComplete(IBinder token) {
        this.mStackSupervisor.scheduleLaunchTaskBehindComplete(token);
    }

    public final void notifyEnterAnimationComplete(IBinder token) {
        this.mHandler.sendMessage(this.mHandler.obtainMessage(44, token));
    }

    public String getCallingPackage(IBinder token) {
        String str = null;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = getCallingRecordLocked(token);
                if (r != null) {
                    str = r.info.packageName;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return str;
    }

    public ComponentName getCallingActivity(IBinder token) {
        ComponentName componentName = null;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = getCallingRecordLocked(token);
                if (r != null) {
                    componentName = r.intent.getComponent();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return componentName;
    }

    private ActivityRecord getCallingRecordLocked(IBinder token) {
        ActivityRecord r = ActivityRecord.isInStackLocked(token);
        if (r == null) {
            return null;
        }
        return r.resultTo;
    }

    public ComponentName getActivityClassForToken(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                } else {
                    ComponentName component = r.intent.getComponent();
                    resetPriorityAfterLockedSection();
                    return component;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return null;
    }

    public String getPackageForToken(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                } else {
                    String str = r.packageName;
                    resetPriorityAfterLockedSection();
                    return str;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return null;
    }

    public boolean isRootVoiceInteraction(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    boolean z = r.rootVoiceInteraction;
                    resetPriorityAfterLockedSection();
                    return z;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return false;
    }

    public IIntentSender getIntentSender(int type, String packageName, IBinder token, String resultWho, int requestCode, Intent[] intents, String[] resolvedTypes, int flags, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller("getIntentSender");
        if (intents != null) {
            if (intents.length < 1) {
                throw new IllegalArgumentException("Intents array length must be >= 1");
            }
            for (int i = 0; i < intents.length; i++) {
                Intent intent = intents[i];
                if (intent != null) {
                    if (intent.hasFileDescriptors()) {
                        throw new IllegalArgumentException("File descriptors passed in Intent");
                    } else if (type != 1 || (intent.getFlags() & PhoneWindowManager.SYSTEM_UI_FLAG_APP_CUSTOM_NAVIGATION_BAR) == 0) {
                        intents[i] = new Intent(intent);
                    } else {
                        throw new IllegalArgumentException("Can't use FLAG_RECEIVER_BOOT_UPGRADE here");
                    }
                }
            }
            if (!(resolvedTypes == null || resolvedTypes.length == intents.length)) {
                throw new IllegalArgumentException("Intent array length does not match resolvedTypes length");
            }
        }
        if (bOptions == null || !bOptions.hasFileDescriptors()) {
            IIntentSender intentSenderLocked;
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    int callingUid = Binder.getCallingUid();
                    int origUserId = userId;
                    userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), callingUid, userId, type == 1, 0, "getIntentSender", null);
                    if (origUserId == -2) {
                        userId = -2;
                    }
                    if (!(callingUid == 0 || callingUid == 1000)) {
                        int uid = AppGlobals.getPackageManager().getPackageUid(packageName, 268435456, UserHandle.getUserId(callingUid));
                        if (!UserHandle.isSameApp(callingUid, uid)) {
                            String msg = "Permission Denial: getIntentSender() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + ", (need uid=" + uid + ")" + " is not allowed to send as package " + packageName;
                            Slog.w(TAG, msg);
                            throw new SecurityException(msg);
                        }
                    }
                    intentSenderLocked = getIntentSenderLocked(type, packageName, callingUid, userId, token, resultWho, requestCode, intents, resolvedTypes, flags, bOptions);
                } catch (Throwable e) {
                    throw new SecurityException(e);
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                }
            }
            resetPriorityAfterLockedSection();
            return intentSenderLocked;
        }
        throw new IllegalArgumentException("File descriptors passed in options");
    }

    IIntentSender getIntentSenderLocked(int type, String packageName, int callingUid, int userId, IBinder token, String resultWho, int requestCode, Intent[] intents, String[] resolvedTypes, int flags, Bundle bOptions) {
        if (ActivityManagerDebugConfig.DEBUG_MU) {
            Slog.v(TAG_MU, "getIntentSenderLocked(): uid=" + callingUid);
        }
        ActivityRecord activity = null;
        if (type == 3) {
            activity = ActivityRecord.isInStackLocked(token);
            if (activity == null) {
                Slog.w(TAG, "Failed createPendingResult: activity " + token + " not in any stack");
                return null;
            } else if (activity.finishing) {
                Slog.w(TAG, "Failed createPendingResult: activity " + activity + " is finishing");
                return null;
            }
        }
        if (intents != null) {
            for (Intent defusable : intents) {
                defusable.setDefusable(true);
            }
        }
        Bundle.setDefusable(bOptions, true);
        boolean noCreate = (536870912 & flags) != 0;
        boolean cancelCurrent = (268435456 & flags) != 0;
        boolean updateCurrent = (134217728 & flags) != 0;
        Key key = new Key(type, packageName, activity, resultWho, requestCode, intents, resolvedTypes, flags & -939524097, bOptions, userId);
        WeakReference<PendingIntentRecord> ref = (WeakReference) this.mIntentSenderRecords.get(key);
        IIntentSender rec = ref != null ? (PendingIntentRecord) ref.get() : null;
        if (rec != null) {
            if (cancelCurrent) {
                makeIntentSenderCanceledLocked(rec);
                this.mIntentSenderRecords.remove(key);
            } else {
                if (updateCurrent) {
                    if (rec.key.requestIntent != null) {
                        rec.key.requestIntent.replaceExtras(intents != null ? intents[intents.length - 1] : null);
                    }
                    if (intents != null) {
                        intents[intents.length - 1] = rec.key.requestIntent;
                        rec.key.allIntents = intents;
                        rec.key.allResolvedTypes = resolvedTypes;
                    } else {
                        rec.key.allIntents = null;
                        rec.key.allResolvedTypes = null;
                    }
                }
                return rec;
            }
        }
        if (noCreate) {
            return rec;
        }
        PendingIntentRecord pendingIntentRecord = new PendingIntentRecord(this, key, callingUid);
        this.mIntentSenderRecords.put(key, pendingIntentRecord.ref);
        if (type == 3) {
            if (activity.pendingResults == null) {
                activity.pendingResults = new HashSet();
            }
            activity.pendingResults.add(pendingIntentRecord.ref);
        }
        return pendingIntentRecord;
    }

    public int sendIntentSender(IIntentSender target, IBinder whitelistToken, int code, Intent intent, String resolvedType, IIntentReceiver finishedReceiver, String requiredPermission, Bundle options) {
        if (target instanceof PendingIntentRecord) {
            return ((PendingIntentRecord) target).sendWithResult(code, intent, resolvedType, whitelistToken, finishedReceiver, requiredPermission, options);
        }
        if (intent == null) {
            Slog.wtf(TAG, "Can't use null intent with direct IIntentSender call");
            intent = new Intent("android.intent.action.MAIN");
        }
        try {
            target.send(code, intent, resolvedType, whitelistToken, null, requiredPermission, options);
        } catch (RemoteException e) {
        }
        if (finishedReceiver != null) {
            try {
                finishedReceiver.performReceive(intent, 0, null, null, false, false, UserHandle.getCallingUserId());
            } catch (RemoteException e2) {
            }
        }
        return 0;
    }

    public void cancelIntentSender(IIntentSender sender) {
        if (sender instanceof PendingIntentRecord) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    PendingIntentRecord rec = (PendingIntentRecord) sender;
                    if (UserHandle.isSameApp(AppGlobals.getPackageManager().getPackageUid(rec.key.packageName, 268435456, UserHandle.getCallingUserId()), Binder.getCallingUid())) {
                        cancelIntentSenderLocked(rec, true);
                    } else {
                        String msg = "Permission Denial: cancelIntentSender() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " is not allowed to cancel package " + rec.key.packageName;
                        Slog.w(TAG, msg);
                        throw new SecurityException(msg);
                    }
                } catch (RemoteException e) {
                    throw new SecurityException(e);
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                }
            }
            resetPriorityAfterLockedSection();
        }
    }

    void cancelIntentSenderLocked(PendingIntentRecord rec, boolean cleanActivity) {
        makeIntentSenderCanceledLocked(rec);
        this.mIntentSenderRecords.remove(rec.key);
        if (cleanActivity && rec.key.activity != null) {
            rec.key.activity.pendingResults.remove(rec.ref);
        }
    }

    void makeIntentSenderCanceledLocked(PendingIntentRecord rec) {
        rec.canceled = true;
        RemoteCallbackList<IResultReceiver> callbacks = rec.detachCancelListenersLocked();
        if (callbacks != null) {
            this.mHandler.obtainMessage(67, callbacks).sendToTarget();
        }
    }

    public String getPackageForIntentSender(IIntentSender pendingResult) {
        if (!(pendingResult instanceof PendingIntentRecord)) {
            return null;
        }
        try {
            return ((PendingIntentRecord) pendingResult).key.packageName;
        } catch (ClassCastException e) {
            return null;
        }
    }

    public void registerIntentSenderCancelListener(IIntentSender sender, IResultReceiver receiver) {
        if (sender instanceof PendingIntentRecord) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    ((PendingIntentRecord) sender).registerCancelListenerLocked(receiver);
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        }
    }

    public void unregisterIntentSenderCancelListener(IIntentSender sender, IResultReceiver receiver) {
        if (sender instanceof PendingIntentRecord) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    ((PendingIntentRecord) sender).unregisterCancelListenerLocked(receiver);
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        }
    }

    public int getUidForIntentSender(IIntentSender sender) {
        if (sender instanceof PendingIntentRecord) {
            try {
                return ((PendingIntentRecord) sender).uid;
            } catch (ClassCastException e) {
            }
        }
        return -1;
    }

    public boolean isIntentSenderTargetedToPackage(IIntentSender pendingResult) {
        if (!(pendingResult instanceof PendingIntentRecord)) {
            return false;
        }
        try {
            PendingIntentRecord res = (PendingIntentRecord) pendingResult;
            if (res.key.allIntents == null) {
                return false;
            }
            for (Intent intent : res.key.allIntents) {
                if (intent.getPackage() != null && intent.getComponent() != null) {
                    return false;
                }
            }
            return true;
        } catch (ClassCastException e) {
            return false;
        }
    }

    public boolean isIntentSenderAnActivity(IIntentSender pendingResult) {
        if (!(pendingResult instanceof PendingIntentRecord)) {
            return false;
        }
        try {
            if (((PendingIntentRecord) pendingResult).key.type == 2) {
                return true;
            }
            return false;
        } catch (ClassCastException e) {
            return false;
        }
    }

    public Intent getIntentForIntentSender(IIntentSender pendingResult) {
        enforceCallingPermission("android.permission.GET_INTENT_SENDER_INTENT", "getIntentForIntentSender()");
        if (!(pendingResult instanceof PendingIntentRecord)) {
            return null;
        }
        try {
            PendingIntentRecord res = (PendingIntentRecord) pendingResult;
            return res.key.requestIntent != null ? new Intent(res.key.requestIntent) : null;
        } catch (ClassCastException e) {
            return null;
        }
    }

    public String getTagForIntentSender(IIntentSender pendingResult, String prefix) {
        if (!(pendingResult instanceof PendingIntentRecord)) {
            return null;
        }
        try {
            String tagForIntentSenderLocked;
            PendingIntentRecord res = (PendingIntentRecord) pendingResult;
            synchronized (this) {
                boostPriorityForLockedSection();
                tagForIntentSenderLocked = getTagForIntentSenderLocked(res, prefix);
            }
            resetPriorityAfterLockedSection();
            return tagForIntentSenderLocked;
        } catch (ClassCastException e) {
            return null;
        } catch (Throwable th) {
            resetPriorityAfterLockedSection();
        }
    }

    String getTagForIntentSenderLocked(PendingIntentRecord res, String prefix) {
        Intent intent = res.key.requestIntent;
        if (intent == null) {
            return null;
        }
        if (res.lastTag != null && res.lastTagPrefix == prefix && (res.lastTagPrefix == null || res.lastTagPrefix.equals(prefix))) {
            return res.lastTag;
        }
        res.lastTagPrefix = prefix;
        StringBuilder sb = new StringBuilder(128);
        if (prefix != null) {
            sb.append(prefix);
        }
        if (intent.getAction() != null) {
            sb.append(intent.getAction());
        } else if (intent.getComponent() != null) {
            intent.getComponent().appendShortString(sb);
        } else {
            sb.append("?");
        }
        String stringBuilder = sb.toString();
        res.lastTag = stringBuilder;
        return stringBuilder;
    }

    public void setProcessLimit(int max) {
        enforceCallingPermission("android.permission.SET_PROCESS_LIMIT", "setProcessLimit()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mConstants.setOverrideMaxCachedProcesses(max);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        trimApplications();
    }

    public int getProcessLimit() {
        int overrideMaxCachedProcesses;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                overrideMaxCachedProcesses = this.mConstants.getOverrideMaxCachedProcesses();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return overrideMaxCachedProcesses;
    }

    void importanceTokenDied(ImportanceToken token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    if (((ImportanceToken) this.mImportantProcesses.get(token.pid)) == token) {
                        this.mImportantProcesses.remove(token.pid);
                        ProcessRecord pr = (ProcessRecord) this.mPidsSelfLocked.get(token.pid);
                        if (pr == null) {
                            resetPriorityAfterLockedSection();
                            return;
                        }
                        pr.forcingToImportant = null;
                        updateProcessForegroundLocked(pr, false, false);
                        updateOomAdjLocked();
                        resetPriorityAfterLockedSection();
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void setProcessImportant(IBinder token, int pid, boolean isForeground, String reason) {
        enforceCallingPermission("android.permission.SET_PROCESS_LIMIT", "setProcessImportant()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                boolean changed = false;
                synchronized (this.mPidsSelfLocked) {
                    ProcessRecord pr = (ProcessRecord) this.mPidsSelfLocked.get(pid);
                    if (pr == null && isForeground) {
                        Slog.w(TAG, "setProcessForeground called on unknown pid: " + pid);
                    } else {
                        ImportanceToken oldToken = (ImportanceToken) this.mImportantProcesses.get(pid);
                        if (oldToken != null) {
                            oldToken.token.unlinkToDeath(oldToken, 0);
                            this.mImportantProcesses.remove(pid);
                            if (pr != null) {
                                pr.forcingToImportant = null;
                            }
                            changed = true;
                        }
                        if (isForeground && token != null) {
                            final ActivityManagerService activityManagerService = this;
                            ImportanceToken newToken = new ImportanceToken(this, pid, token, reason) {
                                public void binderDied() {
                                    activityManagerService.importanceTokenDied(this);
                                }
                            };
                            try {
                                token.linkToDeath(newToken, 0);
                                this.mImportantProcesses.put(pid, newToken);
                                pr.forcingToImportant = newToken;
                                changed = true;
                            } catch (RemoteException e) {
                            }
                        }
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean isAppForeground(int uid) throws RemoteException {
        boolean z = false;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                UidRecord uidRec = (UidRecord) this.mActiveUids.get(uid);
                if (uidRec == null || uidRec.idle) {
                } else if (uidRec.curProcState <= 6) {
                    z = true;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return false;
    }

    int getUidState(int uid) {
        int uidStateLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                uidStateLocked = getUidStateLocked(uid);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return uidStateLocked;
    }

    int getUidStateLocked(int uid) {
        UidRecord uidRec = (UidRecord) this.mActiveUids.get(uid);
        return uidRec == null ? 18 : uidRec.curProcState;
    }

    public boolean isInMultiWindowMode(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(origId);
                    return false;
                }
                boolean z = r.getTask().mFullscreen ^ 1;
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(origId);
                return z;
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public boolean isInPictureInPictureMode(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        try {
            boolean isInPictureInPictureMode;
            synchronized (this) {
                boostPriorityForLockedSection();
                isInPictureInPictureMode = isInPictureInPictureMode(ActivityRecord.forTokenLocked(token));
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(origId);
            return isInPictureInPictureMode;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    private boolean isInPictureInPictureMode(ActivityRecord r) {
        if (r == null || r.getStack() == null || (r.getStack().isPinnedStack() ^ 1) != 0 || r.getStack().isInStackLocked(r) == null) {
            return false;
        }
        return ((PinnedStackWindowController) ((PinnedActivityStack) r.getStack()).getWindowContainerController()).isAnimatingBoundsToFullscreen() ^ 1;
    }

    public boolean enterPictureInPictureMode(IBinder token, PictureInPictureParams params) {
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ensureValidPictureInPictureActivityParamsLocked("enterPictureInPictureMode", token, params);
                if (isInPictureInPictureMode(r)) {
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(origId);
                    return true;
                } else if (r.checkEnterPictureInPictureState("enterPictureInPictureMode", false)) {
                    final Runnable enterPipRunnable = new com.android.server.am.-$Lambda$njIALZ9XLXuT-vhmazyQkVX7Z0U.AnonymousClass1(this, r, params);
                    if (isKeyguardLocked()) {
                        try {
                            dismissKeyguard(token, new IKeyguardDismissCallback.Stub() {
                                public void onDismissError() throws RemoteException {
                                }

                                public void onDismissSucceeded() throws RemoteException {
                                    ActivityManagerService.this.mHandler.post(enterPipRunnable);
                                }

                                public void onDismissCancelled() throws RemoteException {
                                }
                            });
                        } catch (RemoteException e) {
                        }
                    } else {
                        enterPipRunnable.run();
                    }
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(origId);
                    return true;
                } else {
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(origId);
                    return false;
                }
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    /* synthetic */ void lambda$-com_android_server_am_ActivityManagerService_408860(ActivityRecord r, PictureInPictureParams params) {
        r.pictureInPictureArgs.copyOnlySet(params);
        float aspectRatio = r.pictureInPictureArgs.getAspectRatio();
        List<RemoteAction> actions = r.pictureInPictureArgs.getActions();
        ActivityRecord activityRecord = r;
        this.mStackSupervisor.moveActivityToPinnedStackLocked(activityRecord, new Rect(r.pictureInPictureArgs.getSourceRectHint()), aspectRatio, true, "enterPictureInPictureMode");
        PinnedActivityStack stack = (PinnedActivityStack) this.mStackSupervisor.getStack(4);
        stack.setPictureInPictureAspectRatio(aspectRatio);
        stack.setPictureInPictureActions(actions);
        MetricsLogger.action(this.mContext, 819, r.supportsEnterPipOnTaskSwitch);
        logPictureInPictureArgs(params);
    }

    public void setPictureInPictureParams(IBinder token, PictureInPictureParams params) {
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ensureValidPictureInPictureActivityParamsLocked("setPictureInPictureParams", token, params);
                r.pictureInPictureArgs.copyOnlySet(params);
                if (r.getStack().getStackId() == 4) {
                    PinnedActivityStack stack = (PinnedActivityStack) r.getStack();
                    if (!stack.isAnimatingBoundsToFullscreen()) {
                        stack.setPictureInPictureAspectRatio(r.pictureInPictureArgs.getAspectRatio());
                        stack.setPictureInPictureActions(r.pictureInPictureArgs.getActions());
                    }
                }
                logPictureInPictureArgs(params);
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(origId);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public int getMaxNumPictureInPictureActions(IBinder token) {
        return 3;
    }

    private void logPictureInPictureArgs(PictureInPictureParams params) {
        if (params.hasSetActions()) {
            MetricsLogger.histogram(this.mContext, "tron_varz_picture_in_picture_actions_count", params.getActions().size());
        }
        if (params.hasSetAspectRatio()) {
            LogMaker lm = new LogMaker(824);
            lm.addTaggedData(825, Float.valueOf(params.getAspectRatio()));
            MetricsLogger.action(lm);
        }
    }

    private ActivityRecord ensureValidPictureInPictureActivityParamsLocked(String caller, IBinder token, PictureInPictureParams params) {
        if (this.mSupportsPictureInPicture) {
            ActivityRecord r = ActivityRecord.forTokenLocked(token);
            if (r == null) {
                throw new IllegalStateException(caller + ": Can't find activity for token=" + token);
            } else if (!r.supportsPictureInPicture()) {
                throw new IllegalStateException(caller + ": Current activity does not support picture-in-picture.");
            } else if (!StackId.isAllowedToEnterPictureInPicture(r.getStack().getStackId())) {
                throw new IllegalStateException(caller + ": Activities on the home, assistant, or recents stack not supported");
            } else if (!params.hasSetAspectRatio() || (this.mWindowManager.isValidPictureInPictureAspectRatio(r.getStack().mDisplayId, params.getAspectRatio()) ^ 1) == 0) {
                params.truncateActions(getMaxNumPictureInPictureActions(token));
                return r;
            } else {
                float minAspectRatio = this.mContext.getResources().getFloat(17104960);
                float maxAspectRatio = this.mContext.getResources().getFloat(17104959);
                throw new IllegalArgumentException(String.format(caller + ": Aspect ratio is too extreme (must be between %f and %f).", new Object[]{Float.valueOf(minAspectRatio), Float.valueOf(maxAspectRatio)}));
            }
        }
        throw new IllegalStateException(caller + ": Device doesn't support picture-in-picture mode.");
    }

    public void getProcessStatesAndOomScoresForPIDs(int[] pids, int[] states, int[] scores) {
        if (scores != null) {
            enforceCallingPermission("android.permission.GET_PROCESS_STATE_AND_OOM_SCORE", "getProcessStatesAndOomScoresForPIDs()");
        }
        if (pids == null) {
            throw new NullPointerException("pids");
        } else if (states == null) {
            throw new NullPointerException("states");
        } else if (pids.length != states.length) {
            throw new IllegalArgumentException("pids and states arrays have different lengths!");
        } else if (scores == null || pids.length == scores.length) {
            synchronized (this.mPidsSelfLocked) {
                for (int i = 0; i < pids.length; i++) {
                    int i2;
                    ProcessRecord pr = (ProcessRecord) this.mPidsSelfLocked.get(pids[i]);
                    if (pr == null) {
                        i2 = 18;
                    } else {
                        i2 = pr.curProcState;
                    }
                    states[i] = i2;
                    if (scores != null) {
                        if (pr == null) {
                            i2 = -10000;
                        } else {
                            i2 = pr.curAdj;
                        }
                        scores[i] = i2;
                    }
                }
            }
        } else {
            throw new IllegalArgumentException("pids and scores arrays have different lengths!");
        }
    }

    int checkComponentPermission(String permission, int pid, int uid, int owningUid, boolean exported) {
        if (pid == MY_PID) {
            return 0;
        }
        return ActivityManager.checkComponentPermission(permission, uid, owningUid, exported);
    }

    public int checkPermission(String permission, int pid, int uid) {
        if (permission == null) {
            return -1;
        }
        return checkComponentPermission(permission, pid, uid, -1, true);
    }

    public int checkPermissionWithToken(String permission, int pid, int uid, IBinder callerToken) {
        if (permission == null) {
            return -1;
        }
        Identity tlsIdentity = (Identity) sCallerIdentity.get();
        if (tlsIdentity != null && tlsIdentity.token == callerToken) {
            Slog.d(TAG, "checkComponentPermission() adjusting {pid,uid} to {" + tlsIdentity.pid + "," + tlsIdentity.uid + "}");
            uid = tlsIdentity.uid;
            pid = tlsIdentity.pid;
        }
        return checkComponentPermission(permission, pid, uid, -1, true);
    }

    int checkCallingPermission(String permission) {
        return checkPermission(permission, Binder.getCallingPid(), UserHandle.getAppId(Binder.getCallingUid()));
    }

    void enforceCallingPermission(String permission, String func) {
        if (checkCallingPermission(permission) != 0) {
            String msg = "Permission Denial: " + func + " from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + permission;
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
    }

    private final boolean checkHoldingPermissionsLocked(IPackageManager pm, ProviderInfo pi, GrantUri grantUri, int uid, int modeFlags) {
        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
            Slog.v(TAG_URI_PERMISSION, "checkHoldingPermissionsLocked: uri=" + grantUri + " uid=" + uid);
        }
        if (UserHandle.getUserId(uid) == grantUri.sourceUserId || ActivityManager.checkComponentPermission("android.permission.INTERACT_ACROSS_USERS", uid, -1, true) == 0) {
            return checkHoldingPermissionsInternalLocked(pm, pi, grantUri, uid, modeFlags, true);
        }
        return false;
    }

    private final boolean checkHoldingPermissionsInternalLocked(IPackageManager pm, ProviderInfo pi, GrantUri grantUri, int uid, int modeFlags, boolean considerUidPermissions) {
        if (pi.applicationInfo.uid == uid) {
            return true;
        }
        if (!pi.exported) {
            return false;
        }
        boolean readMet = (modeFlags & 1) == 0;
        boolean writeMet = (modeFlags & 2) == 0;
        if (!readMet) {
            try {
                if (pi.readPermission != null && considerUidPermissions) {
                    if (pm.checkUidPermission(pi.readPermission, uid) == 0) {
                        readMet = true;
                    }
                }
            } catch (RemoteException e) {
                return false;
            }
        }
        if (!(writeMet || pi.writePermission == null || !considerUidPermissions)) {
            if (pm.checkUidPermission(pi.writePermission, uid) == 0) {
                writeMet = true;
            }
        }
        boolean allowDefaultRead = pi.readPermission == null;
        boolean allowDefaultWrite = pi.writePermission == null;
        PathPermission[] pps = pi.pathPermissions;
        if (pps != null) {
            String path = grantUri.uri.getPath();
            int i = pps.length;
            while (i > 0 && (!readMet || (writeMet ^ 1) != 0)) {
                i--;
                PathPermission pp = pps[i];
                if (pp.match(path)) {
                    if (!readMet) {
                        String pprperm = pp.getReadPermission();
                        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                            Slog.v(TAG_URI_PERMISSION, "Checking read perm for " + pprperm + " for " + pp.getPath() + ": match=" + pp.match(path) + " check=" + pm.checkUidPermission(pprperm, uid));
                        }
                        if (pprperm != null) {
                            if (considerUidPermissions && pm.checkUidPermission(pprperm, uid) == 0) {
                                readMet = true;
                            } else {
                                allowDefaultRead = false;
                            }
                        }
                    }
                    int writeMet2;
                    if (writeMet2 == 0) {
                        String ppwperm = pp.getWritePermission();
                        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                            Slog.v(TAG_URI_PERMISSION, "Checking write perm " + ppwperm + " for " + pp.getPath() + ": match=" + pp.match(path) + " check=" + pm.checkUidPermission(ppwperm, uid));
                        }
                        if (ppwperm != null) {
                            if (considerUidPermissions && pm.checkUidPermission(ppwperm, uid) == 0) {
                                writeMet2 = 1;
                            } else {
                                allowDefaultWrite = false;
                            }
                        }
                    }
                }
            }
        }
        if (allowDefaultRead) {
            readMet = true;
        }
        if (allowDefaultWrite) {
            writeMet = true;
        }
        if (!readMet) {
            writeMet = false;
        }
        return writeMet;
    }

    public boolean isAppStartModeDisabled(int uid, String packageName) {
        boolean z;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                z = getAppStartModeLocked(uid, packageName, 0, -1, false, true) == 3;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return z;
    }

    int appRestrictedInBackgroundLocked(int uid, String packageName, int packageTargetSdk) {
        if (packageTargetSdk >= 26) {
            if (ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK) {
                Slog.i(TAG, "App " + uid + "/" + packageName + " targets O+, restricted");
            }
            return 2;
        }
        int appop = this.mAppOpsService.noteOperation(63, uid, packageName);
        if (ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK) {
            Slog.i(TAG, "Legacy app " + uid + "/" + packageName + " bg appop " + appop);
        }
        switch (appop) {
            case 0:
                return 0;
            case 1:
                return 1;
            default:
                return 2;
        }
    }

    int appServicesRestrictedInBackgroundLocked(int uid, String packageName, int packageTargetSdk) {
        if (this.mPackageManagerInt.isPackagePersistent(packageName)) {
            if (ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK) {
                Slog.i(TAG, "App " + uid + "/" + packageName + " is persistent; not restricted in background");
            }
            return 0;
        } else if (uidOnBackgroundWhitelist(uid)) {
            if (ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK) {
                Slog.i(TAG, "App " + uid + "/" + packageName + " on background whitelist; not restricted in background");
            }
            return 0;
        } else if (!isOnDeviceIdleWhitelistLocked(uid)) {
            return appRestrictedInBackgroundLocked(uid, packageName, packageTargetSdk);
        } else {
            if (ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK) {
                Slog.i(TAG, "App " + uid + "/" + packageName + " on idle whitelist; not restricted in background");
            }
            return 0;
        }
    }

    int getAppStartModeLocked(int uid, String packageName, int packageTargetSdk, int callingPid, boolean alwaysRestrict, boolean disabledOnly) {
        UidRecord uidRec = (UidRecord) this.mActiveUids.get(uid);
        if (ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK) {
            boolean z;
            String str = TAG;
            StringBuilder append = new StringBuilder().append("checkAllowBackground: uid=").append(uid).append(" pkg=").append(packageName).append(" rec=").append(uidRec).append(" always=").append(alwaysRestrict).append(" idle=");
            if (uidRec != null) {
                z = uidRec.idle;
            } else {
                z = false;
            }
            Slog.d(str, append.append(z).toString());
        }
        if (uidRec != null && !alwaysRestrict && !uidRec.idle) {
            return 0;
        }
        boolean ephemeral;
        if (uidRec == null) {
            ephemeral = getPackageManagerInternalLocked().isPackageEphemeral(UserHandle.getUserId(uid), packageName);
        } else {
            ephemeral = uidRec.ephemeral;
        }
        if (ephemeral) {
            return 3;
        }
        if (disabledOnly) {
            return 0;
        }
        int startMode;
        if (alwaysRestrict) {
            startMode = appRestrictedInBackgroundLocked(uid, packageName, packageTargetSdk);
        } else {
            startMode = appServicesRestrictedInBackgroundLocked(uid, packageName, packageTargetSdk);
        }
        if (ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK) {
            Slog.d(TAG, "checkAllowBackground: uid=" + uid + " pkg=" + packageName + " startMode=" + startMode + " onwhitelist=" + isOnDeviceIdleWhitelistLocked(uid));
        }
        if (startMode == 1 && callingPid >= 0) {
            ProcessRecord proc;
            synchronized (this.mPidsSelfLocked) {
                proc = (ProcessRecord) this.mPidsSelfLocked.get(callingPid);
            }
            if (proc == null || (ActivityManager.isProcStateBackground(proc.curProcState) ^ 1) == 0) {
                return startMode;
            }
            return 0;
        }
        return startMode;
    }

    boolean isOnDeviceIdleWhitelistLocked(int uid) {
        int appId = UserHandle.getAppId(uid);
        if (Arrays.binarySearch(this.mDeviceIdleWhitelist, appId) >= 0 || Arrays.binarySearch(this.mDeviceIdleTempWhitelist, appId) >= 0 || this.mPendingTempWhitelist.indexOfKey(uid) >= 0) {
            return true;
        }
        return false;
    }

    boolean isAutoStartAllowed(int uid, String packageName) {
        if (((UidRecord) this.mActiveUids.get(uid)) != null || this.mAppOpsService.noteOperation(72, uid, packageName) == 0) {
            return true;
        }
        return false;
    }

    private ProviderInfo getProviderInfoLocked(String authority, int userHandle, int pmFlags) {
        ProviderInfo pi = null;
        ContentProviderRecord cpr = this.mProviderMap.getProviderByName(authority, userHandle);
        if (cpr != null) {
            return cpr.info;
        }
        try {
            return AppGlobals.getPackageManager().resolveContentProvider(authority, pmFlags | 2048, userHandle);
        } catch (RemoteException e) {
            return pi;
        }
    }

    void grantEphemeralAccessLocked(int userId, Intent intent, int targetAppId, int ephemeralAppId) {
        getPackageManagerInternalLocked().grantEphemeralAccess(userId, intent, targetAppId, ephemeralAppId);
    }

    private UriPermission findUriPermissionLocked(int targetUid, GrantUri grantUri) {
        ArrayMap<GrantUri, UriPermission> targetUris = (ArrayMap) this.mGrantedUriPermissions.get(targetUid);
        if (targetUris != null) {
            return (UriPermission) targetUris.get(grantUri);
        }
        return null;
    }

    private UriPermission findOrCreateUriPermissionLocked(String sourcePkg, String targetPkg, int targetUid, GrantUri grantUri) {
        ArrayMap<GrantUri, UriPermission> targetUris = (ArrayMap) this.mGrantedUriPermissions.get(targetUid);
        if (targetUris == null) {
            targetUris = Maps.newArrayMap();
            this.mGrantedUriPermissions.put(targetUid, targetUris);
        }
        UriPermission perm = (UriPermission) targetUris.get(grantUri);
        if (perm != null) {
            return perm;
        }
        perm = new UriPermission(sourcePkg, targetPkg, targetUid, grantUri);
        targetUris.put(grantUri, perm);
        return perm;
    }

    private final boolean checkUriPermissionLocked(GrantUri grantUri, int uid, int modeFlags) {
        int minStrength;
        if ((modeFlags & 64) != 0) {
            minStrength = 3;
        } else {
            minStrength = 1;
        }
        if (uid == 0) {
            return true;
        }
        ArrayMap<GrantUri, UriPermission> perms = (ArrayMap) this.mGrantedUriPermissions.get(uid);
        if (perms == null) {
            return false;
        }
        UriPermission exactPerm = (UriPermission) perms.get(grantUri);
        if (exactPerm != null && exactPerm.getStrength(modeFlags) >= minStrength) {
            return true;
        }
        int N = perms.size();
        for (int i = 0; i < N; i++) {
            UriPermission perm = (UriPermission) perms.valueAt(i);
            if (perm.uri.prefix && grantUri.uri.isPathPrefixMatch(perm.uri.uri) && perm.getStrength(modeFlags) >= minStrength) {
                return true;
            }
        }
        return false;
    }

    public int checkUriPermission(Uri uri, int pid, int uid, int modeFlags, int userId, IBinder callerToken) {
        int i = 0;
        enforceNotIsolatedCaller("checkUriPermission");
        Identity tlsIdentity = (Identity) sCallerIdentity.get();
        if (tlsIdentity != null && tlsIdentity.token == callerToken) {
            uid = tlsIdentity.uid;
            pid = tlsIdentity.pid;
        }
        if (pid == MY_PID) {
            return 0;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (!checkUriPermissionLocked(new GrantUri(userId, uri, false), uid, modeFlags)) {
                    i = -1;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return i;
    }

    int checkGrantUriPermissionLocked(int callingUid, String targetPkg, GrantUri grantUri, int modeFlags, int lastTargetUid) {
        if ((callingUid == 1000 && OppoMultiAppManagerUtil.getInstance().isMultiApp(targetPkg)) || (Integer.MIN_VALUE & modeFlags) != 0) {
            return lastTargetUid;
        }
        if (!Intent.isAccessUriMode(modeFlags)) {
            return -1;
        }
        if (targetPkg != null && ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
            Slog.v(TAG_URI_PERMISSION, "Checking grant " + targetPkg + " permission to " + grantUri);
        }
        IPackageManager pm = AppGlobals.getPackageManager();
        if (UserHandle.getUserId(callingUid) == OppoMultiAppManager.USER_ID) {
            try {
                String packageName = pm.getNameForUid(callingUid);
                String targetName = pm.getNameForUid(lastTargetUid);
                String authority = grantUri.uri.getAuthority();
                if (packageName != null && "com.viber.voip".equals(packageName) && targetName != null && "com.google.android.gm".equals(targetName) && authority != null && OppoProcessManager.RESUME_REASON_MEDIA_STR.equals(authority)) {
                    return lastTargetUid;
                }
            } catch (Exception e) {
            }
        }
        if ("content".equals(grantUri.uri.getScheme())) {
            int callingAppId = UserHandle.getAppId(callingUid);
            if ((callingAppId == 1000 || callingAppId == 0) && !"com.android.settings.files".equals(grantUri.uri.getAuthority())) {
                Slog.w(TAG, "For security reasons, the system cannot issue a Uri permission grant to " + grantUri + "; use startActivityAsCaller() instead");
                return -1;
            }
            ProviderInfo pi = getProviderInfoLocked(grantUri.uri.getAuthority(), grantUri.sourceUserId, 268435456);
            if (pi == null) {
                Slog.w(TAG, "No content provider found for permission check: " + grantUri.uri.toSafeString());
                return -1;
            }
            int targetUid = lastTargetUid;
            if (lastTargetUid < 0 && targetPkg != null) {
                try {
                    targetUid = pm.getPackageUid(targetPkg, 268435456, UserHandle.getUserId(callingUid));
                    if (targetUid < 0) {
                        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                            Slog.v(TAG_URI_PERMISSION, "Can't grant URI permission no uid for: " + targetPkg);
                        }
                        return -1;
                    }
                } catch (RemoteException e2) {
                    return -1;
                }
            }
            if ((modeFlags & 64) != 0) {
                return targetUid;
            }
            boolean allowed;
            boolean specialCrossUserGrant;
            if (targetUid < 0) {
                allowed = pi.exported;
                if (!((modeFlags & 1) == 0 || pi.readPermission == null)) {
                    allowed = false;
                }
                if (!((modeFlags & 2) == 0 || pi.writePermission == null)) {
                    allowed = false;
                }
                if (allowed) {
                    return -1;
                }
            } else if (checkHoldingPermissionsLocked(pm, pi, grantUri, targetUid, modeFlags)) {
                if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                    Slog.v(TAG_URI_PERMISSION, "Target " + targetPkg + " already has full permission to " + grantUri);
                }
                return -1;
            }
            if (UserHandle.getUserId(targetUid) != grantUri.sourceUserId) {
                specialCrossUserGrant = checkHoldingPermissionsInternalLocked(pm, pi, grantUri, callingUid, modeFlags, false);
            } else {
                specialCrossUserGrant = false;
            }
            if (!specialCrossUserGrant) {
                if (!pi.grantUriPermissions) {
                    throw new SecurityException("Provider " + pi.packageName + "/" + pi.name + " does not allow granting of Uri permissions (uri " + grantUri + ")");
                } else if (pi.uriPermissionPatterns != null) {
                    int N = pi.uriPermissionPatterns.length;
                    allowed = false;
                    int i = 0;
                    while (i < N) {
                        if (pi.uriPermissionPatterns[i] != null && pi.uriPermissionPatterns[i].match(grantUri.uri.getPath())) {
                            allowed = true;
                            break;
                        }
                        i++;
                    }
                    if (!allowed) {
                        throw new SecurityException("Provider " + pi.packageName + "/" + pi.name + " does not allow granting of permission to path of Uri " + grantUri);
                    }
                }
            }
            if (checkHoldingPermissionsLocked(pm, pi, grantUri, callingUid, modeFlags) || checkUriPermissionLocked(grantUri, callingUid, modeFlags)) {
                return targetUid;
            }
            if ("android.permission.MANAGE_DOCUMENTS".equals(pi.readPermission)) {
                throw new SecurityException("UID " + callingUid + " does not have permission to " + grantUri + "; you could obtain access using ACTION_OPEN_DOCUMENT " + "or related APIs");
            }
            throw new SecurityException("UID " + callingUid + " does not have permission to " + grantUri);
        }
        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
            Slog.v(TAG_URI_PERMISSION, "Can't grant URI permission for non-content URI: " + grantUri);
        }
        return -1;
    }

    public int checkGrantUriPermission(int callingUid, String targetPkg, Uri uri, int modeFlags, int userId) {
        int checkGrantUriPermissionLocked;
        enforceNotIsolatedCaller("checkGrantUriPermission");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                checkGrantUriPermissionLocked = checkGrantUriPermissionLocked(callingUid, targetPkg, new GrantUri(userId, uri, false), modeFlags, -1);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return checkGrantUriPermissionLocked;
    }

    void grantUriPermissionUncheckedLocked(int targetUid, String targetPkg, GrantUri grantUri, int modeFlags, UriPermissionOwner owner) {
        if (Intent.isAccessUriMode(modeFlags)) {
            if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                Slog.v(TAG_URI_PERMISSION, "Granting " + targetPkg + "/" + targetUid + " permission to " + grantUri);
            }
            ProviderInfo pi = getProviderInfoLocked(grantUri.uri.getAuthority(), grantUri.sourceUserId, 268435456);
            if (pi == null) {
                Slog.w(TAG, "No content provider found for grant: " + grantUri.toSafeString());
                return;
            }
            if ((modeFlags & 128) != 0) {
                grantUri.prefix = true;
            }
            findOrCreateUriPermissionLocked(pi.packageName, targetPkg, targetUid, grantUri).grantModes(modeFlags, owner);
        }
    }

    void grantUriPermissionLocked(int callingUid, String targetPkg, GrantUri grantUri, int modeFlags, UriPermissionOwner owner, int targetUserId) {
        if (targetPkg == null) {
            throw new NullPointerException(ATTR_TARGET_PKG);
        }
        try {
            int targetUid = checkGrantUriPermissionLocked(callingUid, targetPkg, grantUri, modeFlags, AppGlobals.getPackageManager().getPackageUid(targetPkg, 268435456, targetUserId));
            if (targetUid >= 0) {
                grantUriPermissionUncheckedLocked(targetUid, targetPkg, grantUri, modeFlags, owner);
            }
        } catch (RemoteException e) {
        }
    }

    com.android.server.am.ActivityManagerService.NeededUriGrants checkGrantUriPermissionFromIntentLocked(int r25, java.lang.String r26, android.content.Intent r27, int r28, com.android.server.am.ActivityManagerService.NeededUriGrants r29, int r30) {
        /* JADX: method processing error */
/*
Error: jadx.core.utils.exceptions.JadxRuntimeException: Unknown predecessor block by arg (r29_1 'needed' com.android.server.am.ActivityManagerService$NeededUriGrants) in PHI: PHI: (r29_2 'needed' com.android.server.am.ActivityManagerService$NeededUriGrants) = (r29_0 'needed' com.android.server.am.ActivityManagerService$NeededUriGrants), (r29_1 'needed' com.android.server.am.ActivityManagerService$NeededUriGrants) binds: {(r29_0 'needed' com.android.server.am.ActivityManagerService$NeededUriGrants)=B:35:0x00a4, (r29_1 'needed' com.android.server.am.ActivityManagerService$NeededUriGrants)=B:36:0x00a6}
	at jadx.core.dex.instructions.PhiInsn.replaceArg(PhiInsn.java:78)
	at jadx.core.dex.visitors.ModVisitor.processInvoke(ModVisitor.java:222)
	at jadx.core.dex.visitors.ModVisitor.replaceStep(ModVisitor.java:83)
	at jadx.core.dex.visitors.ModVisitor.visit(ModVisitor.java:68)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:27)
	at jadx.core.dex.visitors.DepthTraversal.lambda$visit$1(DepthTraversal.java:14)
	at java.util.ArrayList.forEach(ArrayList.java:1251)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:14)
	at jadx.core.ProcessClass.process(ProcessClass.java:32)
	at jadx.core.ProcessClass.lambda$processDependencies$0(ProcessClass.java:51)
	at java.lang.Iterable.forEach(Iterable.java:75)
	at jadx.core.ProcessClass.processDependencies(ProcessClass.java:51)
	at jadx.core.ProcessClass.process(ProcessClass.java:37)
	at jadx.api.JadxDecompiler.processClass(JadxDecompiler.java:286)
	at jadx.api.JavaClass.decompile(JavaClass.java:62)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
*/
        /*
        r24 = this;
        r3 = com.android.server.am.ActivityManagerDebugConfig.DEBUG_URI_PERMISSION;
        if (r3 == 0) goto L_0x0056;
    L_0x0004:
        r4 = TAG_URI_PERMISSION;
        r3 = new java.lang.StringBuilder;
        r3.<init>();
        r5 = "Checking URI perm to data=";
        r5 = r3.append(r5);
        if (r27 == 0) goto L_0x0061;
    L_0x0014:
        r3 = r27.getData();
    L_0x0018:
        r3 = r5.append(r3);
        r5 = " clip=";
        r5 = r3.append(r5);
        if (r27 == 0) goto L_0x0063;
    L_0x0025:
        r3 = r27.getClipData();
    L_0x0029:
        r3 = r5.append(r3);
        r5 = " from ";
        r3 = r3.append(r5);
        r0 = r27;
        r3 = r3.append(r0);
        r5 = "; flags=0x";
        r5 = r3.append(r5);
        if (r27 == 0) goto L_0x0065;
    L_0x0043:
        r3 = r27.getFlags();
    L_0x0047:
        r3 = java.lang.Integer.toHexString(r3);
        r3 = r5.append(r3);
        r3 = r3.toString();
        android.util.Slog.v(r4, r3);
    L_0x0056:
        if (r26 != 0) goto L_0x0067;
    L_0x0058:
        r3 = new java.lang.NullPointerException;
        r4 = "targetPkg";
        r3.<init>(r4);
        throw r3;
    L_0x0061:
        r3 = 0;
        goto L_0x0018;
    L_0x0063:
        r3 = 0;
        goto L_0x0029;
    L_0x0065:
        r3 = 0;
        goto L_0x0047;
    L_0x0067:
        if (r27 != 0) goto L_0x006b;
    L_0x0069:
        r3 = 0;
        return r3;
    L_0x006b:
        r18 = r27.getData();
        r16 = r27.getClipData();
        if (r18 != 0) goto L_0x0079;
    L_0x0075:
        if (r16 != 0) goto L_0x0079;
    L_0x0077:
        r3 = 0;
        return r3;
    L_0x0079:
        r17 = r27.getContentUserHint();
        r3 = -2;
        r0 = r17;
        if (r0 != r3) goto L_0x0086;
    L_0x0082:
        r17 = android.os.UserHandle.getUserId(r25);
    L_0x0086:
        r22 = android.app.AppGlobals.getPackageManager();
        if (r29 == 0) goto L_0x00fb;
    L_0x008c:
        r0 = r29;
        r8 = r0.targetUid;
    L_0x0090:
        if (r18 == 0) goto L_0x00b6;
    L_0x0092:
        r6 = com.android.server.am.ActivityManagerService.GrantUri.resolve(r17, r18);
        r3 = r24;
        r4 = r25;
        r5 = r26;
        r7 = r28;
        r8 = r3.checkGrantUriPermissionLocked(r4, r5, r6, r7, r8);
        if (r8 <= 0) goto L_0x00b6;
    L_0x00a4:
        if (r29 != 0) goto L_0x00b1;
    L_0x00a6:
        r29 = new com.android.server.am.ActivityManagerService$NeededUriGrants;
        r0 = r29;
        r1 = r26;
        r2 = r28;
        r0.<init>(r1, r8, r2);
    L_0x00b1:
        r0 = r29;
        r0.add(r6);
    L_0x00b6:
        if (r16 == 0) goto L_0x015d;
    L_0x00b8:
        r20 = 0;
    L_0x00ba:
        r3 = r16.getItemCount();
        r0 = r20;
        if (r0 >= r3) goto L_0x015d;
    L_0x00c2:
        r0 = r16;
        r1 = r20;
        r3 = r0.getItemAt(r1);
        r23 = r3.getUri();
        if (r23 == 0) goto L_0x013a;
    L_0x00d0:
        r0 = r17;
        r1 = r23;
        r6 = com.android.server.am.ActivityManagerService.GrantUri.resolve(r0, r1);
        r3 = r24;
        r4 = r25;
        r5 = r26;
        r7 = r28;
        r8 = r3.checkGrantUriPermissionLocked(r4, r5, r6, r7, r8);
        if (r8 <= 0) goto L_0x00f8;
    L_0x00e6:
        if (r29 != 0) goto L_0x00f3;
    L_0x00e8:
        r29 = new com.android.server.am.ActivityManagerService$NeededUriGrants;
        r0 = r29;
        r1 = r26;
        r2 = r28;
        r0.<init>(r1, r8, r2);
    L_0x00f3:
        r0 = r29;
        r0.add(r6);
    L_0x00f8:
        r20 = r20 + 1;
        goto L_0x00ba;
    L_0x00fb:
        r3 = 268435456; // 0x10000000 float:2.5243549E-29 double:1.32624737E-315;
        r0 = r22;	 Catch:{ RemoteException -> 0x0137 }
        r1 = r26;	 Catch:{ RemoteException -> 0x0137 }
        r2 = r30;	 Catch:{ RemoteException -> 0x0137 }
        r8 = r0.getPackageUid(r1, r3, r2);	 Catch:{ RemoteException -> 0x0137 }
        if (r8 >= 0) goto L_0x0090;
    L_0x0109:
        r3 = com.android.server.am.ActivityManagerDebugConfig.DEBUG_URI_PERMISSION;
        if (r3 == 0) goto L_0x0135;
    L_0x010d:
        r3 = TAG_URI_PERMISSION;
        r4 = new java.lang.StringBuilder;
        r4.<init>();
        r5 = "Can't grant URI permission no uid for: ";
        r4 = r4.append(r5);
        r0 = r26;
        r4 = r4.append(r0);
        r5 = " on user ";
        r4 = r4.append(r5);
        r0 = r30;
        r4 = r4.append(r0);
        r4 = r4.toString();
        android.util.Slog.v(r3, r4);
    L_0x0135:
        r3 = 0;
        return r3;
    L_0x0137:
        r19 = move-exception;
        r3 = 0;
        return r3;
    L_0x013a:
        r0 = r16;
        r1 = r20;
        r3 = r0.getItemAt(r1);
        r12 = r3.getIntent();
        if (r12 == 0) goto L_0x00f8;
    L_0x0148:
        r9 = r24;
        r10 = r25;
        r11 = r26;
        r13 = r28;
        r14 = r29;
        r15 = r30;
        r21 = r9.checkGrantUriPermissionFromIntentLocked(r10, r11, r12, r13, r14, r15);
        if (r21 == 0) goto L_0x00f8;
    L_0x015a:
        r29 = r21;
        goto L_0x00f8;
    L_0x015d:
        return r29;
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.checkGrantUriPermissionFromIntentLocked(int, java.lang.String, android.content.Intent, int, com.android.server.am.ActivityManagerService$NeededUriGrants, int):com.android.server.am.ActivityManagerService$NeededUriGrants");
    }

    void grantUriPermissionUncheckedFromIntentLocked(NeededUriGrants needed, UriPermissionOwner owner) {
        if (needed != null) {
            for (int i = 0; i < needed.size(); i++) {
                grantUriPermissionUncheckedLocked(needed.targetUid, needed.targetPkg, (GrantUri) needed.get(i), needed.flags, owner);
            }
        }
    }

    void grantUriPermissionFromIntentLocked(int callingUid, String targetPkg, Intent intent, UriPermissionOwner owner, int targetUserId) {
        NeededUriGrants needed = checkGrantUriPermissionFromIntentLocked(callingUid, targetPkg, intent, intent != null ? intent.getFlags() : 0, null, targetUserId);
        if (needed != null) {
            grantUriPermissionUncheckedFromIntentLocked(needed, owner);
        }
    }

    public void grantUriPermission(IApplicationThread caller, String targetPkg, Uri uri, int modeFlags, int userId) {
        enforceNotIsolatedCaller("grantUriPermission");
        GrantUri grantUri = new GrantUri(userId, uri, false);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ProcessRecord r = getRecordForAppLocked(caller);
                if (r == null) {
                    throw new SecurityException("Unable to find app for caller " + caller + " when granting permission to uri " + grantUri);
                } else if (targetPkg == null) {
                    throw new IllegalArgumentException("null target");
                } else if (grantUri == null) {
                    throw new IllegalArgumentException("null uri");
                } else {
                    Preconditions.checkFlagsArgument(modeFlags, HdmiCecKeycode.UI_SOUND_PRESENTATION_TREBLE_STEP_MINUS);
                    grantUriPermissionLocked(r.uid, targetPkg, grantUri, modeFlags, null, UserHandle.getUserId(r.uid));
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    void removeUriPermissionIfNeededLocked(UriPermission perm) {
        if (perm.modeFlags == 0) {
            ArrayMap<GrantUri, UriPermission> perms = (ArrayMap) this.mGrantedUriPermissions.get(perm.targetUid);
            if (perms != null) {
                if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                    Slog.v(TAG_URI_PERMISSION, "Removing " + perm.targetUid + " permission to " + perm.uri);
                }
                perms.remove(perm.uri);
                if (perms.isEmpty()) {
                    this.mGrantedUriPermissions.remove(perm.targetUid);
                }
            }
        }
    }

    private void revokeUriPermissionLocked(String targetPackage, int callingUid, GrantUri grantUri, int modeFlags) {
        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
            Slog.v(TAG_URI_PERMISSION, "Revoking all granted permissions to " + grantUri);
        }
        IPackageManager pm = AppGlobals.getPackageManager();
        ProviderInfo pi = getProviderInfoLocked(grantUri.uri.getAuthority(), grantUri.sourceUserId, 786432);
        int i;
        ArrayMap<GrantUri, UriPermission> perms;
        UriPermission perm;
        if (pi == null) {
            Slog.w(TAG, "No content provider found for permission revoke: " + grantUri.toSafeString());
        } else if (checkHoldingPermissionsLocked(pm, pi, grantUri, callingUid, modeFlags)) {
            boolean persistChanged = false;
            for (i = this.mGrantedUriPermissions.size() - 1; i >= 0; i--) {
                int targetUid = this.mGrantedUriPermissions.keyAt(i);
                perms = (ArrayMap) this.mGrantedUriPermissions.valueAt(i);
                for (int j = perms.size() - 1; j >= 0; j--) {
                    perm = (UriPermission) perms.valueAt(j);
                    if ((targetPackage == null || (targetPackage.equals(perm.targetPkg) ^ 1) == 0) && perm.uri.sourceUserId == grantUri.sourceUserId && perm.uri.uri.isPathPrefixMatch(grantUri.uri)) {
                        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                            Slog.v(TAG_URI_PERMISSION, "Revoking " + perm.targetUid + " permission to " + perm.uri);
                        }
                        persistChanged |= perm.revokeModes(modeFlags | 64, targetPackage == null);
                        if (perm.modeFlags == 0) {
                            perms.removeAt(j);
                        }
                    }
                }
                if (perms.isEmpty()) {
                    this.mGrantedUriPermissions.removeAt(i);
                }
            }
            if (persistChanged) {
                schedulePersistUriGrants();
            }
        } else {
            perms = (ArrayMap) this.mGrantedUriPermissions.get(callingUid);
            if (perms != null) {
                int persistChanged2 = 0;
                for (i = perms.size() - 1; i >= 0; i--) {
                    perm = (UriPermission) perms.valueAt(i);
                    if ((targetPackage == null || (targetPackage.equals(perm.targetPkg) ^ 1) == 0) && perm.uri.sourceUserId == grantUri.sourceUserId && perm.uri.uri.isPathPrefixMatch(grantUri.uri)) {
                        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                            Slog.v(TAG_URI_PERMISSION, "Revoking non-owned " + perm.targetUid + " permission to " + perm.uri);
                        }
                        persistChanged2 |= perm.revokeModes(modeFlags | 64, false);
                        if (perm.modeFlags == 0) {
                            perms.removeAt(i);
                        }
                    }
                }
                if (perms.isEmpty()) {
                    this.mGrantedUriPermissions.remove(callingUid);
                }
                if (persistChanged2 != 0) {
                    schedulePersistUriGrants();
                }
            }
        }
    }

    public void revokeUriPermission(IApplicationThread caller, String targetPackage, Uri uri, int modeFlags, int userId) {
        enforceNotIsolatedCaller("revokeUriPermission");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ProcessRecord r = getRecordForAppLocked(caller);
                if (r == null) {
                    throw new SecurityException("Unable to find app for caller " + caller + " when revoking permission to uri " + uri);
                } else if (uri == null) {
                    Slog.w(TAG, "revokeUriPermission: null uri");
                } else if (!Intent.isAccessUriMode(modeFlags)) {
                    resetPriorityAfterLockedSection();
                } else if (getProviderInfoLocked(uri.getAuthority(), userId, 786432) == null) {
                    Slog.w(TAG, "No content provider found for permission revoke: " + uri.toSafeString());
                    resetPriorityAfterLockedSection();
                } else {
                    revokeUriPermissionLocked(targetPackage, r.uid, new GrantUri(userId, uri, false), modeFlags);
                    resetPriorityAfterLockedSection();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private void removeUriPermissionsForPackageLocked(String packageName, int userHandle, boolean persistable) {
        if (userHandle == -1 && packageName == null) {
            throw new IllegalArgumentException("Must narrow by either package or user");
        }
        int persistChanged = 0;
        int N = this.mGrantedUriPermissions.size();
        int i = 0;
        while (i < N) {
            int targetUid = this.mGrantedUriPermissions.keyAt(i);
            ArrayMap<GrantUri, UriPermission> perms = (ArrayMap) this.mGrantedUriPermissions.valueAt(i);
            if (userHandle == -1 || userHandle == UserHandle.getUserId(targetUid)) {
                Iterator<UriPermission> it = perms.values().iterator();
                while (it.hasNext()) {
                    UriPermission perm = (UriPermission) it.next();
                    if ((packageName == null || perm.sourcePkg.equals(packageName) || perm.targetPkg.equals(packageName)) && (!"downloads".equals(perm.uri.uri.getAuthority()) || (persistable ^ 1) == 0)) {
                        int i2;
                        if (persistable) {
                            i2 = -1;
                        } else {
                            i2 = -65;
                        }
                        persistChanged |= perm.revokeModes(i2, true);
                        if (perm.modeFlags == 0) {
                            it.remove();
                        }
                    }
                }
                if (perms.isEmpty()) {
                    this.mGrantedUriPermissions.remove(targetUid);
                    N--;
                    i--;
                }
            }
            i++;
        }
        if (persistChanged != 0) {
            schedulePersistUriGrants();
        }
    }

    public IBinder newUriPermissionOwner(String name) {
        IBinder externalTokenLocked;
        enforceNotIsolatedCaller("newUriPermissionOwner");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                externalTokenLocked = new UriPermissionOwner(this, name).getExternalTokenLocked();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return externalTokenLocked;
    }

    public IBinder getUriPermissionOwnerForActivity(IBinder activityToken) {
        IBinder externalTokenLocked;
        enforceNotIsolatedCaller("getUriPermissionOwnerForActivity");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(activityToken);
                if (r == null) {
                    throw new IllegalArgumentException("Activity does not exist; token=" + activityToken);
                }
                externalTokenLocked = r.getUriPermissionsLocked().getExternalTokenLocked();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return externalTokenLocked;
    }

    public void grantUriPermissionFromOwner(IBinder token, int fromUid, String targetPkg, Uri uri, int modeFlags, int sourceUserId, int targetUserId) {
        targetUserId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), targetUserId, false, 2, "grantUriPermissionFromOwner", null);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                UriPermissionOwner owner = UriPermissionOwner.fromExternalToken(token);
                if (owner == null) {
                    throw new IllegalArgumentException("Unknown owner: " + token);
                } else if (fromUid != Binder.getCallingUid() && Binder.getCallingUid() != Process.myUid()) {
                    throw new SecurityException("nice try");
                } else if (targetPkg == null) {
                    throw new IllegalArgumentException("null target");
                } else if (uri == null) {
                    throw new IllegalArgumentException("null uri");
                } else {
                    grantUriPermissionLocked(fromUid, targetPkg, new GrantUri(sourceUserId, uri, false), modeFlags, owner, targetUserId);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void revokeUriPermissionFromOwner(IBinder token, Uri uri, int mode, int userId) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                UriPermissionOwner owner = UriPermissionOwner.fromExternalToken(token);
                if (owner == null) {
                    throw new IllegalArgumentException("Unknown owner: " + token);
                }
                if (uri == null) {
                    owner.removeUriPermissionsLocked(mode);
                } else {
                    owner.removeUriPermissionLocked(new GrantUri(userId, uri, (mode & 128) != 0), mode);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private void schedulePersistUriGrants() {
        if (!this.mHandler.hasMessages(38)) {
            this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(38), 10000);
        }
    }

    private void writeGrantedUriPermissions() {
        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
            Slog.v(TAG_URI_PERMISSION, "writeGrantedUriPermissions()");
        }
        ArrayList<Snapshot> persist = Lists.newArrayList();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int size = this.mGrantedUriPermissions.size();
                for (int i = 0; i < size; i++) {
                    for (UriPermission perm : ((ArrayMap) this.mGrantedUriPermissions.valueAt(i)).values()) {
                        if (perm.persistedModeFlags != 0) {
                            persist.add(perm.snapshot());
                        }
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        FileOutputStream fos = null;
        try {
            fos = this.mGrantFile.startWrite();
            XmlSerializer out = new FastXmlSerializer();
            out.setOutput(fos, StandardCharsets.UTF_8.name());
            out.startDocument(null, Boolean.valueOf(true));
            out.startTag(null, TAG_URI_GRANTS);
            for (Snapshot perm2 : persist) {
                out.startTag(null, TAG_URI_GRANT);
                XmlUtils.writeIntAttribute(out, ATTR_SOURCE_USER_ID, perm2.uri.sourceUserId);
                XmlUtils.writeIntAttribute(out, ATTR_TARGET_USER_ID, perm2.targetUserId);
                out.attribute(null, ATTR_SOURCE_PKG, perm2.sourcePkg);
                out.attribute(null, ATTR_TARGET_PKG, perm2.targetPkg);
                out.attribute(null, ATTR_URI, String.valueOf(perm2.uri.uri));
                XmlUtils.writeBooleanAttribute(out, ATTR_PREFIX, perm2.uri.prefix);
                XmlUtils.writeIntAttribute(out, ATTR_MODE_FLAGS, perm2.persistedModeFlags);
                XmlUtils.writeLongAttribute(out, ATTR_CREATED_TIME, perm2.persistedCreateTime);
                out.endTag(null, TAG_URI_GRANT);
            }
            out.endTag(null, TAG_URI_GRANTS);
            out.endDocument();
            this.mGrantFile.finishWrite(fos);
        } catch (IOException e) {
            if (fos != null) {
                this.mGrantFile.failWrite(fos);
            }
        }
    }

    private void readGrantedUriPermissionsLocked() {
        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
            Slog.v(TAG_URI_PERMISSION, "readGrantedUriPermissions()");
        }
        long now = System.currentTimeMillis();
        AutoCloseable autoCloseable = null;
        try {
            autoCloseable = this.mGrantFile.openRead();
            XmlPullParser in = Xml.newPullParser();
            in.setInput(autoCloseable, StandardCharsets.UTF_8.name());
            loop0:
            while (true) {
                int type = in.next();
                if (type == 1) {
                    break loop0;
                }
                String tag = in.getName();
                if (type == 2 && TAG_URI_GRANT.equals(tag)) {
                    int sourceUserId;
                    int targetUserId;
                    int userHandle = XmlUtils.readIntAttribute(in, ATTR_USER_HANDLE, -10000);
                    if (userHandle != -10000) {
                        sourceUserId = userHandle;
                        targetUserId = userHandle;
                    } else {
                        sourceUserId = XmlUtils.readIntAttribute(in, ATTR_SOURCE_USER_ID);
                        targetUserId = XmlUtils.readIntAttribute(in, ATTR_TARGET_USER_ID);
                    }
                    String sourcePkg = in.getAttributeValue(null, ATTR_SOURCE_PKG);
                    String targetPkg = in.getAttributeValue(null, ATTR_TARGET_PKG);
                    Uri uri = Uri.parse(in.getAttributeValue(null, ATTR_URI));
                    boolean prefix = XmlUtils.readBooleanAttribute(in, ATTR_PREFIX);
                    int modeFlags = XmlUtils.readIntAttribute(in, ATTR_MODE_FLAGS);
                    long createdTime = XmlUtils.readLongAttribute(in, ATTR_CREATED_TIME, now);
                    ProviderInfo pi = getProviderInfoLocked(uri.getAuthority(), sourceUserId, 786432);
                    if (pi != null) {
                        if (sourcePkg.equals(pi.packageName)) {
                            int targetUid = -1;
                            try {
                                targetUid = AppGlobals.getPackageManager().getPackageUid(targetPkg, 8192, targetUserId);
                            } catch (RemoteException e) {
                            }
                            if (targetUid != -1) {
                                findOrCreateUriPermissionLocked(sourcePkg, targetPkg, targetUid, new GrantUri(sourceUserId, uri, prefix)).initPersistedModes(modeFlags, createdTime);
                            } else {
                                continue;
                            }
                        }
                    }
                    Slog.w(TAG, "Persisted grant for " + uri + " had source " + sourcePkg + " but instead found " + pi);
                }
            }
        } catch (FileNotFoundException e2) {
        } catch (IOException e3) {
            Slog.wtf(TAG, "Failed reading Uri grants", e3);
        } catch (XmlPullParserException e4) {
            Slog.wtf(TAG, "Failed reading Uri grants", e4);
        } finally {
            IoUtils.closeQuietly(autoCloseable);
        }
    }

    public void takePersistableUriPermission(Uri uri, int modeFlags, int userId) {
        boolean z = true;
        enforceNotIsolatedCaller("takePersistableUriPermission");
        Preconditions.checkFlagsArgument(modeFlags, 3);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int callingUid = Binder.getCallingUid();
                boolean persistChanged = false;
                GrantUri grantUri = new GrantUri(userId, uri, false);
                UriPermission exactPerm = findUriPermissionLocked(callingUid, new GrantUri(userId, uri, false));
                UriPermission prefixPerm = findUriPermissionLocked(callingUid, new GrantUri(userId, uri, true));
                boolean exactValid = exactPerm != null ? (exactPerm.persistableModeFlags & modeFlags) == modeFlags : false;
                boolean prefixValid = prefixPerm != null ? (prefixPerm.persistableModeFlags & modeFlags) == modeFlags : false;
                if (!exactValid) {
                    z = prefixValid;
                }
                if (z) {
                    if (exactValid) {
                        persistChanged = exactPerm.takePersistableModes(modeFlags);
                    }
                    if (prefixValid) {
                        persistChanged |= prefixPerm.takePersistableModes(modeFlags);
                    }
                    if (persistChanged | maybePrunePersistedUriGrantsLocked(callingUid)) {
                        schedulePersistUriGrants();
                    }
                } else {
                    throw new SecurityException("No persistable permission grants found for UID " + callingUid + " and Uri " + grantUri.toSafeString());
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void releasePersistableUriPermission(Uri uri, int modeFlags, int userId) {
        enforceNotIsolatedCaller("releasePersistableUriPermission");
        Preconditions.checkFlagsArgument(modeFlags, 3);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int callingUid = Binder.getCallingUid();
                boolean persistChanged = false;
                UriPermission exactPerm = findUriPermissionLocked(callingUid, new GrantUri(userId, uri, false));
                UriPermission prefixPerm = findUriPermissionLocked(callingUid, new GrantUri(userId, uri, true));
                if (exactPerm == null && prefixPerm == null) {
                    throw new SecurityException("No permission grants found for UID " + callingUid + " and Uri " + uri.toSafeString());
                }
                if (exactPerm != null) {
                    persistChanged = exactPerm.releasePersistableModes(modeFlags);
                    removeUriPermissionIfNeededLocked(exactPerm);
                }
                if (prefixPerm != null) {
                    persistChanged |= prefixPerm.releasePersistableModes(modeFlags);
                    removeUriPermissionIfNeededLocked(prefixPerm);
                }
                if (persistChanged) {
                    schedulePersistUriGrants();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private boolean maybePrunePersistedUriGrantsLocked(int uid) {
        ArrayMap<GrantUri, UriPermission> perms = (ArrayMap) this.mGrantedUriPermissions.get(uid);
        if (perms == null || perms.size() < 128) {
            return false;
        }
        UriPermission perm;
        ArrayList<UriPermission> persisted = Lists.newArrayList();
        for (UriPermission perm2 : perms.values()) {
            if (perm2.persistedModeFlags != 0) {
                persisted.add(perm2);
            }
        }
        int trimCount = persisted.size() - 128;
        if (trimCount <= 0) {
            return false;
        }
        Collections.sort(persisted, new PersistedTimeComparator());
        for (int i = 0; i < trimCount; i++) {
            perm2 = (UriPermission) persisted.get(i);
            if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                Slog.v(TAG_URI_PERMISSION, "Trimming grant created at " + perm2.persistedCreateTime);
            }
            perm2.releasePersistableModes(-1);
            removeUriPermissionIfNeededLocked(perm2);
        }
        return true;
    }

    public ParceledListSlice<UriPermission> getPersistedUriPermissions(String packageName, boolean incoming) {
        enforceNotIsolatedCaller("getPersistedUriPermissions");
        Preconditions.checkNotNull(packageName, "packageName");
        int callingUid = Binder.getCallingUid();
        try {
            if (AppGlobals.getPackageManager().getPackageUid(packageName, 786432, UserHandle.getUserId(callingUid)) != callingUid) {
                throw new SecurityException("Package " + packageName + " does not belong to calling UID " + callingUid);
            }
            ArrayList<UriPermission> result = Lists.newArrayList();
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (incoming) {
                        ArrayMap<GrantUri, UriPermission> perms = (ArrayMap) this.mGrantedUriPermissions.get(callingUid);
                        if (perms == null) {
                            Slog.w(TAG, "No permission grants found for " + packageName);
                        } else {
                            for (UriPermission perm : perms.values()) {
                                if (packageName.equals(perm.targetPkg) && perm.persistedModeFlags != 0) {
                                    result.add(perm.buildPersistedPublicApiObject());
                                }
                            }
                        }
                    } else {
                        int size = this.mGrantedUriPermissions.size();
                        for (int i = 0; i < size; i++) {
                            for (UriPermission perm2 : ((ArrayMap) this.mGrantedUriPermissions.valueAt(i)).values()) {
                                if (packageName.equals(perm2.sourcePkg) && perm2.persistedModeFlags != 0) {
                                    result.add(perm2.buildPersistedPublicApiObject());
                                }
                            }
                        }
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return new ParceledListSlice(result);
        } catch (RemoteException e) {
            throw new SecurityException("Failed to verify package name ownership");
        }
    }

    public ParceledListSlice<UriPermission> getGrantedUriPermissions(String packageName, int userId) {
        enforceCallingPermission("android.permission.GET_APP_GRANTED_URI_PERMISSIONS", "getGrantedUriPermissions");
        ArrayList<UriPermission> result = Lists.newArrayList();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int size = this.mGrantedUriPermissions.size();
                for (int i = 0; i < size; i++) {
                    for (UriPermission perm : ((ArrayMap) this.mGrantedUriPermissions.valueAt(i)).values()) {
                        if (packageName.equals(perm.targetPkg) && perm.targetUserId == userId && perm.persistedModeFlags != 0) {
                            result.add(perm.buildPersistedPublicApiObject());
                        }
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return new ParceledListSlice(result);
    }

    public void clearGrantedUriPermissions(String packageName, int userId) {
        enforceCallingPermission("android.permission.CLEAR_APP_GRANTED_URI_PERMISSIONS", "clearGrantedUriPermissions");
        removeUriPermissionsForPackageLocked(packageName, userId, true);
    }

    public void showWaitingForDebugger(IApplicationThread who, boolean waiting) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                Object app = who != null ? getRecordForAppLocked(who) : null;
                if (app == null) {
                } else {
                    Message msg = Message.obtain();
                    msg.what = 6;
                    msg.obj = app;
                    msg.arg1 = waiting ? 1 : 0;
                    this.mUiHandler.sendMessage(msg);
                    resetPriorityAfterLockedSection();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void getMemoryInfo(ActivityManager.MemoryInfo outInfo) {
        long homeAppMem = this.mProcessList.getMemLevel(600);
        long cachedAppMem = this.mProcessList.getMemLevel(900);
        outInfo.availMem = Process.getFreeMemory();
        outInfo.totalMem = Process.getTotalMemory();
        outInfo.threshold = homeAppMem;
        outInfo.lowMemory = outInfo.availMem < ((cachedAppMem - homeAppMem) / 2) + homeAppMem;
        outInfo.hiddenAppThreshold = cachedAppMem;
        outInfo.secondaryServerThreshold = this.mProcessList.getMemLevel(500);
        outInfo.visibleAppThreshold = this.mProcessList.getMemLevel(100);
        outInfo.foregroundAppThreshold = this.mProcessList.getMemLevel(0);
    }

    public List<IBinder> getAppTasks(String callingPackage) {
        ArrayList<IBinder> list;
        int callingUid = Binder.getCallingUid();
        long ident = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                list = new ArrayList();
                int N = this.mRecentTasks.size();
                for (int i = 0; i < N; i++) {
                    TaskRecord tr = (TaskRecord) this.mRecentTasks.get(i);
                    if (tr.effectiveUid == callingUid) {
                        Intent intent = tr.getBaseIntent();
                        if (intent != null && (callingPackage.equals(intent.getComponent().getPackageName()) ^ 1) == 0) {
                            list.add(new AppTaskImpl(createRecentTaskInfoFromTaskRecord(tr).persistentId, callingUid).asBinder());
                        }
                    }
                }
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
        return list;
    }

    public List<RunningTaskInfo> getTasks(int maxNum, int flags) {
        int callingUid = Binder.getCallingUid();
        ArrayList<RunningTaskInfo> list = new ArrayList();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mStackSupervisor.getTasksLocked(maxNum, list, callingUid, isGetTasksAllowed("getTasks", Binder.getCallingPid(), callingUid));
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return list;
    }

    private RecentTaskInfo createRecentTaskInfoFromTaskRecord(TaskRecord tr) {
        ComponentName component;
        ComponentName componentName = null;
        tr.updateTaskDescription();
        RecentTaskInfo rti = new RecentTaskInfo();
        rti.id = tr.getTopActivity() == null ? -1 : tr.taskId;
        rti.persistentId = tr.taskId;
        rti.baseIntent = new Intent(tr.getBaseIntent());
        rti.origActivity = tr.origActivity;
        rti.realActivity = tr.realActivity;
        rti.description = tr.lastDescription;
        rti.stackId = tr.getStackId();
        rti.userId = tr.userId;
        rti.taskDescription = new TaskDescription(tr.lastTaskDescription);
        rti.firstActiveTime = tr.firstActiveTime;
        rti.lastActiveTime = tr.lastActiveTime;
        rti.affiliatedTaskId = tr.mAffiliatedTaskId;
        rti.affiliatedTaskColor = tr.mAffiliatedTaskColor;
        rti.numActivities = 0;
        if (tr.mBounds != null) {
            rti.bounds = new Rect(tr.mBounds);
        }
        rti.supportsSplitScreenMultiWindow = tr.supportsSplitScreen();
        rti.resizeMode = tr.mResizeMode;
        ActivityRecord base = null;
        ActivityRecord top = null;
        for (int i = tr.mActivities.size() - 1; i >= 0; i--) {
            ActivityRecord tmp = (ActivityRecord) tr.mActivities.get(i);
            if (!tmp.finishing) {
                base = tmp;
                if (top == null || top.state == ActivityState.INITIALIZING) {
                    top = tmp;
                }
                rti.numActivities++;
            }
        }
        if (base != null) {
            component = base.intent.getComponent();
        } else {
            component = null;
        }
        rti.baseActivity = component;
        if (top != null) {
            componentName = top.intent.getComponent();
        }
        rti.topActivity = componentName;
        return rti;
    }

    private boolean isGetTasksAllowed(String caller, int callingPid, int callingUid) {
        boolean allowed = checkPermission("android.permission.REAL_GET_TASKS", callingPid, callingUid) == 0;
        if (!allowed && checkPermission("android.permission.GET_TASKS", callingPid, callingUid) == 0) {
            try {
                if (AppGlobals.getPackageManager().isUidPrivileged(callingUid)) {
                    allowed = true;
                    if (ActivityManagerDebugConfig.DEBUG_TASKS) {
                        Slog.w(TAG, caller + ": caller " + callingUid + " is using old GET_TASKS but privileged; allowing");
                    }
                }
            } catch (RemoteException e) {
            }
        }
        if (!allowed && ActivityManagerDebugConfig.DEBUG_TASKS) {
            Slog.w(TAG, caller + ": caller " + callingUid + " does not hold REAL_GET_TASKS; limiting output");
        }
        return allowed;
    }

    public ParceledListSlice<RecentTaskInfo> getRecentTasks(int maxNum, int flags, int userId) {
        ParceledListSlice<RecentTaskInfo> parceledListSlice;
        int callingUid = Binder.getCallingUid();
        userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), callingUid, userId, false, 2, "getRecentTasks", null);
        boolean includeProfiles = (flags & 4) != 0;
        boolean withExcluded = (flags & 1) != 0;
        if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
            Slog.d(TAG_RECENTS, "includeProfiles: " + includeProfiles + " withExcluded " + withExcluded + " maxNum " + maxNum + " userId " + userId + " " + Debug.getCallers(4));
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                boolean allowed = isGetTasksAllowed("getRecentTasks", Binder.getCallingPid(), callingUid);
                boolean detailed = checkCallingPermission("android.permission.GET_DETAILED_TASKS") == 0;
                if (isUserRunning(userId, 4)) {
                    int i;
                    Set<Integer> includedUsers;
                    this.mRecentTasks.loadUserRecentsLocked(userId);
                    int recentsCount = this.mRecentTasks.size();
                    if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                        Slog.d(TAG_RECENTS, "allowed: " + allowed + " detailed " + detailed + " recentsCount " + recentsCount);
                    }
                    if (maxNum < recentsCount) {
                        i = maxNum;
                    } else {
                        i = recentsCount;
                    }
                    ArrayList<RecentTaskInfo> arrayList = new ArrayList(i);
                    if (includeProfiles) {
                        includedUsers = this.mUserController.getProfileIds(userId);
                    } else {
                        includedUsers = new HashSet();
                    }
                    includedUsers.add(Integer.valueOf(userId));
                    OppoMultiAppManager.getInstance().inRecentTask(includedUsers);
                    for (int i2 = 0; i2 < recentsCount && maxNum > 0; i2++) {
                        TaskRecord tr = (TaskRecord) this.mRecentTasks.get(i2);
                        if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                            Slog.d(TAG_RECENTS, "getRecentTasks tr: " + tr);
                        }
                        if (includedUsers.contains(Integer.valueOf(tr.userId))) {
                            if (!tr.realActivitySuspended) {
                                if (!(i2 == 0 || withExcluded)) {
                                    if (!(tr.intent == null || (tr.intent.getFlags() & DumpState.DUMP_VOLUMES) == 0)) {
                                    }
                                }
                                if (allowed || tr.isHomeTask() || tr.effectiveUid == callingUid) {
                                    ActivityStack stack = tr.getStack();
                                    if ((flags & 8) == 0 || stack == null || !stack.isHomeOrRecentsStack()) {
                                        if ((flags & 16) == 0 || stack == null || !stack.isDockedStack() || stack.topTask() != tr) {
                                            if ((flags & 32) == 0 || stack == null || !stack.isPinnedStack()) {
                                                if (stack == null || stack.mStackId != 7) {
                                                    if (tr.autoRemoveRecents && tr.getTopActivity() == null) {
                                                        if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                                                            Slog.d(TAG_RECENTS, "Skipping, auto-remove without activity: " + tr);
                                                        }
                                                    } else if ((flags & 2) == 0 || (tr.isAvailable ^ 1) == 0) {
                                                        if (tr.mUserSetupComplete || tr.userId == OppoMultiAppManager.USER_ID) {
                                                            if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                                                                Slog.d(TAG_RECENTS, "after skip id: " + tr.taskId + " tr " + tr);
                                                            }
                                                            RecentTaskInfo rti = createRecentTaskInfoFromTaskRecord(tr);
                                                            if (!detailed) {
                                                                rti.baseIntent.replaceExtras((Bundle) null);
                                                            }
                                                            arrayList.add(rti);
                                                            maxNum--;
                                                        } else if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                                                            Slog.d(TAG_RECENTS, "Skipping, user setup not complete: " + tr);
                                                        }
                                                    } else if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                                                        Slog.d(TAG_RECENTS, "Skipping, unavail real act: " + tr);
                                                    }
                                                } else if (NeuronSystemManager.LOG_ON) {
                                                    Slog.d("NeuronSystem", "task is preload, so do not show in recent view");
                                                }
                                            } else if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                                                Slog.d(TAG_RECENTS, "Skipping, pinned stack task: " + tr);
                                            }
                                        } else if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                                            Slog.d(TAG_RECENTS, "Skipping, top task in docked stack: " + tr);
                                        }
                                    } else if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                                        Slog.d(TAG_RECENTS, "Skipping, home or recents stack task: " + tr);
                                    }
                                } else if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                                    Slog.d(TAG_RECENTS, "Skipping, not allowed: " + tr);
                                }
                            } else if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                                Slog.d(TAG_RECENTS, "Skipping, activity suspended: " + tr);
                            }
                        } else if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                            Slog.d(TAG_RECENTS, "Skipping, not user: " + tr);
                        }
                    }
                    parceledListSlice = new ParceledListSlice(arrayList);
                    resetPriorityAfterLockedSection();
                    return parceledListSlice;
                }
                Slog.i(TAG, "user " + userId + " is still locked. Cannot load recents");
                parceledListSlice = ParceledListSlice.emptyList();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return parceledListSlice;
    }

    public TaskThumbnail getTaskThumbnail(int id) {
        TaskThumbnail taskThumbnailLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                enforceCallingPermission("android.permission.READ_FRAME_BUFFER", "getTaskThumbnail()");
                TaskRecord tr = this.mStackSupervisor.anyTaskForIdLocked(id, 1, -1);
                if (ActivityManagerDebugConfig.DEBUG_RECENTS) {
                    Slog.d(TAG_RECENTS, "getTaskThumbnail id: " + id + " tr " + tr + " " + Debug.getCallers(4));
                }
                if (tr != null) {
                    taskThumbnailLocked = tr.getTaskThumbnailLocked();
                } else {
                    resetPriorityAfterLockedSection();
                    return null;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return taskThumbnailLocked;
    }

    public TaskDescription getTaskDescription(int id) {
        TaskDescription taskDescription;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "getTaskDescription()");
                TaskRecord tr = this.mStackSupervisor.anyTaskForIdLocked(id, 1, -1);
                if (tr != null) {
                    taskDescription = tr.lastTaskDescription;
                } else {
                    resetPriorityAfterLockedSection();
                    return null;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return taskDescription;
    }

    public int addAppTask(IBinder activityToken, Intent intent, TaskDescription description, Bitmap thumbnail) throws RemoteException {
        int callingUid = Binder.getCallingUid();
        long callingIdent = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(activityToken);
                if (r == null) {
                    throw new IllegalArgumentException("Activity does not exist; token=" + activityToken);
                }
                ComponentName comp = intent.getComponent();
                if (comp == null) {
                    throw new IllegalArgumentException("Intent " + intent + " must specify explicit component");
                } else if (thumbnail.getWidth() == this.mThumbnailWidth && thumbnail.getHeight() == this.mThumbnailHeight) {
                    if (intent.getSelector() != null) {
                        intent.setSelector(null);
                    }
                    if (intent.getSourceBounds() != null) {
                        intent.setSourceBounds(null);
                    }
                    if ((intent.getFlags() & DumpState.DUMP_FROZEN) != 0 && (intent.getFlags() & 8192) == 0) {
                        intent.addFlags(8192);
                    }
                    if (!(comp.equals(this.mLastAddedTaskComponent) && callingUid == this.mLastAddedTaskUid)) {
                        this.mLastAddedTaskActivity = null;
                    }
                    ActivityInfo ainfo = this.mLastAddedTaskActivity;
                    if (ainfo == null) {
                        ainfo = AppGlobals.getPackageManager().getActivityInfo(comp, 0, UserHandle.getUserId(callingUid));
                        this.mLastAddedTaskActivity = ainfo;
                        if (ainfo.applicationInfo.uid != callingUid) {
                            throw new SecurityException("Can't add task for another application: target uid=" + ainfo.applicationInfo.uid + ", calling uid=" + callingUid);
                        }
                    }
                    TaskRecord task = new TaskRecord(this, this.mStackSupervisor.getNextTaskIdForUserLocked(r.userId), ainfo, intent, description, new TaskThumbnailInfo());
                    if (this.mRecentTasks.trimForTaskLocked(task, false) >= 0) {
                        resetPriorityAfterLockedSection();
                        Binder.restoreCallingIdentity(callingIdent);
                        return -1;
                    }
                    int N = this.mRecentTasks.size();
                    if (N >= ActivityManager.getMaxRecentTasksStatic() - 1) {
                        ((TaskRecord) this.mRecentTasks.remove(N - 1)).removedFromRecents();
                    }
                    task.inRecents = true;
                    this.mRecentTasks.add(task);
                    r.getStack().addTask(task, false, "addAppTask");
                    task.setLastThumbnailLocked(thumbnail);
                    task.freeLastThumbnail();
                    int i = task.taskId;
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(callingIdent);
                    return i;
                } else {
                    throw new IllegalArgumentException("Bad thumbnail size: got " + thumbnail.getWidth() + "x" + thumbnail.getHeight() + ", require " + this.mThumbnailWidth + "x" + this.mThumbnailHeight);
                }
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(callingIdent);
        }
    }

    public Point getAppTaskThumbnailSize() {
        Point point;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                point = new Point(this.mThumbnailWidth, this.mThumbnailHeight);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return point;
    }

    public void setTaskDescription(IBinder token, TaskDescription td) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    r.setTaskDescription(td);
                    TaskRecord task = r.getTask();
                    task.updateTaskDescription();
                    this.mTaskChangeNotificationController.notifyTaskDescriptionChanged(task.taskId, td);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void setTaskResizeable(int taskId, int resizeableMode) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId, 1, -1);
                if (task == null) {
                    Slog.w(TAG, "setTaskResizeable: taskId=" + taskId + " not found");
                } else {
                    task.setResizeMode(resizeableMode);
                    resetPriorityAfterLockedSection();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void resizeTask(int taskId, Rect bounds, int resizeMode) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "resizeTask()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task == null) {
                    Slog.w(TAG, "resizeTask: taskId=" + taskId + " not found");
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(ident);
                    return;
                }
                int stackId = task.getStackId();
                if (!StackId.isTaskResizeAllowed(stackId)) {
                    Slog.e(TAG, "resizeTask not allowed on task=" + task);
                }
                if (bounds == null && stackId == 2) {
                    stackId = 1;
                } else if (!(bounds == null || stackId == 2)) {
                    stackId = 2;
                }
                boolean preserveWindow = (resizeMode & 1) != 0;
                if (stackId != task.getStackId()) {
                    task.reparent(stackId, true, 1, true, true, "resizeTask");
                    preserveWindow = false;
                }
                task.resize(bounds, resizeMode, preserveWindow, false);
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(ident);
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public Rect getTaskBounds(int taskId) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "getTaskBounds()");
        long ident = Binder.clearCallingIdentity();
        Rect rect = new Rect();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId, 1, -1);
                if (task == null) {
                    Slog.w(TAG, "getTaskBounds: taskId=" + taskId + " not found");
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(ident);
                    return rect;
                }
                if (task.getStack() != null) {
                    task.getWindowContainerBounds(rect);
                } else if (task.mBounds != null) {
                    rect.set(task.mBounds);
                } else if (task.mLastNonFullscreenBounds != null) {
                    rect.set(task.mLastNonFullscreenBounds);
                }
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(ident);
                return rect;
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void cancelTaskWindowTransition(int taskId) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "cancelTaskWindowTransition()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId, 0, -1);
                if (task == null) {
                    Slog.w(TAG, "cancelTaskWindowTransition: taskId=" + taskId + " not found");
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(ident);
                    return;
                }
                task.cancelWindowTransition();
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(ident);
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void cancelTaskThumbnailTransition(int taskId) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "cancelTaskThumbnailTransition()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId, 0, -1);
                if (task == null) {
                    Slog.w(TAG, "cancelTaskThumbnailTransition: taskId=" + taskId + " not found");
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(ident);
                    return;
                }
                task.cancelThumbnailTransition();
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(ident);
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public TaskSnapshot getTaskSnapshot(int taskId, boolean reducedResolution) {
        enforceCallingPermission("android.permission.READ_FRAME_BUFFER", "getTaskSnapshot()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId, 1, -1);
                if (task == null) {
                    Slog.w(TAG, "getTaskSnapshot: taskId=" + taskId + " not found");
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(ident);
                    return null;
                }
                resetPriorityAfterLockedSection();
                TaskSnapshot snapshot = task.getSnapshot(reducedResolution);
                Binder.restoreCallingIdentity(ident);
                return snapshot;
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public Bitmap getTaskDescriptionIcon(String filePath, int userId) {
        if (userId != UserHandle.getCallingUserId()) {
            enforceCallingPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "getTaskDescriptionIcon");
        }
        if (new File(TaskPersister.getUserImagesDir(userId), new File(filePath).getName()).getPath().equals(filePath) && (filePath.contains("_activity_icon_") ^ 1) == 0) {
            return this.mRecentTasks.getTaskDescriptionIcon(filePath);
        }
        throw new IllegalArgumentException("Bad file path: " + filePath + " passed for userId " + userId);
    }

    public void startInPlaceAnimationOnFrontMostApplication(Bundle opts) throws RemoteException {
        ActivityOptions activityOptions = ActivityOptions.fromBundle(opts);
        if (activityOptions.getAnimationType() != 10 || activityOptions.getCustomInPlaceResId() == 0) {
            throw new IllegalArgumentException("Expected in-place ActivityOption with valid animation");
        }
        this.mWindowManager.prepareAppTransition(17, false);
        this.mWindowManager.overridePendingAppTransitionInPlace(activityOptions.getPackageName(), activityOptions.getCustomInPlaceResId());
        this.mWindowManager.executeAppTransition();
    }

    private void removeTasksByPackageNameLocked(String packageName, int userId) {
        for (int i = this.mRecentTasks.size() - 1; i >= 0; i--) {
            TaskRecord tr = (TaskRecord) this.mRecentTasks.get(i);
            if (tr.userId == userId) {
                ComponentName cn = tr.intent.getComponent();
                if (cn != null && cn.getPackageName().equals(packageName)) {
                    this.mStackSupervisor.removeTaskByIdLocked(tr.taskId, true, true);
                }
            }
        }
    }

    private void cleanupDisabledPackageTasksLocked(String packageName, Set<String> filterByClasses, int userId) {
        for (int i = this.mRecentTasks.size() - 1; i >= 0; i--) {
            TaskRecord tr = (TaskRecord) this.mRecentTasks.get(i);
            if (userId == -1 || tr.userId == userId) {
                ComponentName cn = tr.intent.getComponent();
                boolean sameComponent = (cn == null || !cn.getPackageName().equals(packageName)) ? false : filterByClasses != null ? filterByClasses.contains(cn.getClassName()) : true;
                if (sameComponent) {
                    this.mStackSupervisor.removeTaskByIdLocked(tr.taskId, false, true);
                }
            }
        }
    }

    public void removeStack(int stackId) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "removeStack()");
        if (StackId.isHomeOrRecentsStack(stackId)) {
            throw new IllegalArgumentException("Removing home or recents stack is not allowed.");
        }
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                this.mStackSupervisor.removeStackLocked(stackId);
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void moveStackToDisplay(int stackId, int displayId) {
        enforceCallingPermission("android.permission.INTERNAL_SYSTEM_WINDOW", "moveStackToDisplay()");
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                if (ActivityManagerDebugConfig.DEBUG_STACK) {
                    Slog.d(TAG_STACK, "moveStackToDisplay: moving stackId=" + stackId + " to displayId=" + displayId);
                }
                this.mStackSupervisor.moveStackToDisplayLocked(stackId, displayId, true);
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public boolean removeTask(int taskId) {
        boolean z = true;
        enforceCallingPermission("android.permission.REMOVE_TASKS", "removeTask()");
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                if (taskId == -1) {
                    if (this.mRecentTasks != null) {
                        List<String> protectList = new ArrayList();
                        int N = this.mRecentTasks.size();
                        int num = N > 2 ? 2 : N;
                        ComponentName topCpn = getTopAppName();
                        if (!(topCpn == null || topCpn.getPackageName() == null)) {
                            protectList.add(topCpn.getPackageName());
                        }
                        for (int i = 0; i < num; i++) {
                            TaskRecord record = (TaskRecord) this.mRecentTasks.get(i);
                            if (!(record == null || record.getBaseIntent() == null || record.getBaseIntent().getComponent() == null)) {
                                String pkgName = record.getBaseIntent().getComponent().getPackageName();
                                if (!(pkgName == null || (pkgName.equals("com.coloros.recents") ^ 1) == 0)) {
                                    protectList.add(pkgName);
                                }
                            }
                        }
                        if (forceTrimMemory(80, protectList) != 0) {
                            z = false;
                        }
                        Binder.restoreCallingIdentity(ident);
                        resetPriorityAfterLockedSection();
                        return z;
                    }
                }
                z = this.mStackSupervisor.removeTaskByIdLocked(taskId, true, true);
                Binder.restoreCallingIdentity(ident);
                resetPriorityAfterLockedSection();
                return z;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void moveTaskToFront(int taskId, int flags, Bundle bOptions) {
        enforceCallingPermission("android.permission.REORDER_TASKS", "moveTaskToFront()");
        if (ActivityManagerDebugConfig.DEBUG_STACK) {
            Slog.d(TAG_STACK, "moveTaskToFront: moving taskId=" + taskId);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                moveTaskToFrontLocked(taskId, flags, bOptions, false);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    void moveTaskToFrontLocked(int taskId, int flags, Bundle bOptions, boolean fromRecents) {
        ActivityOptions options = ActivityOptions.fromBundle(bOptions);
        if (checkAppSwitchAllowedLocked(Binder.getCallingPid(), Binder.getCallingUid(), -1, -1, "Task to front")) {
            long origId = Binder.clearCallingIdentity();
            try {
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task == null) {
                    Slog.d(TAG, "Could not find task for id: " + taskId);
                } else if (this.mStackSupervisor.isLockTaskModeViolation(task)) {
                    this.mStackSupervisor.showLockTaskToast();
                    Slog.e(TAG, "moveTaskToFront: Attempt to violate Lock Task Mode");
                    Binder.restoreCallingIdentity(origId);
                } else {
                    ActivityRecord prev = this.mStackSupervisor.topRunningActivityLocked();
                    if (prev != null) {
                        task.setTaskToReturnTo(prev);
                    }
                    this.mStackSupervisor.findTaskToMoveToFrontLocked(task, flags, options, "moveTaskToFront", false);
                    ActivityRecord topActivity = task.getTopActivity();
                    if (topActivity != null) {
                        topActivity.showStartingWindow(null, false, true, fromRecents);
                    }
                    Binder.restoreCallingIdentity(origId);
                    ActivityOptions.abort(options);
                }
            } finally {
                Binder.restoreCallingIdentity(origId);
            }
        } else {
            ActivityOptions.abort(options);
        }
    }

    public boolean moveActivityTaskToBack(IBinder token, boolean nonRoot) {
        enforceNotIsolatedCaller("moveActivityTaskToBack");
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                origId = Binder.clearCallingIdentity();
                int taskId = ActivityRecord.getTaskForActivityLocked(token, nonRoot ^ 1);
                if (this.mStackSupervisor.anyTaskForIdLocked(taskId) != null) {
                    ActivityRecord mFocusedActivity = this.mStackSupervisor.getResumedActivityLocked();
                    if (mFocusedActivity != null && OppoSplitWindowAppReader.isInTwoSecond()) {
                        Slog.d(TAG, "back_key movetask: " + mFocusedActivity.packageName + " userId " + mFocusedActivity.userId);
                        this.mHandler.removeMessages(START_FORCESTOP_MSG, mFocusedActivity.packageName);
                        this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(START_FORCESTOP_MSG, mFocusedActivity.userId, -1, mFocusedActivity.packageName), 1000);
                    }
                    boolean moveTaskToBackLocked = ActivityRecord.getStackLocked(token).moveTaskToBackLocked(taskId);
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return moveTaskToBackLocked;
                }
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
                return false;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void moveTaskBackwards(int task) {
        enforceCallingPermission("android.permission.REORDER_TASKS", "moveTaskBackwards()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (checkAppSwitchAllowedLocked(Binder.getCallingPid(), Binder.getCallingUid(), -1, -1, "Task backwards")) {
                    long origId = Binder.clearCallingIdentity();
                    moveTaskBackwardsLocked(task);
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private final void moveTaskBackwardsLocked(int task) {
        Slog.e(TAG, "moveTaskBackwards not yet implemented!");
    }

    public int createStackOnDisplay(int displayId) throws RemoteException {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "createStackOnDisplay()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = this.mStackSupervisor.createStackOnDisplay(this.mStackSupervisor.getNextStackId(), displayId, true);
                if (stack != null) {
                    int i = stack.mStackId;
                    resetPriorityAfterLockedSection();
                    return i;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return -1;
    }

    public int getActivityDisplayId(IBinder activityToken) throws RemoteException {
        int i;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(activityToken);
                if (stack == null || stack.mDisplayId == -1) {
                    resetPriorityAfterLockedSection();
                    return 0;
                }
                i = stack.mDisplayId;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return i;
    }

    public int getActivityStackId(IBinder token) throws RemoteException {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                if (stack != null) {
                    int i = stack.mStackId;
                    resetPriorityAfterLockedSection();
                    return i;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return -1;
    }

    public void exitFreeformMode(IBinder token) throws RemoteException {
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                ActivityRecord r = ActivityRecord.forTokenLocked(token);
                if (r == null) {
                    throw new IllegalArgumentException("exitFreeformMode: No activity record matching token=" + token);
                }
                ActivityStack stack = r.getStack();
                if (stack == null || stack.mStackId != 2) {
                    throw new IllegalStateException("exitFreeformMode: You can only go fullscreen from freeform.");
                }
                if (ActivityManagerDebugConfig.DEBUG_STACK) {
                    Slog.d(TAG_STACK, "exitFreeformMode: " + r);
                }
                this.mWindowManager.startFreezingScreen(0, 0);
                r.getTask().reparent(1, true, 1, true, false, "exitFreeformMode");
                this.mWindowManager.stopFreezingScreen();
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void moveTaskToStack(int taskId, int stackId, boolean toTop) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "moveTaskToStack()");
        if (StackId.isHomeOrRecentsStack(stackId)) {
            throw new IllegalArgumentException("moveTaskToStack: Attempt to move task " + taskId + " to stack " + stackId);
        }
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task == null) {
                    Slog.w(TAG, "moveTaskToStack: No task for id=" + taskId);
                    Binder.restoreCallingIdentity(ident);
                    resetPriorityAfterLockedSection();
                    return;
                }
                if (ActivityManagerDebugConfig.DEBUG_STACK) {
                    Slog.d(TAG_STACK, "moveTaskToStack: moving task=" + taskId + " to stackId=" + stackId + " toTop=" + toTop);
                }
                if (stackId == 3) {
                    this.mWindowManager.setDockedStackCreateState(0, null);
                }
                task.reparent(stackId, toTop, 1, true, false, "moveTaskToStack");
                Binder.restoreCallingIdentity(ident);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void swapDockedAndFullscreenStack() throws RemoteException {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "swapDockedAndFullscreenStack()");
        synchronized (this) {
            long ident;
            try {
                TaskRecord topTask;
                ArrayList tasks;
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                ActivityStack fullscreenStack = this.mStackSupervisor.getStack(1);
                if (fullscreenStack != null) {
                    topTask = fullscreenStack.topTask();
                } else {
                    topTask = null;
                }
                ActivityStack dockedStack = this.mStackSupervisor.getStack(3);
                if (dockedStack != null) {
                    tasks = dockedStack.getAllTasks();
                } else {
                    tasks = null;
                }
                if (!(topTask == null || tasks == null)) {
                    if (tasks.size() != 0) {
                        this.mWindowManager.startFreezingScreen(0, 0);
                        this.mWindowManager.prepareAppTransition(18, false);
                        topTask.reparent(3, true, 1, true, true, "swapDockedAndFullscreenStack - DOCKED_STACK");
                        int size = tasks.size();
                        for (int i = 0; i < size; i++) {
                            if (((TaskRecord) tasks.get(i)).taskId != topTask.taskId) {
                                ((TaskRecord) tasks.get(i)).reparent(1, true, 1, true, true, "swapDockedAndFullscreenStack - FULLSCREEN_STACK");
                            }
                        }
                        this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                        this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
                        this.mWindowManager.executeAppTransition();
                        this.mWindowManager.stopFreezingScreen();
                        Binder.restoreCallingIdentity(ident);
                        resetPriorityAfterLockedSection();
                        return;
                    }
                }
                Slog.w(TAG, "Unable to swap tasks, either docked or fullscreen stack is empty.");
                this.mWindowManager.stopFreezingScreen();
                Binder.restoreCallingIdentity(ident);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public boolean moveTaskToDockedStack(int taskId, int createMode, boolean toTop, boolean animate, Rect initialBounds) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "moveTaskToDockedStack()");
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task == null) {
                    Slog.w(TAG, "moveTaskToDockedStack: No task for id=" + taskId);
                    Binder.restoreCallingIdentity(ident);
                    resetPriorityAfterLockedSection();
                    return false;
                }
                if (ActivityManagerDebugConfig.DEBUG_STACK) {
                    Slog.d(TAG_STACK, "moveTaskToDockedStack: moving task=" + taskId + " to createMode=" + createMode + " toTop=" + toTop);
                }
                this.mWindowManager.setDockedStackCreateState(createMode, initialBounds);
                boolean moved = task.reparent(3, toTop, 1, animate, false, "moveTaskToDockedStack");
                if (moved) {
                    this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                }
                Binder.restoreCallingIdentity(ident);
                resetPriorityAfterLockedSection();
                return moved;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public boolean moveTopActivityToPinnedStack(int stackId, Rect bounds) {
        boolean moveTopStackActivityToPinnedStackLocked;
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "moveTopActivityToPinnedStack()");
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                if (this.mSupportsPictureInPicture) {
                    ident = Binder.clearCallingIdentity();
                    moveTopStackActivityToPinnedStackLocked = this.mStackSupervisor.moveTopStackActivityToPinnedStackLocked(stackId, bounds);
                    Binder.restoreCallingIdentity(ident);
                } else {
                    throw new IllegalStateException("moveTopActivityToPinnedStack:Device doesn't support picture-in-picture mode");
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
        return moveTopStackActivityToPinnedStackLocked;
    }

    public void resizeStack(int stackId, Rect destBounds, boolean allowResizeInDockedMode, boolean preserveWindows, boolean animate, int animationDuration) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "resizeStack()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                if (!animate) {
                    this.mStackSupervisor.resizeStackLocked(stackId, destBounds, null, null, preserveWindows, allowResizeInDockedMode, false);
                } else if (stackId == 4) {
                    PinnedActivityStack pinnedStack = (PinnedActivityStack) this.mStackSupervisor.getStack(4);
                    if (pinnedStack != null) {
                        pinnedStack.animateResizePinnedStack(null, destBounds, animationDuration, false);
                    }
                } else {
                    throw new IllegalArgumentException("Stack: " + stackId + " doesn't support animated resize.");
                }
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(ident);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void resizeDockedStack(Rect dockedBounds, Rect tempDockedTaskBounds, Rect tempDockedTaskInsetBounds, Rect tempOtherTaskBounds, Rect tempOtherTaskInsetBounds) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "resizeDockedStack()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                this.mStackSupervisor.resizeDockedStackLocked(dockedBounds, tempDockedTaskBounds, tempDockedTaskInsetBounds, tempOtherTaskBounds, tempOtherTaskInsetBounds, true);
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(ident);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void resizePinnedStack(Rect pinnedBounds, Rect tempPinnedTaskBounds) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "resizePinnedStack()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                this.mStackSupervisor.resizePinnedStackLocked(pinnedBounds, tempPinnedTaskBounds);
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(ident);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void positionTaskInStack(int taskId, int stackId, int position) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "positionTaskInStack()");
        if (StackId.isHomeOrRecentsStack(stackId)) {
            throw new IllegalArgumentException("positionTaskInStack: Attempt to change the position of task " + taskId + " in/to home/recents stack");
        }
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                if (ActivityManagerDebugConfig.DEBUG_STACK) {
                    Slog.d(TAG_STACK, "positionTaskInStack: positioning task=" + taskId + " in stackId=" + stackId + " at position=" + position);
                }
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task == null) {
                    throw new IllegalArgumentException("positionTaskInStack: no task for id=" + taskId);
                }
                ActivityStack stack = this.mStackSupervisor.getStack(stackId, true, false);
                if (task.getStack() == stack) {
                    stack.positionChildAt(task, position);
                } else {
                    task.reparent(stackId, position, 2, false, false, "positionTaskInStack");
                }
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public List<StackInfo> getAllStackInfos() {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "getAllStackInfos()");
        long ident = Binder.clearCallingIdentity();
        try {
            List allStackInfosLocked;
            synchronized (this) {
                boostPriorityForLockedSection();
                allStackInfosLocked = this.mStackSupervisor.getAllStackInfosLocked();
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(ident);
            return allStackInfosLocked;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public StackInfo getStackInfo(int stackId) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "getStackInfo()");
        long ident = Binder.clearCallingIdentity();
        try {
            StackInfo stackInfoLocked;
            synchronized (this) {
                boostPriorityForLockedSection();
                stackInfoLocked = this.mStackSupervisor.getStackInfoLocked(stackId);
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(ident);
            return stackInfoLocked;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public int getTaskForActivity(IBinder token, boolean onlyRoot) {
        int taskForActivityLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                taskForActivityLocked = ActivityRecord.getTaskForActivityLocked(token, onlyRoot);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return taskForActivityLocked;
    }

    public void updateDeviceOwner(String packageName) {
        int callingUid = Binder.getCallingUid();
        if (callingUid == 0 || callingUid == 1000) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    this.mDeviceOwnerName = packageName;
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return;
        }
        throw new SecurityException("updateDeviceOwner called from non-system process");
    }

    public void updateLockTaskPackages(int userId, String[] packages) {
        int callingUid = Binder.getCallingUid();
        if (!(callingUid == 0 || callingUid == 1000)) {
            enforceCallingPermission("android.permission.UPDATE_LOCK_TASK_PACKAGES", "updateLockTaskPackages()");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (ActivityManagerDebugConfig.DEBUG_LOCKTASK) {
                    Slog.w(TAG_LOCKTASK, "Whitelisting " + userId + ":" + Arrays.toString(packages));
                }
                this.mLockTaskPackages.put(userId, packages);
                this.mStackSupervisor.onLockTaskPackagesUpdatedLocked();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    void startLockTaskModeLocked(TaskRecord task) {
        int i = 1;
        if (ActivityManagerDebugConfig.DEBUG_LOCKTASK) {
            Slog.w(TAG_LOCKTASK, "startLockTaskModeLocked: " + task);
        }
        if (task.mLockTaskAuth != 0) {
            if (((PinnedActivityStack) this.mStackSupervisor.getStack(4)) != null) {
                this.mStackSupervisor.removeStackLocked(4);
            }
            int callingUid = Binder.getCallingUid();
            boolean isSystemInitiated = callingUid == 1000;
            long ident = Binder.clearCallingIdentity();
            try {
                String pkg;
                synchronized (this) {
                    boostPriorityForLockedSection();
                    pkg = task.intent.getComponent().getPackageName();
                }
                resetPriorityAfterLockedSection();
                if (pkg != null && pkg.equals("com.android.cts.verifier")) {
                    Slog.v(TAG, "let the com.android.cts.verifier pass this!");
                } else if (!isSystemInitiated) {
                    task.mLockTaskUid = callingUid;
                    if (task.mLockTaskAuth == 1) {
                        if (ActivityManagerDebugConfig.DEBUG_LOCKTASK) {
                            Slog.w(TAG_LOCKTASK, "Mode default, asking user");
                        }
                        StatusBarManagerInternal statusBarManager = (StatusBarManagerInternal) LocalServices.getService(StatusBarManagerInternal.class);
                        if (statusBarManager != null) {
                            statusBarManager.showScreenPinningRequest(task.taskId);
                        }
                        Binder.restoreCallingIdentity(ident);
                        return;
                    }
                    ActivityStack stack = this.mStackSupervisor.getFocusedStack();
                    if (stack == null || task != stack.topTask()) {
                        throw new IllegalArgumentException("Invalid task, not in foreground");
                    }
                }
                if (ActivityManagerDebugConfig.DEBUG_LOCKTASK) {
                    String str;
                    String str2 = TAG_LOCKTASK;
                    if (isSystemInitiated) {
                        str = "Locking pinned";
                    } else {
                        str = "Locking fully";
                    }
                    Slog.w(str2, str);
                }
                ActivityStackSupervisor activityStackSupervisor = this.mStackSupervisor;
                if (isSystemInitiated) {
                    i = 2;
                }
                activityStackSupervisor.setLockTaskModeLocked(task, i, "startLockTask", true);
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(ident);
            }
        }
    }

    public void startLockTaskModeById(int taskId) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task != null) {
                    startLockTaskModeLocked(task);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void startLockTaskModeByToken(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.forTokenLocked(token);
                if (r == null) {
                } else {
                    TaskRecord task = r.getTask();
                    if (task != null) {
                        startLockTaskModeLocked(task);
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void startSystemLockTaskMode(int taskId) throws RemoteException {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "startSystemLockTaskMode");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                startLockTaskModeById(taskId);
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(ident);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void stopLockTaskMode() {
        TaskRecord lockTask = this.mStackSupervisor.getLockedTaskLocked();
        if (lockTask != null) {
            int callingUid = Binder.getCallingUid();
            int lockTaskUid = lockTask.mLockTaskUid;
            if (this.mStackSupervisor.getLockTaskModeState() != 0) {
                if (checkCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS") == 0 || callingUid == lockTaskUid || (lockTaskUid == 0 && callingUid == lockTask.effectiveUid)) {
                    long ident = Binder.clearCallingIdentity();
                    try {
                        Log.d(TAG, "stopLockTaskMode");
                        synchronized (this) {
                            boostPriorityForLockedSection();
                            this.mStackSupervisor.setLockTaskModeLocked(null, 0, "stopLockTask", true);
                        }
                        resetPriorityAfterLockedSection();
                        TelecomManager tm = (TelecomManager) this.mContext.getSystemService("telecom");
                        if (tm != null) {
                            tm.showInCallScreen(false);
                        }
                        Binder.restoreCallingIdentity(ident);
                    } catch (Throwable th) {
                        Binder.restoreCallingIdentity(ident);
                    }
                } else {
                    throw new SecurityException("Invalid uid, expected " + lockTaskUid + " callingUid=" + callingUid + " effectiveUid=" + lockTask.effectiveUid);
                }
            }
        }
    }

    public void stopSystemLockTaskMode() throws RemoteException {
        if (this.mStackSupervisor.getLockTaskModeState() == 2) {
            stopLockTaskMode();
        } else {
            this.mStackSupervisor.showLockTaskToast();
        }
    }

    public boolean isInLockTaskMode() {
        return getLockTaskModeState() != 0;
    }

    public int getLockTaskModeState() {
        int lockTaskModeState;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                lockTaskModeState = this.mStackSupervisor.getLockTaskModeState();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return lockTaskModeState;
    }

    public void showLockTaskEscapeMessage(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.forTokenLocked(token);
                if (r == null) {
                } else {
                    this.mStackSupervisor.showLockTaskEscapeMessageLocked(r.getTask());
                    resetPriorityAfterLockedSection();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void setDisablePreviewScreenshots(IBinder token, boolean disable) throws RemoteException {
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    Slog.w(TAG, "setDisablePreviewScreenshots: Unable to find activity for token=" + token);
                    resetPriorityAfterLockedSection();
                    return;
                }
                origId = Binder.clearCallingIdentity();
                r.setDisablePreviewScreenshots(disable);
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private final List<ProviderInfo> generateApplicationProvidersLocked(ProcessRecord app) {
        List<ProviderInfo> providers = null;
        try {
            providers = AppGlobals.getPackageManager().queryContentProviders(app.processName, app.uid, 268438528, null).getList();
        } catch (RemoteException e) {
        }
        if (ActivityManagerDebugConfig.DEBUG_MU) {
            Slog.v(TAG_MU, "generateApplicationProvidersLocked, app.info.uid = " + app.uid);
        }
        int userId = app.userId;
        if (providers != null) {
            int N = providers.size();
            app.pubProviders.ensureCapacity(app.pubProviders.size() + N);
            int i = 0;
            while (i < N) {
                ProviderInfo cpi = (ProviderInfo) providers.get(i);
                boolean singleton = isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags);
                if (!singleton || UserHandle.getUserId(app.uid) == 0) {
                    ComponentName comp = new ComponentName(cpi.packageName, cpi.name);
                    ContentProviderRecord cpr = this.mProviderMap.getProviderByClass(comp, userId);
                    if (cpr == null) {
                        cpr = new ContentProviderRecord(this, cpi, app.info, comp, singleton);
                        this.mProviderMap.putProviderByClass(comp, cpr);
                    }
                    if (ActivityManagerDebugConfig.DEBUG_MU) {
                        Slog.v(TAG_MU, "generateApplicationProvidersLocked, cpi.uid = " + cpr.uid);
                    }
                    app.pubProviders.put(cpi.name, cpr);
                    if (!(cpi.multiprocess && ("android".equals(cpi.packageName) ^ 1) == 0)) {
                        app.addPackage(cpi.applicationInfo.packageName, cpi.applicationInfo.versionCode, this.mProcessStats);
                    }
                    notifyPackageUse(cpi.applicationInfo.packageName, 4);
                } else {
                    providers.remove(i);
                    N--;
                    i--;
                }
                i++;
            }
        }
        return providers;
    }

    public String checkContentProviderAccess(String authority, int userId) {
        if (userId == -1) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", TAG);
            userId = UserHandle.getCallingUserId();
        }
        ProviderInfo cpi = null;
        try {
            cpi = AppGlobals.getPackageManager().resolveContentProvider(authority, 790016, userId);
        } catch (RemoteException e) {
        }
        if (cpi == null) {
            return "Failed to find provider " + authority + " for user " + userId + "; expected to find a valid ContentProvider for this authority";
        }
        ProcessRecord r;
        synchronized (this.mPidsSelfLocked) {
            r = (ProcessRecord) this.mPidsSelfLocked.get(Binder.getCallingPid());
        }
        if (r == null) {
            return "Failed to find PID " + Binder.getCallingPid();
        }
        String checkContentProviderPermissionLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                checkContentProviderPermissionLocked = checkContentProviderPermissionLocked(cpi, r, userId, true);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return checkContentProviderPermissionLocked;
    }

    private final String checkContentProviderPermissionLocked(ProviderInfo cpi, ProcessRecord r, int userId, boolean checkUser) {
        int callingPid = r != null ? r.pid : Binder.getCallingPid();
        int callingUid = r != null ? r.uid : Binder.getCallingUid();
        boolean checkedGrants = false;
        if (checkUser) {
            int tmpTargetUserId = this.mUserController.unsafeConvertIncomingUserLocked(userId);
            if (tmpTargetUserId != UserHandle.getUserId(callingUid)) {
                if (checkAuthorityGrants(callingUid, cpi, tmpTargetUserId, checkUser)) {
                    return null;
                }
                checkedGrants = true;
            }
            userId = this.mUserController.handleIncomingUser(callingPid, callingUid, userId, false, 0, "checkContentProviderPermissionLocked " + cpi.authority, null);
            if (userId != tmpTargetUserId) {
                checkedGrants = false;
            }
        }
        if (checkComponentPermission(cpi.readPermission, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == 0) {
            return null;
        }
        if (checkComponentPermission(cpi.writePermission, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == 0) {
            return null;
        }
        PathPermission[] pps = cpi.pathPermissions;
        if (pps != null) {
            int i = pps.length;
            while (i > 0) {
                i--;
                PathPermission pp = pps[i];
                String pprperm = pp.getReadPermission();
                if (pprperm != null) {
                    if (checkComponentPermission(pprperm, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == 0) {
                        return null;
                    }
                }
                String ppwperm = pp.getWritePermission();
                if (ppwperm != null) {
                    if (checkComponentPermission(ppwperm, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == 0) {
                        return null;
                    }
                }
            }
        }
        if (!checkedGrants && checkAuthorityGrants(callingUid, cpi, userId, checkUser)) {
            return null;
        }
        String suffix;
        if (!cpi.exported) {
            suffix = " that is not exported from UID " + cpi.applicationInfo.uid;
        } else if ("android.permission.MANAGE_DOCUMENTS".equals(cpi.readPermission)) {
            suffix = " requires that you obtain access using ACTION_OPEN_DOCUMENT or related APIs";
        } else {
            suffix = " requires " + cpi.readPermission + " or " + cpi.writePermission;
        }
        StringBuilder append = new StringBuilder().append("Permission Denial: opening provider ").append(cpi.name).append(" from ");
        if (r == null) {
            r = "(null)";
        }
        String msg = append.append(r).append(" (pid=").append(callingPid).append(", uid=").append(callingUid).append(")").append(suffix).toString();
        Slog.w(TAG, msg);
        return msg;
    }

    boolean checkAuthorityGrants(int callingUid, ProviderInfo cpi, int userId, boolean checkUser) {
        ArrayMap<GrantUri, UriPermission> perms = (ArrayMap) this.mGrantedUriPermissions.get(callingUid);
        if (perms != null) {
            for (int i = perms.size() - 1; i >= 0; i--) {
                GrantUri grantUri = (GrantUri) perms.keyAt(i);
                if ((grantUri.sourceUserId == userId || (checkUser ^ 1) != 0) && matchesProvider(grantUri.uri, cpi)) {
                    return true;
                }
            }
        }
        return false;
    }

    boolean matchesProvider(Uri uri, ProviderInfo cpi) {
        String uriAuth = uri.getAuthority();
        String cpiAuth = cpi.authority;
        if (cpiAuth.indexOf(59) == -1) {
            return cpiAuth.equals(uriAuth);
        }
        for (String equals : cpiAuth.split(";")) {
            if (equals.equals(uriAuth)) {
                return true;
            }
        }
        return false;
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "ZhiYong.Lin@Plf.Framework, modify for BPM", property = OppoRomType.ROM)
    ContentProviderConnection incProviderCountLocked(ProcessRecord r, ContentProviderRecord cpr, IBinder externalProcessToken, boolean stable) {
        if (r != null) {
            ContentProviderConnection conn;
            for (int i = 0; i < r.conProviders.size(); i++) {
                conn = (ContentProviderConnection) r.conProviders.get(i);
                if (conn.provider == cpr) {
                    if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                        Slog.v(TAG_PROVIDER, "Adding provider requested by " + r.processName + " from process " + cpr.info.processName + ": " + cpr.name.flattenToShortString() + " scnt=" + conn.stableCount + " uscnt=" + conn.unstableCount);
                    }
                    OppoProcessManagerHelper.resumeProvider(cpr);
                    if (stable) {
                        conn.stableCount++;
                        conn.numStableIncs++;
                    } else {
                        conn.unstableCount++;
                        conn.numUnstableIncs++;
                    }
                    return conn;
                }
            }
            conn = new ContentProviderConnection(cpr, r);
            if (stable) {
                conn.stableCount = 1;
                conn.numStableIncs = 1;
            } else {
                conn.unstableCount = 1;
                conn.numUnstableIncs = 1;
            }
            cpr.connections.add(conn);
            r.conProviders.add(conn);
            startAssociationLocked(r.uid, r.processName, r.curProcState, cpr.uid, cpr.name, cpr.info.processName);
            return conn;
        }
        cpr.addExternalProcessHandleLocked(externalProcessToken);
        return null;
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "ZhiYong.Lin@Plf.Framework, modify for BPM", property = OppoRomType.ROM)
    boolean decProviderCountLocked(ContentProviderConnection conn, ContentProviderRecord cpr, IBinder externalProcessToken, boolean stable) {
        if (conn != null) {
            cpr = conn.provider;
            if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                Slog.v(TAG_PROVIDER, "Removing provider requested by " + conn.client.processName + " from process " + cpr.info.processName + ": " + cpr.name.flattenToShortString() + " scnt=" + conn.stableCount + " uscnt=" + conn.unstableCount);
            }
            OppoProcessManagerHelper.resumeProvider(cpr);
            if (stable) {
                conn.stableCount--;
            } else {
                conn.unstableCount--;
            }
            if (conn.stableCount != 0 || conn.unstableCount != 0) {
                return false;
            }
            cpr.connections.remove(conn);
            conn.client.conProviders.remove(conn);
            if (conn.client.setProcState < 14 && cpr.proc != null) {
                cpr.proc.lastProviderTime = SystemClock.uptimeMillis();
            }
            stopAssociationLocked(conn.client.uid, conn.client.processName, cpr.uid, cpr.name);
            return true;
        }
        cpr.removeExternalProcessHandleLocked(externalProcessToken);
        return false;
    }

    private void checkTime(long startTime, String where) {
        long now = SystemClock.uptimeMillis();
        if (now - startTime > 50) {
            Slog.w(TAG, "Slow operation: " + (now - startTime) + "ms so far, now at " + where);
        }
    }

    boolean isProcessAliveLocked(ProcessRecord proc) {
        boolean z = false;
        if (proc.procStatFile == null) {
            proc.procStatFile = "/proc/" + proc.pid + "/stat";
        }
        this.mProcessStateStatsLongs[0] = 0;
        if (Process.readProcFile(proc.procStatFile, PROCESS_STATE_STATS_FORMAT, null, this.mProcessStateStatsLongs, null)) {
            long state = this.mProcessStateStatsLongs[0];
            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                Slog.d(TAG, "RETRIEVED STATE FOR " + proc.procStatFile + ": " + ((char) ((int) state)));
            }
            if (!(state == 90 || state == 88 || state == 120 || state == 75)) {
                z = true;
            }
            return z;
        }
        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
            Slog.d(TAG, "UNABLE TO RETRIEVE STATE FOR " + proc.procStatFile);
        }
        return false;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "ZhiYong.Lin@Plf.Framework, modify for BPM", property = OppoRomType.ROM)
    private ContentProviderHolder getContentProviderImpl(IApplicationThread caller, String name, IBinder token, boolean stable, int userId) {
        ContentProviderRecord cpr;
        long ident;
        Throwable th;
        Throwable e;
        ContentProviderConnection conn = null;
        ProviderInfo cpi = null;
        synchronized (this) {
            String msg;
            long origId;
            boostPriorityForLockedSection();
            long startTime = SystemClock.uptimeMillis();
            ProcessRecord processRecord = null;
            if (caller != null) {
                processRecord = getRecordForAppLocked(caller);
                if (processRecord == null) {
                    throw new SecurityException("Unable to find app for caller " + caller + " (pid=" + Binder.getCallingPid() + ") when getting content provider " + name);
                }
            }
            boolean checkCrossUser = true;
            checkTime(startTime, "getContentProviderImpl: getProviderByName");
            cpr = this.mProviderMap.getProviderByName(name, userId);
            if (cpr != null && userId == 999) {
                String cprPkgName = "";
                if (cpr.appInfo != null) {
                    cprPkgName = cpr.appInfo.packageName;
                }
                if (!OppoMultiAppManagerUtil.getInstance().isMultiApp(cprPkgName)) {
                    if (DEBUG_COLOROS_AMS) {
                        Slog.v(TAG, "multi app getContentProviderImpl: cpr = " + cpr + "  name = " + name + "  userId = " + userId + "  cprPkgName = " + cprPkgName);
                    }
                    userId = 0;
                    cpr = this.mProviderMap.getProviderByName(name, 0);
                }
            }
            boolean openTraceLog = false;
            if (name != null) {
                if (!name.contains("SafeProvider")) {
                }
                openTraceLog = true;
            }
            if (openTraceLog) {
                Slog.d(TAG, "getContentProviderImpl, cpr:" + cpr + ", name:" + name + " callingPid " + Binder.getCallingPid());
            }
            if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                Throwable trace = new RuntimeException();
                trace.fillInStackTrace();
                Slog.d(TAG, "getContentProviderImpl, cpr:" + cpr, trace);
            }
            if (cpr == null && userId != 0) {
                cpr = this.mProviderMap.getProviderByName(name, 0);
                if (cpr != null) {
                    cpi = cpr.info;
                    if (isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags) && isValidSingletonCall(processRecord.uid, cpi.applicationInfo.uid)) {
                        userId = 0;
                        checkCrossUser = false;
                    } else {
                        cpr = null;
                        cpi = null;
                    }
                }
            }
            if (openTraceLog) {
                Slog.d(TAG, "getContentProviderImpl 02, cpr:" + cpr);
            }
            boolean providerRunning = (cpr == null || cpr.proc == null) ? false : cpr.proc.killed ^ 1;
            if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                Slog.v(TAG_MU, "providerRunning " + providerRunning + " cpr.proc " + (cpr != null ? cpr.proc : null));
            }
            if (providerRunning) {
                cpi = cpr.info;
                checkTime(startTime, "getContentProviderImpl: before checkContentProviderPermission");
                msg = checkContentProviderPermissionLocked(cpi, processRecord, userId, checkCrossUser);
                if (msg != null) {
                    throw new SecurityException(msg);
                }
                checkTime(startTime, "getContentProviderImpl: after checkContentProviderPermission");
                if (processRecord == null || !cpr.canRunHere(processRecord)) {
                    try {
                        if (AppGlobals.getPackageManager().resolveContentProvider(name, 0, userId) == null) {
                            resetPriorityAfterLockedSection();
                            return null;
                        }
                    } catch (RemoteException e2) {
                    }
                    try {
                        origId = Binder.clearCallingIdentity();
                        checkTime(startTime, "getContentProviderImpl: incProviderCountLocked");
                        if (processRecord != null || cpr == null || cpr.proc == null || !OppoProcessManagerHelper.isFrozingByPid(cpr.proc.pid)) {
                            conn = incProviderCountLocked(processRecord, cpr, token, stable);
                            if (conn != null && conn.stableCount + conn.unstableCount == 1 && cpr.proc != null && processRecord.setAdj <= 200) {
                                checkTime(startTime, "getContentProviderImpl: before updateLruProcess");
                                updateLruProcessLocked(cpr.proc, false, null);
                                checkTime(startTime, "getContentProviderImpl: after updateLruProcess");
                            }
                            checkTime(startTime, "getContentProviderImpl: before updateOomAdj");
                            int verifiedAdj = cpr.proc.verifiedAdj;
                            boolean success = updateOomAdjLocked(cpr.proc, true);
                            if (!(!success || verifiedAdj == cpr.proc.setAdj || (isProcessAliveLocked(cpr.proc) ^ 1) == 0)) {
                                success = false;
                            }
                            maybeUpdateProviderUsageStatsLocked(processRecord, cpr.info.packageName, name);
                            checkTime(startTime, "getContentProviderImpl: after updateOomAdj");
                            if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                                Slog.i(TAG_PROVIDER, "Adjust success: " + success);
                            }
                            if (success) {
                                cpr.proc.verifiedAdj = cpr.proc.setAdj;
                            } else {
                                Slog.i(TAG, "Existing provider " + cpr.name.flattenToShortString() + " is crashing; detaching " + processRecord);
                                boolean lastRef = decProviderCountLocked(conn, cpr, token, stable);
                                checkTime(startTime, "getContentProviderImpl: before appDied");
                                appDiedLocked(cpr.proc);
                                checkTime(startTime, "getContentProviderImpl: after appDied");
                                if (lastRef) {
                                    providerRunning = false;
                                    conn = null;
                                } else {
                                    resetPriorityAfterLockedSection();
                                    return null;
                                }
                            }
                            Binder.restoreCallingIdentity(origId);
                        } else {
                            if (DEBUG_COLOROS_AMS) {
                                Log.i(TAG, "skip for suspend app cpr = " + cpr);
                            }
                            resetPriorityAfterLockedSection();
                            return null;
                        }
                    } catch (RemoteException e3) {
                        Binder.restoreCallingIdentity(ident);
                    } catch (Throwable th2) {
                        resetPriorityAfterLockedSection();
                    }
                }
                ContentProviderHolder holder = cpr.newHolder(null);
                holder.provider = null;
                resetPriorityAfterLockedSection();
                return holder;
            }
            if (!providerRunning) {
                try {
                    checkTime(startTime, "getContentProviderImpl: before resolveContentProvider");
                    cpi = AppGlobals.getPackageManager().resolveContentProvider(name, 3072, userId);
                    if (openTraceLog) {
                        Slog.d(TAG, "getContentProviderImpl 03, cpi:" + cpi);
                    }
                    if (cpi != null && userId == 999) {
                        String cpiPkgName = "";
                        if (cpi.applicationInfo != null) {
                            cpiPkgName = cpi.applicationInfo.packageName;
                        }
                        if (!OppoMultiAppManagerUtil.getInstance().isMultiApp(cpiPkgName)) {
                            if (DEBUG_COLOROS_AMS || openTraceLog) {
                                Slog.v(TAG, "multi app getContentProviderImpl: cpi = " + cpi + "  name = " + name + "  userId = " + userId + "  cpiPkgName = " + cpiPkgName);
                            }
                            userId = 0;
                            cpi = AppGlobals.getPackageManager().resolveContentProvider(name, 3072, 0);
                        }
                    }
                    checkTime(startTime, "getContentProviderImpl: after resolveContentProvider");
                } catch (RemoteException e4) {
                }
                if (cpi == null) {
                    resetPriorityAfterLockedSection();
                    return null;
                }
                boolean singleton;
                if (isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags)) {
                    singleton = isValidSingletonCall(processRecord.uid, cpi.applicationInfo.uid);
                } else {
                    singleton = false;
                }
                if (singleton) {
                    userId = 0;
                }
                cpi.applicationInfo = getAppInfoForUser(cpi.applicationInfo, userId);
                checkTime(startTime, "getContentProviderImpl: got app info for user");
                if (openTraceLog) {
                    Slog.d(TAG, "getContentProviderImpl 04, singleton:" + singleton + ", for cpi:" + cpi);
                }
                checkTime(startTime, "getContentProviderImpl: before checkContentProviderPermission");
                msg = checkContentProviderPermissionLocked(cpi, processRecord, userId, singleton ^ 1);
                if (msg != null) {
                    throw new SecurityException(msg);
                }
                checkTime(startTime, "getContentProviderImpl: after checkContentProviderPermission");
                if (!this.mProcessesReady && (cpi.processName.equals("system") ^ 1) != 0) {
                    throw new IllegalArgumentException("Attempt to launch content provider before system ready");
                } else if (this.mUserController.isUserRunningLocked(userId, 0)) {
                    int N;
                    int i;
                    ComponentName comp = new ComponentName(cpi.packageName, cpi.name);
                    checkTime(startTime, "getContentProviderImpl: before getProviderByClass");
                    ContentProviderRecord cpr2 = this.mProviderMap.getProviderByClass(comp, userId);
                    checkTime(startTime, "getContentProviderImpl: after getProviderByClass");
                    boolean firstClass = cpr2 == null;
                    if (firstClass) {
                        ident = Binder.clearCallingIdentity();
                        if (!this.mPermissionReviewRequired || requestTargetProviderPermissionsReviewIfNeededLocked(cpi, processRecord, userId)) {
                            checkTime(startTime, "getContentProviderImpl: before getApplicationInfo");
                            ApplicationInfo ai = AppGlobals.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName, 1024, userId);
                            checkTime(startTime, "getContentProviderImpl: after getApplicationInfo");
                            if (ai == null) {
                                Slog.w(TAG, "No package info for content provider " + cpi.name);
                                Binder.restoreCallingIdentity(ident);
                                resetPriorityAfterLockedSection();
                                return null;
                            }
                            cpr = new ContentProviderRecord(this, cpi, getAppInfoForUser(ai, userId), comp, singleton);
                            Binder.restoreCallingIdentity(ident);
                            checkTime(startTime, "getContentProviderImpl: now have ContentProviderRecord");
                            if (processRecord == null && cpr.canRunHere(processRecord)) {
                                ContentProviderHolder newHolder = cpr.newHolder(null);
                                resetPriorityAfterLockedSection();
                                return newHolder;
                            }
                            if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                                Slog.w(TAG_PROVIDER, "LAUNCHING REMOTE PROVIDER (myuid " + (processRecord != null ? Integer.valueOf(processRecord.uid) : null) + " pruid " + cpr.appInfo.uid + "): " + cpr.info.name + " callers=" + Debug.getCallers(6));
                            }
                            N = this.mLaunchingProviders.size();
                            i = 0;
                            while (i < N && this.mLaunchingProviders.get(i) != cpr) {
                                i++;
                            }
                            if (i >= N) {
                                origId = Binder.clearCallingIdentity();
                                try {
                                    checkTime(startTime, "getContentProviderImpl: before set stopped state");
                                    AppGlobals.getPackageManager().setPackageStoppedState(cpr.appInfo.packageName, false, userId);
                                    checkTime(startTime, "getContentProviderImpl: after set stopped state");
                                } catch (RemoteException e5) {
                                } catch (IllegalArgumentException e6) {
                                    Slog.w(TAG, "Failed trying to unstop package " + cpr.appInfo.packageName + ": " + e6);
                                } catch (Throwable th3) {
                                    th = th3;
                                }
                                checkTime(startTime, "getContentProviderImpl: looking for process record");
                                ProcessRecord proc = getProcessRecordLocked(cpi.processName, cpr.appInfo.uid, false);
                                if (openTraceLog) {
                                    boolean isThreadNull = (proc == null || proc.thread == null) ? false : true;
                                    Slog.d(TAG, "getContentProviderImpl 05, proc for:" + cpi.processName + ", isThreadNull:" + isThreadNull + ", cprUid:" + cpr.appInfo.uid + ", proc:" + proc);
                                }
                                if (proc != null && proc.thread != null && (proc.killed ^ 1) != 0) {
                                    if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                                        Slog.d(TAG_PROVIDER, "Installing in existing process " + proc);
                                    }
                                    if (!proc.pubProviders.containsKey(cpi.name)) {
                                        checkTime(startTime, "getContentProviderImpl: scheduling install");
                                        proc.pubProviders.put(cpi.name, cpr);
                                        try {
                                            if (ActivityManagerDebugConfig.DEBUG_PROVIDER || ActivityManagerDebugConfig.DEBUG_AMS) {
                                                Slog.d(TAG_PROVIDER, "Installing provider " + proc + " cpr " + cpr);
                                            }
                                            proc.thread.scheduleInstallProvider(cpi);
                                        } catch (RemoteException e7) {
                                        }
                                    }
                                } else if (OppoAbnormalAppManager.getInstance().validStartProvider(cpr)) {
                                    Slog.i(OppoAbnormalAppManager.TAG, "UL for provider " + cpr + " : is R");
                                    Binder.restoreCallingIdentity(origId);
                                    resetPriorityAfterLockedSection();
                                    return null;
                                } else if (OppoAppStartupManager.getInstance().handleStartProvider(cpr, processRecord)) {
                                    Slog.i(TAG, "can't start " + cpr + " caller is " + processRecord);
                                    Binder.restoreCallingIdentity(origId);
                                    resetPriorityAfterLockedSection();
                                    return null;
                                } else {
                                    if (cpr != null) {
                                        if (!OppoAppStartupManager.getInstance().isAllowStartFromProvider(processRecord, cpr, cpi.applicationInfo)) {
                                            Binder.restoreCallingIdentity(origId);
                                            resetPriorityAfterLockedSection();
                                            return null;
                                        }
                                    }
                                    checkTime(startTime, "getContentProviderImpl: before start process");
                                    if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                                        Slog.d(TAG_PROVIDER, "Start process " + cpi.processName + " for " + name);
                                    }
                                    proc = startProcessLocked(cpi.processName, cpr.appInfo, false, 0, "content provider", new ComponentName(cpi.applicationInfo.packageName, cpi.name), false, false, false);
                                    checkTime(startTime, "getContentProviderImpl: after start process");
                                    if (proc == null) {
                                        Slog.w(TAG, "Unable to launch app " + cpi.applicationInfo.packageName + "/" + cpi.applicationInfo.uid + " for provider " + name + ": process is bad");
                                        Binder.restoreCallingIdentity(origId);
                                        resetPriorityAfterLockedSection();
                                        return null;
                                    } else if (!firstClass) {
                                        cpr = this.mProviderMap.getProviderByClass(comp, userId);
                                        if (cpr == null) {
                                            if (!Build.PERMISSIONS_REVIEW_REQUIRED || requestTargetProviderPermissionsReviewIfNeededLocked(cpi, processRecord, userId)) {
                                                try {
                                                    checkTime(startTime, "getContentProviderImpl: before getApplicationInfo 2");
                                                    ai = AppGlobals.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName, 1024, userId);
                                                    checkTime(startTime, "getContentProviderImpl: after getApplicationInfo 2 ");
                                                    if (ai == null) {
                                                        Slog.w(TAG, "No package info for content provider 2 " + cpi.name);
                                                        Binder.restoreCallingIdentity(origId);
                                                        resetPriorityAfterLockedSection();
                                                        return null;
                                                    }
                                                    cpr2 = new ContentProviderRecord(this, cpi, getAppInfoForUser(ai, userId), comp, singleton);
                                                    try {
                                                        this.mProviderMap.putProviderByClass(comp, cpr2);
                                                        if (ActivityManagerDebugConfig.DEBUG_PROVIDER || ActivityManagerDebugConfig.DEBUG_AMS) {
                                                            Slog.d(TAG_PROVIDER, "new ContentProviderRecord " + cpr2 + " comp " + comp);
                                                        }
                                                        cpr = cpr2;
                                                    } catch (Exception e8) {
                                                        e = e8;
                                                        cpr = cpr2;
                                                        Slog.e(TAG, "Exception in cpr " + cpr, e);
                                                        Binder.restoreCallingIdentity(origId);
                                                        resetPriorityAfterLockedSection();
                                                        return null;
                                                    } catch (Throwable th4) {
                                                        th = th4;
                                                        cpr = cpr2;
                                                        Binder.restoreCallingIdentity(origId);
                                                        throw th;
                                                    }
                                                } catch (Exception e9) {
                                                    e = e9;
                                                    Slog.e(TAG, "Exception in cpr " + cpr, e);
                                                    Binder.restoreCallingIdentity(origId);
                                                    resetPriorityAfterLockedSection();
                                                    return null;
                                                }
                                            }
                                            Binder.restoreCallingIdentity(origId);
                                            resetPriorityAfterLockedSection();
                                            return null;
                                        }
                                    }
                                }
                                cpr.launchingApp = proc;
                                this.mLaunchingProviders.add(cpr);
                                Binder.restoreCallingIdentity(origId);
                            }
                            checkTime(startTime, "getContentProviderImpl: updating data structures");
                            if (firstClass) {
                                this.mProviderMap.putProviderByClass(comp, cpr);
                            }
                            this.mProviderMap.putProviderByName(name, cpr);
                            conn = incProviderCountLocked(processRecord, cpr, token, stable);
                            if (conn != null) {
                                conn.waiting = true;
                            }
                        } else {
                            resetPriorityAfterLockedSection();
                            return null;
                        }
                    }
                    cpr = cpr2;
                    checkTime(startTime, "getContentProviderImpl: now have ContentProviderRecord");
                    if (processRecord == null) {
                    }
                    if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                        Slog.w(TAG_PROVIDER, "LAUNCHING REMOTE PROVIDER (myuid " + (processRecord != null ? Integer.valueOf(processRecord.uid) : null) + " pruid " + cpr.appInfo.uid + "): " + cpr.info.name + " callers=" + Debug.getCallers(6));
                    }
                    N = this.mLaunchingProviders.size();
                    i = 0;
                    while (i < N) {
                        i++;
                    }
                    if (i >= N) {
                        origId = Binder.clearCallingIdentity();
                        try {
                            checkTime(startTime, "getContentProviderImpl: before set stopped state");
                            AppGlobals.getPackageManager().setPackageStoppedState(cpr.appInfo.packageName, false, userId);
                            checkTime(startTime, "getContentProviderImpl: after set stopped state");
                        } catch (RemoteException e52) {
                        } catch (IllegalArgumentException e62) {
                            Slog.w(TAG, "Failed trying to unstop package " + cpr.appInfo.packageName + ": " + e62);
                        } catch (Throwable th32) {
                            th = th32;
                        }
                        checkTime(startTime, "getContentProviderImpl: looking for process record");
                        ProcessRecord proc2 = getProcessRecordLocked(cpi.processName, cpr.appInfo.uid, false);
                        if (openTraceLog) {
                            boolean isThreadNull2 = (proc2 == null || proc2.thread == null) ? false : true;
                            Slog.d(TAG, "getContentProviderImpl 05, proc for:" + cpi.processName + ", isThreadNull:" + isThreadNull2 + ", cprUid:" + cpr.appInfo.uid + ", proc:" + proc2);
                        }
                        if (proc2 != null && proc2.thread != null && (proc2.killed ^ 1) != 0) {
                            if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                                Slog.d(TAG_PROVIDER, "Installing in existing process " + proc2);
                            }
                            if (!proc2.pubProviders.containsKey(cpi.name)) {
                                checkTime(startTime, "getContentProviderImpl: scheduling install");
                                proc2.pubProviders.put(cpi.name, cpr);
                                try {
                                    if (ActivityManagerDebugConfig.DEBUG_PROVIDER || ActivityManagerDebugConfig.DEBUG_AMS) {
                                        Slog.d(TAG_PROVIDER, "Installing provider " + proc2 + " cpr " + cpr);
                                    }
                                    proc2.thread.scheduleInstallProvider(cpi);
                                } catch (RemoteException e72) {
                                }
                            }
                        } else if (OppoAbnormalAppManager.getInstance().validStartProvider(cpr)) {
                            Slog.i(OppoAbnormalAppManager.TAG, "UL for provider " + cpr + " : is R");
                            Binder.restoreCallingIdentity(origId);
                            resetPriorityAfterLockedSection();
                            return null;
                        } else if (OppoAppStartupManager.getInstance().handleStartProvider(cpr, processRecord)) {
                            Slog.i(TAG, "can't start " + cpr + " caller is " + processRecord);
                            Binder.restoreCallingIdentity(origId);
                            resetPriorityAfterLockedSection();
                            return null;
                        } else {
                            if (cpr != null) {
                                if (!OppoAppStartupManager.getInstance().isAllowStartFromProvider(processRecord, cpr, cpi.applicationInfo)) {
                                    Binder.restoreCallingIdentity(origId);
                                    resetPriorityAfterLockedSection();
                                    return null;
                                }
                            }
                            checkTime(startTime, "getContentProviderImpl: before start process");
                            if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                                Slog.d(TAG_PROVIDER, "Start process " + cpi.processName + " for " + name);
                            }
                            proc2 = startProcessLocked(cpi.processName, cpr.appInfo, false, 0, "content provider", new ComponentName(cpi.applicationInfo.packageName, cpi.name), false, false, false);
                            checkTime(startTime, "getContentProviderImpl: after start process");
                            if (proc2 == null) {
                                Slog.w(TAG, "Unable to launch app " + cpi.applicationInfo.packageName + "/" + cpi.applicationInfo.uid + " for provider " + name + ": process is bad");
                                Binder.restoreCallingIdentity(origId);
                                resetPriorityAfterLockedSection();
                                return null;
                            } else if (!firstClass) {
                                cpr = this.mProviderMap.getProviderByClass(comp, userId);
                                if (cpr == null) {
                                    if (!Build.PERMISSIONS_REVIEW_REQUIRED || requestTargetProviderPermissionsReviewIfNeededLocked(cpi, processRecord, userId)) {
                                        try {
                                            checkTime(startTime, "getContentProviderImpl: before getApplicationInfo 2");
                                            ai = AppGlobals.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName, 1024, userId);
                                            checkTime(startTime, "getContentProviderImpl: after getApplicationInfo 2 ");
                                            if (ai == null) {
                                                Slog.w(TAG, "No package info for content provider 2 " + cpi.name);
                                                Binder.restoreCallingIdentity(origId);
                                                resetPriorityAfterLockedSection();
                                                return null;
                                            }
                                            cpr2 = new ContentProviderRecord(this, cpi, getAppInfoForUser(ai, userId), comp, singleton);
                                            try {
                                                this.mProviderMap.putProviderByClass(comp, cpr2);
                                                if (ActivityManagerDebugConfig.DEBUG_PROVIDER || ActivityManagerDebugConfig.DEBUG_AMS) {
                                                    Slog.d(TAG_PROVIDER, "new ContentProviderRecord " + cpr2 + " comp " + comp);
                                                }
                                                cpr = cpr2;
                                            } catch (Exception e82) {
                                                e = e82;
                                                cpr = cpr2;
                                                Slog.e(TAG, "Exception in cpr " + cpr, e);
                                                Binder.restoreCallingIdentity(origId);
                                                resetPriorityAfterLockedSection();
                                                return null;
                                            } catch (Throwable th42) {
                                                th = th42;
                                                cpr = cpr2;
                                                Binder.restoreCallingIdentity(origId);
                                                throw th;
                                            }
                                        } catch (Exception e92) {
                                            e = e92;
                                            Slog.e(TAG, "Exception in cpr " + cpr, e);
                                            Binder.restoreCallingIdentity(origId);
                                            resetPriorityAfterLockedSection();
                                            return null;
                                        }
                                    }
                                    Binder.restoreCallingIdentity(origId);
                                    resetPriorityAfterLockedSection();
                                    return null;
                                }
                            }
                        }
                        cpr.launchingApp = proc2;
                        this.mLaunchingProviders.add(cpr);
                        Binder.restoreCallingIdentity(origId);
                    }
                    checkTime(startTime, "getContentProviderImpl: updating data structures");
                    if (firstClass) {
                        this.mProviderMap.putProviderByClass(comp, cpr);
                    }
                    this.mProviderMap.putProviderByName(name, cpr);
                    conn = incProviderCountLocked(processRecord, cpr, token, stable);
                    if (conn != null) {
                        conn.waiting = true;
                    }
                } else {
                    Slog.w(TAG, "Unable to launch app " + cpi.applicationInfo.packageName + "/" + cpi.applicationInfo.uid + " for provider " + name + ": user " + userId + " is stopped");
                    resetPriorityAfterLockedSection();
                    return null;
                }
            }
            checkTime(startTime, "getContentProviderImpl: done!");
            grantEphemeralAccessLocked(userId, null, cpi.applicationInfo.uid, UserHandle.getAppId(Binder.getCallingUid()));
        }
        return null;
        boolean bPublishTimeout;
        while (cpr.provider == null) {
            if (cpr.launchingApp == null) {
                Slog.w(TAG, "Unable to launch app " + cpi.applicationInfo.packageName + "/" + cpi.applicationInfo.uid + " for provider " + name + ": launching app became null");
                EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS, new Object[]{Integer.valueOf(UserHandle.getUserId(cpi.applicationInfo.uid)), cpi.applicationInfo.packageName, Integer.valueOf(cpi.applicationInfo.uid), name});
                return null;
            }
            try {
                if (ActivityManagerDebugConfig.DEBUG_MU) {
                    Slog.v(TAG_MU, "Waiting to start provider " + cpr + " launchingApp=" + cpr.launchingApp);
                }
                if (conn != null) {
                    conn.waiting = true;
                }
                if (this.mSimulateBindBlockedCase) {
                    cpr.wait();
                } else {
                    long timeCprWaitBegin = SystemClock.elapsedRealtime();
                    if (ActivityManagerDebugConfig.DEBUG_PROVIDER || ActivityManagerDebugConfig.DEBUG_AMS) {
                        Slog.v(TAG_MU, "cpr.wait " + cpr + " launchingApp= " + cpr.launchingApp);
                    }
                    cpr.wait(APP_DEXOPT_TIMEOUT);
                    bPublishTimeout = SystemClock.elapsedRealtime() - timeCprWaitBegin >= APP_DEXOPT_TIMEOUT;
                    if (bPublishTimeout) {
                        if (conn != null) {
                            conn.waiting = false;
                        }
                        if (bPublishTimeout) {
                            return cpr != null ? cpr.newHolder(conn) : null;
                        }
                        Slog.w(TAG_MU, "getContentProviderImpl wait publish timeout, we clean it, cpr:" + cpr + " launchingApp=" + cpr.launchingApp);
                        synchronized (this) {
                            try {
                                boostPriorityForLockedSection();
                                cleanupAppInLaunchingProvidersLocked(cpr.launchingApp, true);
                            } finally {
                                resetPriorityAfterLockedSection();
                            }
                        }
                        return null;
                    }
                }
                if (conn != null) {
                    conn.waiting = false;
                } else {
                    continue;
                }
            } catch (InterruptedException e10) {
                if (conn != null) {
                    conn.waiting = false;
                } else {
                    continue;
                }
            } catch (Throwable th5) {
                if (conn != null) {
                    conn.waiting = false;
                }
            }
        }
        if (bPublishTimeout) {
            return cpr != null ? cpr.newHolder(conn) : null;
        }
        Slog.w(TAG_MU, "getContentProviderImpl wait publish timeout, we clean it, cpr:" + cpr + " launchingApp=" + cpr.launchingApp);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                cleanupAppInLaunchingProvidersLocked(cpr.launchingApp, true);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return null;
    }

    private boolean requestTargetProviderPermissionsReviewIfNeededLocked(ProviderInfo cpi, ProcessRecord r, int userId) {
        if (!getPackageManagerInternalLocked().isPermissionsReviewRequired(cpi.packageName, userId)) {
            return true;
        }
        boolean callerForeground = r == null || r.setSchedGroup != 0;
        if (callerForeground) {
            final Intent intent = new Intent("android.intent.action.REVIEW_PERMISSIONS");
            intent.addFlags(276824064);
            intent.putExtra("android.intent.extra.PACKAGE_NAME", cpi.packageName);
            if (ActivityManagerDebugConfig.DEBUG_PERMISSIONS_REVIEW) {
                Slog.i(TAG, "u" + userId + " Launching permission review " + "for package " + cpi.packageName);
            }
            final UserHandle userHandle = new UserHandle(userId);
            this.mHandler.post(new Runnable() {
                public void run() {
                    ActivityManagerService.this.mContext.startActivityAsUser(intent, userHandle);
                }
            });
            return false;
        }
        Slog.w(TAG, "u" + userId + " Instantiating a provider in package" + cpi.packageName + " requires a permissions review");
        return false;
    }

    PackageManagerInternal getPackageManagerInternalLocked() {
        if (this.mPackageManagerInt == null) {
            this.mPackageManagerInt = (PackageManagerInternal) LocalServices.getService(PackageManagerInternal.class);
        }
        return this.mPackageManagerInt;
    }

    public final ContentProviderHolder getContentProvider(IApplicationThread caller, String name, int userId, boolean stable) {
        enforceNotIsolatedCaller("getContentProvider");
        if (caller == null) {
            String msg = "null IApplicationThread when getting content provider " + name;
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        ContentProviderHolder holder = getContentProviderImpl(caller, name, null, stable, userId);
        if (holder != null || userId != OppoMultiAppManager.USER_ID) {
            return holder;
        }
        try {
            String[] packages = AppGlobals.getPackageManager().getPackagesForUid(Binder.getCallingUid());
            if (packages == null) {
                return holder;
            }
            for (String pkgName : packages) {
                if (OppoMultiAppManagerUtil.getInstance().isMultiApp(pkgName)) {
                    return getContentProviderImpl(caller, name, null, stable, 0);
                }
            }
            return holder;
        } catch (RemoteException e) {
            return holder;
        }
    }

    public ContentProviderHolder getContentProviderExternal(String name, int userId, IBinder token) {
        enforceCallingPermission("android.permission.ACCESS_CONTENT_PROVIDERS_EXTERNALLY", "Do not have permission in call getContentProviderExternal()");
        return getContentProviderExternalUnchecked(name, token, this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "getContentProvider", null));
    }

    private ContentProviderHolder getContentProviderExternalUnchecked(String name, IBinder token, int userId) {
        return getContentProviderImpl(null, name, token, true, userId);
    }

    public void removeContentProvider(IBinder connection, boolean stable) {
        enforceNotIsolatedCaller("removeContentProvider");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ContentProviderConnection conn = (ContentProviderConnection) connection;
                if (conn == null) {
                    throw new NullPointerException("connection is null");
                }
                if (decProviderCountLocked(conn, null, null, stable)) {
                    updateOomAdjLocked();
                }
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(ident);
        } catch (ClassCastException e) {
            String msg = "removeContentProvider: " + connection + " not a ContentProviderConnection";
            Slog.w(TAG, msg);
            throw new IllegalArgumentException(msg);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void removeContentProviderExternal(String name, IBinder token) {
        enforceCallingPermission("android.permission.ACCESS_CONTENT_PROVIDERS_EXTERNALLY", "Do not have permission in call removeContentProviderExternal()");
        int userId = UserHandle.getCallingUserId();
        long ident = Binder.clearCallingIdentity();
        try {
            removeContentProviderExternalUnchecked(name, token, userId);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void removeContentProviderExternalUnchecked(String name, IBinder token, int userId) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ContentProviderRecord cpr = this.mProviderMap.getProviderByName(name, userId);
                if (cpr == null) {
                } else {
                    ContentProviderRecord localCpr = this.mProviderMap.getProviderByClass(new ComponentName(cpr.info.packageName, cpr.info.name), userId);
                    if (!localCpr.hasExternalProcessHandles()) {
                        Slog.e(TAG, "Attmpt to remove content provider: " + localCpr + " with no external references.");
                    } else if (localCpr.removeExternalProcessHandleLocked(token)) {
                        updateOomAdjLocked();
                    } else {
                        Slog.e(TAG, "Attmpt to remove content provider " + localCpr + " with no external reference for token: " + token + ".");
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public final void publishContentProviders(IApplicationThread caller, List<ContentProviderHolder> providers) {
        if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
            Slog.d(TAG_PROVIDER, "publishContentProviders providers " + providers);
        }
        if (providers != null) {
            enforceNotIsolatedCaller("publishContentProviders");
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    ProcessRecord r = getRecordForAppLocked(caller);
                    if (ActivityManagerDebugConfig.DEBUG_MU) {
                        Slog.v(TAG_MU, "ProcessRecord uid = " + r.uid);
                    }
                    if (r == null) {
                        throw new SecurityException("Unable to find app for caller " + caller + " (pid=" + Binder.getCallingPid() + ") when publishing content providers");
                    }
                    long origId = Binder.clearCallingIdentity();
                    int N = providers.size();
                    for (int i = 0; i < N; i++) {
                        ContentProviderHolder src = (ContentProviderHolder) providers.get(i);
                        if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                            Slog.d(TAG_PROVIDER, "src " + src + " src.info " + (src != null ? src.info : null) + " src.provider " + (src != null ? src.provider : null));
                        }
                        if (!(src == null || src.info == null || src.provider == null)) {
                            ContentProviderRecord dst = (ContentProviderRecord) r.pubProviders.get(src.info.name);
                            if (ActivityManagerDebugConfig.DEBUG_MU) {
                                Slog.v(TAG_MU, "ContentProviderRecord uid = " + dst.uid);
                            }
                            if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                                Slog.d(TAG_PROVIDER, "ContentProviderRecord " + dst + " src.info " + src.info + " src.info.name " + src.info.name);
                            }
                            if (dst != null) {
                                this.mProviderMap.putProviderByClass(new ComponentName(dst.info.packageName, dst.info.name), dst);
                                String[] names = dst.info.authority.split(";");
                                for (String putProviderByName : names) {
                                    this.mProviderMap.putProviderByName(putProviderByName, dst);
                                }
                                int launchingCount = this.mLaunchingProviders.size();
                                boolean wasInLaunchingProviders = false;
                                int j = 0;
                                while (j < launchingCount) {
                                    if (this.mLaunchingProviders.get(j) == dst) {
                                        this.mLaunchingProviders.remove(j);
                                        wasInLaunchingProviders = true;
                                        j--;
                                        launchingCount--;
                                    }
                                    j++;
                                }
                                if (wasInLaunchingProviders) {
                                    this.mHandler.removeMessages(57, r);
                                }
                                synchronized (dst) {
                                    dst.provider = src.provider;
                                    dst.proc = r;
                                    if (!this.mSimulateBindBlockedCase) {
                                        if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                                            Slog.v(TAG_MU, "dst = " + dst + " dst.proc " + dst.proc + " dst.provider " + dst.provider);
                                        }
                                        dst.notifyAll();
                                    }
                                }
                                updateOomAdjLocked(r, true);
                                maybeUpdateProviderUsageStatsLocked(r, src.info.packageName, src.info.authority);
                            } else {
                                continue;
                            }
                        }
                    }
                    Binder.restoreCallingIdentity(origId);
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                }
            }
            resetPriorityAfterLockedSection();
        }
    }

    public boolean refContentProvider(IBinder connection, int stable, int unstable) {
        try {
            ContentProviderConnection conn = (ContentProviderConnection) connection;
            if (conn == null) {
                throw new NullPointerException("connection is null");
            }
            boolean z;
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (stable > 0) {
                        conn.numStableIncs += stable;
                    }
                    stable += conn.stableCount;
                    if (stable < 0) {
                        throw new IllegalStateException("stableCount < 0: " + stable);
                    }
                    if (unstable > 0) {
                        conn.numUnstableIncs += unstable;
                    }
                    unstable += conn.unstableCount;
                    if (unstable < 0) {
                        throw new IllegalStateException("unstableCount < 0: " + unstable);
                    } else if (stable + unstable <= 0) {
                        throw new IllegalStateException("ref counts can't go to zero here: stable=" + stable + " unstable=" + unstable);
                    } else {
                        conn.stableCount = stable;
                        conn.unstableCount = unstable;
                        z = conn.dead ^ 1;
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return z;
        } catch (ClassCastException e) {
            String msg = "refContentProvider: " + connection + " not a ContentProviderConnection";
            Slog.w(TAG, msg);
            throw new IllegalArgumentException(msg);
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void unstableProviderDied(IBinder connection) {
        try {
            IContentProvider provider;
            ContentProviderConnection conn = (ContentProviderConnection) connection;
            if (conn == null) {
                throw new NullPointerException("connection is null");
            }
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    provider = conn.provider.provider;
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            if (provider != null) {
                if (provider.asBinder().pingBinder()) {
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            Slog.w(TAG, "unstableProviderDied: caller " + Binder.getCallingUid() + " says " + conn + " died, but we don't agree");
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                }
                synchronized (this) {
                    long ident;
                    try {
                        boostPriorityForLockedSection();
                        if (conn.provider.provider != provider) {
                            resetPriorityAfterLockedSection();
                            return;
                        }
                        ProcessRecord proc = conn.provider.proc;
                        if (proc == null || proc.thread == null) {
                        } else {
                            Slog.i(TAG, "Process " + proc.processName + " (pid " + proc.pid + ") early provider death");
                            ident = Binder.clearCallingIdentity();
                            appDiedLocked(proc);
                            Binder.restoreCallingIdentity(ident);
                            resetPriorityAfterLockedSection();
                        }
                    } catch (Throwable th) {
                        resetPriorityAfterLockedSection();
                    }
                }
            }
        } catch (ClassCastException e) {
            String msg = "refContentProvider: " + connection + " not a ContentProviderConnection";
            Slog.w(TAG, msg);
            throw new IllegalArgumentException(msg);
        }
    }

    public void appNotRespondingViaProvider(IBinder connection) {
        enforceCallingPermission("android.permission.REMOVE_TASKS", "appNotRespondingViaProvider()");
        ContentProviderConnection conn = (ContentProviderConnection) connection;
        if (conn == null) {
            Slog.w(TAG, "ContentProviderConnection is null");
            return;
        }
        final ProcessRecord host = conn.provider.proc;
        if (host == null) {
            Slog.w(TAG, "Failed to find hosting ProcessRecord");
        } else {
            this.mHandler.post(new Runnable() {
                public void run() {
                    ActivityManagerService.this.mAppErrors.appNotResponding(host, null, null, false, "ContentProvider not responding");
                }
            });
        }
    }

    public final void installSystemProviders() {
        List<ProviderInfo> providers;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                providers = generateApplicationProvidersLocked((ProcessRecord) this.mProcessNames.get("system", 1000));
                if (providers != null) {
                    for (int i = providers.size() - 1; i >= 0; i--) {
                        ProviderInfo pi = (ProviderInfo) providers.get(i);
                        if ((pi.applicationInfo.flags & 1) == 0) {
                            Slog.w(TAG, "Not installing system proc provider " + pi.name + ": not system .apk");
                            providers.remove(i);
                        }
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        if (providers != null) {
            this.mSystemThread.installSystemProviders(providers);
        }
        this.mConstants.start(this.mContext.getContentResolver());
        this.mCoreSettingsObserver = new CoreSettingsObserver(this);
        this.mFontScaleSettingObserver = new FontScaleSettingObserver();
        RescueParty.onSettingsProviderPublished(this.mContext);
    }

    private void startPersistentApps(int matchFlags) {
        if (this.mFactoryTest != 1) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    try {
                        for (ApplicationInfo app : AppGlobals.getPackageManager().getPersistentApplications(matchFlags | 1024).getList()) {
                            if (!"android".equals(app.packageName)) {
                                addAppLocked(app, null, false, null);
                            }
                        }
                    } catch (RemoteException e) {
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        }
    }

    private void installEncryptionUnawareProviders(int userId) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int NP = this.mProcessNames.getMap().size();
                for (int ip = 0; ip < NP; ip++) {
                    SparseArray<ProcessRecord> apps = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
                    int NA = apps.size();
                    for (int ia = 0; ia < NA; ia++) {
                        ProcessRecord app = (ProcessRecord) apps.valueAt(ia);
                        if (!(app.userId != userId || app.thread == null || app.unlocked)) {
                            int NG = app.pkgList.size();
                            for (int ig = 0; ig < NG; ig++) {
                                try {
                                    PackageInfo pkgInfo = AppGlobals.getPackageManager().getPackageInfo((String) app.pkgList.keyAt(ig), 262152, userId);
                                    if (!(pkgInfo == null || (ArrayUtils.isEmpty(pkgInfo.providers) ^ 1) == 0)) {
                                        for (ProviderInfo pi : pkgInfo.providers) {
                                            boolean processMatch;
                                            if (Objects.equals(pi.processName, app.processName)) {
                                                processMatch = true;
                                            } else {
                                                processMatch = pi.multiprocess;
                                            }
                                            boolean userMatch = !isSingleton(pi.processName, pi.applicationInfo, pi.name, pi.flags) || app.userId == 0;
                                            if (processMatch && userMatch) {
                                                Log.v(TAG, "Installing " + pi);
                                                app.thread.scheduleInstallProvider(pi);
                                            } else {
                                                Log.v(TAG, "Skipping " + pi);
                                            }
                                        }
                                    }
                                } catch (RemoteException e) {
                                }
                            }
                        }
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public String getProviderMimeType(Uri uri, int userId) {
        enforceNotIsolatedCaller("getProviderMimeType");
        String name = uri.getAuthority();
        int callingUid = Binder.getCallingUid();
        int callingPid = Binder.getCallingPid();
        long ident = 0;
        boolean clearedIdentity = false;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                userId = this.mUserController.unsafeConvertIncomingUserLocked(userId);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        if (canClearIdentity(callingPid, callingUid, userId)) {
            clearedIdentity = true;
            ident = Binder.clearCallingIdentity();
        }
        ContentProviderHolder holder = null;
        try {
            holder = getContentProviderExternalUnchecked(name, null, userId);
            if (holder == null && userId == 999) {
                if (OppoMultiAppManagerUtil.getInstance().isMultiApp(AppGlobals.getPackageManager().getNameForUid(callingUid))) {
                    holder = getContentProviderExternalUnchecked(name, null, 0);
                }
            }
            if (holder != null) {
                String type = holder.provider.getType(uri);
                if (!clearedIdentity) {
                    ident = Binder.clearCallingIdentity();
                }
                if (holder != null) {
                    try {
                        removeContentProviderExternalUnchecked(name, null, userId);
                    } catch (Throwable th) {
                        Binder.restoreCallingIdentity(ident);
                    }
                }
                Binder.restoreCallingIdentity(ident);
                return type;
            }
            if (!clearedIdentity) {
                ident = Binder.clearCallingIdentity();
            }
            if (holder != null) {
                try {
                    removeContentProviderExternalUnchecked(name, null, userId);
                } catch (Throwable th2) {
                    Binder.restoreCallingIdentity(ident);
                }
            }
            Binder.restoreCallingIdentity(ident);
            return null;
        } catch (RemoteException e) {
            Log.w(TAG, "Content provider dead retrieving " + uri, e);
            if (!clearedIdentity) {
                ident = Binder.clearCallingIdentity();
            }
            if (holder != null) {
                removeContentProviderExternalUnchecked(name, null, userId);
            }
            Binder.restoreCallingIdentity(ident);
            return null;
        } catch (Exception e2) {
            Log.w(TAG, "Exception while determining type of " + uri, e2);
            if (!clearedIdentity) {
                ident = Binder.clearCallingIdentity();
            }
            if (holder != null) {
                removeContentProviderExternalUnchecked(name, null, userId);
            }
            Binder.restoreCallingIdentity(ident);
            return null;
        } catch (Throwable th3) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    private boolean canClearIdentity(int callingPid, int callingUid, int userId) {
        return UserHandle.getUserId(callingUid) == userId || checkComponentPermission("android.permission.INTERACT_ACROSS_USERS", callingPid, callingUid, -1, true) == 0 || checkComponentPermission("android.permission.INTERACT_ACROSS_USERS_FULL", callingPid, callingUid, -1, true) == 0;
    }

    final ProcessRecord newProcessRecordLocked(ApplicationInfo info, String customProcess, boolean isolated, int isolatedUid) {
        String proc = customProcess != null ? customProcess : info.processName;
        BatteryStatsImpl stats = this.mBatteryStatsService.getActiveStatistics();
        int userId = UserHandle.getUserId(info.uid);
        int uid = info.uid;
        if (isolated) {
            if (isolatedUid == 0) {
                int stepsLeft = 1000;
                do {
                    if (this.mNextIsolatedProcessUid < 99000 || this.mNextIsolatedProcessUid > 99999) {
                        this.mNextIsolatedProcessUid = 99000;
                    }
                    uid = UserHandle.getUid(userId, this.mNextIsolatedProcessUid);
                    this.mNextIsolatedProcessUid++;
                    if (this.mIsolatedProcesses.indexOfKey(uid) >= 0) {
                        stepsLeft--;
                    }
                } while (stepsLeft > 0);
                return null;
            }
            uid = isolatedUid;
            getPackageManagerInternalLocked().addIsolatedUid(uid, info.uid);
            this.mBatteryStatsService.addIsolatedUid(uid, info.uid);
        }
        ProcessRecord r = new ProcessRecord(stats, info, proc, uid);
        if (!this.mBooted && (this.mBooting ^ 1) != 0 && userId == 0 && (info.flags & 9) == 9) {
            r.persistent = true;
            r.maxAdj = -800;
        }
        addProcessNameLocked(r);
        return r;
    }

    private boolean uidOnBackgroundWhitelist(int uid) {
        int appId = UserHandle.getAppId(uid);
        for (int i : this.mBackgroundAppIdWhitelist) {
            if (appId == i) {
                return true;
            }
        }
        return false;
    }

    public void backgroundWhitelistUid(int uid) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("Only the OS may call backgroundWhitelistUid()");
        }
        if (ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK) {
            Slog.i(TAG, "Adding uid " + uid + " to bg uid whitelist");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int N = this.mBackgroundAppIdWhitelist.length;
                int[] newList = new int[(N + 1)];
                System.arraycopy(this.mBackgroundAppIdWhitelist, 0, newList, 0, N);
                newList[N] = UserHandle.getAppId(uid);
                this.mBackgroundAppIdWhitelist = newList;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    final ProcessRecord addAppLocked(ApplicationInfo info, String customProcess, boolean isolated, String abiOverride) {
        ProcessRecord app;
        if (isolated) {
            app = null;
        } else {
            app = getProcessRecordLocked(customProcess != null ? customProcess : info.processName, info.uid, true);
        }
        if (app == null) {
            app = newProcessRecordLocked(info, customProcess, isolated, 0);
            updateLruProcessLocked(app, false, null);
            updateOomAdjLocked();
        }
        try {
            AppGlobals.getPackageManager().setPackageStoppedState(info.packageName, false, UserHandle.getUserId(app.uid));
        } catch (RemoteException e) {
        } catch (IllegalArgumentException e2) {
            Slog.w(TAG, "Failed trying to unstop package " + info.packageName + ": " + e2);
        }
        if ((info.flags & 9) == 9) {
            app.persistent = true;
            if (!"system".equals(app.processName)) {
                app.maxAdj = -800;
            }
        }
        boolean isImportantPersistProc = isImportantPersistProc(app.processName);
        if (app.thread == null && this.mPersistentStartingProcesses.indexOf(app) < 0) {
            if (isImportantPersistProc) {
                Slog.i(TAG, "addAppLocked will start proc " + app.processName);
            }
            this.mPersistentStartingProcesses.add(app);
            startProcessLocked(app, "added application", customProcess != null ? customProcess : app.processName, abiOverride, null, null);
        } else if (isImportantPersistProc) {
            int appIndex = this.mPersistentStartingProcesses.indexOf(app);
            boolean appThreadIsNull = app.thread == null;
            Slog.i(TAG, "addAppLocked, proc " + app.processName + ", appIndex:" + appIndex + ", app.thread is null ? " + appThreadIsNull);
            if (appThreadIsNull && appIndex >= 0) {
                Slog.i(TAG, "addAppLocked, proc " + app.processName + " need to start for attach failed ?");
            }
        }
        return app;
    }

    public void unhandledBack() {
        enforceCallingPermission("android.permission.FORCE_BACK", "unhandledBack()");
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                origId = Binder.clearCallingIdentity();
                getFocusedStack().unhandledBackLocked();
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public ParcelFileDescriptor openContentUri(String uriString) throws RemoteException {
        enforceNotIsolatedCaller("openContentUri");
        int userId = UserHandle.getCallingUserId();
        Uri uri = Uri.parse(uriString);
        String name = uri.getAuthority();
        ContentProviderHolder cph = getContentProviderExternalUnchecked(name, null, userId);
        ParcelFileDescriptor pfd = null;
        if (cph != null) {
            Binder token = new Binder();
            sCallerIdentity.set(new Identity(token, Binder.getCallingPid(), Binder.getCallingUid()));
            try {
                pfd = cph.provider.openFile(null, uri, "r", null, token);
            } catch (FileNotFoundException e) {
            } finally {
                sCallerIdentity.remove();
                removeContentProviderExternalUnchecked(name, null, userId);
            }
        } else {
            Slog.d(TAG, "Failed to get provider for authority '" + name + "'");
        }
        return pfd;
    }

    boolean isSleepingOrShuttingDownLocked() {
        return !isSleepingLocked() ? this.mShuttingDown : true;
    }

    boolean isShuttingDownLocked() {
        return this.mShuttingDown;
    }

    boolean isSleepingLocked() {
        return this.mSleeping;
    }

    void onWakefulnessChanged(int wakefulness) {
        if (ActivityManagerDebugConfig.DEBUG_PAUSE) {
            Slog.d(TAG, "onWakefulnessChanged: wake = " + wakefulness);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                boolean wasAwake = this.mWakefulness == 1;
                boolean isAwake = wakefulness == 1;
                this.mWakefulness = wakefulness;
                if (wasAwake != isAwake) {
                    this.mServices.updateScreenStateLocked(isAwake);
                    sendNotifyVrManagerOfSleepState(isAwake ^ 1);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    void finishRunningVoiceLocked() {
        if (this.mRunningVoice != null) {
            this.mRunningVoice = null;
            this.mVoiceWakeLock.release();
            updateSleepIfNeededLocked();
        }
    }

    void startTimeTrackingFocusedActivityLocked() {
        ActivityRecord resumedActivity = this.mStackSupervisor.getResumedActivityLocked();
        if (!this.mSleeping && this.mCurAppTimeTracker != null && resumedActivity != null) {
            this.mCurAppTimeTracker.start(resumedActivity.packageName);
        }
    }

    void updateSleepIfNeededLocked() {
        boolean shouldSleep = this.mStackSupervisor.hasAwakeDisplay() ^ 1;
        boolean wasSleeping = this.mSleeping;
        if (!shouldSleep) {
            if (wasSleeping) {
                if (ActivityManagerDebugConfig.DEBUG_PAUSE) {
                    Slog.d(TAG, "updateSleepIfNeededLocked: comeOutOfSleep");
                }
                this.mSleeping = false;
                startTimeTrackingFocusedActivityLocked();
                this.mTopProcessState = 2;
                this.mStackSupervisor.comeOutOfSleepIfNeededLocked();
            }
            this.mStackSupervisor.applySleepTokensLocked(true);
            if (wasSleeping) {
                updateOomAdjLocked();
            }
        } else if (!this.mSleeping && shouldSleep) {
            if (ActivityManagerDebugConfig.DEBUG_PAUSE) {
                Slog.d(TAG, "updateSleepIfNeededLocked: goingToSleep");
            }
            this.mSleeping = true;
            if (this.mCurAppTimeTracker != null) {
                this.mCurAppTimeTracker.stop();
            }
            this.mTopProcessState = 5;
            this.mStackSupervisor.goingToSleepLocked();
            ActivityStack stack = this.mStackSupervisor.getStack(2);
            if (stack != null) {
                if (ActivityManagerDebugConfig.DEBUG_FOCUS) {
                    Slog.v(TAG, "goingToSleep: stack = " + stack);
                }
                this.mStackSupervisor.moveTasksToFullscreenStackLocked(2, false);
                if (ActivityManagerDebugConfig.DEBUG_FOCUS) {
                    Slog.v(TAG, "oppo freeform: moveTasksToFullscreenStackLocked for sleep");
                }
            }
            updateOomAdjLocked();
        }
    }

    void notifyTaskPersisterLocked(TaskRecord task, boolean flush) {
        this.mRecentTasks.notifyTaskPersisterLocked(task, flush);
    }

    public void notifyPinnedStackAnimationStarted() {
        this.mTaskChangeNotificationController.notifyPinnedStackAnimationStarted();
    }

    public void notifyPinnedStackAnimationEnded() {
        this.mTaskChangeNotificationController.notifyPinnedStackAnimationEnded();
    }

    public void notifyCleartextNetwork(int uid, byte[] firstPacket) {
        this.mHandler.obtainMessage(49, uid, 0, firstPacket).sendToTarget();
    }

    public boolean shutdown(int timeout) {
        if (checkCallingPermission("android.permission.SHUTDOWN") != 0) {
            throw new SecurityException("Requires permission android.permission.SHUTDOWN");
        }
        boolean timedout = false;
        OppoJunkRecorder.getInstance().forcePersist(System.currentTimeMillis());
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mShuttingDown = true;
                this.mStackSupervisor.prepareForShutdownLocked();
                updateEventDispatchingLocked();
                timedout = this.mStackSupervisor.shutdownLocked(timeout);
                this.mAppOpsService.shutdown();
                if (this.mNs != null) {
                    this.mNs.shutdown();
                }
                if (this.mUsageStatsService != null) {
                    this.mUsageStatsService.prepareShutdown();
                }
                this.mBatteryStatsService.shutdown();
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        this.mProcessStats.shutdownLocked();
                        notifyTaskPersisterLocked(null, true);
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
                return timedout;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return timedout;
    }

    public final void activitySlept(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    this.mStackSupervisor.activitySleptLocked(r);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        Binder.restoreCallingIdentity(origId);
    }

    void startRunningVoiceLocked(IVoiceInteractionSession session, int targetUid) {
        Slog.d(TAG, "<<<  startRunningVoiceLocked()");
        this.mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));
        if (this.mRunningVoice == null || this.mRunningVoice.asBinder() != session.asBinder()) {
            boolean wasRunningVoice = this.mRunningVoice != null;
            this.mRunningVoice = session;
            if (!wasRunningVoice) {
                this.mVoiceWakeLock.acquire();
                updateSleepIfNeededLocked();
            }
        }
    }

    private void updateEventDispatchingLocked() {
        this.mWindowManager.setEventDispatching(this.mBooted ? this.mShuttingDown ^ 1 : false);
    }

    public void setLockScreenShown(boolean showing, int secondaryDisplayShowing) {
        if (checkCallingPermission("android.permission.DEVICE_POWER") != 0) {
            throw new SecurityException("Requires permission android.permission.DEVICE_POWER");
        }
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                this.mKeyguardController.setKeyguardShown(showing, secondaryDisplayShowing);
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
        sendNotifyVrManagerOfKeyguardState(showing);
    }

    public void notifyLockedProfile(int userId) {
        try {
            if (AppGlobals.getPackageManager().isUidPrivileged(Binder.getCallingUid())) {
                synchronized (this) {
                    long ident;
                    try {
                        boostPriorityForLockedSection();
                        ident = Binder.clearCallingIdentity();
                        if (this.mUserController.shouldConfirmCredentials(userId)) {
                            if (this.mKeyguardController.isKeyguardLocked()) {
                                startHomeActivityLocked(this.mUserController.getCurrentUserIdLocked(), "notifyLockedProfile");
                            }
                            this.mStackSupervisor.lockAllProfileTasks(userId);
                        }
                        Binder.restoreCallingIdentity(ident);
                    } catch (Throwable th) {
                        resetPriorityAfterLockedSection();
                    }
                }
                resetPriorityAfterLockedSection();
                return;
            }
            throw new SecurityException("Only privileged app can call notifyLockedProfile");
        } catch (RemoteException ex) {
            throw new SecurityException("Fail to check is caller a privileged app", ex);
        }
    }

    public void startConfirmDeviceCredentialIntent(Intent intent, Bundle options) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "startConfirmDeviceCredentialIntent");
        synchronized (this) {
            long ident;
            try {
                boostPriorityForLockedSection();
                ident = Binder.clearCallingIdentity();
                this.mActivityStarter.startConfirmCredentialIntent(intent, options);
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void stopAppSwitches() {
        if (checkCallingPermission("android.permission.STOP_APP_SWITCHES") != 0) {
            throw new SecurityException("viewquires permission android.permission.STOP_APP_SWITCHES");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mAppSwitchesAllowedTime = SystemClock.uptimeMillis() + FaceDaemonWrapper.TIMEOUT_FACED_BINDERCALL_CHECK;
                this.mDidAppSwitch = false;
                this.mHandler.removeMessages(21);
                this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(21), FaceDaemonWrapper.TIMEOUT_FACED_BINDERCALL_CHECK);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void resumeAppSwitches() {
        if (checkCallingPermission("android.permission.STOP_APP_SWITCHES") != 0) {
            throw new SecurityException("Requires permission android.permission.STOP_APP_SWITCHES");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mAppSwitchesAllowedTime = 0;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    boolean checkAppSwitchAllowedLocked(int sourcePid, int sourceUid, int callingPid, int callingUid, String name) {
        if (this.mAppSwitchesAllowedTime < SystemClock.uptimeMillis() || checkComponentPermission("android.permission.STOP_APP_SWITCHES", sourcePid, sourceUid, -1, true) == 0) {
            return true;
        }
        if (callingUid != -1 && callingUid != sourceUid && checkComponentPermission("android.permission.STOP_APP_SWITCHES", callingPid, callingUid, -1, true) == 0) {
            return true;
        }
        Slog.w(TAG, name + " request from " + sourceUid + " stopped");
        return false;
    }

    public void setDebugApp(String packageName, boolean waitForDebugger, boolean persistent) {
        enforceCallingPermission("android.permission.SET_DEBUG_APP", "setDebugApp()");
        long ident = Binder.clearCallingIdentity();
        if (persistent) {
            try {
                ContentResolver resolver = this.mContext.getContentResolver();
                Global.putString(resolver, "debug_app", packageName);
                Global.putInt(resolver, "wait_for_debugger", waitForDebugger ? 1 : 0);
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(ident);
            }
        }
        synchronized (this) {
            boostPriorityForLockedSection();
            if (!persistent) {
                this.mOrigDebugApp = this.mDebugApp;
                this.mOrigWaitForDebugger = this.mWaitForDebugger;
            }
            this.mDebugApp = packageName;
            this.mWaitForDebugger = waitForDebugger;
            this.mDebugTransient = persistent ^ 1;
            if (packageName != null) {
                forceStopPackageLocked(packageName, -1, false, false, true, true, false, -1, "set debug app");
            }
        }
        resetPriorityAfterLockedSection();
        Binder.restoreCallingIdentity(ident);
    }

    void setTrackAllocationApp(ApplicationInfo app, String processName) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0")) || (app.flags & 2) != 0) {
                    this.mTrackAllocationApp = processName;
                } else {
                    throw new SecurityException("Process not debuggable: " + app.packageName);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    void setProfileApp(ApplicationInfo app, String processName, ProfilerInfo profilerInfo) {
        synchronized (this) {
            boostPriorityForLockedSection();
            if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0")) || (app.flags & 2) != 0) {
                try {
                    this.mProfileApp = processName;
                    if (!(this.mProfilerInfo == null || this.mProfilerInfo.profileFd == null)) {
                        try {
                            this.mProfilerInfo.profileFd.close();
                        } catch (IOException e) {
                        }
                    }
                    this.mProfilerInfo = new ProfilerInfo(profilerInfo);
                    this.mProfileType = 0;
                } finally {
                    resetPriorityAfterLockedSection();
                }
            } else {
                throw new SecurityException("Process not debuggable: " + app.packageName);
            }
        }
    }

    void setNativeDebuggingAppLocked(ApplicationInfo app, String processName) {
        if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0")) || (app.flags & 2) != 0) {
            this.mNativeDebuggingApp = processName;
            return;
        }
        throw new SecurityException("Process not debuggable: " + app.packageName);
    }

    public void setAlwaysFinish(boolean enabled) {
        enforceCallingPermission("android.permission.SET_ALWAYS_FINISH", "setAlwaysFinish()");
        long ident = Binder.clearCallingIdentity();
        try {
            Global.putInt(this.mContext.getContentResolver(), "always_finish_activities", enabled ? 1 : 0);
            synchronized (this) {
                boostPriorityForLockedSection();
                this.mAlwaysFinishActivities = enabled;
            }
            resetPriorityAfterLockedSection();
            Binder.restoreCallingIdentity(ident);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "ZhiYong.Lin@Plf.Framework, modify for secure protect", property = OppoRomType.ROM)
    public void setActivityController(IActivityController controller, boolean imAMonkey) {
        enforceCallingPermission("android.permission.SET_ACTIVITY_WATCHER", "setActivityController()");
        if (SystemProperties.getBoolean("oppo.app.secure.enable", false)) {
            Slog.i(TAG, "can't setActivityController because safe");
            return;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                OppoSecureProtectUtils.setMonkeyControllerLocked(this, controller);
                this.mControllerIsAMonkey = imAMonkey;
                if (this.mOppoActivityControlerScheduler != null) {
                    this.mOppoActivityControlerScheduler.exitRunningScheduler();
                }
                if (this.mController != null) {
                    this.mOppoActivityControlerScheduler = new OppoActivityControlerScheduler(this.mController);
                } else {
                    this.mOppoActivityControlerScheduler = null;
                }
                Watchdog.getInstance().setActivityController(controller);
                if (controller == null) {
                    OppoSecureProtectUtils.nofityMonkeyFinish(this);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void setOppoKinectActivityController(IOppoKinectActivityController controller) {
        enforceCallingPermission("android.permission.SET_ACTIVITY_WATCHER", "setActivityController()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mOppoKinectController = controller;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void setUserIsMonkey(boolean userIsMonkey) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    int callingPid = Binder.getCallingPid();
                    ProcessRecord proc = (ProcessRecord) this.mPidsSelfLocked.get(callingPid);
                    if (proc == null) {
                        throw new SecurityException("Unknown process: " + callingPid);
                    } else if (proc.instr == null || proc.instr.mUiAutomationConnection == null) {
                        throw new SecurityException("Only an instrumentation process with a UiAutomation can call setUserIsMonkey");
                    }
                }
                this.mUserIsMonkey = userIsMonkey;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "ZhiYong.Lin@Plf.Framework, modify for secure protect", property = OppoRomType.ROM)
    public boolean isUserAMonkey() {
        boolean isMonkeyController;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                isMonkeyController = !this.mUserIsMonkey ? this.mController != null ? OppoSecureProtectUtils.isMonkeyController(this) : false : true;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return isMonkeyController;
    }

    @Deprecated
    public void requestBugReport(int bugreportType) {
        String extraOptions = null;
        switch (bugreportType) {
            case 0:
                break;
            case 1:
                extraOptions = "bugreportplus";
                break;
            case 2:
                extraOptions = "bugreportremote";
                break;
            case 3:
                extraOptions = "bugreportwear";
                break;
            case 4:
                extraOptions = "bugreporttelephony";
                break;
            default:
                throw new IllegalArgumentException("Provided bugreport type is not correct, value: " + bugreportType);
        }
        Slog.i(TAG, (extraOptions == null ? "bugreport" : extraOptions) + " requested by UID " + Binder.getCallingUid());
        enforceCallingPermission("android.permission.DUMP", "requestBugReport");
        if (extraOptions != null) {
            SystemProperties.set("dumpstate.options", extraOptions);
        }
        SystemProperties.set("ctl.start", "bugreport");
    }

    @Deprecated
    public void requestTelephonyBugReport(String shareTitle, String shareDescription) {
        if (!TextUtils.isEmpty(shareTitle)) {
            if (shareTitle.length() > 50) {
                throw new IllegalArgumentException("shareTitle should be less than 50 characters");
            }
            if (!TextUtils.isEmpty(shareDescription)) {
                try {
                    if (shareDescription.getBytes("UTF-8").length > 91) {
                        throw new IllegalArgumentException("shareTitle should be less than 91 bytes");
                    }
                    SystemProperties.set("dumpstate.options.description", shareDescription);
                } catch (UnsupportedEncodingException e) {
                    throw new IllegalArgumentException("shareDescription: UnsupportedEncodingException");
                }
            }
            SystemProperties.set("dumpstate.options.title", shareTitle);
        }
        Slog.d(TAG, "Bugreport notification title " + shareTitle + " description " + shareDescription);
        requestBugReport(4);
    }

    public static long getInputDispatchingTimeoutLocked(ActivityRecord r) {
        return r != null ? getInputDispatchingTimeoutLocked(r.app) : FaceDaemonWrapper.TIMEOUT_FACED_BINDERCALL_CHECK;
    }

    public static long getInputDispatchingTimeoutLocked(ProcessRecord r) {
        if (r == null || (r.instr == null && !r.usingWrapper)) {
            return FaceDaemonWrapper.TIMEOUT_FACED_BINDERCALL_CHECK;
        }
        return 60000;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "liumei@Plf.Framework, 2013/10/23: Add for permission intercept", property = OppoRomType.ROM)
    public long inputDispatchingTimedOut(int pid, boolean aboveSystem, String reason) {
        long j = null;
        if (checkCallingPermission("android.permission.FILTER_EVENTS") != 0) {
            throw new SecurityException("Requires permission android.permission.FILTER_EVENTS");
        }
        synchronized (this) {
            try {
                ProcessRecord proc;
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    proc = (ProcessRecord) this.mPidsSelfLocked.get(pid);
                }
                if (proc.isWaitingPermissionChoice) {
                    j = 60000;
                } else {
                    long timeout = getInputDispatchingTimeoutLocked(proc);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return j;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean inputDispatchingTimedOut(ProcessRecord proc, ActivityRecord activity, ActivityRecord parent, boolean aboveSystem, String reason) {
        int currentPid;
        if (checkCallingPermission("android.permission.FILTER_EVENTS") != 0) {
            throw new SecurityException("Requires permission android.permission.FILTER_EVENTS");
        }
        String separator = "@#@";
        currentPid = -1;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (proc != null) {
                    currentPid = proc.pid;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        String annotation;
        String suffix = SystemClock.uptimeMillis() + "@#@" + currentPid;
        if (reason == null) {
            annotation = "Input dispatching timed out";
        } else {
            annotation = "Input dispatching timed out (" + reason + ")";
        }
        if (proc != null) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (!proc.debugging) {
                        if (isDoingDexopt(proc.uid)) {
                            resetPriorityAfterLockedSection();
                            return false;
                        } else if (proc.instr != null) {
                            Bundle info = new Bundle();
                            info.putString("shortMsg", "keyDispatchingTimedOut");
                            info.putString("longMsg", annotation);
                            finishInstrumentationLocked(proc, 0, info);
                            resetPriorityAfterLockedSection();
                            return true;
                        }
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        }
        return true;
        return false;
    }

    public Bundle getAssistContextExtras(int requestType) {
        PendingAssistExtras pae = enqueueAssistContext(requestType, null, null, null, null, null, true, true, UserHandle.getCallingUserId(), null, 500, 0);
        if (pae == null) {
            return null;
        }
        synchronized (pae) {
            while (!pae.haveResult) {
                try {
                    pae.wait();
                } catch (InterruptedException e) {
                }
            }
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                buildAssistBundleLocked(pae, pae.result);
                this.mPendingAssistExtras.remove(pae);
                this.mUiHandler.removeCallbacks(pae);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return pae.extras;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean isAssistDataAllowedOnCurrentActivity() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack focusedStack = getFocusedStack();
                if (focusedStack == null || focusedStack.isAssistantStack()) {
                } else {
                    ActivityRecord activity = focusedStack.topActivity();
                    if (activity == null) {
                        resetPriorityAfterLockedSection();
                        return false;
                    }
                    int userId = activity.userId;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return false;
    }

    public boolean showAssistFromActivity(IBinder token, Bundle args) {
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord caller = ActivityRecord.forTokenLocked(token);
                ActivityRecord top = getFocusedStack().topActivity();
                if (top != caller) {
                    Slog.w(TAG, "showAssistFromActivity failed: caller " + caller + " is not current top " + top);
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(ident);
                    return false;
                } else if (top.nowVisible) {
                    resetPriorityAfterLockedSection();
                    boolean showSessionForActiveService = this.mAssistUtils.showSessionForActiveService(args, 8, null, token);
                    Binder.restoreCallingIdentity(ident);
                    return showSessionForActiveService;
                } else {
                    Slog.w(TAG, "showAssistFromActivity failed: caller " + caller + " is not visible");
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(ident);
                    return false;
                }
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public boolean requestAssistContextExtras(int requestType, IResultReceiver receiver, Bundle receiverExtras, IBinder activityToken, boolean focused, boolean newSessionId) {
        return enqueueAssistContext(requestType, null, null, receiver, receiverExtras, activityToken, focused, newSessionId, UserHandle.getCallingUserId(), null, 2000, 0) != null;
    }

    public boolean requestAutofillData(IResultReceiver receiver, Bundle receiverExtras, IBinder activityToken, int flags) {
        return enqueueAssistContext(2, null, null, receiver, receiverExtras, activityToken, true, true, UserHandle.getCallingUserId(), null, 2000, flags) != null;
    }

    private PendingAssistExtras enqueueAssistContext(int requestType, Intent intent, String hint, IResultReceiver receiver, Bundle receiverExtras, IBinder activityToken, boolean focused, boolean newSessionId, int userHandle, Bundle args, long timeout, int flags) {
        PendingAssistExtras pendingAssistExtras;
        PendingAssistExtras pae;
        enforceCallingPermission("android.permission.GET_TOP_ACTIVITY_INFO", "enqueueAssistContext()");
        synchronized (this) {
            ActivityRecord activity;
            try {
                boostPriorityForLockedSection();
                activity = getFocusedStack().topActivity();
                if (activity == null) {
                    Slog.w(TAG, "getAssistContextExtras failed: no top activity");
                    pendingAssistExtras = null;
                } else if (activity.app == null || activity.app.thread == null) {
                    Slog.w(TAG, "getAssistContextExtras failed: no process for " + activity);
                    resetPriorityAfterLockedSection();
                    return null;
                } else {
                    if (!focused) {
                        activity = ActivityRecord.forTokenLocked(activityToken);
                        if (activity == null) {
                            Slog.w(TAG, "enqueueAssistContext failed: activity for token=" + activityToken + " couldn't be found");
                            resetPriorityAfterLockedSection();
                            return null;
                        } else if (activity.app == null || activity.app.thread == null) {
                            Slog.w(TAG, "enqueueAssistContext failed: no process for " + activity);
                            resetPriorityAfterLockedSection();
                            return null;
                        }
                    } else if (activityToken != null) {
                        ActivityRecord caller = ActivityRecord.forTokenLocked(activityToken);
                        if (activity != caller) {
                            Slog.w(TAG, "enqueueAssistContext failed: caller " + caller + " is not current top " + activity);
                            resetPriorityAfterLockedSection();
                            return null;
                        }
                    }
                    Bundle extras = new Bundle();
                    if (args != null) {
                        extras.putAll(args);
                    }
                    extras.putString("android.intent.extra.ASSIST_PACKAGE", activity.packageName);
                    extras.putInt("android.intent.extra.ASSIST_UID", activity.app.uid);
                    pae = new PendingAssistExtras(activity, extras, intent, hint, receiver, receiverExtras, userHandle);
                    pae.isHome = activity.isHomeActivity();
                    if (newSessionId) {
                        this.mViSessionId++;
                    }
                    activity.app.thread.requestAssistContextExtras(activity.appToken, pae, requestType, this.mViSessionId, flags);
                    this.mPendingAssistExtras.add(pae);
                    pendingAssistExtras = this.mUiHandler;
                    pendingAssistExtras.postDelayed(pae, timeout);
                }
            } catch (RemoteException e) {
                Slog.w(TAG, "getAssistContextExtras failed: crash calling " + activity);
                pendingAssistExtras = null;
                return pendingAssistExtras;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return pendingAssistExtras;
        return pae;
    }

    void pendingAssistExtrasTimedOut(PendingAssistExtras pae) {
        IResultReceiver receiver;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mPendingAssistExtras.remove(pae);
                receiver = pae.receiver;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        if (receiver != null) {
            Bundle sendBundle = new Bundle();
            sendBundle.putBundle("receiverExtras", pae.receiverExtras);
            try {
                pae.receiver.send(0, sendBundle);
            } catch (RemoteException e) {
            }
        }
    }

    private void buildAssistBundleLocked(PendingAssistExtras pae, Bundle result) {
        if (result != null) {
            pae.extras.putBundle("android.intent.extra.ASSIST_CONTEXT", result);
        }
        if (pae.hint != null) {
            pae.extras.putBoolean(pae.hint, true);
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void reportAssistContextExtras(IBinder token, Bundle extras, AssistStructure structure, AssistContent content, Uri referrer) {
        PendingAssistExtras pae = (PendingAssistExtras) token;
        synchronized (pae) {
            pae.result = extras;
            pae.structure = structure;
            pae.content = content;
            if (referrer != null) {
                pae.extras.putParcelable("android.intent.extra.REFERRER", referrer);
            }
            if (structure != null) {
                structure.setHomeActivity(pae.isHome);
            }
            pae.haveResult = true;
            pae.notifyAll();
            if (pae.intent == null && pae.receiver == null) {
                return;
            }
        }
        return;
        Binder.restoreCallingIdentity(ident);
    }

    public boolean launchAssistIntent(Intent intent, int requestType, String hint, int userHandle, Bundle args) {
        return enqueueAssistContext(requestType, intent, hint, null, null, null, true, true, userHandle, args, 500, 0) != null;
    }

    public void registerProcessObserver(IProcessObserver observer) {
        enforceCallingPermission("android.permission.SET_ACTIVITY_WATCHER", "registerProcessObserver()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mProcessObservers.register(observer);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void unregisterProcessObserver(IProcessObserver observer) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mProcessObservers.unregister(observer);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public int getUidProcessState(int uid, String callingPackage) {
        int i;
        if (!hasUsageStatsPermission(callingPackage)) {
            enforceCallingPermission("android.permission.PACKAGE_USAGE_STATS", "getUidProcessState");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                UidRecord uidRec = (UidRecord) this.mActiveUids.get(uid);
                i = uidRec != null ? uidRec.curProcState : 18;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return i;
    }

    public void registerUidObserver(IUidObserver observer, int which, int cutpoint, String callingPackage) {
        if (!hasUsageStatsPermission(callingPackage)) {
            enforceCallingPermission("android.permission.PACKAGE_USAGE_STATS", "registerUidObserver");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mUidObservers.register(observer, new UidObserverRegistration(Binder.getCallingUid(), callingPackage, which, cutpoint));
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void unregisterUidObserver(IUidObserver observer) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mUidObservers.unregister(observer);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public boolean convertFromTranslucent(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(origId);
                    return false;
                }
                boolean translucentChanged = r.changeWindowTranslucency(true);
                if (translucentChanged) {
                    this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                }
                this.mWindowManager.setAppFullscreen(token, true);
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(origId);
                return translucentChanged;
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public boolean convertToTranslucent(IBinder token, Bundle options) {
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(origId);
                    return false;
                }
                TaskRecord task = r.getTask();
                int index = task.mActivities.lastIndexOf(r);
                if (index > 0) {
                    ((ActivityRecord) task.mActivities.get(index - 1)).returningOptions = ActivityOptions.fromBundle(options);
                }
                boolean translucentChanged = r.changeWindowTranslucency(false);
                if (translucentChanged) {
                    r.getStack().convertActivityToTranslucent(r);
                }
                this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                this.mWindowManager.setAppFullscreen(token, false);
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(origId);
                return translucentChanged;
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public Bundle getActivityOptions(IBinder token) {
        Bundle bundle = null;
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    ActivityOptions activityOptions = r.takeOptionsLocked();
                    if (activityOptions != null) {
                        bundle = activityOptions.toBundle();
                    }
                    resetPriorityAfterLockedSection();
                    Binder.restoreCallingIdentity(origId);
                    return bundle;
                }
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(origId);
                return null;
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public void setImmersive(IBinder token, boolean immersive) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    throw new IllegalArgumentException();
                }
                r.immersive = immersive;
                if (r == this.mStackSupervisor.getResumedActivityLocked()) {
                    if (ActivityManagerDebugConfig.DEBUG_IMMERSIVE) {
                        Slog.d(TAG_IMMERSIVE, "Frontmost changed immersion: " + r);
                    }
                    applyUpdateLockStateLocked(r);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public boolean isImmersive(IBinder token) {
        boolean z;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    throw new IllegalArgumentException();
                }
                z = r.immersive;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return z;
    }

    public void setVrThread(int tid) {
        enforceSystemHasVrFeature();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    int pid = Binder.getCallingPid();
                    this.mVrController.setVrThreadLocked(tid, pid, (ProcessRecord) this.mPidsSelfLocked.get(pid));
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void setPersistentVrThread(int tid) {
        if (checkCallingPermission("android.permission.RESTRICTED_VR_ACCESS") != 0) {
            String msg = "Permission Denial: setPersistentVrThread() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.RESTRICTED_VR_ACCESS";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        enforceSystemHasVrFeature();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    int pid = Binder.getCallingPid();
                    this.mVrController.setPersistentVrThreadLocked(tid, pid, (ProcessRecord) this.mPidsSelfLocked.get(pid));
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    static boolean scheduleAsRegularPriority(int tid, boolean suppressLogs) {
        try {
            Process.setThreadScheduler(tid, 0, 0);
            return true;
        } catch (IllegalArgumentException e) {
            if (!suppressLogs) {
                Slog.w(TAG, "Failed to set scheduling policy, thread does not exist:\n" + e);
            }
            return false;
        } catch (SecurityException e2) {
            if (!suppressLogs) {
                Slog.w(TAG, "Failed to set scheduling policy, not allowed:\n" + e2);
            }
            return false;
        }
    }

    static boolean scheduleAsFifoPriority(int tid, boolean suppressLogs) {
        try {
            Process.setThreadScheduler(tid, 1073741825, 1);
            return true;
        } catch (IllegalArgumentException e) {
            if (!suppressLogs) {
                Slog.w(TAG, "Failed to set scheduling policy, thread does not exist:\n" + e);
            }
            return false;
        } catch (SecurityException e2) {
            if (!suppressLogs) {
                Slog.w(TAG, "Failed to set scheduling policy, not allowed:\n" + e2);
            }
            return false;
        }
    }

    private void enforceSystemHasVrFeature() {
        if (!this.mContext.getPackageManager().hasSystemFeature("android.software.vr.mode")) {
            throw new UnsupportedOperationException("VR mode not supported on this device!");
        }
    }

    public void setRenderThread(int tid) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int pid = Binder.getCallingPid();
                if (pid == Process.myPid()) {
                    demoteSystemServerRenderThread(tid);
                } else {
                    synchronized (this.mPidsSelfLocked) {
                        ProcessRecord proc = (ProcessRecord) this.mPidsSelfLocked.get(pid);
                        if (proc == null || proc.renderThreadTid != 0 || tid <= 0) {
                            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                Slog.d("UI_FIFO", "Didn't set thread from setRenderThread? PID: " + pid + ", TID: " + tid + " FIFO: " + this.mUseFifoUiScheduling);
                            }
                        } else if (Process.isThreadInProcess(pid, tid)) {
                            proc.renderThreadTid = tid;
                            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                Slog.d("UI_FIFO", "Set RenderThread tid " + tid + " for pid " + pid);
                            }
                            if (proc.curSchedGroup == 2) {
                                if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                    Slog.d("UI_FIFO", "Promoting " + tid + "out of band");
                                }
                                if (this.mUseFifoUiScheduling) {
                                    Process.setThreadScheduler(proc.renderThreadTid, 1073741825, 1);
                                } else {
                                    Process.setThreadPriority(proc.renderThreadTid, -10);
                                }
                            }
                        } else {
                            throw new IllegalArgumentException("Render thread does not belong to process");
                        }
                    }
                    resetPriorityAfterLockedSection();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private void demoteSystemServerRenderThread(int tid) {
        Process.setThreadPriority(tid, 10);
    }

    public int setVrMode(IBinder token, boolean enabled, ComponentName packageName) {
        if (this.mContext.getPackageManager().hasSystemFeature("android.software.vr.mode")) {
            VrManagerInternal vrService = (VrManagerInternal) LocalServices.getService(VrManagerInternal.class);
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    ActivityRecord r = ActivityRecord.isInStackLocked(token);
                    if (r == null) {
                        throw new IllegalArgumentException();
                    }
                    int err = vrService.hasVrPackage(packageName, r.userId);
                    if (err != 0) {
                        return err;
                    }
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            if (!enabled) {
                                packageName = null;
                            }
                            r.requestedVrComponent = packageName;
                            if (r == this.mStackSupervisor.getResumedActivityLocked()) {
                                applyUpdateVrModeLocked(r);
                            }
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                    return 0;
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return 0;
        }
        throw new UnsupportedOperationException("VR mode not supported on this device!");
    }

    public boolean isVrModePackageEnabled(ComponentName packageName) {
        if (!this.mContext.getPackageManager().hasSystemFeature("android.software.vr.mode")) {
            throw new UnsupportedOperationException("VR mode not supported on this device!");
        } else if (((VrManagerInternal) LocalServices.getService(VrManagerInternal.class)).hasVrPackage(packageName, UserHandle.getCallingUserId()) == 0) {
            return true;
        } else {
            return false;
        }
    }

    public boolean isTopActivityImmersive() {
        boolean z;
        enforceNotIsolatedCaller("startActivity");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = getFocusedStack().topRunningActivityLocked();
                z = r != null ? r.immersive : false;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return z;
    }

    boolean shouldDisableNonVrUiLocked() {
        return this.mVrController.shouldDisableNonVrUiLocked();
    }

    public boolean isTopOfTask(IBinder token) {
        boolean z;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    throw new IllegalArgumentException();
                }
                if (r.getTask().getTopActivity() == r) {
                    z = true;
                } else {
                    z = false;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return z;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void setHasTopUi(boolean hasTopUi) throws RemoteException {
        if (checkCallingPermission("android.permission.INTERNAL_SYSTEM_WINDOW") != 0) {
            String msg = "Permission Denial: setHasTopUi() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.INTERNAL_SYSTEM_WINDOW";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        int pid = Binder.getCallingPid();
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    boolean changed = false;
                    synchronized (this.mPidsSelfLocked) {
                        ProcessRecord pr = (ProcessRecord) this.mPidsSelfLocked.get(pid);
                        if (pr == null) {
                            Slog.w(TAG, "setHasTopUi called on unknown pid: " + pid);
                        } else if (pr.hasTopUi != hasTopUi) {
                            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                Slog.d(TAG, "Setting hasTopUi=" + hasTopUi + " for pid=" + pid);
                            }
                            pr.hasTopUi = hasTopUi;
                            changed = true;
                        }
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public final void enterSafeMode() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (!this.mSystemReady) {
                    try {
                        AppGlobals.getPackageManager().enterSafeMode();
                    } catch (RemoteException e) {
                    }
                }
                this.mSafeMode = true;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public final void showSafeModeOverlay() {
        View v = LayoutInflater.from(this.mContext).inflate(17367246, null);
        LayoutParams lp = new LayoutParams();
        lp.type = 2015;
        lp.width = -2;
        lp.height = -2;
        lp.gravity = 8388691;
        lp.format = v.getBackground().getOpacity();
        lp.flags = 24;
        lp.privateFlags |= 16;
        ((WindowManager) this.mContext.getSystemService(OppoProcessManager.RESUME_REASON_VISIBLE_WINDOW_STR)).addView(v, lp);
    }

    public void noteWakeupAlarm(IIntentSender sender, int sourceUid, String sourcePkg, String tag) {
        if (sender == null || ((sender instanceof PendingIntentRecord) ^ 1) == 0) {
            PendingIntentRecord rec = (PendingIntentRecord) sender;
            BatteryStatsImpl stats = this.mBatteryStatsService.getActiveStatistics();
            synchronized (stats) {
                if (this.mBatteryStatsService.isOnBattery()) {
                    this.mBatteryStatsService.enforceCallingPermission();
                    int uid = sender == null ? sourceUid : rec.uid == Binder.getCallingUid() ? 1000 : rec.uid;
                    if (sourceUid < 0) {
                        sourceUid = uid;
                    }
                    if (sourcePkg == null) {
                        sourcePkg = rec.key.packageName;
                    }
                    stats.getPackageStatsLocked(sourceUid, sourcePkg).noteWakeupAlarmLocked(tag);
                }
            }
        }
    }

    public void noteAlarmStart(IIntentSender sender, int sourceUid, String tag) {
        if (sender == null || ((sender instanceof PendingIntentRecord) ^ 1) == 0) {
            PendingIntentRecord rec = (PendingIntentRecord) sender;
            synchronized (this.mBatteryStatsService.getActiveStatistics()) {
                this.mBatteryStatsService.enforceCallingPermission();
                int uid = sender == null ? sourceUid : rec.uid == Binder.getCallingUid() ? 1000 : rec.uid;
                BatteryStatsService batteryStatsService = this.mBatteryStatsService;
                if (sourceUid < 0) {
                    sourceUid = uid;
                }
                batteryStatsService.noteAlarmStart(tag, sourceUid);
            }
        }
    }

    public void noteAlarmFinish(IIntentSender sender, int sourceUid, String tag) {
        if (sender == null || ((sender instanceof PendingIntentRecord) ^ 1) == 0) {
            PendingIntentRecord rec = (PendingIntentRecord) sender;
            synchronized (this.mBatteryStatsService.getActiveStatistics()) {
                this.mBatteryStatsService.enforceCallingPermission();
                int uid = sender == null ? sourceUid : rec.uid == Binder.getCallingUid() ? 1000 : rec.uid;
                BatteryStatsService batteryStatsService = this.mBatteryStatsService;
                if (sourceUid < 0) {
                    sourceUid = uid;
                }
                batteryStatsService.noteAlarmFinish(tag, sourceUid);
            }
        }
    }

    public boolean killPids(int[] pids, String pReason, boolean secure) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("killPids only available to the system");
        }
        String reason = pReason == null ? "Unknown" : pReason;
        boolean killed = false;
        synchronized (this.mPidsSelfLocked) {
            ProcessRecord proc;
            int worstType = 0;
            for (int i : pids) {
                proc = (ProcessRecord) this.mPidsSelfLocked.get(i);
                if (proc != null) {
                    int type = proc.setAdj;
                    if (type > worstType) {
                        worstType = type;
                    }
                }
            }
            if (worstType < 906 && worstType > 900) {
                worstType = 900;
            }
            if (!secure && worstType < 500) {
                worstType = 500;
            }
            Slog.w(TAG, "Killing processes " + reason + " at adjustment " + worstType);
            for (int i2 : pids) {
                proc = (ProcessRecord) this.mPidsSelfLocked.get(i2);
                if (!(proc == null || proc.setAdj < worstType || (proc.killedByAm ^ 1) == 0)) {
                    proc.kill(reason, true);
                    killed = true;
                }
            }
        }
        return killed;
    }

    public void killUid(int appId, int userId, String reason) {
        enforceCallingPermission("android.permission.KILL_UID", "killUid");
        synchronized (this) {
            long identity;
            try {
                boostPriorityForLockedSection();
                identity = Binder.clearCallingIdentity();
                killPackageProcessesLocked(null, appId, userId, -800, false, true, true, true, reason != null ? reason : "kill uid");
                Binder.restoreCallingIdentity(identity);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public boolean killProcessesBelowForeground(String reason) {
        if (Binder.getCallingUid() == 1000) {
            return killProcessesBelowAdj(0, reason);
        }
        throw new SecurityException("killProcessesBelowForeground() only available to system");
    }

    private boolean killProcessesBelowAdj(int belowAdj, String reason) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("killProcessesBelowAdj() only available to system");
        }
        boolean killed = false;
        synchronized (this.mPidsSelfLocked) {
            int size = this.mPidsSelfLocked.size();
            for (int i = 0; i < size; i++) {
                int pid = this.mPidsSelfLocked.keyAt(i);
                ProcessRecord proc = (ProcessRecord) this.mPidsSelfLocked.valueAt(i);
                if (!(proc == null || proc.setAdj <= belowAdj || (proc.killedByAm ^ 1) == 0)) {
                    proc.kill(reason, true);
                    killed = true;
                }
            }
        }
        return killed;
    }

    public void hang(IBinder who, boolean allowRestart) {
        if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
            throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
        }
        DeathRecipient death = new DeathRecipient() {
            public void binderDied() {
                synchronized (this) {
                    notifyAll();
                }
            }
        };
        try {
            who.linkToDeath(death, 0);
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    Watchdog.getInstance().setAllowRestart(allowRestart);
                    Slog.i(TAG, "Hanging system process at request of pid " + Binder.getCallingPid());
                    synchronized (death) {
                        while (who.isBinderAlive()) {
                            try {
                                death.wait();
                            } catch (InterruptedException e) {
                            }
                        }
                    }
                    Watchdog.getInstance().setAllowRestart(true);
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        } catch (RemoteException e2) {
            Slog.w(TAG, "hang: given caller IBinder is already dead.");
        }
    }

    public void restart() {
        if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
            throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
        }
        Log.i(TAG, "Sending shutdown broadcast...");
        BroadcastReceiver br = new BroadcastReceiver() {
            public void onReceive(Context context, Intent intent) {
                Log.i(ActivityManagerService.TAG, "Shutting down activity manager...");
                ActivityManagerService.this.shutdown(10000);
                Log.i(ActivityManagerService.TAG, "Shutdown complete, restarting!");
                Process.killProcess(Process.myPid());
                System.exit(10);
            }
        };
        Intent intent = new Intent("android.intent.action.ACTION_SHUTDOWN");
        intent.addFlags(268435456);
        intent.putExtra("android.intent.extra.SHUTDOWN_USERSPACE_ONLY", true);
        br.onReceive(this.mContext, intent);
    }

    private long getLowRamTimeSinceIdle(long now) {
        long j = 0;
        long j2 = this.mLowRamTimeSinceLastIdle;
        if (this.mLowRamStartTime > 0) {
            j = now - this.mLowRamStartTime;
        }
        return j + j2;
    }

    public void performIdleMaintenance() {
        if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
            throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long now = SystemClock.uptimeMillis();
                long timeSinceLastIdle = now - this.mLastIdleTime;
                long lowRamSinceLastIdle = getLowRamTimeSinceIdle(now);
                this.mLastIdleTime = now;
                this.mLowRamTimeSinceLastIdle = 0;
                if (this.mLowRamStartTime != 0) {
                    this.mLowRamStartTime = now;
                }
                StringBuilder sb = new StringBuilder(128);
                sb.append("Idle maintenance over ");
                TimeUtils.formatDuration(timeSinceLastIdle, sb);
                sb.append(" low RAM for ");
                TimeUtils.formatDuration(lowRamSinceLastIdle, sb);
                Slog.i(TAG, sb.toString());
                boolean doKilling = lowRamSinceLastIdle > timeSinceLastIdle / 3;
                for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                    ProcessRecord proc = (ProcessRecord) this.mLruProcesses.get(i);
                    if (proc.notCachedSinceIdle) {
                        if (proc.setProcState != 5 && proc.setProcState >= 4 && proc.setProcState <= 11 && doKilling && proc.initialIdlePss != 0 && proc.lastPss > (proc.initialIdlePss * 3) / 2) {
                            sb = new StringBuilder(128);
                            sb.append("Kill");
                            sb.append(proc.processName);
                            sb.append(" in idle maint: pss=");
                            sb.append(proc.lastPss);
                            sb.append(", swapPss=");
                            sb.append(proc.lastSwapPss);
                            sb.append(", initialPss=");
                            sb.append(proc.initialIdlePss);
                            sb.append(", period=");
                            TimeUtils.formatDuration(timeSinceLastIdle, sb);
                            sb.append(", lowRamPeriod=");
                            TimeUtils.formatDuration(lowRamSinceLastIdle, sb);
                            if (ActivityManagerDebugConfig.DEBUG_FSTRIM) {
                                Slog.wtfQuiet(TAG, sb.toString());
                            } else {
                                Slog.w(TAG, sb.toString());
                            }
                            proc.kill("idle maint (pss " + proc.lastPss + " from " + proc.initialIdlePss + ")", true);
                        }
                    } else if (proc.setProcState < 13 && proc.setProcState >= 0) {
                        proc.notCachedSinceIdle = true;
                        proc.initialIdlePss = 0;
                        proc.nextPssTime = ProcessList.computeNextPssTime(proc.setProcState, true, this.mTestPssMode, isSleepingLocked(), now);
                    }
                }
                this.mHandler.removeMessages(39);
                this.mHandler.sendEmptyMessageDelayed(39, JobStatus.DEFAULT_TRIGGER_MAX_DELAY);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void sendIdleJobTrigger() {
        if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
            throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
        }
        long ident = Binder.clearCallingIdentity();
        try {
            broadcastIntent(null, new Intent(ACTION_TRIGGER_IDLE).setPackage("android").addFlags(1073741824), null, null, 0, null, null, null, -1, null, true, false, -1);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    private void retrieveSettings() {
        boolean supportsPictureInPicture;
        ContentResolver resolver = this.mContext.getContentResolver();
        boolean freeformWindowManagement = !this.mContext.getPackageManager().hasSystemFeature("android.software.freeform_window_management") ? Global.getInt(resolver, "enable_freeform_support", 0) != 0 : true;
        boolean supportsMultiWindow = ActivityManager.supportsMultiWindow(this.mContext);
        if (supportsMultiWindow) {
            supportsPictureInPicture = this.mContext.getPackageManager().hasSystemFeature("android.software.picture_in_picture");
        } else {
            supportsPictureInPicture = false;
        }
        boolean supportsSplitScreenMultiWindow = ActivityManager.supportsSplitScreenMultiWindow(this.mContext);
        boolean supportsMultiDisplay = this.mContext.getPackageManager().hasSystemFeature("android.software.activities_on_secondary_displays");
        String debugApp = Global.getString(resolver, "debug_app");
        boolean waitForDebugger = Global.getInt(resolver, "wait_for_debugger", 0) != 0;
        boolean alwaysFinishActivities = Global.getInt(resolver, "always_finish_activities", 0) != 0;
        boolean forceRtl = Global.getInt(resolver, "debug.force_rtl", 0) != 0;
        boolean forceResizable = Global.getInt(resolver, "force_resizable_activities", 0) != 0;
        long waitForNetworkTimeoutMs = Global.getLong(resolver, "network_access_timeout_ms", NETWORK_ACCESS_TIMEOUT_DEFAULT_MS);
        boolean supportsLeanbackOnly = this.mContext.getPackageManager().hasSystemFeature("android.software.leanback_only");
        SystemProperties.set("debug.force_rtl", forceRtl ? LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON : "0");
        Configuration configuration = new Configuration();
        System.getConfiguration(resolver, configuration);
        if (forceRtl) {
            configuration.setLayoutDirection(configuration.locale);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mOrigDebugApp = debugApp;
                this.mDebugApp = debugApp;
                this.mOrigWaitForDebugger = waitForDebugger;
                this.mWaitForDebugger = waitForDebugger;
                this.mAlwaysFinishActivities = alwaysFinishActivities;
                this.mSupportsLeanbackOnly = supportsLeanbackOnly;
                this.mForceResizableActivities = forceResizable;
                boolean multiWindowFormEnabled;
                if (freeformWindowManagement || supportsSplitScreenMultiWindow || supportsPictureInPicture) {
                    multiWindowFormEnabled = true;
                } else {
                    multiWindowFormEnabled = supportsMultiDisplay;
                }
                if ((supportsMultiWindow || forceResizable) && multiWindowFormEnabled) {
                    this.mSupportsMultiWindow = true;
                    this.mSupportsFreeformWindowManagement = freeformWindowManagement;
                    this.mSupportsSplitScreenMultiWindow = supportsSplitScreenMultiWindow;
                    this.mSupportsPictureInPicture = supportsPictureInPicture;
                    this.mSupportsMultiDisplay = supportsMultiDisplay;
                } else {
                    this.mSupportsMultiWindow = false;
                    this.mSupportsFreeformWindowManagement = false;
                    this.mSupportsSplitScreenMultiWindow = false;
                    this.mSupportsPictureInPicture = false;
                    this.mSupportsMultiDisplay = false;
                }
                this.mWindowManager.setForceResizableTasks(this.mForceResizableActivities);
                this.mWindowManager.setSupportsPictureInPicture(this.mSupportsPictureInPicture);
                updateConfigurationLocked(configuration, null, true);
                Configuration globalConfig = getGlobalConfiguration();
                if (ActivityManagerDebugConfig.DEBUG_CONFIGURATION) {
                    Slog.v(TAG_CONFIGURATION, "Initial config: " + globalConfig);
                }
                Resources res = this.mContext.getResources();
                this.mHasRecents = res.getBoolean(17956976);
                this.mThumbnailWidth = res.getDimensionPixelSize(17104898);
                this.mThumbnailHeight = res.getDimensionPixelSize(17104897);
                this.mAppErrors.loadAppsNotReportingCrashesFromConfigLocked(res.getString(17039647));
                this.mUserController.mUserSwitchUiEnabled = res.getBoolean(17956915) ^ 1;
                if ((globalConfig.uiMode & 4) == 4) {
                    this.mFullscreenThumbnailScale = ((float) res.getInteger(17694964)) / ((float) globalConfig.screenWidthDp);
                } else {
                    this.mFullscreenThumbnailScale = res.getFraction(18022411, 1, 1);
                }
                this.mWaitForNetworkTimeoutMs = waitForNetworkTimeoutMs;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "ZhiYong.Lin@Plf.Framework, modify for permission intercept; Jianhua.Lin@Plf.SDK, 2017-02-13 : Add for accidentally touch; Jianhua.Lin@Plf.SDK, 2017-07-12 : Add for secure keyboard; Changwei.Li@ROM.SDK, 2017-06-29 : Add for display optimization", property = OppoRomType.OPPO)
    public void systemReady(Runnable goingCallback, TimingsTraceLog traceLog) {
        Throwable th;
        traceLog.traceBegin("PhaseActivityManagerReady");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (!this.mSystemReady) {
                    this.mLocalDeviceIdleController = (com.android.server.DeviceIdleController.LocalService) LocalServices.getService(com.android.server.DeviceIdleController.LocalService.class);
                    this.mAssistUtils = new AssistUtils(this.mContext);
                    this.mVrController.onSystemReady();
                    if (SystemProperties.getBoolean("persist.sys.remove.task", false)) {
                        this.mRecentTasks.clearTasksWhileRebooting();
                        SystemProperties.set("persist.sys.remove.task", "");
                    }
                    this.mUserController.onSystemReady();
                    this.mRecentTasks.onSystemReadyLocked();
                    permissionInterceptPolicyReady();
                    this.mAppOpsService.systemReady();
                    this.mSystemReady = true;
                } else if (goingCallback != null) {
                    goingCallback.run();
                }
            } catch (Throwable th2) {
                resetPriorityAfterLockedSection();
                throw th2;
            }
        }
        if (!Build.isBuildConsistent()) {
            Slog.e(TAG, "Build fingerprint is not consistent, warning user");
            this.mUiHandler.obtainMessage(15).sendToTarget();
        }
        long ident = Binder.clearCallingIdentity();
        try {
            Intent intent = new Intent("android.intent.action.USER_STARTED");
            intent.addFlags(1342177280);
            intent.putExtra("android.intent.extra.user_handle", currentUserId);
            broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, -1, null, false, false, MY_PID, 1000, currentUserId);
            intent = new Intent("android.intent.action.USER_STARTING");
            intent.addFlags(1073741824);
            intent.putExtra("android.intent.extra.user_handle", currentUserId);
            Intent intent2 = intent;
            broadcastIntentLocked(null, null, intent2, null, new IIntentReceiver.Stub() {
                public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException {
                }
            }, 0, null, null, new String[]{"android.permission.INTERACT_ACROSS_USERS"}, -1, null, true, false, MY_PID, 1000, -1);
            Binder.restoreCallingIdentity(ident);
        } catch (Throwable th22) {
            Binder.restoreCallingIdentity(ident);
            throw th22;
        }
        this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
        this.mUserController.sendUserSwitchBroadcastsLocked(-1, currentUserId);
        traceLog.traceEnd();
        traceLog.traceEnd();
        resetPriorityAfterLockedSection();
        return;
        synchronized (this.mPidsSelfLocked) {
            try {
                int i = this.mPidsSelfLocked.size() - 1;
                ArrayList<ProcessRecord> procsToKill = null;
                while (i >= 0) {
                    ArrayList<ProcessRecord> procsToKill2;
                    try {
                        ProcessRecord proc = (ProcessRecord) this.mPidsSelfLocked.valueAt(i);
                        if (isAllowedWhileBooting(proc.info)) {
                            procsToKill2 = procsToKill;
                        } else {
                            if (procsToKill == null) {
                                procsToKill2 = new ArrayList();
                            } else {
                                procsToKill2 = procsToKill;
                            }
                            procsToKill2.add(proc);
                        }
                        i--;
                        procsToKill = procsToKill2;
                    } catch (Throwable th3) {
                        th22 = th3;
                        procsToKill2 = procsToKill;
                        throw th22;
                    }
                }
            } catch (Throwable th4) {
                th22 = th4;
            }
        }
    }

    private void reportLowmemStats(ArrayList<ProcessMemInfo> memInfos) {
        int i;
        ProcessMemInfo mi;
        SparseArray<ProcessMemInfo> sparseArray = new SparseArray(memInfos.size());
        int N = memInfos.size();
        for (i = 0; i < N; i++) {
            mi = (ProcessMemInfo) memInfos.get(i);
            sparseArray.put(mi.pid, mi);
        }
        updateCpuStatsNow();
        long[] memtrackTmp = new long[1];
        synchronized (this.mProcessCpuTracker) {
            N = this.mProcessCpuTracker.countStats();
            for (i = 0; i < N; i++) {
                Stats st = this.mProcessCpuTracker.getStats(i);
                if (st.vsize > 0) {
                    long pss = Debug.getPss(st.pid, null, memtrackTmp);
                    if (pss > 0) {
                        if (sparseArray.indexOfKey(st.pid) < 0) {
                            mi = new ProcessMemInfo(st.name, st.pid, JobSchedulerShellCommand.CMD_ERR_NO_PACKAGE, -1, "native", null);
                            mi.pss = pss;
                            mi.memtrack = memtrackTmp[0];
                            memInfos.add(mi);
                        }
                    }
                }
            }
        }
        long totalPss = 0;
        long totalMemtrack = 0;
        N = memInfos.size();
        for (i = 0; i < N; i++) {
            mi = (ProcessMemInfo) memInfos.get(i);
            if (mi.pss == 0) {
                mi.pss = Debug.getPss(mi.pid, null, memtrackTmp);
                mi.memtrack = memtrackTmp[0];
            }
            totalPss += mi.pss;
            totalMemtrack += mi.memtrack;
        }
        Collections.sort(memInfos, new Comparator<ProcessMemInfo>() {
            public int compare(ProcessMemInfo lhs, ProcessMemInfo rhs) {
                int i = 1;
                int i2 = -1;
                if (lhs.oomAdj != rhs.oomAdj) {
                    if (lhs.oomAdj >= rhs.oomAdj) {
                        i2 = 1;
                    }
                    return i2;
                } else if (lhs.pss == rhs.pss) {
                    return 0;
                } else {
                    if (lhs.pss >= rhs.pss) {
                        i = -1;
                    }
                    return i;
                }
            }
        });
        StringBuilder stringBuilder = new StringBuilder(128);
        stringBuilder.append("Low on memory maybe memleak ");
        stringBuilder = new StringBuilder(1024);
        StringBuilder shortNativeBuilder = new StringBuilder(1024);
        stringBuilder = new StringBuilder(1024);
        long extraNativeRam = 0;
        long extraNativeMemtrack = 0;
        long cachedPss = 0;
        N = memInfos.size();
        for (i = 0; i < N; i++) {
            mi = (ProcessMemInfo) memInfos.get(i);
            if (mi.oomAdj >= 900) {
                cachedPss += mi.pss;
            }
            appendMemInfo(stringBuilder, mi);
            if (mi.oomAdj != JobSchedulerShellCommand.CMD_ERR_NO_PACKAGE) {
                if (extraNativeRam > 0) {
                    appendBasicMemEntry(shortNativeBuilder, JobSchedulerShellCommand.CMD_ERR_NO_PACKAGE, -1, extraNativeRam, extraNativeMemtrack, "(Other native)");
                    shortNativeBuilder.append(10);
                    extraNativeRam = 0;
                }
                appendMemInfo(stringBuilder, mi);
            } else if (mi.pss >= 512) {
                appendMemInfo(shortNativeBuilder, mi);
            } else {
                extraNativeRam += mi.pss;
                extraNativeMemtrack += mi.memtrack;
            }
        }
        stringBuilder.append("           ");
        ProcessList.appendRamKb(stringBuilder, totalPss);
        stringBuilder.append(" kB: TOTAL");
        if (totalMemtrack > 0) {
            stringBuilder.append(" (");
            stringBuilder.append(totalMemtrack);
            stringBuilder.append(" kB memtrack)");
        }
        stringBuilder.append("\n");
        MemInfoReader memInfo = new MemInfoReader();
        memInfo.readMemInfo();
        long[] infos = memInfo.getRawInfo();
        stringBuilder = new StringBuilder(1024);
        stringBuilder.append("  MemInfo: ");
        stringBuilder.append(infos[5]).append(" kB slab, ");
        stringBuilder.append(infos[4]).append(" kB shmem, ");
        stringBuilder.append(infos[12]).append(" kB vm alloc, ");
        stringBuilder.append(infos[13]).append(" kB page tables ");
        stringBuilder.append(infos[14]).append(" kB kernel stack\n");
        stringBuilder.append("           ");
        stringBuilder.append(infos[2]).append(" kB buffers, ");
        stringBuilder.append(infos[3]).append(" kB cached, ");
        stringBuilder.append(infos[11]).append(" kB mapped, ");
        stringBuilder.append(infos[1]).append(" kB free\n");
        if (infos[10] != 0) {
            stringBuilder.append("  ZRAM: ");
            stringBuilder.append(infos[10]);
            stringBuilder.append(" kB RAM, ");
            stringBuilder.append(infos[8]);
            stringBuilder.append(" kB swap total, ");
            stringBuilder.append(infos[9]);
            stringBuilder.append(" kB swap free\n");
        }
        long[] ksm = getKsmInfo();
        if (!(ksm[1] == 0 && ksm[0] == 0 && ksm[2] == 0 && ksm[3] == 0)) {
            stringBuilder.append("  KSM: ");
            stringBuilder.append(ksm[1]);
            stringBuilder.append(" kB saved from shared ");
            stringBuilder.append(ksm[0]);
            stringBuilder.append(" kB\n");
            stringBuilder.append("       ");
            stringBuilder.append(ksm[2]);
            stringBuilder.append(" kB unshared; ");
            stringBuilder.append(ksm[3]);
            stringBuilder.append(" kB volatile\n");
        }
        stringBuilder.append("  Free RAM: ");
        stringBuilder.append((memInfo.getCachedSizeKb() + cachedPss) + memInfo.getFreeSizeKb());
        stringBuilder.append(" kB\n");
        stringBuilder.append("  Used RAM: ");
        stringBuilder.append((totalPss - cachedPss) + memInfo.getKernelUsedSizeKb());
        stringBuilder.append(" kB\n");
        stringBuilder.append("  Lost RAM: ");
        stringBuilder.append((((memInfo.getTotalSizeKb() - totalPss) - memInfo.getFreeSizeKb()) - memInfo.getCachedSizeKb()) - memInfo.getKernelUsedSizeKb());
        stringBuilder.append(" kB\n");
        stringBuilder.append("  ExtraMemInfo: \n");
        if (infos[15] != 0) {
            stringBuilder.append("           ");
            stringBuilder.append(infos[15] * 4).append(" kB ion cached\n");
        }
        if (infos[16] != 0) {
            stringBuilder.append("           ");
            stringBuilder.append(infos[16]).append(" kB ion orphaned\n");
            String[] ionOrphaned = new String[50];
            Debug.getIonOrphanedProcess(ionOrphaned);
            i = 0;
            while (i < 50 && !ionOrphaned[i].equals("null")) {
                stringBuilder.append("           ");
                stringBuilder.append(ionOrphaned[i]);
                i++;
            }
            stringBuilder.append("\n");
        }
        Slog.i(TAG, "Low on memory:");
        Slog.i(TAG, shortNativeBuilder.toString());
        Slog.i(TAG, stringBuilder.toString());
        Slog.i(TAG, stringBuilder.toString());
        stringBuilder = new StringBuilder(1024);
        stringBuilder.append("Low on memory:");
        stringBuilder.append(10);
        stringBuilder.append(stringBuilder);
        stringBuilder.append(stringBuilder);
        stringBuilder.append(10);
        stringBuilder.append(stringBuilder);
        stringBuilder.append(10);
        addErrorToDropBox("lmk_uevent", null, "lowmmeorykiller", null, null, stringBuilder.toString(), stringBuilder.toString(), null, null);
    }

    void killAppAtUsersRequest(ProcessRecord app, Dialog fromDialog) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (app.pid > 0 && app.pid != MY_PID) {
                    OppoExtraActivityManagerService.setKeyLockModeNormal(this.mContext, app.processName, this.mSystemReady);
                }
                this.mAppErrors.killAppAtUserRequestLocked(app, fromDialog);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    void skipCurrentReceiverLocked(ProcessRecord app) {
        for (BroadcastQueue queue : this.mBroadcastQueues) {
            queue.skipCurrentReceiverLocked(app);
        }
    }

    public void handleApplicationCrash(IBinder app, ParcelableCrashInfo crashInfo) {
        ProcessRecord r = findAppProcess(app, "Crash");
        String processName = app == null ? "system_server" : r == null ? Shell.NIGHT_MODE_STR_UNKNOWN : r.processName;
        if (app == null) {
            AgingCriticalEvent.getInstance().writeEvent(AgingCriticalEvent.EVENT_SYSTEMSERVER_JAVA_CRASH, "systemserver pid:" + Process.myPid());
        }
        if (!(r == null || r.info == null || crashInfo == null)) {
            OppoAppStartupManager.getInstance().handleApplicationCrash(r, crashInfo.exceptionClassName, crashInfo.exceptionMessage, crashInfo.stackTrace);
        }
        handleApplicationCrashInner("crash", r, processName, crashInfo);
    }

    void handleApplicationCrashInner(String eventType, ProcessRecord r, String processName, CrashInfo crashInfo) {
        Object[] objArr = new Object[8];
        objArr[0] = Integer.valueOf(Binder.getCallingPid());
        objArr[1] = Integer.valueOf(UserHandle.getUserId(Binder.getCallingUid()));
        objArr[2] = processName;
        objArr[3] = Integer.valueOf(r == null ? -1 : r.info.flags);
        objArr[4] = crashInfo.exceptionClassName;
        objArr[5] = crashInfo.exceptionMessage;
        objArr[6] = crashInfo.throwFileName;
        objArr[7] = Integer.valueOf(crashInfo.throwLineNumber);
        EventLog.writeEvent(EventLogTags.AM_CRASH, objArr);
        addErrorToDropBox(eventType, r, processName, null, null, null, null, null, crashInfo);
        this.mAppErrors.crashApplication(r, crashInfo);
    }

    public void handleApplicationStrictModeViolation(IBinder app, int violationMask, ViolationInfo info) {
        ProcessRecord r = findAppProcess(app, "StrictMode");
        if (r != null) {
            if ((DumpState.DUMP_COMPILER_STATS & violationMask) != 0) {
                Integer stackFingerprint = Integer.valueOf(info.hashCode());
                boolean logIt = true;
                synchronized (this.mAlreadyLoggedViolatedStacks) {
                    if (this.mAlreadyLoggedViolatedStacks.contains(stackFingerprint)) {
                        logIt = false;
                    } else {
                        if (this.mAlreadyLoggedViolatedStacks.size() >= OppoArpPeer.ARP_DUP_RESPONSE_TIMEOUT) {
                            this.mAlreadyLoggedViolatedStacks.clear();
                        }
                        this.mAlreadyLoggedViolatedStacks.add(stackFingerprint);
                    }
                }
                if (logIt) {
                    logStrictModeViolationToDropBox(r, info);
                }
            }
            if ((DumpState.DUMP_INTENT_FILTER_VERIFIERS & violationMask) != 0) {
                AppErrorResult result = new AppErrorResult();
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        long origId = Binder.clearCallingIdentity();
                        Message msg = Message.obtain();
                        msg.what = 26;
                        HashMap<String, Object> data = new HashMap();
                        data.put("result", result);
                        data.put("app", r);
                        data.put("violationMask", Integer.valueOf(violationMask));
                        data.put("info", info);
                        msg.obj = data;
                        this.mUiHandler.sendMessage(msg);
                        Binder.restoreCallingIdentity(origId);
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
                Slog.w(TAG, "handleApplicationStrictModeViolation; res=" + result.get());
            }
        }
    }

    private void logStrictModeViolationToDropBox(ProcessRecord process, ViolationInfo info) {
        if (info != null) {
            boolean isSystemApp = process != null ? (process.info.flags & 129) != 0 : true;
            String processName = process == null ? Shell.NIGHT_MODE_STR_UNKNOWN : process.processName;
            final String dropboxTag = isSystemApp ? "system_app_strictmode" : "data_app_strictmode";
            final DropBoxManager dbox = (DropBoxManager) this.mContext.getSystemService("dropbox");
            if (dbox != null) {
                try {
                    if ((dbox.isTagEnabled(dropboxTag) ^ 1) == 0) {
                        boolean bufferWasEmpty;
                        final StringBuilder sb = isSystemApp ? this.mStrictModeBuffer : new StringBuilder(1024);
                        synchronized (sb) {
                            bufferWasEmpty = sb.length() == 0;
                            appendDropBoxProcessHeaders(process, processName, sb);
                            sb.append("Build: ").append(Build.FINGERPRINT).append("\n");
                            sb.append("System-App: ").append(isSystemApp).append("\n");
                            sb.append("Uptime-Millis: ").append(info.violationUptimeMillis).append("\n");
                            if (info.violationNumThisLoop != 0) {
                                sb.append("Loop-Violation-Number: ").append(info.violationNumThisLoop).append("\n");
                            }
                            if (info.numAnimationsRunning != 0) {
                                sb.append("Animations-Running: ").append(info.numAnimationsRunning).append("\n");
                            }
                            if (info.broadcastIntentAction != null) {
                                sb.append("Broadcast-Intent-Action: ").append(info.broadcastIntentAction).append("\n");
                            }
                            if (info.durationMillis != -1) {
                                sb.append("Duration-Millis: ").append(info.durationMillis).append("\n");
                            }
                            if (info.numInstances != -1) {
                                sb.append("Instance-Count: ").append(info.numInstances).append("\n");
                            }
                            if (info.tags != null) {
                                for (String tag : info.tags) {
                                    sb.append("Span-Tag: ").append(tag).append("\n");
                                }
                            }
                            sb.append("\n");
                            if (!(info.crashInfo == null || info.crashInfo.stackTrace == null)) {
                                sb.append(info.crashInfo.stackTrace);
                                sb.append("\n");
                            }
                            if (info.message != null) {
                                sb.append(info.message);
                                sb.append("\n");
                            }
                            boolean needsFlush = sb.length() > 65536;
                        }
                        if (!isSystemApp || needsFlush) {
                            new Thread("Error dump: " + dropboxTag) {
                                public void run() {
                                    String report;
                                    synchronized (sb) {
                                        report = sb.toString();
                                        sb.delete(0, sb.length());
                                        sb.trimToSize();
                                    }
                                    if (report.length() != 0) {
                                        dbox.addText(dropboxTag, report);
                                    }
                                }
                            }.start();
                        } else if (bufferWasEmpty) {
                            new Thread("Error dump: " + dropboxTag) {
                                public void run() {
                                    try {
                                        Thread.sleep(FaceDaemonWrapper.TIMEOUT_FACED_BINDERCALL_CHECK);
                                    } catch (InterruptedException e) {
                                    }
                                    synchronized (ActivityManagerService.this.mStrictModeBuffer) {
                                        String errorReport = ActivityManagerService.this.mStrictModeBuffer.toString();
                                        if (errorReport.length() == 0) {
                                            return;
                                        }
                                        ActivityManagerService.this.mStrictModeBuffer.delete(0, ActivityManagerService.this.mStrictModeBuffer.length());
                                        ActivityManagerService.this.mStrictModeBuffer.trimToSize();
                                        dbox.addText(dropboxTag, errorReport);
                                    }
                                }
                            }.start();
                        }
                    }
                } catch (RuntimeException e) {
                    Slog.e(TAG, "Exception in dbox", e);
                }
            }
        }
    }

    public boolean handleApplicationWtf(IBinder app, String tag, boolean system, ParcelableCrashInfo crashInfo) {
        final int callingUid = Binder.getCallingUid();
        final int callingPid = Binder.getCallingPid();
        if (system) {
            final IBinder iBinder = app;
            final String str = tag;
            final ParcelableCrashInfo parcelableCrashInfo = crashInfo;
            this.mHandler.post(new Runnable() {
                public void run() {
                    ActivityManagerService.this.handleApplicationWtfInner(callingUid, callingPid, iBinder, str, parcelableCrashInfo);
                }
            });
            return false;
        }
        ProcessRecord r = handleApplicationWtfInner(callingUid, callingPid, app, tag, crashInfo);
        boolean isFatal = Build.IS_ENG || Global.getInt(this.mContext.getContentResolver(), "wtf_is_fatal", 0) != 0;
        int isSystem = r != null ? r.persistent : 1;
        if (!isFatal || (isSystem ^ 1) == 0) {
            return false;
        }
        this.mAppErrors.crashApplication(r, crashInfo);
        return true;
    }

    ProcessRecord handleApplicationWtfInner(int callingUid, int callingPid, IBinder app, String tag, CrashInfo crashInfo) {
        ProcessRecord r = findAppProcess(app, "WTF");
        String processName = app == null ? "system_server" : r == null ? Shell.NIGHT_MODE_STR_UNKNOWN : r.processName;
        Object[] objArr = new Object[6];
        objArr[0] = Integer.valueOf(UserHandle.getUserId(callingUid));
        objArr[1] = Integer.valueOf(callingPid);
        objArr[2] = processName;
        objArr[3] = Integer.valueOf(r == null ? -1 : r.info.flags);
        objArr[4] = tag;
        objArr[5] = crashInfo.exceptionMessage;
        EventLog.writeEvent(EventLogTags.AM_WTF, objArr);
        addErrorToDropBox("wtf", r, processName, null, null, tag, null, null, crashInfo);
        return r;
    }

    private ProcessRecord findAppProcess(IBinder app, String reason) {
        ProcessRecord p;
        if (app == null) {
            return null;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int NP = this.mProcessNames.getMap().size();
                for (int ip = 0; ip < NP; ip++) {
                    SparseArray<ProcessRecord> apps = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
                    int NA = apps.size();
                    int ia = 0;
                    while (ia < NA) {
                        p = (ProcessRecord) apps.valueAt(ia);
                        if (p.thread == null || p.thread.asBinder() != app) {
                            ia++;
                        }
                    }
                }
                Slog.w(TAG, "Can't find mystery application for " + reason + " from pid=" + Binder.getCallingPid() + " uid=" + Binder.getCallingUid() + ": " + app);
                resetPriorityAfterLockedSection();
                return null;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return p;
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "Jianhua.Lin@Plf.SDK, 2017-08-22 : Add for EAP", property = OppoRomType.ROM)
    private void appendDropBoxProcessHeaders(ProcessRecord process, String processName, StringBuilder sb) {
        if (process == null) {
            sb.append("Process: ").append(processName).append("\n");
            return;
        }
        synchronized (this) {
            String pkg;
            try {
                boostPriorityForLockedSection();
                sb.append("Process: ").append(processName).append("\n");
                sb.append("PID: ").append(process.pid).append("\n");
                this.mErrorTime = System.currentTimeMillis();
                sb.append("Time: ").append(this.mErrorTime).append("\n");
                int flags = process.info.flags;
                IPackageManager pm = AppGlobals.getPackageManager();
                sb.append("Flags: 0x").append(Integer.toHexString(flags)).append("\n");
                for (int ip = 0; ip < process.pkgList.size(); ip++) {
                    pkg = (String) process.pkgList.keyAt(ip);
                    sb.append("Package: ").append(pkg);
                    this.mErrorPkgName = pkg;
                    PackageInfo pi = pm.getPackageInfo(pkg, 0, UserHandle.getCallingUserId());
                    if (pi != null) {
                        sb.append(" v").append(pi.versionCode);
                        if (pi.versionName != null) {
                            sb.append(" (").append(pi.versionName).append(")");
                        }
                    }
                    sb.append("\n");
                }
                sb.append("PID: ").append(process.pid).append("\n");
                if (process.info.isInstantApp()) {
                    sb.append("Instant-App: true\n");
                }
            } catch (RemoteException e) {
                Slog.e(TAG, "Error getting package info: " + pkg, e);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    private static String processClass(ProcessRecord process) {
        if (process == null || process.pid == MY_PID) {
            return "system_server";
        }
        if ((process.info.flags & 1) != 0) {
            return "system_app";
        }
        return "data_app";
    }

    private void DumpEnvironment() {
        SystemProperties.set("sys.dumpenvironment.finished", "0");
        SystemProperties.set("ctl.start", "dumpenvironment");
        long begin = SystemClock.elapsedRealtime();
        int wait_time = SystemProperties.getInt("ro.dumpenvironment.time", 4000);
        while (SystemProperties.getInt("sys.dumpenvironment.finished", 0) != 1 && SystemClock.elapsedRealtime() - begin < ((long) wait_time)) {
            SystemClock.sleep(100);
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void addErrorToDropBox(String eventType, ProcessRecord process, String processName, ActivityRecord activity, ActivityRecord parent, String subject, String report, File dataFile, CrashInfo crashInfo) {
        if (ServiceManager.getService("dropbox") != null) {
            final DropBoxManager dbox = (DropBoxManager) this.mContext.getSystemService(DropBoxManager.class);
            String dropboxTag = processClass(process) + LocationManagerService.OPPO_FAKE_LOCATION_SPLIT + eventType;
            if (dbox != null) {
                try {
                    if ((dbox.isTagEnabled(dropboxTag) ^ 1) == 0) {
                        long now = SystemClock.elapsedRealtime();
                        if (now - this.mWtfClusterStart > 10000) {
                            this.mWtfClusterStart = now;
                            this.mWtfClusterCount = 1;
                        } else {
                            int i = this.mWtfClusterCount;
                            this.mWtfClusterCount = i + 1;
                            if (i >= 5) {
                                return;
                            }
                        }
                        StringBuilder stringBuilder = new StringBuilder(1024);
                        appendDropBoxProcessHeaders(process, processName, stringBuilder);
                        collectErrorInfo(dropboxTag, eventType, process, processName, activity, subject, crashInfo);
                        if (process != null) {
                            stringBuilder.append("Foreground: ").append(process.isInterestingToUserLocked() ? "Yes" : "No").append("\n");
                        }
                        if (activity != null) {
                            stringBuilder.append("Activity: ").append(activity.shortComponentName).append("\n");
                        }
                        if (parent != null) {
                            try {
                                if (!(parent.app == null || parent.app.pid == process.pid)) {
                                    stringBuilder.append("Parent-Process: ").append(parent.app.processName).append("\n");
                                }
                            } catch (Throwable e) {
                                Slog.e(TAG, "Exception when append parent app processName!", e);
                            }
                        }
                        if (!(parent == null || parent == activity)) {
                            stringBuilder.append("Parent-Activity: ").append(parent.shortComponentName).append("\n");
                        }
                        if (subject != null) {
                            stringBuilder.append("Subject: ").append(subject).append("\n");
                        }
                        stringBuilder.append("Build: ").append(Build.FINGERPRINT).append("\n");
                        if (Debug.isDebuggerConnected()) {
                            stringBuilder.append("Debugger: Connected\n");
                        }
                        stringBuilder.append("\n");
                        final String str = report;
                        final StringBuilder stringBuilder2 = stringBuilder;
                        final String str2 = dropboxTag;
                        final File file = dataFile;
                        final CrashInfo crashInfo2 = crashInfo;
                        final String str3 = eventType;
                        Thread worker = new Thread("Error dump: " + dropboxTag) {
                            public void run() {
                                IOException e;
                                Throwable th;
                                if (str != null) {
                                    stringBuilder2.append(str);
                                }
                                int lines = Global.getInt(ActivityManagerService.this.mContext.getContentResolver(), "logcat_for_" + str2, 0);
                                int maxDataFileSize = (1048576 - stringBuilder2.length()) - (lines * 100);
                                if (file != null) {
                                    try {
                                        stringBuilder2.append(FileUtils.readTextFile(file, maxDataFileSize, "\n\n[[TRUNCATED]]"));
                                    } catch (IOException e2) {
                                        Slog.e(ActivityManagerService.TAG, "Error reading " + file, e2);
                                    }
                                }
                                if (!(crashInfo2 == null || crashInfo2.stackTrace == null)) {
                                    stringBuilder2.append(crashInfo2.stackTrace);
                                }
                                ActivityManagerService.this.appendCpuInfo(stringBuilder2, str3);
                                if (lines > 0) {
                                    stringBuilder2.append("\n");
                                    InputStreamReader input = null;
                                    try {
                                        Process logcat = new ProcessBuilder(new String[]{"/system/bin/timeout", "-k", "15s", "10s", "/system/bin/logcat", "-v", "threadtime", "-b", "events", "-b", "system", "-b", "main", "-b", "crash", "-t", String.valueOf(lines)}).redirectErrorStream(true).start();
                                        try {
                                            logcat.getOutputStream().close();
                                        } catch (IOException e3) {
                                        }
                                        try {
                                            logcat.getErrorStream().close();
                                        } catch (IOException e4) {
                                        }
                                        InputStreamReader input2 = new InputStreamReader(logcat.getInputStream());
                                        try {
                                            char[] buf = new char[8192];
                                            while (true) {
                                                int num = input2.read(buf);
                                                if (num <= 0) {
                                                    break;
                                                }
                                                stringBuilder2.append(buf, 0, num);
                                            }
                                            if (input2 != null) {
                                                try {
                                                    input2.close();
                                                } catch (IOException e5) {
                                                }
                                            }
                                        } catch (IOException e6) {
                                            e2 = e6;
                                            input = input2;
                                            try {
                                                Slog.e(ActivityManagerService.TAG, "Error running logcat", e2);
                                                if (input != null) {
                                                    try {
                                                        input.close();
                                                    } catch (IOException e7) {
                                                    }
                                                }
                                                dbox.addText(str2, stringBuilder2.toString());
                                            } catch (Throwable th2) {
                                                th = th2;
                                                if (input != null) {
                                                    try {
                                                        input.close();
                                                    } catch (IOException e8) {
                                                    }
                                                }
                                                throw th;
                                            }
                                        } catch (Throwable th3) {
                                            th = th3;
                                            input = input2;
                                            if (input != null) {
                                                try {
                                                    input.close();
                                                } catch (IOException e82) {
                                                }
                                            }
                                            throw th;
                                        }
                                    } catch (IOException e9) {
                                        e2 = e9;
                                    }
                                }
                                dbox.addText(str2, stringBuilder2.toString());
                            }
                        };
                        if (process == null) {
                            worker.run();
                        } else {
                            worker.start();
                        }
                        if (processName != null) {
                            if (!processClass(process).equals("system_app")) {
                                if (!processName.contains(".oppo.")) {
                                }
                            }
                            if (eventType.equals("crash")) {
                                OppoExtraActivityManagerService.setKeyLockModeNormal(this.mContext, processName, this.mSystemReady);
                            }
                        }
                        if (processClass(process).equals("system_server")) {
                            if ((eventType.equals("wtf") ^ 1) != 0) {
                                if ((eventType.equals("lowmem") ^ 1) != 0) {
                                    DumpEnvironment();
                                    if (MONITOR_THREAD_CPU_USAGE) {
                                        ASSERT.copyBinderInfo();
                                    }
                                }
                            }
                        }
                        if (eventType.equals("anr") && MONITOR_THREAD_CPU_USAGE) {
                            ASSERT.copyBinderInfo();
                        }
                    }
                } catch (Throwable e2) {
                    Slog.e(TAG, "addErrorToDropBox Exception in dbox", e2);
                }
            }
        }
    }

    public List<ProcessErrorStateInfo> getProcessesInErrorState() {
        Throwable th;
        enforceNotIsolatedCaller("getProcessesInErrorState");
        boolean allUsers = ActivityManager.checkUidPermission("android.permission.INTERACT_ACROSS_USERS_FULL", Binder.getCallingUid()) == 0;
        int userId = UserHandle.getUserId(Binder.getCallingUid());
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int i = this.mLruProcesses.size() - 1;
                List<ProcessErrorStateInfo> errList = null;
                while (i >= 0) {
                    List<ProcessErrorStateInfo> errList2;
                    try {
                        ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
                        if (!allUsers && app.userId != userId) {
                            errList2 = errList;
                        } else if (app.thread == null) {
                            errList2 = errList;
                        } else if (app.crashing || app.notResponding) {
                            Object report = null;
                            if (app.crashing) {
                                report = app.crashingReport;
                            } else if (app.notResponding) {
                                report = app.notRespondingReport;
                            }
                            if (report != null) {
                                if (errList == null) {
                                    errList2 = new ArrayList(1);
                                } else {
                                    errList2 = errList;
                                }
                                errList2.add(report);
                            } else {
                                Slog.w(TAG, "Missing app error report, app = " + app.processName + " crashing = " + app.crashing + " notResponding = " + app.notResponding);
                                errList2 = errList;
                            }
                        } else {
                            errList2 = errList;
                        }
                        i--;
                        errList = errList2;
                    } catch (Throwable th2) {
                        th = th2;
                        errList2 = errList;
                        resetPriorityAfterLockedSection();
                        throw th;
                    }
                }
                resetPriorityAfterLockedSection();
                return errList;
            } catch (Throwable th3) {
                th = th3;
            }
        }
    }

    static int procStateToImportance(int procState, int memAdj, RunningAppProcessInfo currApp, int clientTargetSdk) {
        int imp = RunningAppProcessInfo.procStateToImportanceForTargetSdk(procState, clientTargetSdk);
        if (imp == 400) {
            currApp.lru = memAdj;
        } else {
            currApp.lru = 0;
        }
        return imp;
    }

    private void fillInProcMemInfo(ProcessRecord app, RunningAppProcessInfo outInfo, int clientTargetSdk) {
        outInfo.pid = app.pid;
        outInfo.uid = app.info.uid;
        if (this.mHeavyWeightProcess == app) {
            outInfo.flags |= 1;
        }
        if (app.persistent) {
            outInfo.flags |= 2;
        }
        if (app.activities.size() > 0) {
            outInfo.flags |= 4;
        }
        outInfo.lastTrimLevel = app.trimMemoryLevel;
        outInfo.importance = procStateToImportance(app.curProcState, app.curAdj, outInfo, clientTargetSdk);
        outInfo.importanceReasonCode = app.adjTypeCode;
        outInfo.processState = app.curProcState;
    }

    public List<RunningAppProcessInfo> getRunningAppProcesses() {
        Throwable th;
        enforceNotIsolatedCaller("getRunningAppProcesses");
        int callingUid = Binder.getCallingUid();
        int clientTargetSdk = this.mPackageManagerInt.getUidTargetSdkVersion(callingUid);
        boolean allUsers = ActivityManager.checkUidPermission("android.permission.INTERACT_ACROSS_USERS_FULL", callingUid) == 0;
        int userId = UserHandle.getUserId(callingUid);
        boolean allUids = isGetTasksAllowed("getRunningAppProcesses", Binder.getCallingPid(), callingUid);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int i = this.mLruProcesses.size() - 1;
                List<RunningAppProcessInfo> runList = null;
                while (i >= 0) {
                    List<RunningAppProcessInfo> runList2;
                    try {
                        ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
                        if ((!allUsers && app.userId != userId) || (!allUids && app.uid != callingUid)) {
                            runList2 = runList;
                        } else if (app.thread == null || app.crashing) {
                            runList2 = runList;
                        } else if ((app.notResponding ^ 1) != 0) {
                            RunningAppProcessInfo currApp = new RunningAppProcessInfo(app.processName, app.pid, app.getPackageList());
                            fillInProcMemInfo(app, currApp, clientTargetSdk);
                            if (app.adjSource instanceof ProcessRecord) {
                                currApp.importanceReasonPid = ((ProcessRecord) app.adjSource).pid;
                                currApp.importanceReasonImportance = RunningAppProcessInfo.procStateToImportance(app.adjSourceProcState);
                            } else if (app.adjSource instanceof ActivityRecord) {
                                ActivityRecord r = app.adjSource;
                                if (r.app != null) {
                                    currApp.importanceReasonPid = r.app.pid;
                                }
                            }
                            if (app.adjTarget instanceof ComponentName) {
                                currApp.importanceReasonComponent = (ComponentName) app.adjTarget;
                            }
                            if (runList == null) {
                                runList2 = new ArrayList();
                            } else {
                                runList2 = runList;
                            }
                            runList2.add(currApp);
                        } else {
                            runList2 = runList;
                        }
                        i--;
                        runList = runList2;
                    } catch (Throwable th2) {
                        th = th2;
                        runList2 = runList;
                        resetPriorityAfterLockedSection();
                        throw th;
                    }
                }
                resetPriorityAfterLockedSection();
                return runList;
            } catch (Throwable th3) {
                th = th3;
            }
        }
    }

    public List<Integer> getConnectionPids(List<Integer> srcPids) {
        if (srcPids == null) {
            return null;
        }
        List<Integer> outPids;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                outPids = new ArrayList();
                for (ProcessRecord proc : this.mLruProcesses) {
                    if (srcPids.contains(Integer.valueOf(proc.pid))) {
                        ProcessRecord pr;
                        if (!proc.connections.isEmpty()) {
                            for (ConnectionRecord cr : proc.connections) {
                                AppBindRecord abr = cr.binding;
                                if (abr != null) {
                                    ServiceRecord sr = abr.service;
                                    if (sr != null) {
                                        pr = sr.app;
                                        if (pr != null) {
                                            outPids.add(Integer.valueOf(pr.pid));
                                        }
                                    }
                                }
                            }
                        }
                        if (!proc.conProviders.isEmpty()) {
                            for (ContentProviderConnection cpc : proc.conProviders) {
                                ContentProviderRecord cpr = cpc.provider;
                                if (cpr != null) {
                                    pr = cpr.proc;
                                    if (pr != null) {
                                        outPids.add(Integer.valueOf(pr.pid));
                                    }
                                }
                            }
                        }
                        if (proc.adjSource instanceof ProcessRecord) {
                            ProcessRecord procAdj = proc.adjSource;
                            if (proc != null) {
                                outPids.add(Integer.valueOf(procAdj.pid));
                            }
                        }
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return outPids;
    }

    public List<ApplicationInfo> getRunningExternalApplications() {
        enforceNotIsolatedCaller("getRunningExternalApplications");
        List<RunningAppProcessInfo> runningApps = getRunningAppProcesses();
        List<ApplicationInfo> retList = new ArrayList();
        if (runningApps != null && runningApps.size() > 0) {
            Set<String> extList = new HashSet();
            for (RunningAppProcessInfo app : runningApps) {
                if (app.pkgList != null) {
                    for (String pkg : app.pkgList) {
                        extList.add(pkg);
                    }
                }
            }
            IPackageManager pm = AppGlobals.getPackageManager();
            for (String pkg2 : extList) {
                try {
                    ApplicationInfo info = pm.getApplicationInfo(pkg2, 0, UserHandle.getCallingUserId());
                    if ((info.flags & DumpState.DUMP_DOMAIN_PREFERRED) != 0) {
                        retList.add(info);
                    }
                } catch (RemoteException e) {
                }
            }
        }
        return retList;
    }

    public void getMyMemoryState(RunningAppProcessInfo outInfo) {
        enforceNotIsolatedCaller("getMyMemoryState");
        int clientTargetSdk = this.mPackageManagerInt.getUidTargetSdkVersion(Binder.getCallingUid());
        synchronized (this) {
            try {
                ProcessRecord proc;
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    proc = (ProcessRecord) this.mPidsSelfLocked.get(Binder.getCallingPid());
                }
                fillInProcMemInfo(proc, outInfo, clientTargetSdk);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public int getMemoryTrimLevel() {
        int i;
        enforceNotIsolatedCaller("getMyMemoryState");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                i = this.mLastMemoryLevel;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return i;
    }

    public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err, String[] args, ShellCallback callback, ResultReceiver resultReceiver) {
        new ActivityManagerShellCommand(this, false).exec(this, in, out, err, args, callback, resultReceiver);
    }

    SleepToken acquireSleepToken(String tag, int displayId) {
        SleepToken token;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                token = this.mStackSupervisor.createSleepTokenLocked(tag, displayId);
                updateSleepIfNeededLocked();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return token;
    }

    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
        if (DumpUtils.checkDumpAndUsageStatsPermission(this.mContext, TAG, pw)) {
            boolean dumpAll = false;
            boolean dumpClient = false;
            boolean dumpCheckin = false;
            boolean dumpCheckinFormat = false;
            boolean dumpVisibleStacksOnly = false;
            boolean dumpFocusedStackOnly = false;
            String dumpPackage = null;
            int opti = 0;
            while (opti < args.length) {
                String opt = args[opti];
                if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
                    break;
                }
                opti++;
                if ("-a".equals(opt)) {
                    dumpAll = true;
                } else if ("-c".equals(opt)) {
                    dumpClient = true;
                } else if ("-v".equals(opt)) {
                    dumpVisibleStacksOnly = true;
                } else if ("-f".equals(opt)) {
                    dumpFocusedStackOnly = true;
                } else if ("-p".equals(opt)) {
                    if (opti < args.length) {
                        dumpPackage = args[opti];
                        opti++;
                        dumpClient = true;
                    } else {
                        pw.println("Error: -p option requires package argument");
                        return;
                    }
                } else if ("--checkin".equals(opt)) {
                    dumpCheckinFormat = true;
                    dumpCheckin = true;
                } else if ("-C".equals(opt)) {
                    dumpCheckinFormat = true;
                } else if ("-h".equals(opt)) {
                    ActivityManagerShellCommand.dumpHelp(pw, true);
                    return;
                } else {
                    pw.println("Unknown argument: " + opt + "; use -h for help");
                }
            }
            long origId = Binder.clearCallingIdentity();
            boolean more = false;
            if (opti < args.length) {
                String cmd = args[opti];
                opti++;
                String[] newArgs;
                Object newArgs2;
                String name;
                if ("activities".equals(cmd) || "a".equals(cmd)) {
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            dumpActivitiesLocked(fd, pw, args, opti, true, dumpClient, dumpPackage);
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                    Binder.restoreCallingIdentity(origId);
                } else if ("lastanr".equals(cmd)) {
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            dumpLastANRLocked(pw);
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                    Binder.restoreCallingIdentity(origId);
                } else if ("starter".equals(cmd)) {
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            dumpActivityStarterLocked(pw, dumpPackage);
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                    Binder.restoreCallingIdentity(origId);
                } else if ("recents".equals(cmd) || "r".equals(cmd)) {
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            dumpRecentsLocked(fd, pw, args, opti, true, dumpPackage);
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                    Binder.restoreCallingIdentity(origId);
                } else if ("broadcasts".equals(cmd) || "b".equals(cmd)) {
                    if (opti >= args.length) {
                        newArgs = EMPTY_STRING_ARRAY;
                    } else {
                        dumpPackage = args[opti];
                        opti++;
                        newArgs2 = new String[(args.length - opti)];
                        if (args.length > 2) {
                            System.arraycopy(args, opti, newArgs2, 0, args.length - opti);
                        }
                    }
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            dumpBroadcastsLocked(fd, pw, args, opti, true, dumpPackage);
                            OppoBroadcastManager.getInstance(this).dumpLocked(fd, pw, args, opti, dumpAll, dumpPackage, true);
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                    Binder.restoreCallingIdentity(origId);
                } else if ("broadcast-stats".equals(cmd)) {
                    if (opti >= args.length) {
                        newArgs = EMPTY_STRING_ARRAY;
                    } else {
                        dumpPackage = args[opti];
                        opti++;
                        newArgs2 = new String[(args.length - opti)];
                        if (args.length > 2) {
                            System.arraycopy(args, opti, newArgs2, 0, args.length - opti);
                        }
                    }
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            if (dumpCheckinFormat) {
                                dumpBroadcastStatsCheckinLocked(fd, pw, args, opti, dumpCheckin, dumpPackage);
                            } else {
                                dumpBroadcastStatsLocked(fd, pw, args, opti, true, dumpPackage);
                            }
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                    Binder.restoreCallingIdentity(origId);
                } else if ("intents".equals(cmd) || "i".equals(cmd)) {
                    if (opti >= args.length) {
                        newArgs = EMPTY_STRING_ARRAY;
                    } else {
                        dumpPackage = args[opti];
                        opti++;
                        newArgs2 = new String[(args.length - opti)];
                        if (args.length > 2) {
                            System.arraycopy(args, opti, newArgs2, 0, args.length - opti);
                        }
                    }
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            dumpPendingIntentsLocked(fd, pw, args, opti, true, dumpPackage);
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                    Binder.restoreCallingIdentity(origId);
                } else if ("processes".equals(cmd) || OppoCrashClearManager.CRASH_CLEAR_NAME.equals(cmd)) {
                    if (opti >= args.length) {
                        newArgs = EMPTY_STRING_ARRAY;
                    } else {
                        dumpPackage = args[opti];
                        opti++;
                        newArgs2 = new String[(args.length - opti)];
                        if (args.length > 2) {
                            System.arraycopy(args, opti, newArgs2, 0, args.length - opti);
                        }
                    }
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            dumpProcessesLocked(fd, pw, args, opti, true, dumpPackage);
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                    Binder.restoreCallingIdentity(origId);
                } else if ("oom".equals(cmd) || OppoCrashClearManager.CRASH_TIMEOUT.equals(cmd)) {
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            dumpOomLocked(fd, pw, args, opti, true);
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                    Binder.restoreCallingIdentity(origId);
                } else if ("permissions".equals(cmd) || "perm".equals(cmd)) {
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            dumpPermissionsLocked(fd, pw, args, opti, true, null);
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                    Binder.restoreCallingIdentity(origId);
                } else if ("provider".equals(cmd)) {
                    if (opti >= args.length) {
                        name = null;
                        newArgs = EMPTY_STRING_ARRAY;
                    } else {
                        name = args[opti];
                        opti++;
                        newArgs2 = new String[(args.length - opti)];
                        if (args.length > 2) {
                            System.arraycopy(args, opti, newArgs2, 0, args.length - opti);
                        }
                    }
                    if (!dumpProvider(fd, pw, name, newArgs, 0, dumpAll)) {
                        pw.println("No providers match: " + name);
                        pw.println("Use -h for help.");
                    }
                } else if ("providers".equals(cmd) || "prov".equals(cmd)) {
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            dumpProvidersLocked(fd, pw, args, opti, true, null);
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                    Binder.restoreCallingIdentity(origId);
                } else if ("service".equals(cmd)) {
                    if (opti >= args.length) {
                        name = null;
                        newArgs = EMPTY_STRING_ARRAY;
                    } else {
                        name = args[opti];
                        opti++;
                        newArgs2 = new String[(args.length - opti)];
                        if (args.length > 2) {
                            System.arraycopy(args, opti, newArgs2, 0, args.length - opti);
                        }
                    }
                    if (!this.mServices.dumpService(fd, pw, name, newArgs, 0, dumpAll)) {
                        pw.println("No services match: " + name);
                        pw.println("Use -h for help.");
                    }
                } else if ("package".equals(cmd)) {
                    if (opti >= args.length) {
                        pw.println("package: no package name specified");
                        pw.println("Use -h for help.");
                    } else {
                        dumpPackage = args[opti];
                        opti++;
                        newArgs2 = new String[(args.length - opti)];
                        if (args.length > 2) {
                            System.arraycopy(args, opti, newArgs2, 0, args.length - opti);
                        }
                        Object args2 = newArgs2;
                        opti = 0;
                        more = true;
                    }
                } else if ("associations".equals(cmd) || "as".equals(cmd)) {
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            dumpAssociationsLocked(fd, pw, args, opti, true, dumpClient, dumpPackage);
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                    Binder.restoreCallingIdentity(origId);
                } else if ("settings".equals(cmd)) {
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            this.mConstants.dump(pw);
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                    Binder.restoreCallingIdentity(origId);
                } else if ("services".equals(cmd) || "s".equals(cmd)) {
                    if (dumpClient) {
                        synchronized (this) {
                            try {
                                boostPriorityForLockedSection();
                                ServiceDumper dumper = this.mServices.newServiceDumperLocked(fd, pw, args, opti, true, dumpPackage);
                                dumper.dumpWithClient();
                            } finally {
                                resetPriorityAfterLockedSection();
                            }
                        }
                        Binder.restoreCallingIdentity(origId);
                    }
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            this.mServices.newServiceDumperLocked(fd, pw, args, opti, true, dumpPackage).dumpLocked();
                        } finally {
                            resetPriorityAfterLockedSection();
                        }
                    }
                    Binder.restoreCallingIdentity(origId);
                } else if ("log".equals(cmd)) {
                    dynamicallyConfigLogTag(pw, args, opti);
                } else if ("get_value".equals(cmd)) {
                    dynamicGetValue(pw, args);
                    return;
                } else if ("debug_switch".equals(cmd)) {
                    dumpDynamicallyLogSwitch(pw, args, opti);
                } else if ("locks".equals(cmd)) {
                    LockGuard.dump(fd, pw, args);
                } else if ("coloros-log".equals(cmd)) {
                    OppoDynamicLogManager.getInstance().handleOppoDynamicLog(pw, args, opti);
                    return;
                } else if ("force_persist_junk_event".equals(cmd)) {
                    if (opti == args.length) {
                        OppoJunkRecorder.getInstance().forcePersist(System.currentTimeMillis());
                        pw.println("All junk events persisted.");
                    } else if ("resetEnable".equals(args[opti])) {
                        OppoJunkRecorder.getInstance().resetEnable();
                        pw.println("OppoJunkRecorder isEnable: " + OppoJunkRecorder.getInstance().isEnable());
                    }
                } else if (!dumpActivity(fd, pw, cmd, args, opti, dumpAll, dumpVisibleStacksOnly, dumpFocusedStackOnly)) {
                    if (new ActivityManagerShellCommand(this, true).exec(this, null, fd, null, args, null, new ResultReceiver(null)) < 0) {
                        pw.println("Bad activity command, or no activities match: " + cmd);
                        pw.println("Use -h for help.");
                    }
                }
                if (!more) {
                    Binder.restoreCallingIdentity(origId);
                    return;
                }
            }
            if (dumpCheckinFormat) {
                dumpBroadcastStatsCheckinLocked(fd, pw, args, opti, dumpCheckin, dumpPackage);
            } else if (dumpClient) {
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        this.mConstants.dump(pw);
                        pw.println();
                        if (dumpAll) {
                            pw.println("-------------------------------------------------------------------------------");
                        }
                        dumpPendingIntentsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                        pw.println();
                        if (dumpAll) {
                            pw.println("-------------------------------------------------------------------------------");
                        }
                        dumpBroadcastsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                        pw.println();
                        if (dumpAll) {
                            pw.println("-------------------------------------------------------------------------------");
                        }
                        if (dumpAll || dumpPackage != null) {
                            dumpBroadcastStatsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                            pw.println();
                            if (dumpAll) {
                                pw.println("-------------------------------------------------------------------------------");
                            }
                        }
                        dumpProvidersLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                        pw.println();
                        if (dumpAll) {
                            pw.println("-------------------------------------------------------------------------------");
                        }
                        dumpPermissionsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                        pw.println();
                        if (dumpAll) {
                            pw.println("-------------------------------------------------------------------------------");
                        }
                        ServiceDumper sdumper = this.mServices.newServiceDumperLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                        sdumper.dumpWithClient();
                        pw.println();
                        synchronized (this) {
                            try {
                                boostPriorityForLockedSection();
                                if (dumpAll) {
                                    pw.println("-------------------------------------------------------------------------------");
                                }
                                dumpRecentsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                                pw.println();
                                if (dumpAll) {
                                    pw.println("-------------------------------------------------------------------------------");
                                }
                                dumpLastANRLocked(pw);
                                pw.println();
                                if (dumpAll) {
                                    pw.println("-------------------------------------------------------------------------------");
                                }
                                dumpActivityStarterLocked(pw, dumpPackage);
                                pw.println();
                                if (dumpAll) {
                                    pw.println("-------------------------------------------------------------------------------");
                                }
                                dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
                                if (this.mAssociations.size() > 0) {
                                    pw.println();
                                    if (dumpAll) {
                                        pw.println("-------------------------------------------------------------------------------");
                                    }
                                    dumpAssociationsLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
                                }
                                pw.println();
                                if (dumpAll) {
                                    pw.println("-------------------------------------------------------------------------------");
                                }
                                dumpProcessesLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                            } finally {
                                resetPriorityAfterLockedSection();
                            }
                        }
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
            } else {
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        this.mConstants.dump(pw);
                        pw.println();
                        if (dumpAll) {
                            pw.println("-------------------------------------------------------------------------------");
                        }
                        dumpPendingIntentsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                        pw.println();
                        if (dumpAll) {
                            pw.println("-------------------------------------------------------------------------------");
                        }
                        dumpBroadcastsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                        pw.println();
                        if (dumpAll) {
                            pw.println("-------------------------------------------------------------------------------");
                        }
                        if (dumpAll || dumpPackage != null) {
                            dumpBroadcastStatsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                            pw.println();
                            if (dumpAll) {
                                pw.println("-------------------------------------------------------------------------------");
                            }
                        }
                        dumpProvidersLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                        pw.println();
                        if (dumpAll) {
                            pw.println("-------------------------------------------------------------------------------");
                        }
                        dumpPermissionsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                        pw.println();
                        if (dumpAll) {
                            pw.println("-------------------------------------------------------------------------------");
                        }
                        this.mServices.newServiceDumperLocked(fd, pw, args, opti, dumpAll, dumpPackage).dumpLocked();
                        pw.println();
                        if (dumpAll) {
                            pw.println("-------------------------------------------------------------------------------");
                        }
                        dumpRecentsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                        pw.println();
                        if (dumpAll) {
                            pw.println("-------------------------------------------------------------------------------");
                        }
                        dumpLastANRLocked(pw);
                        pw.println();
                        if (dumpAll) {
                            pw.println("-------------------------------------------------------------------------------");
                        }
                        dumpActivityStarterLocked(pw, dumpPackage);
                        pw.println();
                        if (dumpAll) {
                            pw.println("-------------------------------------------------------------------------------");
                        }
                        dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
                        if (this.mAssociations.size() > 0) {
                            pw.println();
                            if (dumpAll) {
                                pw.println("-------------------------------------------------------------------------------");
                            }
                            dumpAssociationsLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
                        }
                        pw.println();
                        if (dumpAll) {
                            pw.println("-------------------------------------------------------------------------------");
                        }
                        dumpProcessesLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
            }
            Binder.restoreCallingIdentity(origId);
        }
    }

    private void dumpLastANRLocked(PrintWriter pw) {
        pw.println("ACTIVITY MANAGER LAST ANR (dumpsys activity lastanr)");
        if (this.mLastANRState == null) {
            pw.println("  <no ANR has occurred since boot>");
        } else {
            pw.println(this.mLastANRState);
        }
    }

    private void dumpActivityStarterLocked(PrintWriter pw, String dumpPackage) {
        pw.println("ACTIVITY MANAGER STARTER (dumpsys activity starter)");
        this.mActivityStarter.dump(pw, "", dumpPackage);
    }

    void dumpActivitiesLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, boolean dumpClient, String dumpPackage) {
        dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage, "ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)");
    }

    void dumpActivitiesLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, boolean dumpClient, String dumpPackage, String header) {
        pw.println(header);
        boolean printedAnything = this.mStackSupervisor.dumpActivitiesLocked(fd, pw, dumpAll, dumpClient, dumpPackage);
        boolean needSep = printedAnything;
        if (ActivityStackSupervisor.printThisActivity(pw, this.mStackSupervisor.getResumedActivityLocked(), dumpPackage, printedAnything, "  ResumedActivity: ")) {
            printedAnything = true;
            needSep = false;
        }
        if (dumpPackage == null) {
            if (needSep) {
                pw.println();
            }
            printedAnything = true;
            this.mStackSupervisor.dump(pw, "  ");
        }
        if (!printedAnything) {
            pw.println("  (nothing)");
        }
    }

    void dumpRecentsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        pw.println("ACTIVITY MANAGER RECENT TASKS (dumpsys activity recents)");
        boolean printedAnything = false;
        if (this.mRecentTasks != null && this.mRecentTasks.size() > 0) {
            boolean printedHeader = false;
            int N = this.mRecentTasks.size();
            for (int i = 0; i < N; i++) {
                TaskRecord tr = (TaskRecord) this.mRecentTasks.get(i);
                if (dumpPackage == null || (tr.realActivity != null && (dumpPackage.equals(tr.realActivity.getPackageName()) ^ 1) == 0)) {
                    if (!printedHeader) {
                        pw.println("  Recent tasks:");
                        printedHeader = true;
                        printedAnything = true;
                    }
                    pw.print("  * Recent #");
                    pw.print(i);
                    pw.print(": ");
                    pw.println(tr);
                    if (dumpAll) {
                        ((TaskRecord) this.mRecentTasks.get(i)).dump(pw, "    ");
                    }
                }
            }
        }
        if (!printedAnything) {
            pw.println("  (nothing)");
        }
    }

    void dumpAssociationsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, boolean dumpClient, String dumpPackage) {
        pw.println("ACTIVITY MANAGER ASSOCIATIONS (dumpsys activity associations)");
        int dumpUid = 0;
        if (dumpPackage != null) {
            try {
                dumpUid = AppGlobals.getPackageManager().getPackageUid(dumpPackage, DumpState.DUMP_CHANGES, 0);
            } catch (RemoteException e) {
            }
        }
        boolean printedAnything = false;
        long now = SystemClock.uptimeMillis();
        int N1 = this.mAssociations.size();
        for (int i1 = 0; i1 < N1; i1++) {
            ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> targetComponents = (ArrayMap) this.mAssociations.valueAt(i1);
            int N2 = targetComponents.size();
            for (int i2 = 0; i2 < N2; i2++) {
                SparseArray<ArrayMap<String, Association>> sourceUids = (SparseArray) targetComponents.valueAt(i2);
                int N3 = sourceUids.size();
                for (int i3 = 0; i3 < N3; i3++) {
                    ArrayMap<String, Association> sourceProcesses = (ArrayMap) sourceUids.valueAt(i3);
                    int N4 = sourceProcesses.size();
                    for (int i4 = 0; i4 < N4; i4++) {
                        Association ass = (Association) sourceProcesses.valueAt(i4);
                        if (dumpPackage == null || ass.mTargetComponent.getPackageName().equals(dumpPackage) || UserHandle.getAppId(ass.mSourceUid) == dumpUid) {
                            printedAnything = true;
                            pw.print("  ");
                            pw.print(ass.mTargetProcess);
                            pw.print("/");
                            UserHandle.formatUid(pw, ass.mTargetUid);
                            pw.print(" <- ");
                            pw.print(ass.mSourceProcess);
                            pw.print("/");
                            UserHandle.formatUid(pw, ass.mSourceUid);
                            pw.println();
                            pw.print("    via ");
                            pw.print(ass.mTargetComponent.flattenToShortString());
                            pw.println();
                            pw.print("    ");
                            long dur = ass.mTime;
                            if (ass.mNesting > 0) {
                                dur += now - ass.mStartTime;
                            }
                            TimeUtils.formatDuration(dur, pw);
                            pw.print(" (");
                            pw.print(ass.mCount);
                            pw.print(" times)");
                            pw.print("  ");
                            for (int i = 0; i < ass.mStateTimes.length; i++) {
                                long amt = ass.mStateTimes[i];
                                if (ass.mLastState + 0 == i) {
                                    amt += now - ass.mLastStateUptime;
                                }
                                if (amt != 0) {
                                    pw.print(" ");
                                    pw.print(ProcessList.makeProcStateString(i + 0));
                                    pw.print("=");
                                    TimeUtils.formatDuration(amt, pw);
                                    if (ass.mLastState + 0 == i) {
                                        pw.print("*");
                                    }
                                }
                            }
                            pw.println();
                            if (ass.mNesting > 0) {
                                pw.print("    Currently active: ");
                                TimeUtils.formatDuration(now - ass.mStartTime, pw);
                                pw.println();
                            }
                        }
                    }
                }
            }
        }
        if (!printedAnything) {
            pw.println("  (nothing)");
        }
    }

    boolean dumpUids(PrintWriter pw, String dumpPackage, SparseArray<UidRecord> uids, String header, boolean needSep) {
        boolean printed = false;
        int whichAppId = -1;
        if (dumpPackage != null) {
            try {
                whichAppId = UserHandle.getAppId(this.mContext.getPackageManager().getApplicationInfo(dumpPackage, 0).uid);
            } catch (NameNotFoundException e) {
                e.printStackTrace();
            }
        }
        for (int i = 0; i < uids.size(); i++) {
            UidRecord uidRec = (UidRecord) uids.valueAt(i);
            if (dumpPackage == null || UserHandle.getAppId(uidRec.uid) == whichAppId) {
                if (!printed) {
                    printed = true;
                    if (needSep) {
                        pw.println();
                    }
                    pw.print("  ");
                    pw.println(header);
                    needSep = true;
                }
                pw.print("    UID ");
                UserHandle.formatUid(pw, uidRec.uid);
                pw.print(": ");
                pw.println(uidRec);
            }
        }
        return printed;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    void dumpProcessesLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        ProcessRecord r;
        boolean printed;
        int i;
        int j;
        boolean needSep = false;
        boolean printedAnything = false;
        int numPers = 0;
        pw.println("ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)");
        if (dumpAll) {
            int NP = this.mProcessNames.getMap().size();
            for (int ip = 0; ip < NP; ip++) {
                SparseArray<ProcessRecord> procs = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
                int NA = procs.size();
                for (int ia = 0; ia < NA; ia++) {
                    r = (ProcessRecord) procs.valueAt(ia);
                    if (dumpPackage == null || (r.pkgList.containsKey(dumpPackage) ^ 1) == 0) {
                        if (!needSep) {
                            pw.println("  All known processes:");
                            needSep = true;
                            printedAnything = true;
                        }
                        pw.print(r.persistent ? "  *PERS*" : "  *APP*");
                        pw.print(" UID ");
                        pw.print(procs.keyAt(ia));
                        pw.print(" ");
                        pw.println(r);
                        r.dump(pw, "    ");
                        if (r.persistent) {
                            numPers++;
                        }
                    }
                }
            }
        }
        if (this.mIsolatedProcesses.size() > 0) {
            printed = false;
            for (i = 0; i < this.mIsolatedProcesses.size(); i++) {
                r = (ProcessRecord) this.mIsolatedProcesses.valueAt(i);
                if (dumpPackage == null || (r.pkgList.containsKey(dumpPackage) ^ 1) == 0) {
                    if (!printed) {
                        if (needSep) {
                            pw.println();
                        }
                        pw.println("  Isolated process list (sorted by uid):");
                        printedAnything = true;
                        printed = true;
                        needSep = true;
                    }
                    pw.print("    Isolated #");
                    pw.print(i);
                    pw.print(": ");
                    pw.println(r);
                }
            }
        }
        if (this.mActiveInstrumentation.size() > 0) {
            printed = false;
            for (i = 0; i < this.mActiveInstrumentation.size(); i++) {
                ActiveInstrumentation ai = (ActiveInstrumentation) this.mActiveInstrumentation.get(i);
                if (dumpPackage == null || (ai.mClass.getPackageName().equals(dumpPackage) ^ 1) == 0 || (ai.mTargetInfo.packageName.equals(dumpPackage) ^ 1) == 0) {
                    if (!printed) {
                        if (needSep) {
                            pw.println();
                        }
                        pw.println("  Active instrumentation:");
                        printedAnything = true;
                        printed = true;
                        needSep = true;
                    }
                    pw.print("    Instrumentation #");
                    pw.print(i);
                    pw.print(": ");
                    pw.println(ai);
                    ai.dump(pw, "      ");
                }
            }
        }
        if (this.mActiveUids.size() > 0) {
            if (dumpUids(pw, dumpPackage, this.mActiveUids, "UID states:", needSep)) {
                needSep = true;
                printedAnything = true;
            }
        }
        if (dumpAll && this.mValidateUids.size() > 0) {
            if (dumpUids(pw, dumpPackage, this.mValidateUids, "UID validation:", needSep)) {
                needSep = true;
                printedAnything = true;
            }
        }
        if (this.mLruProcesses.size() > 0) {
            if (needSep) {
                pw.println();
            }
            pw.print("  Process LRU list (sorted by oom_adj, ");
            pw.print(this.mLruProcesses.size());
            pw.print(" total, non-act at ");
            pw.print(this.mLruProcesses.size() - this.mLruProcessActivityStart);
            pw.print(", non-svc at ");
            pw.print(this.mLruProcesses.size() - this.mLruProcessServiceStart);
            pw.println("):");
            dumpProcessOomList(pw, this, this.mLruProcesses, "    ", "Proc", "PERS", false, dumpPackage);
            needSep = true;
            printedAnything = true;
        }
        if (dumpAll || dumpPackage != null) {
            synchronized (this.mPidsSelfLocked) {
                printed = false;
                for (i = 0; i < this.mPidsSelfLocked.size(); i++) {
                    r = (ProcessRecord) this.mPidsSelfLocked.valueAt(i);
                    if (dumpPackage == null || (r.pkgList.containsKey(dumpPackage) ^ 1) == 0) {
                        if (!printed) {
                            if (needSep) {
                                pw.println();
                            }
                            needSep = true;
                            pw.println("  PID mappings:");
                            printed = true;
                            printedAnything = true;
                        }
                        pw.print("    PID #");
                        pw.print(this.mPidsSelfLocked.keyAt(i));
                        pw.print(": ");
                        pw.println(this.mPidsSelfLocked.valueAt(i));
                    }
                }
            }
        }
        if (this.mImportantProcesses.size() > 0) {
            synchronized (this.mPidsSelfLocked) {
                printed = false;
                for (i = 0; i < this.mImportantProcesses.size(); i++) {
                    r = (ProcessRecord) this.mPidsSelfLocked.get(((ImportanceToken) this.mImportantProcesses.valueAt(i)).pid);
                    if (dumpPackage == null || (r != null && (r.pkgList.containsKey(dumpPackage) ^ 1) == 0)) {
                        if (!printed) {
                            if (needSep) {
                                pw.println();
                            }
                            needSep = true;
                            pw.println("  Foreground Processes:");
                            printed = true;
                            printedAnything = true;
                        }
                        pw.print("    PID #");
                        pw.print(this.mImportantProcesses.keyAt(i));
                        pw.print(": ");
                        pw.println(this.mImportantProcesses.valueAt(i));
                    }
                }
            }
        }
        if (this.mPersistentStartingProcesses.size() > 0) {
            if (needSep) {
                pw.println();
            }
            needSep = true;
            printedAnything = true;
            pw.println("  Persisent processes that are starting:");
            dumpProcessList(pw, this, this.mPersistentStartingProcesses, "    ", "Starting Norm", "Restarting PERS", dumpPackage);
        }
        if (this.mRemovedProcesses.size() > 0) {
            if (needSep) {
                pw.println();
            }
            needSep = true;
            printedAnything = true;
            pw.println("  Processes that are being removed:");
            dumpProcessList(pw, this, this.mRemovedProcesses, "    ", "Removed Norm", "Removed PERS", dumpPackage);
        }
        if (this.mProcessesOnHold.size() > 0) {
            if (needSep) {
                pw.println();
            }
            needSep = true;
            printedAnything = true;
            pw.println("  Processes that are on old until the system is ready:");
            dumpProcessList(pw, this, this.mProcessesOnHold, "    ", "OnHold Norm", "OnHold PERS", dumpPackage);
        }
        needSep = this.mAppErrors.dumpLocked(fd, pw, dumpProcessesToGc(fd, pw, args, opti, needSep, dumpAll, dumpPackage), dumpPackage);
        if (needSep) {
            printedAnything = true;
        }
        if (dumpPackage == null) {
            pw.println();
            needSep = false;
            this.mUserController.dump(pw, dumpAll);
        }
        if (this.mHomeProcess != null && (dumpPackage == null || this.mHomeProcess.pkgList.containsKey(dumpPackage))) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mHomeProcess: " + this.mHomeProcess);
        }
        if (this.mPreviousProcess != null && (dumpPackage == null || this.mPreviousProcess.pkgList.containsKey(dumpPackage))) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mPreviousProcess: " + this.mPreviousProcess);
        }
        if (dumpAll) {
            StringBuilder stringBuilder = new StringBuilder(128);
            stringBuilder.append("  mPreviousProcessVisibleTime: ");
            TimeUtils.formatDuration(this.mPreviousProcessVisibleTime, stringBuilder);
            pw.println(stringBuilder);
        }
        if (this.mHeavyWeightProcess != null && (dumpPackage == null || this.mHeavyWeightProcess.pkgList.containsKey(dumpPackage))) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mHeavyWeightProcess: " + this.mHeavyWeightProcess);
        }
        if (dumpPackage == null) {
            pw.println("  mGlobalConfiguration: " + getGlobalConfiguration());
            this.mStackSupervisor.dumpDisplayConfigs(pw, "  ");
        }
        if (dumpAll) {
            pw.println("  mConfigWillChange: " + getFocusedStack().mConfigWillChange);
            if (this.mCompatModePackages.getPackages().size() > 0) {
                printed = false;
                for (Entry<String, Integer> entry : this.mCompatModePackages.getPackages().entrySet()) {
                    String pkg = (String) entry.getKey();
                    int mode = ((Integer) entry.getValue()).intValue();
                    if (dumpPackage == null || (dumpPackage.equals(pkg) ^ 1) == 0) {
                        if (!printed) {
                            pw.println("  mScreenCompatPackages:");
                            printed = true;
                        }
                        pw.print("    ");
                        pw.print(pkg);
                        pw.print(": ");
                        pw.print(mode);
                        pw.println();
                    }
                }
            }
            int NI = this.mUidObservers.getRegisteredCallbackCount();
            printed = false;
            for (i = 0; i < NI; i++) {
                UidObserverRegistration reg = (UidObserverRegistration) this.mUidObservers.getRegisteredCallbackCookie(i);
                if (dumpPackage != null) {
                    if (!dumpPackage.equals(reg.pkg)) {
                    }
                }
                if (!printed) {
                    pw.println("  mUidObservers:");
                    printed = true;
                }
                pw.print("    ");
                UserHandle.formatUid(pw, reg.uid);
                pw.print(" ");
                pw.print(reg.pkg);
                pw.print(":");
                if ((reg.which & 4) != 0) {
                    pw.print(" IDLE");
                }
                if ((reg.which & 8) != 0) {
                    pw.print(" ACT");
                }
                if ((reg.which & 2) != 0) {
                    pw.print(" GONE");
                }
                if ((reg.which & 1) != 0) {
                    pw.print(" STATE");
                    pw.print(" (cut=");
                    pw.print(reg.cutpoint);
                    pw.print(")");
                }
                pw.println();
                if (reg.lastProcStates != null) {
                    int NJ = reg.lastProcStates.size();
                    for (j = 0; j < NJ; j++) {
                        pw.print("      Last ");
                        UserHandle.formatUid(pw, reg.lastProcStates.keyAt(j));
                        pw.print(": ");
                        pw.println(reg.lastProcStates.valueAt(j));
                    }
                }
            }
            pw.println("  mDeviceIdleWhitelist=" + Arrays.toString(this.mDeviceIdleWhitelist));
            pw.println("  mDeviceIdleTempWhitelist=" + Arrays.toString(this.mDeviceIdleTempWhitelist));
            if (this.mPendingTempWhitelist.size() > 0) {
                pw.println("  mPendingTempWhitelist:");
                for (i = 0; i < this.mPendingTempWhitelist.size(); i++) {
                    PendingTempWhitelist ptw = (PendingTempWhitelist) this.mPendingTempWhitelist.valueAt(i);
                    pw.print("    ");
                    UserHandle.formatUid(pw, ptw.targetUid);
                    pw.print(": ");
                    TimeUtils.formatDuration(ptw.duration, pw);
                    pw.print(" ");
                    pw.println(ptw.tag);
                }
            }
        }
        if (dumpPackage == null) {
            pw.println("  mWakefulness=" + PowerManagerInternal.wakefulnessToString(this.mWakefulness));
            pw.println("  mSleepTokens=" + this.mStackSupervisor.mSleepTokens);
            pw.println("  mSleeping=" + this.mSleeping);
            pw.println("  mShuttingDown=" + this.mShuttingDown + " mTestPssMode=" + this.mTestPssMode);
            if (this.mRunningVoice != null) {
                pw.println("  mRunningVoice=" + this.mRunningVoice);
                pw.println("  mVoiceWakeLock" + this.mVoiceWakeLock);
            }
        }
        pw.println("  mVrController=" + this.mVrController);
        if (this.mDebugApp != null || this.mOrigDebugApp != null || this.mDebugTransient || this.mOrigWaitForDebugger) {
            if (dumpPackage != null) {
                if (!dumpPackage.equals(this.mDebugApp)) {
                }
            }
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mDebugApp=" + this.mDebugApp + "/orig=" + this.mOrigDebugApp + " mDebugTransient=" + this.mDebugTransient + " mOrigWaitForDebugger=" + this.mOrigWaitForDebugger);
        }
        if (this.mCurAppTimeTracker != null) {
            this.mCurAppTimeTracker.dumpWithHeader(pw, "  ", true);
        }
        if (this.mMemWatchProcesses.getMap().size() > 0) {
            pw.println("  Mem watch processes:");
            ArrayMap<String, SparseArray<Pair<Long, String>>> procs2 = this.mMemWatchProcesses.getMap();
            for (i = 0; i < procs2.size(); i++) {
                String proc = (String) procs2.keyAt(i);
                SparseArray<Pair<Long, String>> uids = (SparseArray) procs2.valueAt(i);
                for (j = 0; j < uids.size(); j++) {
                    if (needSep) {
                        pw.println();
                        needSep = false;
                    }
                    StringBuilder sb = new StringBuilder();
                    sb.append("    ").append(proc).append('/');
                    UserHandle.formatUid(sb, uids.keyAt(j));
                    Pair<Long, String> val = (Pair) uids.valueAt(j);
                    sb.append(": ");
                    DebugUtils.sizeValueToString(((Long) val.first).longValue(), sb);
                    if (val.second != null) {
                        sb.append(", report to ").append((String) val.second);
                    }
                    pw.println(sb.toString());
                }
            }
            pw.print("  mMemWatchDumpProcName=");
            pw.println(this.mMemWatchDumpProcName);
            pw.print("  mMemWatchDumpFile=");
            pw.println(this.mMemWatchDumpFile);
            pw.print("  mMemWatchDumpPid=");
            pw.print(this.mMemWatchDumpPid);
            pw.print(" mMemWatchDumpUid=");
            pw.println(this.mMemWatchDumpUid);
        }
        if (this.mTrackAllocationApp != null) {
            if (dumpPackage != null) {
            }
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mTrackAllocationApp=" + this.mTrackAllocationApp);
        }
        if (!(this.mProfileApp == null && this.mProfileProc == null && (this.mProfilerInfo == null || (this.mProfilerInfo.profileFile == null && this.mProfilerInfo.profileFd == null)))) {
            if (dumpPackage != null) {
            }
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mProfileApp=" + this.mProfileApp + " mProfileProc=" + this.mProfileProc);
            if (this.mProfilerInfo != null) {
                pw.println("  mProfileFile=" + this.mProfilerInfo.profileFile + " mProfileFd=" + this.mProfilerInfo.profileFd);
                pw.println("  mSamplingInterval=" + this.mProfilerInfo.samplingInterval + " mAutoStopProfiler=" + this.mProfilerInfo.autoStopProfiler + " mStreamingOutput=" + this.mProfilerInfo.streamingOutput);
                pw.println("  mProfileType=" + this.mProfileType);
            }
        }
        if (this.mNativeDebuggingApp != null) {
            if (dumpPackage != null) {
            }
            if (needSep) {
                pw.println();
            }
            pw.println("  mNativeDebuggingApp=" + this.mNativeDebuggingApp);
        }
        if (dumpPackage == null) {
            if (this.mAlwaysFinishActivities) {
                pw.println("  mAlwaysFinishActivities=" + this.mAlwaysFinishActivities);
            }
            if (this.mController != null) {
                pw.println("  mController=" + this.mController + " mControllerIsAMonkey=" + this.mControllerIsAMonkey);
            }
            if (dumpAll) {
                pw.println("  Total persistent processes: " + numPers);
                pw.println("  mProcessesReady=" + this.mProcessesReady + " mSystemReady=" + this.mSystemReady + " mBooted=" + this.mBooted + " mFactoryTest=" + this.mFactoryTest);
                pw.println("  mBooting=" + this.mBooting + " mCallFinishBooting=" + this.mCallFinishBooting + " mBootAnimationComplete=" + this.mBootAnimationComplete);
                pw.print("  mLastPowerCheckUptime=");
                TimeUtils.formatDuration(this.mLastPowerCheckUptime, pw);
                pw.println("");
                pw.println("  mGoingToSleep=" + this.mStackSupervisor.mGoingToSleep);
                pw.println("  mLaunchingActivity=" + this.mStackSupervisor.mLaunchingActivity);
                pw.println("  mAdjSeq=" + this.mAdjSeq + " mLruSeq=" + this.mLruSeq);
                pw.println("  mNumNonCachedProcs=" + this.mNumNonCachedProcs + " (" + this.mLruProcesses.size() + " total)" + " mNumCachedHiddenProcs=" + this.mNumCachedHiddenProcs + " mNumServiceProcs=" + this.mNumServiceProcs + " mNewNumServiceProcs=" + this.mNewNumServiceProcs);
                pw.println("  mAllowLowerMemLevel=" + this.mAllowLowerMemLevel + " mLastMemoryLevel=" + this.mLastMemoryLevel + " mLastNumProcesses=" + this.mLastNumProcesses);
                long now = SystemClock.uptimeMillis();
                pw.print("  mLastIdleTime=");
                TimeUtils.formatDuration(now, this.mLastIdleTime, pw);
                pw.print(" mLowRamSinceLastIdle=");
                TimeUtils.formatDuration(getLowRamTimeSinceIdle(now), pw);
                pw.println();
            }
        }
        if (!printedAnything) {
            pw.println("  (nothing)");
        }
    }

    boolean dumpProcessesToGc(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean needSep, boolean dumpAll, String dumpPackage) {
        if (this.mProcessesToGc.size() > 0) {
            boolean printed = false;
            long now = SystemClock.uptimeMillis();
            for (int i = 0; i < this.mProcessesToGc.size(); i++) {
                ProcessRecord proc = (ProcessRecord) this.mProcessesToGc.get(i);
                if (dumpPackage == null || (dumpPackage.equals(proc.info.packageName) ^ 1) == 0) {
                    if (!printed) {
                        if (needSep) {
                            pw.println();
                        }
                        needSep = true;
                        pw.println("  Processes that are waiting to GC:");
                        printed = true;
                    }
                    pw.print("    Process ");
                    pw.println(proc);
                    pw.print("      lowMem=");
                    pw.print(proc.reportLowMemory);
                    pw.print(", last gced=");
                    pw.print(now - proc.lastRequestedGc);
                    pw.print(" ms ago, last lowMem=");
                    pw.print(now - proc.lastLowMemory);
                    pw.println(" ms ago");
                }
            }
        }
        return needSep;
    }

    void printOomLevel(PrintWriter pw, String name, int adj) {
        pw.print("    ");
        if (adj >= 0) {
            pw.print(' ');
            if (adj < 10) {
                pw.print(' ');
            }
        } else if (adj > -10) {
            pw.print(' ');
        }
        pw.print(adj);
        pw.print(": ");
        pw.print(name);
        pw.print(" (");
        pw.print(stringifySize(this.mProcessList.getMemLevel(adj), 1024));
        pw.println(")");
    }

    boolean dumpOomLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll) {
        boolean needSep = false;
        if (this.mLruProcesses.size() > 0) {
            if (null != null) {
                pw.println();
            }
            pw.println("  OOM levels:");
            printOomLevel(pw, "SYSTEM_ADJ", -900);
            printOomLevel(pw, "PERSISTENT_PROC_ADJ", -800);
            printOomLevel(pw, "PERSISTENT_SERVICE_ADJ", -700);
            printOomLevel(pw, "FOREGROUND_APP_ADJ", 0);
            printOomLevel(pw, "VISIBLE_APP_ADJ", 100);
            printOomLevel(pw, "PERCEPTIBLE_APP_ADJ", 200);
            printOomLevel(pw, "BACKUP_APP_ADJ", 300);
            printOomLevel(pw, "HEAVY_WEIGHT_APP_ADJ", 400);
            printOomLevel(pw, "SERVICE_ADJ", 500);
            printOomLevel(pw, "HOME_APP_ADJ", 600);
            printOomLevel(pw, "PREVIOUS_APP_ADJ", START_OPPO_SITE_MSG);
            printOomLevel(pw, "SERVICE_B_ADJ", 800);
            printOomLevel(pw, "CACHED_APP_MIN_ADJ", 900);
            printOomLevel(pw, "CACHED_APP_MAX_ADJ", 906);
            if (true) {
                pw.println();
            }
            pw.print("  Process OOM control (");
            pw.print(this.mLruProcesses.size());
            pw.print(" total, non-act at ");
            pw.print(this.mLruProcesses.size() - this.mLruProcessActivityStart);
            pw.print(", non-svc at ");
            pw.print(this.mLruProcesses.size() - this.mLruProcessServiceStart);
            pw.println("):");
            dumpProcessOomList(pw, this, this.mLruProcesses, "    ", "Proc", "PERS", true, null);
            needSep = true;
        }
        dumpProcessesToGc(fd, pw, args, opti, needSep, dumpAll, null);
        pw.println();
        pw.println("  mHomeProcess: " + this.mHomeProcess);
        pw.println("  mPreviousProcess: " + this.mPreviousProcess);
        if (this.mHeavyWeightProcess != null) {
            pw.println("  mHeavyWeightProcess: " + this.mHeavyWeightProcess);
        }
        return true;
    }

    protected boolean dumpProvider(FileDescriptor fd, PrintWriter pw, String name, String[] args, int opti, boolean dumpAll) {
        return this.mProviderMap.dumpProvider(fd, pw, name, args, opti, dumpAll);
    }

    protected boolean dumpActivity(FileDescriptor fd, PrintWriter pw, String name, String[] args, int opti, boolean dumpAll, boolean dumpVisibleStacksOnly, boolean dumpFocusedStackOnly) {
        ArrayList<ActivityRecord> activities;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                activities = this.mStackSupervisor.getDumpActivitiesLocked(name, dumpVisibleStacksOnly, dumpFocusedStackOnly);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        if (activities.size() <= 0) {
            return false;
        }
        String[] newArgs = new String[(args.length - opti)];
        System.arraycopy(args, opti, newArgs, 0, args.length - opti);
        TaskRecord lastTask = null;
        boolean needSep = false;
        for (int i = activities.size() - 1; i >= 0; i--) {
            ActivityRecord r = (ActivityRecord) activities.get(i);
            if (needSep) {
                pw.println();
            }
            needSep = true;
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    TaskRecord task = r.getTask();
                    if (lastTask != task) {
                        lastTask = task;
                        pw.print("TASK ");
                        pw.print(task.affinity);
                        pw.print(" id=");
                        pw.print(task.taskId);
                        pw.print(" userId=");
                        pw.println(task.userId);
                        if (dumpAll) {
                            task.dump(pw, "  ");
                        }
                    }
                } catch (Throwable th2) {
                    resetPriorityAfterLockedSection();
                    throw th2;
                }
            }
            resetPriorityAfterLockedSection();
            dumpActivity("  ", fd, pw, (ActivityRecord) activities.get(i), newArgs, dumpAll);
        }
        return true;
    }

    private void dumpActivity(String prefix, FileDescriptor fd, PrintWriter pw, ActivityRecord r, String[] args, boolean dumpAll) {
        String innerPrefix = prefix + "  ";
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                pw.print(prefix);
                pw.print("ACTIVITY ");
                pw.print(r.shortComponentName);
                pw.print(" ");
                pw.print(Integer.toHexString(System.identityHashCode(r)));
                pw.print(" pid=");
                if (r.app != null) {
                    pw.println(r.app.pid);
                } else {
                    pw.println("(not running)");
                }
                if (dumpAll) {
                    r.dump(pw, innerPrefix);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        if (r.app != null && r.app.thread != null) {
            pw.flush();
            TransferPipe tp;
            try {
                tp = new TransferPipe();
                r.app.thread.dumpActivity(tp.getWriteFd(), r.appToken, innerPrefix, args);
                tp.go(fd);
                tp.kill();
            } catch (IOException e) {
                pw.println(innerPrefix + "Failure while dumping the activity: " + e);
            } catch (RemoteException e2) {
                pw.println(innerPrefix + "Got a RemoteException while dumping the activity");
            } catch (Throwable th) {
                tp.kill();
            }
        }
    }

    void dumpBroadcastsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        boolean needSep = false;
        boolean onlyHistory = false;
        int printedAnything = false;
        if ("history".equals(dumpPackage)) {
            if (opti < args.length && "-s".equals(args[opti])) {
                dumpAll = false;
            }
            onlyHistory = true;
            dumpPackage = null;
        }
        pw.println("ACTIVITY MANAGER BROADCAST STATE (dumpsys activity broadcasts)");
        if (!onlyHistory && dumpAll) {
            if (this.mRegisteredReceivers.size() > 0) {
                boolean printed = false;
                for (ReceiverList r : this.mRegisteredReceivers.values()) {
                    if (dumpPackage != null) {
                        if (r.app != null) {
                            if ((dumpPackage.equals(r.app.info.packageName) ^ 1) != 0) {
                            }
                        }
                    }
                    if (!printed) {
                        pw.println("  Registered Receivers:");
                        needSep = true;
                        printed = true;
                        boolean printedAnything2 = true;
                    }
                    pw.print("  * ");
                    pw.println(r);
                    r.dump(pw, "    ");
                }
            }
            if (this.mReceiverResolver.dump(pw, needSep ? "\n  Receiver Resolver Table:" : "  Receiver Resolver Table:", "    ", dumpPackage, false, false)) {
                needSep = true;
                printedAnything = true;
            }
        }
        BroadcastQueue[] broadcastQueueArr = this.mBroadcastQueues;
        int i = 0;
        int length = broadcastQueueArr.length;
        while (true) {
            int i2 = i;
            if (i2 >= length) {
                break;
            }
            needSep = broadcastQueueArr[i2].dumpLocked(fd, pw, args, opti, dumpAll, dumpPackage, needSep);
            printedAnything |= needSep;
            i = i2 + 1;
        }
        needSep = true;
        if (!(onlyHistory || this.mStickyBroadcasts == null || dumpPackage != null)) {
            for (int user = 0; user < this.mStickyBroadcasts.size(); user++) {
                if (needSep) {
                    pw.println();
                }
                needSep = true;
                printedAnything = 1;
                pw.print("  Sticky broadcasts for user ");
                pw.print(this.mStickyBroadcasts.keyAt(user));
                pw.println(":");
                StringBuilder sb = new StringBuilder(128);
                for (Entry<String, ArrayList<Intent>> ent : ((ArrayMap) this.mStickyBroadcasts.valueAt(user)).entrySet()) {
                    pw.print("  * Sticky action ");
                    pw.print((String) ent.getKey());
                    if (dumpAll) {
                        pw.println(":");
                        ArrayList<Intent> intents = (ArrayList) ent.getValue();
                        int N = intents.size();
                        for (int i3 = 0; i3 < N; i3++) {
                            sb.setLength(0);
                            sb.append("    Intent: ");
                            ((Intent) intents.get(i3)).toShortString(sb, false, true, false, false);
                            pw.println(sb.toString());
                            Bundle bundle = ((Intent) intents.get(i3)).getExtras();
                            if (bundle != null) {
                                pw.print("      ");
                                pw.println(bundle.toString());
                            }
                        }
                    } else {
                        pw.println("");
                    }
                }
            }
        }
        if (!onlyHistory && dumpAll) {
            pw.println();
            for (BroadcastQueue queue : this.mBroadcastQueues) {
                pw.println("  mBroadcastsScheduled [" + queue.mQueueName + "]=" + queue.mBroadcastsScheduled);
            }
            pw.println("  mHandler:");
            this.mHandler.dump(new PrintWriterPrinter(pw), "    ");
            printedAnything = 1;
        }
        if (printedAnything == 0) {
            pw.println("  (nothing)");
        }
    }

    void dumpBroadcastStatsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        if (this.mCurBroadcastStats != null) {
            pw.println("ACTIVITY MANAGER BROADCAST STATS STATE (dumpsys activity broadcast-stats)");
            long now = SystemClock.elapsedRealtime();
            if (this.mLastBroadcastStats != null) {
                pw.print("  Last stats (from ");
                TimeUtils.formatDuration(this.mLastBroadcastStats.mStartRealtime, now, pw);
                pw.print(" to ");
                TimeUtils.formatDuration(this.mLastBroadcastStats.mEndRealtime, now, pw);
                pw.print(", ");
                TimeUtils.formatDuration(this.mLastBroadcastStats.mEndUptime - this.mLastBroadcastStats.mStartUptime, pw);
                pw.println(" uptime):");
                if (!this.mLastBroadcastStats.dumpStats(pw, "    ", dumpPackage)) {
                    pw.println("    (nothing)");
                }
                pw.println();
            }
            pw.print("  Current stats (from ");
            TimeUtils.formatDuration(this.mCurBroadcastStats.mStartRealtime, now, pw);
            pw.print(" to now, ");
            TimeUtils.formatDuration(SystemClock.uptimeMillis() - this.mCurBroadcastStats.mStartUptime, pw);
            pw.println(" uptime):");
            if (!this.mCurBroadcastStats.dumpStats(pw, "    ", dumpPackage)) {
                pw.println("    (nothing)");
            }
        }
    }

    void dumpBroadcastStatsCheckinLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean fullCheckin, String dumpPackage) {
        if (this.mCurBroadcastStats != null) {
            if (this.mLastBroadcastStats != null) {
                this.mLastBroadcastStats.dumpCheckinStats(pw, dumpPackage);
                if (fullCheckin) {
                    this.mLastBroadcastStats = null;
                    return;
                }
            }
            this.mCurBroadcastStats.dumpCheckinStats(pw, dumpPackage);
            if (fullCheckin) {
                this.mCurBroadcastStats = null;
            }
        }
    }

    void dumpProvidersLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        new ItemMatcher().build(args, opti);
        pw.println("ACTIVITY MANAGER CONTENT PROVIDERS (dumpsys activity providers)");
        boolean needSep = this.mProviderMap.dumpProvidersLocked(pw, dumpAll, dumpPackage);
        boolean z = needSep;
        if (this.mLaunchingProviders.size() > 0) {
            boolean printed = false;
            for (int i = this.mLaunchingProviders.size() - 1; i >= 0; i--) {
                ContentProviderRecord r = (ContentProviderRecord) this.mLaunchingProviders.get(i);
                if (dumpPackage == null || (dumpPackage.equals(r.name.getPackageName()) ^ 1) == 0) {
                    if (!printed) {
                        if (needSep) {
                            pw.println();
                        }
                        needSep = true;
                        pw.println("  Launching content providers:");
                        printed = true;
                        z = true;
                    }
                    pw.print("  Launching #");
                    pw.print(i);
                    pw.print(": ");
                    pw.println(r);
                }
            }
        }
        if (!z) {
            pw.println("  (nothing)");
        }
    }

    void dumpPermissionsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        boolean needSep = false;
        boolean printedAnything = false;
        pw.println("ACTIVITY MANAGER URI PERMISSIONS (dumpsys activity permissions)");
        if (this.mGrantedUriPermissions.size() > 0) {
            boolean printed = false;
            int dumpUid = -2;
            if (dumpPackage != null) {
                try {
                    dumpUid = this.mContext.getPackageManager().getPackageUidAsUser(dumpPackage, DumpState.DUMP_CHANGES, 0);
                } catch (NameNotFoundException e) {
                    dumpUid = -1;
                }
            }
            for (int i = 0; i < this.mGrantedUriPermissions.size(); i++) {
                int uid = this.mGrantedUriPermissions.keyAt(i);
                if (dumpUid < -1 || UserHandle.getAppId(uid) == dumpUid) {
                    ArrayMap<GrantUri, UriPermission> perms = (ArrayMap) this.mGrantedUriPermissions.valueAt(i);
                    if (!printed) {
                        if (needSep) {
                            pw.println();
                        }
                        needSep = true;
                        pw.println("  Granted Uri Permissions:");
                        printed = true;
                        printedAnything = true;
                    }
                    pw.print("  * UID ");
                    pw.print(uid);
                    pw.println(" holds:");
                    for (UriPermission perm : perms.values()) {
                        pw.print("    ");
                        pw.println(perm);
                        if (dumpAll) {
                            perm.dump(pw, "      ");
                        }
                    }
                }
            }
        }
        if (!printedAnything) {
            pw.println("  (nothing)");
        }
    }

    void dumpPendingIntentsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        boolean printed = false;
        pw.println("ACTIVITY MANAGER PENDING INTENTS (dumpsys activity intents)");
        if (this.mIntentSenderRecords.size() > 0) {
            int i;
            ArrayMap<String, ArrayList<PendingIntentRecord>> byPackage = new ArrayMap();
            ArrayList<WeakReference<PendingIntentRecord>> weakRefs = new ArrayList();
            for (WeakReference<PendingIntentRecord> ref : this.mIntentSenderRecords.values()) {
                PendingIntentRecord rec = ref != null ? (PendingIntentRecord) ref.get() : null;
                if (rec == null) {
                    weakRefs.add(ref);
                } else {
                    if (dumpPackage != null) {
                        if ((dumpPackage.equals(rec.key.packageName) ^ 1) != 0) {
                        }
                    }
                    ArrayList<PendingIntentRecord> list = (ArrayList) byPackage.get(rec.key.packageName);
                    if (list == null) {
                        list = new ArrayList();
                        byPackage.put(rec.key.packageName, list);
                    }
                    list.add(rec);
                }
            }
            for (i = 0; i < byPackage.size(); i++) {
                ArrayList<PendingIntentRecord> intents = (ArrayList) byPackage.valueAt(i);
                printed = true;
                pw.print("  * ");
                pw.print((String) byPackage.keyAt(i));
                pw.print(": ");
                pw.print(intents.size());
                pw.println(" items");
                for (int j = 0; j < intents.size(); j++) {
                    pw.print("    #");
                    pw.print(j);
                    pw.print(": ");
                    pw.println(intents.get(j));
                    if (dumpAll) {
                        ((PendingIntentRecord) intents.get(j)).dump(pw, "      ");
                    }
                }
            }
            if (weakRefs.size() > 0) {
                printed = true;
                pw.println("  * WEAK REFS:");
                for (i = 0; i < weakRefs.size(); i++) {
                    pw.print("    #");
                    pw.print(i);
                    pw.print(": ");
                    pw.println(weakRefs.get(i));
                }
            }
        }
        if (!printed) {
            pw.println("  (nothing)");
        }
    }

    private static final int dumpProcessList(PrintWriter pw, ActivityManagerService service, List list, String prefix, String normalLabel, String persistentLabel, String dumpPackage) {
        int numPers = 0;
        for (int i = list.size() - 1; i >= 0; i--) {
            ProcessRecord r = (ProcessRecord) list.get(i);
            if (dumpPackage == null || (dumpPackage.equals(r.info.packageName) ^ 1) == 0) {
                Object obj;
                String str = "%s%s #%2d: %s";
                Object[] objArr = new Object[4];
                objArr[0] = prefix;
                if (r.persistent) {
                    obj = persistentLabel;
                } else {
                    String obj2 = normalLabel;
                }
                objArr[1] = obj2;
                objArr[2] = Integer.valueOf(i);
                objArr[3] = r.toString();
                pw.println(String.format(str, objArr));
                if (r.persistent) {
                    numPers++;
                }
            }
        }
        return numPers;
    }

    private static final boolean dumpProcessOomList(PrintWriter pw, ActivityManagerService service, List<ProcessRecord> origList, String prefix, String normalLabel, String persistentLabel, boolean inclDetails, String dumpPackage) {
        int i;
        ProcessRecord r;
        ArrayList<Pair<ProcessRecord, Integer>> list = new ArrayList(origList.size());
        for (i = 0; i < origList.size(); i++) {
            r = (ProcessRecord) origList.get(i);
            if (dumpPackage == null || (r.pkgList.containsKey(dumpPackage) ^ 1) == 0) {
                list.add(new Pair((ProcessRecord) origList.get(i), Integer.valueOf(i)));
            }
        }
        if (list.size() <= 0) {
            return false;
        }
        Collections.sort(list, new Comparator<Pair<ProcessRecord, Integer>>() {
            public int compare(Pair<ProcessRecord, Integer> object1, Pair<ProcessRecord, Integer> object2) {
                int i = -1;
                if (((ProcessRecord) object1.first).setAdj != ((ProcessRecord) object2.first).setAdj) {
                    return ((ProcessRecord) object1.first).setAdj > ((ProcessRecord) object2.first).setAdj ? -1 : 1;
                } else if (((ProcessRecord) object1.first).setProcState != ((ProcessRecord) object2.first).setProcState) {
                    if (((ProcessRecord) object1.first).setProcState <= ((ProcessRecord) object2.first).setProcState) {
                        i = 1;
                    }
                    return i;
                } else if (((Integer) object1.second).intValue() == ((Integer) object2.second).intValue()) {
                    return 0;
                } else {
                    if (((Integer) object1.second).intValue() <= ((Integer) object2.second).intValue()) {
                        i = 1;
                    }
                    return i;
                }
            }
        });
        long uptimeSince = SystemClock.uptimeMillis() - service.mLastPowerCheckUptime;
        for (i = list.size() - 1; i >= 0; i--) {
            char schedGroup;
            char foreground;
            String str;
            r = (ProcessRecord) ((Pair) list.get(i)).first;
            String oomAdj = ProcessList.makeOomAdjString(r.setAdj);
            switch (r.setSchedGroup) {
                case 0:
                    schedGroup = 'B';
                    break;
                case 1:
                    schedGroup = 'F';
                    break;
                case 2:
                    schedGroup = 'T';
                    break;
                default:
                    schedGroup = '?';
                    break;
            }
            if (r.foregroundActivities) {
                foreground = 'A';
            } else if (r.foregroundServices) {
                foreground = 'S';
            } else {
                foreground = ' ';
            }
            String procState = ProcessList.makeProcStateString(r.curProcState);
            pw.print(prefix);
            if (r.persistent) {
                str = persistentLabel;
            } else {
                str = normalLabel;
            }
            pw.print(str);
            pw.print(" #");
            int num = (origList.size() - 1) - ((Integer) ((Pair) list.get(i)).second).intValue();
            if (num < 10) {
                pw.print(' ');
            }
            pw.print(num);
            pw.print(": ");
            pw.print(oomAdj);
            pw.print(' ');
            pw.print(schedGroup);
            pw.print('/');
            pw.print(foreground);
            pw.print('/');
            pw.print(procState);
            pw.print(" trm:");
            if (r.trimMemoryLevel < 10) {
                pw.print(' ');
            }
            pw.print(r.trimMemoryLevel);
            pw.print(' ');
            pw.print(r.toShortString());
            pw.print(" (");
            pw.print(r.adjType);
            pw.println(')');
            if (!(r.adjSource == null && r.adjTarget == null)) {
                pw.print(prefix);
                pw.print("    ");
                if (r.adjTarget instanceof ComponentName) {
                    pw.print(((ComponentName) r.adjTarget).flattenToShortString());
                } else if (r.adjTarget != null) {
                    pw.print(r.adjTarget.toString());
                } else {
                    pw.print("{null}");
                }
                pw.print("<=");
                if (r.adjSource instanceof ProcessRecord) {
                    pw.print("Proc{");
                    pw.print(((ProcessRecord) r.adjSource).toShortString());
                    pw.println("}");
                } else if (r.adjSource != null) {
                    pw.println(r.adjSource.toString());
                } else {
                    pw.println("{null}");
                }
            }
            if (inclDetails) {
                pw.print(prefix);
                pw.print("    ");
                pw.print("oom: max=");
                pw.print(r.maxAdj);
                pw.print(" curRaw=");
                pw.print(r.curRawAdj);
                pw.print(" setRaw=");
                pw.print(r.setRawAdj);
                pw.print(" cur=");
                pw.print(r.curAdj);
                pw.print(" set=");
                pw.println(r.setAdj);
                pw.print(prefix);
                pw.print("    ");
                pw.print("state: cur=");
                pw.print(ProcessList.makeProcStateString(r.curProcState));
                pw.print(" set=");
                pw.print(ProcessList.makeProcStateString(r.setProcState));
                pw.print(" lastPss=");
                DebugUtils.printSizeValue(pw, r.lastPss * 1024);
                pw.print(" lastSwapPss=");
                DebugUtils.printSizeValue(pw, r.lastSwapPss * 1024);
                pw.print(" lastCachedPss=");
                DebugUtils.printSizeValue(pw, r.lastCachedPss * 1024);
                pw.println();
                pw.print(prefix);
                pw.print("    ");
                pw.print("cached=");
                pw.print(r.cached);
                pw.print(" empty=");
                pw.print(r.empty);
                pw.print(" hasAboveClient=");
                pw.println(r.hasAboveClient);
                if (r.setProcState >= 11 && r.lastCpuTime != 0) {
                    long timeUsed = r.curCpuTime - r.lastCpuTime;
                    pw.print(prefix);
                    pw.print("    ");
                    pw.print("run cpu over ");
                    TimeUtils.formatDuration(uptimeSince, pw);
                    pw.print(" used ");
                    TimeUtils.formatDuration(timeUsed, pw);
                    pw.print(" (");
                    pw.print((100 * timeUsed) / uptimeSince);
                    pw.println("%)");
                }
            }
        }
        return true;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    ArrayList<ProcessRecord> collectProcesses(PrintWriter pw, int start, boolean allPkgs, String[] args) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ArrayList<ProcessRecord> procs;
                if (args == null || args.length <= start || args[start].charAt(0) == '-') {
                    procs = new ArrayList(this.mLruProcesses);
                } else {
                    procs = new ArrayList();
                    int pid = -1;
                    try {
                        pid = Integer.parseInt(args[start]);
                    } catch (NumberFormatException e) {
                    }
                    for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord proc = (ProcessRecord) this.mLruProcesses.get(i);
                        if (proc.pid == pid) {
                            procs.add(proc);
                        } else if (allPkgs && proc.pkgList != null && proc.pkgList.containsKey(args[start])) {
                            procs.add(proc);
                        } else if (proc.processName.equals(args[start])) {
                            procs.add(proc);
                        }
                    }
                    if (procs.size() <= 0) {
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return null;
    }

    final void dumpGraphicsHardwareUsage(FileDescriptor fd, PrintWriter pw, String[] args) {
        ArrayList<ProcessRecord> procs = collectProcesses(pw, 0, false, args);
        if (procs == null) {
            pw.println("No process found for: " + args[0]);
            return;
        }
        long uptime = SystemClock.uptimeMillis();
        long realtime = SystemClock.elapsedRealtime();
        pw.println("Applications Graphics Acceleration Info:");
        pw.println("Uptime: " + uptime + " Realtime: " + realtime);
        for (int i = procs.size() - 1; i >= 0; i--) {
            ProcessRecord r = (ProcessRecord) procs.get(i);
            if (r.thread != null) {
                pw.println("\n** Graphics info for pid " + r.pid + " [" + r.processName + "] **");
                pw.flush();
                TransferPipe tp;
                try {
                    tp = new TransferPipe();
                    r.thread.dumpGfxInfo(tp.getWriteFd(), args);
                    tp.go(fd);
                    tp.kill();
                } catch (IOException e) {
                    pw.println("Failure while dumping the app: " + r);
                    pw.flush();
                } catch (RemoteException e2) {
                    pw.println("Got a RemoteException while dumping the app " + r);
                    pw.flush();
                } catch (Throwable th) {
                    tp.kill();
                }
            }
        }
    }

    final void dumpDbInfo(FileDescriptor fd, PrintWriter pw, String[] args) {
        ArrayList<ProcessRecord> procs = collectProcesses(pw, 0, false, args);
        if (procs == null) {
            pw.println("No process found for: " + args[0]);
            return;
        }
        pw.println("Applications Database Info:");
        for (int i = procs.size() - 1; i >= 0; i--) {
            ProcessRecord r = (ProcessRecord) procs.get(i);
            if (r.thread != null) {
                pw.println("\n** Database info for pid " + r.pid + " [" + r.processName + "] **");
                pw.flush();
                TransferPipe tp;
                try {
                    tp = new TransferPipe();
                    r.thread.dumpDbInfo(tp.getWriteFd(), args);
                    tp.go(fd);
                    tp.kill();
                } catch (IOException e) {
                    pw.println("Failure while dumping the app: " + r);
                    pw.flush();
                } catch (RemoteException e2) {
                    pw.println("Got a RemoteException while dumping the app " + r);
                    pw.flush();
                } catch (Throwable th) {
                    tp.kill();
                }
            }
        }
    }

    static final void dumpMemItems(PrintWriter pw, String prefix, String tag, ArrayList<MemItem> items, boolean sort, boolean isCompact, boolean dumpSwapPss) {
        if (sort && (isCompact ^ 1) != 0) {
            Collections.sort(items, new Comparator<MemItem>() {
                public int compare(MemItem lhs, MemItem rhs) {
                    if (lhs.pss < rhs.pss) {
                        return 1;
                    }
                    if (lhs.pss > rhs.pss) {
                        return -1;
                    }
                    return 0;
                }
            });
        }
        for (int i = 0; i < items.size(); i++) {
            MemItem mi = (MemItem) items.get(i);
            if (isCompact) {
                if (mi.isProc) {
                    pw.print("proc,");
                    pw.print(tag);
                    pw.print(",");
                    pw.print(mi.shortLabel);
                    pw.print(",");
                    pw.print(mi.id);
                    pw.print(",");
                    pw.print(mi.pss);
                    pw.print(",");
                    pw.print(dumpSwapPss ? Long.valueOf(mi.swapPss) : "N/A");
                    pw.println(mi.hasActivities ? ",a" : ",e");
                } else {
                    pw.print(tag);
                    pw.print(",");
                    pw.print(mi.shortLabel);
                    pw.print(",");
                    pw.print(mi.pss);
                    pw.print(",");
                    pw.println(dumpSwapPss ? Long.valueOf(mi.swapPss) : "N/A");
                }
            } else if (dumpSwapPss) {
                pw.printf("%s%s: %-60s (%s in swap)\n", new Object[]{prefix, stringifyKBSize(mi.pss), mi.label, stringifyKBSize(mi.swapPss)});
            } else {
                pw.printf("%s%s: %s\n", new Object[]{prefix, stringifyKBSize(mi.pss), mi.label});
            }
            if (mi.subitems != null) {
                dumpMemItems(pw, prefix + "    ", mi.shortLabel, mi.subitems, true, isCompact, dumpSwapPss);
            }
        }
    }

    static final void appendMemBucket(StringBuilder out, long memKB, String label, boolean stackLike) {
        int start = label.lastIndexOf(46);
        if (start >= 0) {
            start++;
        } else {
            start = 0;
        }
        int end = label.length();
        for (int i = 0; i < DUMP_MEM_BUCKETS.length; i++) {
            if (DUMP_MEM_BUCKETS[i] >= memKB) {
                out.append(DUMP_MEM_BUCKETS[i] / 1024);
                out.append(stackLike ? "MB." : "MB ");
                out.append(label, start, end);
                return;
            }
        }
        out.append(memKB / 1024);
        out.append(stackLike ? "MB." : "MB ");
        out.append(label, start, end);
    }

    private final void dumpApplicationMemoryUsageHeader(PrintWriter pw, long uptime, long realtime, boolean isCheckinRequest, boolean isCompact) {
        if (isCompact) {
            pw.print("version,");
            pw.println(1);
        }
        if (isCheckinRequest || isCompact) {
            pw.print("time,");
            pw.print(uptime);
            pw.print(",");
            pw.println(realtime);
            return;
        }
        pw.println("Applications Memory Usage (in Kilobytes):");
        pw.println("Uptime: " + uptime + " Realtime: " + realtime);
    }

    private final long[] getKsmInfo() {
        long[] longOut = new long[4];
        int[] SINGLE_LONG_FORMAT = new int[]{8224};
        long[] longTmp = new long[1];
        Process.readProcFile("/sys/kernel/mm/ksm/pages_shared", SINGLE_LONG_FORMAT, null, longTmp, null);
        longOut[0] = (longTmp[0] * 4096) / 1024;
        longTmp[0] = 0;
        Process.readProcFile("/sys/kernel/mm/ksm/pages_sharing", SINGLE_LONG_FORMAT, null, longTmp, null);
        longOut[1] = (longTmp[0] * 4096) / 1024;
        longTmp[0] = 0;
        Process.readProcFile("/sys/kernel/mm/ksm/pages_unshared", SINGLE_LONG_FORMAT, null, longTmp, null);
        longOut[2] = (longTmp[0] * 4096) / 1024;
        longTmp[0] = 0;
        Process.readProcFile("/sys/kernel/mm/ksm/pages_volatile", SINGLE_LONG_FORMAT, null, longTmp, null);
        longOut[3] = (longTmp[0] * 4096) / 1024;
        return longOut;
    }

    private static String stringifySize(long size, int order) {
        Locale locale = Locale.US;
        switch (order) {
            case 1:
                return String.format(locale, "%,13d", new Object[]{Long.valueOf(size)});
            case 1024:
                return String.format(locale, "%,9dK", new Object[]{Long.valueOf(size / 1024)});
            case 1048576:
                return String.format(locale, "%,5dM", new Object[]{Long.valueOf((size / 1024) / 1024)});
            case 1073741824:
                return String.format(locale, "%,1dG", new Object[]{Long.valueOf(((size / 1024) / 1024) / 1024)});
            default:
                throw new IllegalArgumentException("Invalid size order");
        }
    }

    private static String stringifyKBSize(long size) {
        return stringifySize(1024 * size, 1024);
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    final void dumpApplicationMemoryUsage(FileDescriptor fd, PrintWriter pw, String prefix, String[] args, boolean brief, PrintWriter categoryPw) {
        int i;
        MemoryInfo mi;
        int pid;
        Object innerArgs;
        ArrayList<MemItem> procMems;
        SparseArray<MemItem> procMemsMap;
        long nativePss;
        long nativeSwapPss;
        long dalvikPss;
        long dalvikSwapPss;
        long[] dalvikSubitemPss;
        long[] dalvikSubitemSwapPss;
        long otherPss;
        long otherSwapPss;
        long[] miscPss;
        long[] miscSwapPss;
        long[] oomPss;
        long[] oomSwapPss;
        ArrayList<MemItem>[] oomProcs;
        long totalPss;
        long totalSwapPss;
        long cachedPss;
        long cachedSwapPss;
        boolean hasSwapPss;
        ProcessRecord r;
        IApplicationThread iApplicationThread;
        int oomAdj;
        boolean hasActivities;
        MemoryInfo mi2;
        long myTotalPss;
        long myTotalSwapPss;
        int j;
        long mem;
        Throwable th;
        boolean dumpDetails = false;
        boolean dumpFullDetails = false;
        boolean dumpDalvik = false;
        boolean dumpSummaryOnly = false;
        boolean dumpUnreachable = false;
        boolean oomOnly = false;
        boolean isCompact = false;
        boolean localOnly = false;
        boolean packages = false;
        boolean isCheckinRequest = false;
        boolean dumpSwapPss = false;
        int opti = 0;
        while (opti < args.length) {
            String opt = args[opti];
            if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
                break;
            }
            opti++;
            if ("-a".equals(opt)) {
                dumpDetails = true;
                dumpFullDetails = true;
                dumpDalvik = true;
                dumpSwapPss = true;
            } else if ("-d".equals(opt)) {
                dumpDalvik = true;
            } else if ("-c".equals(opt)) {
                isCompact = true;
            } else if ("-s".equals(opt)) {
                dumpDetails = true;
                dumpSummaryOnly = true;
            } else if ("-S".equals(opt)) {
                dumpSwapPss = true;
            } else if ("--unreachable".equals(opt)) {
                dumpUnreachable = true;
            } else if ("--oom".equals(opt)) {
                oomOnly = true;
            } else if ("--local".equals(opt)) {
                localOnly = true;
            } else if ("--package".equals(opt)) {
                packages = true;
            } else if ("--checkin".equals(opt)) {
                isCheckinRequest = true;
            } else if ("-h".equals(opt)) {
                pw.println("meminfo dump options: [-a] [-d] [-c] [-s] [--oom] [process]");
                pw.println("  -a: include all available information for each process.");
                pw.println("  -d: include dalvik details.");
                pw.println("  -c: dump in a compact machine-parseable representation.");
                pw.println("  -s: dump only summary of application memory usage.");
                pw.println("  -S: dump also SwapPss.");
                pw.println("  --oom: only show processes organized by oom adj.");
                pw.println("  --local: only collect details locally, don't call process.");
                pw.println("  --package: interpret process arg as package, dumping all");
                pw.println("             processes that have loaded that package.");
                pw.println("  --checkin: dump data for a checkin");
                pw.println("If [process] is specified it can be the name or ");
                pw.println("pid of a specific process to dump.");
                return;
            } else {
                pw.println("Unknown argument: " + opt + "; use -h for help");
            }
        }
        long uptime = SystemClock.uptimeMillis();
        long realtime = SystemClock.elapsedRealtime();
        long[] tmpLong = new long[1];
        ArrayList<ProcessRecord> procs = collectProcesses(pw, opti, packages, args);
        int N;
        Stats st;
        if (procs == null) {
            if (!(args == null || args.length <= opti || args[opti].charAt(0) == '-')) {
                ArrayList<Stats> nativeProcs = new ArrayList();
                updateCpuStatsNow();
                int findPid = -1;
                try {
                    findPid = Integer.parseInt(args[opti]);
                } catch (NumberFormatException e) {
                }
                synchronized (this.mProcessCpuTracker) {
                    N = this.mProcessCpuTracker.countStats();
                    for (i = 0; i < N; i++) {
                        st = this.mProcessCpuTracker.getStats(i);
                        if (st.pid == findPid || (st.baseName != null && st.baseName.equals(args[opti]))) {
                            nativeProcs.add(st);
                        }
                    }
                }
                if (nativeProcs.size() > 0) {
                    dumpApplicationMemoryUsageHeader(pw, uptime, realtime, isCheckinRequest, isCompact);
                    mi = null;
                    for (i = nativeProcs.size() - 1; i >= 0; i--) {
                        Stats r2 = (Stats) nativeProcs.get(i);
                        pid = r2.pid;
                        if (!isCheckinRequest && dumpDetails) {
                            pw.println("\n** MEMINFO in pid " + pid + " [" + r2.baseName + "] **");
                        }
                        if (mi == null) {
                            mi = new MemoryInfo();
                        }
                        if (dumpDetails || !(brief || (oomOnly ^ 1) == 0)) {
                            Debug.getMemoryInfo(pid, mi);
                        } else {
                            mi.dalvikPss = (int) Debug.getPss(pid, tmpLong, null);
                            mi.dalvikPrivateDirty = (int) tmpLong[0];
                        }
                        ActivityThread.dumpMemInfoTable(pw, mi, isCheckinRequest, dumpFullDetails, dumpDalvik, dumpSummaryOnly, pid, r2.baseName, 0, 0, 0, 0, 0, 0);
                        if (isCheckinRequest) {
                            pw.println();
                        }
                    }
                    return;
                }
            }
            pw.println("No process found for: " + args[opti]);
            return;
        }
        if (!(brief || (oomOnly ^ 1) == 0 || (procs.size() != 1 && !isCheckinRequest && !packages))) {
            dumpDetails = true;
        }
        dumpApplicationMemoryUsageHeader(pw, uptime, realtime, isCheckinRequest, isCompact);
        innerArgs = new String[(args.length - opti)];
        System.arraycopy(args, opti, innerArgs, 0, args.length - opti);
        procMems = new ArrayList();
        procMemsMap = new SparseArray();
        nativePss = 0;
        nativeSwapPss = 0;
        dalvikPss = 0;
        dalvikSwapPss = 0;
        if (dumpDalvik) {
            dalvikSubitemPss = new long[14];
        } else {
            dalvikSubitemPss = EmptyArray.LONG;
        }
        if (dumpDalvik) {
            dalvikSubitemSwapPss = new long[14];
        } else {
            dalvikSubitemSwapPss = EmptyArray.LONG;
        }
        otherPss = 0;
        otherSwapPss = 0;
        miscPss = new long[17];
        miscSwapPss = new long[17];
        oomPss = new long[DUMP_MEM_OOM_LABEL.length];
        oomSwapPss = new long[DUMP_MEM_OOM_LABEL.length];
        oomProcs = new ArrayList[DUMP_MEM_OOM_LABEL.length];
        totalPss = 0;
        totalSwapPss = 0;
        cachedPss = 0;
        cachedSwapPss = 0;
        hasSwapPss = false;
        mi = null;
        i = procs.size() - 1;
        while (i >= 0) {
            r = (ProcessRecord) procs.get(i);
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    iApplicationThread = r.thread;
                    pid = r.pid;
                    oomAdj = r.getSetAdjWithServices();
                    hasActivities = r.activities.size() > 0;
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        }
        long nativeProcTotalPss = 0;
        if (!(isCheckinRequest || procs.size() <= 1 || (packages ^ 1) == 0)) {
            updateCpuStatsNow();
            mi = null;
            synchronized (this.mProcessCpuTracker) {
                try {
                    N = this.mProcessCpuTracker.countStats();
                    i = 0;
                    while (true) {
                        mi2 = mi;
                        if (i >= N) {
                            break;
                        }
                        try {
                            st = this.mProcessCpuTracker.getStats(i);
                            if (st.vsize > 0) {
                                if (procMemsMap.indexOfKey(st.pid) < 0) {
                                    if (mi2 == null) {
                                        mi = new MemoryInfo();
                                    } else {
                                        mi = mi2;
                                    }
                                    if (brief || (oomOnly ^ 1) == 0) {
                                        mi.nativePss = (int) Debug.getPss(st.pid, tmpLong, null);
                                        mi.nativePrivateDirty = (int) tmpLong[0];
                                    } else {
                                        Debug.getMemoryInfo(st.pid, mi);
                                    }
                                    myTotalPss = (long) mi.getTotalPss();
                                    myTotalSwapPss = (long) mi.getTotalSwappedOutPss();
                                    totalPss += myTotalPss;
                                    nativeProcTotalPss += myTotalPss;
                                    MemItem memItem = new MemItem(st.name + " (pid " + st.pid + ")", st.name, myTotalPss, (long) mi.getSummaryTotalSwapPss(), st.pid, false);
                                    procMems.add(memItem);
                                    nativePss += (long) mi.nativePss;
                                    nativeSwapPss += (long) mi.nativeSwappedOutPss;
                                    dalvikPss += (long) mi.dalvikPss;
                                    dalvikSwapPss += (long) mi.dalvikSwappedOutPss;
                                    for (j = 0; j < dalvikSubitemPss.length; j++) {
                                        dalvikSubitemPss[j] = dalvikSubitemPss[j] + ((long) mi.getOtherPss(j + 17));
                                        dalvikSubitemSwapPss[j] = dalvikSubitemSwapPss[j] + ((long) mi.getOtherSwappedOutPss(j + 17));
                                    }
                                    otherPss += (long) mi.otherPss;
                                    otherSwapPss += (long) mi.otherSwappedOutPss;
                                    for (j = 0; j < 17; j++) {
                                        mem = (long) mi.getOtherPss(j);
                                        miscPss[j] = miscPss[j] + mem;
                                        otherPss -= mem;
                                        mem = (long) mi.getOtherSwappedOutPss(j);
                                        miscSwapPss[j] = miscSwapPss[j] + mem;
                                        otherSwapPss -= mem;
                                    }
                                    oomPss[0] = oomPss[0] + myTotalPss;
                                    oomSwapPss[0] = oomSwapPss[0] + myTotalSwapPss;
                                    if (oomProcs[0] == null) {
                                        oomProcs[0] = new ArrayList();
                                    }
                                    oomProcs[0].add(memItem);
                                    i++;
                                }
                            }
                            mi = mi2;
                            i++;
                        } catch (Throwable th2) {
                            th = th2;
                            mi = mi2;
                            throw th;
                        }
                    }
                } catch (Throwable th3) {
                    th = th3;
                    throw th;
                }
            }
        }
        if (!(isCheckinRequest || mi == null)) {
            totalPss += myTotalPss;
            totalSwapPss += myTotalSwapPss;
            MemItem pssItem = new MemItem(r.processName + " (pid " + pid + (hasActivities ? " / activities)" : ")"), r.processName, myTotalPss, myTotalSwapPss, pid, hasActivities);
            procMems.add(pssItem);
            procMemsMap.put(pid, pssItem);
            nativePss += (long) mi.nativePss;
            nativeSwapPss += (long) mi.nativeSwappedOutPss;
            dalvikPss += (long) mi.dalvikPss;
            dalvikSwapPss += (long) mi.dalvikSwappedOutPss;
            for (j = 0; j < dalvikSubitemPss.length; j++) {
                dalvikSubitemPss[j] = dalvikSubitemPss[j] + ((long) mi.getOtherPss(j + 17));
                dalvikSubitemSwapPss[j] = dalvikSubitemSwapPss[j] + ((long) mi.getOtherSwappedOutPss(j + 17));
            }
            otherPss += (long) mi.otherPss;
            otherSwapPss += (long) mi.otherSwappedOutPss;
            for (j = 0; j < 17; j++) {
                mem = (long) mi.getOtherPss(j);
                miscPss[j] = miscPss[j] + mem;
                otherPss -= mem;
                mem = (long) mi.getOtherSwappedOutPss(j);
                miscSwapPss[j] = miscSwapPss[j] + mem;
                otherSwapPss -= mem;
            }
            if (oomAdj >= 900) {
                cachedPss += myTotalPss;
                cachedSwapPss += myTotalSwapPss;
            }
            int oomIndex = 0;
            while (oomIndex < oomPss.length) {
                if (oomIndex == oomPss.length - 1 || (oomAdj >= DUMP_MEM_OOM_ADJ[oomIndex] && oomAdj < DUMP_MEM_OOM_ADJ[oomIndex + 1])) {
                    oomPss[oomIndex] = oomPss[oomIndex] + myTotalPss;
                    oomSwapPss[oomIndex] = oomSwapPss[oomIndex] + myTotalSwapPss;
                    if (oomProcs[oomIndex] == null) {
                        oomProcs[oomIndex] = new ArrayList();
                    }
                    oomProcs[oomIndex].add(pssItem);
                } else {
                    oomIndex++;
                }
            }
        }
        i--;
        if (iApplicationThread != null) {
            if (!isCheckinRequest && dumpDetails) {
                pw.println("\n** MEMINFO in pid " + pid + " [" + r.processName + "] **");
            }
            if (mi == null) {
                mi = new MemoryInfo();
            }
            if (dumpDetails || !(brief || (oomOnly ^ 1) == 0)) {
                Debug.getMemoryInfo(pid, mi);
                hasSwapPss = mi.hasSwappedOutPss;
            } else {
                mi.dalvikPss = (int) Debug.getPss(pid, tmpLong, null);
                mi.dalvikPrivateDirty = (int) tmpLong[0];
            }
            if (dumpDetails) {
                if (localOnly) {
                    iApplicationThread = r.processName;
                    ActivityThread.dumpMemInfoTable(pw, mi, isCheckinRequest, dumpFullDetails, dumpDalvik, dumpSummaryOnly, pid, iApplicationThread, 0, 0, 0, 0, 0, 0);
                    if (isCheckinRequest) {
                        pw.println();
                    }
                } else {
                    pw.flush();
                    TransferPipe tp;
                    try {
                        tp = new TransferPipe();
                        iApplicationThread.dumpMemInfo(tp.getWriteFd(), mi, isCheckinRequest, dumpFullDetails, dumpDalvik, dumpSummaryOnly, dumpUnreachable, innerArgs);
                        tp.go(fd);
                        tp.kill();
                    } catch (IOException e2) {
                        if (!isCheckinRequest) {
                            pw.println("Got IoException! " + e2);
                            pw.flush();
                        }
                    } catch (RemoteException e3) {
                        if (!isCheckinRequest) {
                            pw.println("Got RemoteException! " + e3);
                            pw.flush();
                        }
                    } catch (Throwable th4) {
                        tp.kill();
                    }
                }
            }
            myTotalPss = (long) mi.getTotalPss();
            long myTotalUss = (long) mi.getTotalUss();
            myTotalSwapPss = (long) mi.getTotalSwappedOutPss();
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (r.thread != null && oomAdj == r.getSetAdjWithServices()) {
                        r.baseProcessTracker.addPss(myTotalPss, myTotalUss, true, r.pkgList);
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        }
        i--;
        if (!brief) {
            if (isCompact) {
                pw.print("ram,");
                pw.print(memInfo.getTotalSizeKb());
                pw.print(",");
                pw.print((memInfo.getCachedSizeKb() + cachedPss) + memInfo.getFreeSizeKb());
                pw.print(",");
                pw.println(totalPss - cachedPss);
            } else {
                pw.print("Total RAM: ");
                pw.print(stringifyKBSize(memInfo.getTotalSizeKb()));
                pw.print(" (status ");
                switch (this.mLastMemoryLevel) {
                    case 0:
                        pw.println("normal)");
                        break;
                    case 1:
                        pw.println("moderate)");
                        break;
                    case 2:
                        pw.println("low)");
                        break;
                    case 3:
                        pw.println("critical)");
                        break;
                    default:
                        pw.print(this.mLastMemoryLevel);
                        pw.println(")");
                        break;
                }
                pw.print(" Free RAM: ");
                pw.print(stringifyKBSize(((memInfo.getCachedSizeKb() + cachedPss) + memInfo.getFreeSizeKb()) + memInfo.getIonTotalCachedKb()));
                pw.print(" (");
                pw.print(stringifyKBSize(cachedPss));
                pw.print(" cached pss + ");
                pw.print(stringifyKBSize(memInfo.getCachedSizeKb()));
                pw.print(" cached kernel + ");
                pw.print(stringifyKBSize(memInfo.getIonTotalCachedKb()));
                pw.print(" ion cached + ");
                pw.print(stringifyKBSize(memInfo.getFreeSizeKb()));
                pw.println(" free)");
            }
        }
        long lostRAM = (((((memInfo.getTotalSizeKb() - (totalPss - totalSwapPss)) - memInfo.getFreeSizeKb()) - memInfo.getCachedSizeKb()) - memInfo.getKernelUsedSizeKb()) - memInfo.getZramTotalSizeKb()) - memInfo.getIonTotalCachedKb();
        if (isCompact) {
            pw.print("lostram,");
            pw.println(lostRAM);
        } else {
            pw.print(" Used RAM: ");
            pw.print(stringifyKBSize((totalPss - cachedPss) + memInfo.getKernelUsedSizeKb()));
            pw.print(" (");
            pw.print(stringifyKBSize(totalPss - cachedPss));
            pw.print(" used pss + ");
            pw.print(stringifyKBSize(memInfo.getKernelUsedSizeKb()));
            pw.print(" kernel)\n");
            if (SystemProperties.getBoolean("persist.version.confidential", false)) {
                pw.print("UFree RAM: ");
                pw.println(stringifySize(Process.getFreeMemory(), 1048576));
            }
            pw.print(" Lost RAM: ");
            pw.println(stringifyKBSize(lostRAM));
        }
        if (brief) {
            mi = mi2;
        } else {
            if (memInfo.getZramTotalSizeKb() != 0) {
                if (isCompact) {
                    pw.print("zram,");
                    pw.print(memInfo.getZramTotalSizeKb());
                    pw.print(",");
                    pw.print(memInfo.getSwapTotalSizeKb());
                    pw.print(",");
                    pw.println(memInfo.getSwapFreeSizeKb());
                } else {
                    pw.print("     ZRAM: ");
                    pw.print(stringifyKBSize(memInfo.getZramTotalSizeKb()));
                    pw.print(" physical used for ");
                    pw.print(stringifyKBSize(memInfo.getSwapTotalSizeKb() - memInfo.getSwapFreeSizeKb()));
                    pw.print(" in swap (");
                    pw.print(stringifyKBSize(memInfo.getSwapTotalSizeKb()));
                    pw.println(" total swap)");
                }
            }
            long[] ksm = getKsmInfo();
            if (isCompact) {
                pw.print("ksm,");
                pw.print(ksm[1]);
                pw.print(",");
                pw.print(ksm[0]);
                pw.print(",");
                pw.print(ksm[2]);
                pw.print(",");
                pw.println(ksm[3]);
                pw.print("tuning,");
                pw.print(ActivityManager.staticGetMemoryClass());
                pw.print(',');
                pw.print(ActivityManager.staticGetLargeMemoryClass());
                pw.print(',');
                pw.print(this.mProcessList.getMemLevel(906) / 1024);
                if (ActivityManager.isLowRamDeviceStatic()) {
                    pw.print(",low-ram");
                }
                if (ActivityManager.isHighEndGfx()) {
                    pw.print(",high-end-gfx");
                }
                pw.println();
                mi = mi2;
            } else {
                if (!(ksm[1] == 0 && ksm[0] == 0 && ksm[2] == 0 && ksm[3] == 0)) {
                    pw.print("      KSM: ");
                    pw.print(stringifyKBSize(ksm[1]));
                    pw.print(" saved from shared ");
                    pw.print(stringifyKBSize(ksm[0]));
                    pw.print("           ");
                    pw.print(stringifyKBSize(ksm[2]));
                    pw.print(" unshared; ");
                    pw.print(stringifyKBSize(ksm[3]));
                    pw.println(" volatile");
                }
                pw.print("   Tuning: ");
                pw.print(ActivityManager.staticGetMemoryClass());
                pw.print(" (large ");
                pw.print(ActivityManager.staticGetLargeMemoryClass());
                pw.print("), oom ");
                pw.print(stringifySize(this.mProcessList.getMemLevel(906), 1024));
                pw.print(", restore limit ");
                pw.print(stringifyKBSize(this.mProcessList.getCachedRestoreThresholdKb()));
                if (ActivityManager.isLowRamDeviceStatic()) {
                    pw.print(" (low-ram)");
                }
                if (ActivityManager.isHighEndGfx()) {
                    pw.print(" (high-end-gfx)");
                }
                pw.println();
                mi = mi2;
            }
        }
    }

    private void appendBasicMemEntry(StringBuilder sb, int oomAdj, int procState, long pss, long memtrack, String name) {
        sb.append("  ");
        sb.append(ProcessList.makeOomAdjString(oomAdj));
        sb.append(' ');
        sb.append(ProcessList.makeProcStateString(procState));
        sb.append(' ');
        ProcessList.appendRamKb(sb, pss);
        sb.append(": ");
        sb.append(name);
        if (memtrack > 0) {
            sb.append(" (");
            sb.append(stringifyKBSize(memtrack));
            sb.append(" memtrack)");
        }
    }

    private void appendMemInfo(StringBuilder sb, ProcessMemInfo mi) {
        appendBasicMemEntry(sb, mi.oomAdj, mi.procState, mi.pss, mi.memtrack, mi.name);
        sb.append(" (pid ");
        sb.append(mi.pid);
        sb.append(") ");
        sb.append(mi.adjType);
        sb.append(10);
        if (mi.adjReason != null) {
            sb.append("                      ");
            sb.append(mi.adjReason);
            sb.append(10);
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    void reportMemUsage(ArrayList<ProcessMemInfo> memInfos) {
        int i;
        ProcessMemInfo mi;
        List<Stats> stats;
        SparseArray<ProcessMemInfo> sparseArray = new SparseArray(memInfos.size());
        int N = memInfos.size();
        for (i = 0; i < N; i++) {
            mi = (ProcessMemInfo) memInfos.get(i);
            sparseArray.put(mi.pid, mi);
        }
        updateCpuStatsNow();
        long[] memtrackTmp = new long[1];
        synchronized (this.mProcessCpuTracker) {
            stats = this.mProcessCpuTracker.getStats(-$Lambda$njIALZ9XLXuT-vhmazyQkVX7Z0U.$INST$1);
        }
        int statsCount = stats.size();
        for (i = 0; i < statsCount; i++) {
            Stats st = (Stats) stats.get(i);
            long pss = Debug.getPss(st.pid, null, memtrackTmp);
            if (pss > 0) {
                if (sparseArray.indexOfKey(st.pid) < 0) {
                    mi = new ProcessMemInfo(st.name, st.pid, JobSchedulerShellCommand.CMD_ERR_NO_PACKAGE, -1, "native", null);
                    mi.pss = pss;
                    mi.memtrack = memtrackTmp[0];
                    memInfos.add(mi);
                }
            }
        }
        long totalPss = 0;
        long totalMemtrack = 0;
        N = memInfos.size();
        for (i = 0; i < N; i++) {
            mi = (ProcessMemInfo) memInfos.get(i);
            if (mi.pss == 0) {
                mi.pss = Debug.getPss(mi.pid, null, memtrackTmp);
                mi.memtrack = memtrackTmp[0];
            }
            totalPss += mi.pss;
            totalMemtrack += mi.memtrack;
        }
        Collections.sort(memInfos, new Comparator<ProcessMemInfo>() {
            public int compare(ProcessMemInfo lhs, ProcessMemInfo rhs) {
                int i = 1;
                int i2 = -1;
                if (lhs.oomAdj != rhs.oomAdj) {
                    if (lhs.oomAdj >= rhs.oomAdj) {
                        i2 = 1;
                    }
                    return i2;
                } else if (lhs.pss == rhs.pss) {
                    return 0;
                } else {
                    if (lhs.pss >= rhs.pss) {
                        i = -1;
                    }
                    return i;
                }
            }
        });
        StringBuilder stringBuilder = new StringBuilder(128);
        stringBuilder = new StringBuilder(128);
        stringBuilder.append("Low on memory -- ");
        appendMemBucket(stringBuilder, totalPss, "total", false);
        appendMemBucket(stringBuilder, totalPss, "total", true);
        stringBuilder = new StringBuilder(1024);
        StringBuilder shortNativeBuilder = new StringBuilder(1024);
        stringBuilder = new StringBuilder(1024);
        boolean firstLine = true;
        int lastOomAdj = Integer.MIN_VALUE;
        long extraNativeRam = 0;
        long extraNativeMemtrack = 0;
        long cachedPss = 0;
        i = 0;
        N = memInfos.size();
        while (i < N) {
            mi = (ProcessMemInfo) memInfos.get(i);
            if (mi.oomAdj >= 900) {
                cachedPss += mi.pss;
            }
            if (mi.oomAdj != JobSchedulerShellCommand.CMD_ERR_NO_PACKAGE && (mi.oomAdj < 500 || mi.oomAdj == 600 || mi.oomAdj == START_OPPO_SITE_MSG)) {
                if (lastOomAdj != mi.oomAdj) {
                    lastOomAdj = mi.oomAdj;
                    if (mi.oomAdj <= 0) {
                        stringBuilder.append(" / ");
                    }
                    if (mi.oomAdj >= 0) {
                        if (firstLine) {
                            stringBuilder.append(":");
                            firstLine = false;
                        }
                        stringBuilder.append("\n\t at ");
                    } else {
                        stringBuilder.append("$");
                    }
                } else {
                    stringBuilder.append(" ");
                    stringBuilder.append("$");
                }
                if (mi.oomAdj <= 0) {
                    appendMemBucket(stringBuilder, mi.pss, mi.name, false);
                }
                appendMemBucket(stringBuilder, mi.pss, mi.name, true);
                if (mi.oomAdj >= 0) {
                    if (i + 1 < N) {
                    }
                    stringBuilder.append("(");
                    for (int k = 0; k < DUMP_MEM_OOM_ADJ.length; k++) {
                        if (DUMP_MEM_OOM_ADJ[k] == mi.oomAdj) {
                            stringBuilder.append(DUMP_MEM_OOM_LABEL[k]);
                            stringBuilder.append(":");
                            stringBuilder.append(DUMP_MEM_OOM_ADJ[k]);
                        }
                    }
                    stringBuilder.append(")");
                }
            }
            appendMemInfo(stringBuilder, mi);
            if (mi.oomAdj != JobSchedulerShellCommand.CMD_ERR_NO_PACKAGE) {
                if (extraNativeRam > 0) {
                    appendBasicMemEntry(shortNativeBuilder, JobSchedulerShellCommand.CMD_ERR_NO_PACKAGE, -1, extraNativeRam, extraNativeMemtrack, "(Other native)");
                    shortNativeBuilder.append(10);
                    extraNativeRam = 0;
                }
                appendMemInfo(stringBuilder, mi);
            } else if (mi.pss >= 512) {
                appendMemInfo(shortNativeBuilder, mi);
            } else {
                extraNativeRam += mi.pss;
                extraNativeMemtrack += mi.memtrack;
            }
            i++;
        }
        stringBuilder.append("           ");
        ProcessList.appendRamKb(stringBuilder, totalPss);
        stringBuilder.append(": TOTAL");
        if (totalMemtrack > 0) {
            stringBuilder.append(" (");
            stringBuilder.append(stringifyKBSize(totalMemtrack));
            stringBuilder.append(" memtrack)");
        }
        stringBuilder.append("\n");
        MemInfoReader memInfo = new MemInfoReader();
        memInfo.readMemInfo();
        long[] infos = memInfo.getRawInfo();
        stringBuilder = new StringBuilder(1024);
        Debug.getMemInfo(infos);
        stringBuilder.append("  MemInfo: ");
        stringBuilder.append(stringifyKBSize(infos[5])).append(" slab, ");
        stringBuilder.append(stringifyKBSize(infos[4])).append(" shmem, ");
        stringBuilder.append(stringifyKBSize(infos[12])).append(" vm alloc, ");
        stringBuilder.append(stringifyKBSize(infos[13])).append(" page tables ");
        stringBuilder.append(stringifyKBSize(infos[14])).append(" kernel stack\n");
        stringBuilder.append("           ");
        stringBuilder.append(stringifyKBSize(infos[2])).append(" buffers, ");
        stringBuilder.append(stringifyKBSize(infos[3])).append(" cached, ");
        stringBuilder.append(stringifyKBSize(infos[11])).append(" mapped, ");
        stringBuilder.append(stringifyKBSize(infos[1])).append(" free\n");
        if (infos[10] != 0) {
            stringBuilder.append("  ZRAM: ");
            stringBuilder.append(stringifyKBSize(infos[10]));
            stringBuilder.append(" RAM, ");
            stringBuilder.append(stringifyKBSize(infos[8]));
            stringBuilder.append(" swap total, ");
            stringBuilder.append(stringifyKBSize(infos[9]));
            stringBuilder.append(" swap free\n");
        }
        long[] ksm = getKsmInfo();
        if (!(ksm[1] == 0 && ksm[0] == 0 && ksm[2] == 0 && ksm[3] == 0)) {
            stringBuilder.append("  KSM: ");
            stringBuilder.append(stringifyKBSize(ksm[1]));
            stringBuilder.append(" saved from shared ");
            stringBuilder.append(stringifyKBSize(ksm[0]));
            stringBuilder.append("\n       ");
            stringBuilder.append(stringifyKBSize(ksm[2]));
            stringBuilder.append(" unshared; ");
            stringBuilder.append(stringifyKBSize(ksm[3]));
            stringBuilder.append(" volatile\n");
        }
        stringBuilder.append("  Free RAM: ");
        stringBuilder.append(stringifyKBSize((memInfo.getCachedSizeKb() + cachedPss) + memInfo.getFreeSizeKb()));
        stringBuilder.append("\n");
        stringBuilder.append("  Used RAM: ");
        stringBuilder.append(stringifyKBSize((totalPss - cachedPss) + memInfo.getKernelUsedSizeKb()));
        stringBuilder.append("\n");
        stringBuilder.append("  Lost RAM: ");
        stringBuilder.append(stringifyKBSize(((((memInfo.getTotalSizeKb() - totalPss) - memInfo.getFreeSizeKb()) - memInfo.getCachedSizeKb()) - memInfo.getKernelUsedSizeKb()) - memInfo.getZramTotalSizeKb()));
        stringBuilder.append("\n");
        Slog.i(TAG, "Low on memory:");
        Slog.i(TAG, shortNativeBuilder.toString());
        Slog.i(TAG, stringBuilder.toString());
        Slog.i(TAG, stringBuilder.toString());
        stringBuilder = new StringBuilder(1024);
        stringBuilder.append("Low on memory:");
        stringBuilder.append(stringBuilder);
        stringBuilder.append(10);
        stringBuilder.append(stringBuilder);
        stringBuilder.append(stringBuilder);
        stringBuilder.append(10);
        stringBuilder.append(stringBuilder);
        stringBuilder.append(10);
        Writer catSw = new StringWriter();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                PrintWriter fastPrintWriter = new FastPrintWriter(catSw, false, 256);
                String[] emptyArgs = new String[0];
                fastPrintWriter.println();
                dumpProcessesLocked(null, fastPrintWriter, emptyArgs, 0, false, null);
                fastPrintWriter.println();
                this.mServices.newServiceDumperLocked(null, fastPrintWriter, emptyArgs, 0, false, null).dumpLocked();
                fastPrintWriter.println();
                dumpActivitiesLocked(null, fastPrintWriter, emptyArgs, 0, false, false, null);
                fastPrintWriter.flush();
                stringBuilder.append(catSw.toString());
                addErrorToDropBox("lowmem", null, "system_server", null, null, stringBuilder.toString(), stringBuilder.toString(), null, null);
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        long now = SystemClock.uptimeMillis();
                        if (this.mLastMemUsageReportTime < now) {
                            this.mLastMemUsageReportTime = now;
                        }
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    static /* synthetic */ boolean lambda$-com_android_server_am_ActivityManagerService_894506(Stats st) {
        return st.vsize > 0;
    }

    private static boolean scanArgs(String[] args, String value) {
        if (args != null) {
            for (String arg : args) {
                if (value.equals(arg)) {
                    return true;
                }
            }
        }
        return false;
    }

    @OppoHook(level = OppoHookType.CHANGE_ACCESS, note = "ZhiYong.Lin@Plf.Framework, [-private]modify for BPM", property = OppoRomType.ROM)
    final boolean removeDyingProviderLocked(ProcessRecord proc, ContentProviderRecord cpr, boolean always) {
        boolean inLaunching = this.mLaunchingProviders.contains(cpr);
        if (!inLaunching || always) {
            synchronized (cpr) {
                cpr.launchingApp = null;
                if (!this.mSimulateBindBlockedCase) {
                    cpr.notifyAll();
                }
            }
            this.mProviderMap.removeProviderByClass(cpr.name, UserHandle.getUserId(cpr.uid));
            String[] names = cpr.info.authority.split(";");
            for (String removeProviderByName : names) {
                this.mProviderMap.removeProviderByName(removeProviderByName, UserHandle.getUserId(cpr.uid));
            }
        }
        for (int i = cpr.connections.size() - 1; i >= 0; i--) {
            ContentProviderConnection conn = (ContentProviderConnection) cpr.connections.get(i);
            if (!conn.waiting || !inLaunching || (always ^ 1) == 0) {
                ProcessRecord capp = conn.client;
                conn.dead = true;
                if (conn.stableCount > 0) {
                    if (!(capp.persistent || capp.thread == null || capp.pid == 0 || capp.pid == MY_PID)) {
                        capp.kill("depends on provider " + cpr.name.flattenToShortString() + " in dying proc " + (proc != null ? proc.processName : "??") + " (adj " + (proc != null ? Integer.valueOf(proc.setAdj) : "??") + ")", true);
                    }
                } else if (!(capp.thread == null || conn.provider.provider == null)) {
                    try {
                        capp.thread.unstableProviderDied(conn.provider.provider.asBinder());
                    } catch (RemoteException e) {
                    }
                    cpr.connections.remove(i);
                    if (conn.client.conProviders.remove(conn)) {
                        stopAssociationLocked(capp.uid, capp.processName, cpr.uid, cpr.name);
                    }
                }
            }
        }
        if (inLaunching && always) {
            this.mLaunchingProviders.remove(cpr);
        }
        return inLaunching;
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "ZhiYong.Lin@Plf.Framework, modify for BPM", property = OppoRomType.ROM)
    private final boolean cleanUpApplicationRecordLocked(ProcessRecord app, boolean restarting, boolean allowRestart, int index, boolean replacingPid) {
        int i;
        if (index >= 0) {
            removeLruProcessLocked(app);
            ProcessList.remove(app.pid);
        }
        this.mProcessesToGc.remove(app);
        this.mPendingPssProcesses.remove(app);
        try {
            if (!(app.crashDialog == null || (app.forceCrashReport ^ 1) == 0)) {
                app.crashDialog.dismiss();
                app.crashDialog = null;
            }
            if (app.anrDialog != null) {
                app.anrDialog.dismiss();
                app.anrDialog = null;
            }
            if (app.waitDialog != null) {
                app.waitDialog.dismiss();
                app.waitDialog = null;
            }
        } catch (NullPointerException e) {
            Slog.w(TAG, "cleanUpApplicationRecordLocked catch NullPointerException", e);
        }
        app.crashing = false;
        app.notResponding = false;
        app.resetPackageList(this.mProcessStats);
        app.unlinkDeathRecipient();
        app.makeInactive(this.mProcessStats);
        app.waitingToKill = null;
        app.forcingToImportant = null;
        updateProcessForegroundLocked(app, false, false);
        app.foregroundActivities = false;
        app.hasShownUi = false;
        app.treatLikeActivity = false;
        app.hasAboveClient = false;
        app.hasClientActivities = false;
        boolean isAllowedRestart = OppoProcessManagerHelper.checkProcessCanRestart(app);
        if (!isAllowedRestart) {
            allowRestart = isAllowedRestart;
        }
        this.mServices.killServicesLocked(app, allowRestart);
        boolean restart = false;
        if (isAllowedRestart) {
            for (i = app.pubProviders.size() - 1; i >= 0; i--) {
                ContentProviderRecord cpr = (ContentProviderRecord) app.pubProviders.valueAt(i);
                boolean always = !app.bad ? allowRestart ^ 1 : true;
                if ((removeDyingProviderLocked(app, cpr, always) || always) && cpr.hasConnectionOrHandle()) {
                    restart = true;
                }
                cpr.provider = null;
                cpr.proc = null;
            }
            app.pubProviders.clear();
            if (cleanupAppInLaunchingProvidersLocked(app, false)) {
                restart = true;
            }
        } else {
            OppoProcessManagerHelper.checkAppInLaunchingProviders(app);
        }
        if (!app.conProviders.isEmpty()) {
            for (i = app.conProviders.size() - 1; i >= 0; i--) {
                ContentProviderConnection conn = (ContentProviderConnection) app.conProviders.get(i);
                conn.provider.connections.remove(conn);
                stopAssociationLocked(app.uid, app.processName, conn.provider.uid, conn.provider.name);
            }
            app.conProviders.clear();
        }
        skipCurrentReceiverLocked(app);
        for (i = app.receivers.size() - 1; i >= 0; i--) {
            removeReceiverLocked((ReceiverList) app.receivers.valueAt(i));
        }
        app.receivers.clear();
        if (this.mBackupTarget != null && app.pid == this.mBackupTarget.app.pid) {
            if (ActivityManagerDebugConfig.DEBUG_BACKUP || ActivityManagerDebugConfig.DEBUG_CLEANUP) {
                Slog.d(TAG_CLEANUP, "App " + this.mBackupTarget.appInfo + " died during backup");
            }
            final ProcessRecord processRecord = app;
            this.mHandler.post(new Runnable() {
                public void run() {
                    try {
                        IBackupManager.Stub.asInterface(ServiceManager.getService("backup")).agentDisconnected(processRecord.info.packageName);
                    } catch (RemoteException e) {
                    }
                }
            });
        }
        for (i = this.mPendingProcessChanges.size() - 1; i >= 0; i--) {
            ProcessChangeItem item = (ProcessChangeItem) this.mPendingProcessChanges.get(i);
            if (item.pid == app.pid) {
                this.mPendingProcessChanges.remove(i);
                this.mAvailProcessChanges.add(item);
            }
        }
        this.mUiHandler.obtainMessage(32, app.pid, app.info.uid, null).sendToTarget();
        OppoProcessManagerHelper.handleAppDied(app);
        if (restarting) {
            return false;
        }
        int countForSameProcessName = 0;
        if (!app.persistent || app.isolated) {
            if (ActivityManagerDebugConfig.DEBUG_PROCESSES || ActivityManagerDebugConfig.DEBUG_CLEANUP) {
                Slog.v(TAG_CLEANUP, "Removing non-persistent process during cleanup: " + app);
            }
            if (!replacingPid) {
                int cleanProcPid = app.pid;
                if (cleanProcPid == 0) {
                    int NP = this.mProcessNames.getMap().size();
                    for (int ip = 0; ip < NP; ip++) {
                        SparseArray<ProcessRecord> procs = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
                        int NA = procs.size();
                        for (int ia = 0; ia < NA; ia++) {
                            ProcessRecord checkProc = (ProcessRecord) procs.valueAt(ia);
                            if (checkProc.uid == app.uid && checkProc.pid != cleanProcPid && checkProc.processName.equals(app.processName)) {
                                Slog.w(TAG, "cleanUpApplicationRecordLocked detect same process:" + checkProc);
                                countForSameProcessName++;
                                break;
                            }
                        }
                        if (countForSameProcessName == 1) {
                            break;
                        }
                    }
                }
                if (countForSameProcessName == 0) {
                    removeProcessNameLocked(app.processName, app.uid);
                } else {
                    Slog.w(TAG, "cleanUpApplicationRecordLocked detect same process name proc, num:" + countForSameProcessName + ", proc:" + app);
                }
            }
            if (this.mHeavyWeightProcess == app) {
                this.mHandler.sendMessage(this.mHandler.obtainMessage(25, this.mHeavyWeightProcess.userId, 0));
                this.mHeavyWeightProcess = null;
            }
        } else if (!app.removed) {
            if (this.mPersistentStartingProcesses.indexOf(app) < 0) {
                this.mPersistentStartingProcesses.add(app);
                restart = true;
            } else {
                if (isImportantPersistProc(app.processName)) {
                    Slog.i(TAG, "cleanUpApplicationRecordLocked, proc:" + app.processName + " with pid:" + app.pid + ", need to restart!");
                    restart = true;
                }
            }
        }
        if ((ActivityManagerDebugConfig.DEBUG_PROCESSES || ActivityManagerDebugConfig.DEBUG_CLEANUP) && this.mProcessesOnHold.contains(app)) {
            Slog.v(TAG_CLEANUP, "Clean-up removing on hold: " + app);
        }
        this.mProcessesOnHold.remove(app);
        if (app == this.mHomeProcess) {
            this.mHomeProcess = null;
        }
        if (app == this.mPreviousProcess) {
            this.mPreviousProcess = null;
        }
        if (restart && OppoAbnormalAppManager.getInstance().isPackageRestricted(app.info.packageName)) {
            restart = false;
        }
        if (countForSameProcessName > 0 && restart) {
            restart = false;
            Slog.w(TAG, "cleanUpApplicationRecordLocked detect same process name proc, don't restart " + app);
        }
        if (!restart || (app.isolated ^ 1) == 0) {
            if (app.pid > 0 && app.pid != MY_PID) {
                synchronized (this.mPidsSelfLocked) {
                    this.mPidsSelfLocked.remove(app.pid);
                    this.mHandler.removeMessages(20, app);
                }
                this.mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);
                if (app.isolated) {
                    this.mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);
                }
                app.setPid(0);
            }
            return false;
        }
        if (index < 0) {
            ProcessList.remove(app.pid);
        }
        addProcessNameLocked(app);
        startProcessLocked(app, "restart", app.processName);
        return true;
    }

    boolean checkAppInLaunchingProvidersLocked(ProcessRecord app) {
        for (int i = this.mLaunchingProviders.size() - 1; i >= 0; i--) {
            if (((ContentProviderRecord) this.mLaunchingProviders.get(i)).launchingApp == app) {
                return true;
            }
        }
        return false;
    }

    boolean cleanupAppInLaunchingProvidersLocked(ProcessRecord app, boolean alwaysBad) {
        boolean restart = false;
        for (int i = this.mLaunchingProviders.size() - 1; i >= 0; i--) {
            ContentProviderRecord cpr = (ContentProviderRecord) this.mLaunchingProviders.get(i);
            if (cpr.launchingApp == app) {
                if (alwaysBad || (app.bad ^ 1) == 0 || !cpr.hasConnectionOrHandle()) {
                    removeDyingProviderLocked(app, cpr, true);
                } else {
                    restart = true;
                }
            }
        }
        return restart;
    }

    public List<RunningServiceInfo> getServices(int maxNum, int flags) {
        List<RunningServiceInfo> runningServiceInfoLocked;
        enforceNotIsolatedCaller("getServices");
        int callingUid = Binder.getCallingUid();
        boolean canInteractAcrossUsers = ActivityManager.checkUidPermission("android.permission.INTERACT_ACROSS_USERS_FULL", callingUid) == 0;
        boolean allowed = isGetTasksAllowed("getServices", Binder.getCallingPid(), callingUid);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                runningServiceInfoLocked = this.mServices.getRunningServiceInfoLocked(maxNum, flags, callingUid, allowed, canInteractAcrossUsers);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return runningServiceInfoLocked;
    }

    public PendingIntent getRunningServiceControlPanel(ComponentName name) {
        PendingIntent runningServiceControlPanelLocked;
        enforceNotIsolatedCaller("getRunningServiceControlPanel");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                runningServiceControlPanelLocked = this.mServices.getRunningServiceControlPanelLocked(name);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return runningServiceControlPanelLocked;
    }

    public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, boolean requireForeground, String callingPackage, int userId) throws TransactionTooLargeException {
        enforceNotIsolatedCaller("startService");
        if (service != null && service.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        } else if (callingPackage == null) {
            throw new IllegalArgumentException("callingPackage cannot be null");
        } else {
            ComponentName res;
            if (ActivityManagerDebugConfig.DEBUG_SERVICE) {
                Slog.v(TAG_SERVICE, "*** startService: " + service + " type=" + resolvedType + " fg=" + requireForeground);
            }
            if (userId == 999) {
                String pName = null;
                if (!(service == null || service.getComponent() == null)) {
                    pName = service.getComponent().getPackageName();
                }
                if (!(pName == null || (OppoMultiAppManagerUtil.getInstance().isMultiApp(pName) ^ 1) == 0)) {
                    userId = this.mUserController.getCurrentUserIdLocked();
                }
            }
            synchronized (this) {
                long origId;
                try {
                    boostPriorityForLockedSection();
                    int callingPid = Binder.getCallingPid();
                    int callingUid = Binder.getCallingUid();
                    origId = Binder.clearCallingIdentity();
                    res = this.mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, requireForeground, callingPackage, userId);
                    Binder.restoreCallingIdentity(origId);
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                }
            }
            resetPriorityAfterLockedSection();
            return res;
        }
    }

    ComponentName startServiceInPackage(int uid, Intent service, String resolvedType, boolean fgRequired, String callingPackage, int userId) throws TransactionTooLargeException {
        ComponentName res;
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                if (ActivityManagerDebugConfig.DEBUG_SERVICE) {
                    Slog.v(TAG_SERVICE, "startServiceInPackage: " + service + " type=" + resolvedType);
                }
                origId = Binder.clearCallingIdentity();
                res = this.mServices.startServiceLocked(null, service, resolvedType, -1, uid, fgRequired, callingPackage, userId);
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
        return res;
    }

    public int stopService(IApplicationThread caller, Intent service, String resolvedType, int userId) {
        enforceNotIsolatedCaller("stopService");
        if (service == null || !service.hasFileDescriptors()) {
            int stopServiceLocked;
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    stopServiceLocked = this.mServices.stopServiceLocked(caller, service, resolvedType, userId);
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return stopServiceLocked;
        }
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }

    public IBinder peekService(Intent service, String resolvedType, String callingPackage) {
        enforceNotIsolatedCaller("peekService");
        if (service != null && service.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        } else if (callingPackage == null) {
            throw new IllegalArgumentException("callingPackage cannot be null");
        } else {
            IBinder peekServiceLocked;
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    peekServiceLocked = this.mServices.peekServiceLocked(service, resolvedType, callingPackage);
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return peekServiceLocked;
        }
    }

    public boolean stopServiceToken(ComponentName className, IBinder token, int startId) {
        boolean stopServiceTokenLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                stopServiceTokenLocked = this.mServices.stopServiceTokenLocked(className, token, startId);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return stopServiceTokenLocked;
    }

    public void setServiceForeground(ComponentName className, IBinder token, int id, Notification notification, int flags) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mServices.setServiceForegroundLocked(className, token, id, notification, flags);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public int handleIncomingUser(int callingPid, int callingUid, int userId, boolean allowAll, boolean requireFull, String name, String callerPackage) {
        return this.mUserController.handleIncomingUser(callingPid, callingUid, userId, allowAll, requireFull ? 2 : 0, name, callerPackage);
    }

    boolean isSingleton(String componentProcessName, ApplicationInfo aInfo, String className, int flags) {
        boolean result = false;
        if (UserHandle.getAppId(aInfo.uid) >= 10000) {
            if ((flags & 1073741824) != 0) {
                if (ActivityManager.checkUidPermission("android.permission.INTERACT_ACROSS_USERS", aInfo.uid) != 0) {
                    String msg = "Permission Denial: Component " + new ComponentName(aInfo.packageName, className).flattenToShortString() + " requests FLAG_SINGLE_USER, but app does not hold " + "android.permission.INTERACT_ACROSS_USERS";
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                }
                result = true;
            }
        } else if ("system".equals(componentProcessName)) {
            result = true;
        } else if ((flags & 1073741824) != 0) {
            result = !UserHandle.isSameApp(aInfo.uid, 1001) ? (aInfo.flags & 8) != 0 : true;
        }
        if (ActivityManagerDebugConfig.DEBUG_MU) {
            Slog.v(TAG_MU, "isSingleton(" + componentProcessName + ", " + aInfo + ", " + className + ", 0x" + Integer.toHexString(flags) + ") = " + result);
        }
        return result;
    }

    boolean isValidSingletonCall(int callingUid, int componentUid) {
        int componentAppId = UserHandle.getAppId(componentUid);
        if (UserHandle.isSameApp(callingUid, componentUid) || componentAppId == 1000 || componentAppId == 1001 || ActivityManager.checkUidPermission("android.permission.INTERACT_ACROSS_USERS_FULL", componentUid) == 0) {
            return true;
        }
        return false;
    }

    public int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, String callingPackage, int userId) throws TransactionTooLargeException {
        enforceNotIsolatedCaller("bindService");
        if (service != null && service.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        } else if (callingPackage == null) {
            throw new IllegalArgumentException("callingPackage cannot be null");
        } else {
            int bindServiceLocked;
            if (userId == 999) {
                String pName = null;
                if (!(service == null || service.getPackage() == null)) {
                    pName = service.getPackage();
                }
                if (!(pName != null || service == null || service.getComponent() == null)) {
                    pName = service.getComponent().getPackageName();
                }
                if (!(pName == null || (OppoMultiAppManagerUtil.getInstance().isMultiApp(pName) ^ 1) == 0)) {
                    userId = this.mUserController.getCurrentUserIdLocked();
                }
            }
            debugActionIfNecessary(service);
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    bindServiceLocked = this.mServices.bindServiceLocked(caller, token, service, resolvedType, connection, flags, callingPackage, userId);
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return bindServiceLocked;
        }
    }

    public boolean unbindService(IServiceConnection connection) {
        boolean unbindServiceLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                unbindServiceLocked = this.mServices.unbindServiceLocked(connection);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return unbindServiceLocked;
    }

    public void publishService(IBinder token, Intent intent, IBinder service) {
        if (intent == null || !intent.hasFileDescriptors()) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (token instanceof ServiceRecord) {
                        this.mServices.publishServiceLocked((ServiceRecord) token, intent, service);
                    } else {
                        throw new IllegalArgumentException("Invalid service token");
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return;
        }
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }

    public void unbindFinished(IBinder token, Intent intent, boolean doRebind) {
        if (intent == null || !intent.hasFileDescriptors()) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    this.mServices.unbindFinishedLocked((ServiceRecord) token, intent, doRebind);
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return;
        }
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }

    public void serviceDoneExecuting(IBinder token, int type, int startId, int res) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (token instanceof ServiceRecord) {
                    this.mServices.serviceDoneExecutingLocked((ServiceRecord) token, type, startId, res);
                } else {
                    Slog.e(TAG, "serviceDoneExecuting: Invalid service token=" + token);
                    throw new IllegalArgumentException("Invalid service token");
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public boolean bindBackupAgent(String packageName, int backupMode, int userId) {
        int oldBackupUid;
        int newBackupUid;
        if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
            Slog.v(TAG, "bindBackupAgent: app=" + packageName + " mode=" + backupMode);
        }
        enforceCallingPermission("android.permission.CONFIRM_FULL_BACKUP", "bindBackupAgent");
        ApplicationInfo app = null;
        try {
            app = AppGlobals.getPackageManager().getApplicationInfo(packageName, 0, userId);
        } catch (RemoteException e) {
        }
        if (app == null) {
            Slog.w(TAG, "Unable to bind backup agent for " + packageName);
            return false;
        }
        synchronized (this) {
            try {
                Serv ss;
                ComponentName hostingName;
                boostPriorityForLockedSection();
                BatteryStatsImpl stats = this.mBatteryStatsService.getActiveStatistics();
                synchronized (stats) {
                    ss = stats.getServiceStatsLocked(app.uid, app.packageName, app.name);
                }
                try {
                    AppGlobals.getPackageManager().setPackageStoppedState(app.packageName, false, UserHandle.getUserId(app.uid));
                } catch (RemoteException e2) {
                } catch (IllegalArgumentException e3) {
                    Slog.w(TAG, "Failed trying to unstop package " + app.packageName + ": " + e3);
                }
                BackupRecord backupRecord = new BackupRecord(ss, app, backupMode);
                if (backupMode == 0) {
                    hostingName = new ComponentName(app.packageName, app.backupAgentName);
                } else {
                    hostingName = new ComponentName("android", "FullBackupAgent");
                }
                ProcessRecord proc = startProcessLocked(app.processName, app, false, 0, "backup", hostingName, false, false, false);
                if (proc == null) {
                    Slog.e(TAG, "Unable to start backup agent process " + backupRecord);
                } else {
                    if (UserHandle.isApp(app.uid) && backupMode == 1) {
                        proc.inFullBackup = true;
                    }
                    backupRecord.app = proc;
                    oldBackupUid = this.mBackupTarget != null ? this.mBackupTarget.appInfo.uid : -1;
                    newBackupUid = proc.inFullBackup ? backupRecord.appInfo.uid : -1;
                    this.mBackupTarget = backupRecord;
                    this.mBackupAppName = app.packageName;
                    updateOomAdjLocked(proc, true);
                    if (proc.thread != null) {
                        if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
                            Slog.v(TAG_BACKUP, "Agent proc already running: " + proc);
                        }
                        try {
                            proc.thread.scheduleCreateBackupAgent(app, compatibilityInfoForPackageLocked(app), backupMode);
                        } catch (RemoteException e4) {
                        }
                    } else if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
                        Slog.v(TAG_BACKUP, "Agent proc not running, waiting for attach");
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
        JobSchedulerInternal js = (JobSchedulerInternal) LocalServices.getService(JobSchedulerInternal.class);
        if (oldBackupUid != -1) {
            js.removeBackingUpUid(oldBackupUid);
        }
        if (newBackupUid != -1) {
            js.addBackingUpUid(newBackupUid);
        }
        return true;
        return false;
    }

    public void clearPendingBackup() {
        if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
            Slog.v(TAG_BACKUP, "clearPendingBackup");
        }
        enforceCallingPermission("android.permission.BACKUP", "clearPendingBackup");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mBackupTarget = null;
                this.mBackupAppName = null;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        ((JobSchedulerInternal) LocalServices.getService(JobSchedulerInternal.class)).clearAllBackingUpUids();
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void backupAgentCreated(String agentPackageName, IBinder agent) {
        if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
            Slog.v(TAG_BACKUP, "backupAgentCreated: " + agentPackageName + " = " + agent);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (!agentPackageName.equals(this.mBackupAppName)) {
                    Slog.e(TAG, "Backup agent created for " + agentPackageName + " but not requested!");
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void unbindBackupAgent(ApplicationInfo appInfo) {
        if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
            Slog.v(TAG_BACKUP, "unbindBackupAgent: " + appInfo);
        }
        if (appInfo == null) {
            Slog.w(TAG, "unbind backup agent for null app");
            return;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                try {
                    if (this.mBackupAppName == null) {
                        Slog.w(TAG, "Unbinding backup agent with no active backup");
                        this.mBackupTarget = null;
                        this.mBackupAppName = null;
                    } else if (this.mBackupAppName.equals(appInfo.packageName)) {
                        ProcessRecord proc = this.mBackupTarget.app;
                        updateOomAdjLocked(proc, true);
                        proc.inFullBackup = false;
                        int oldBackupUid = this.mBackupTarget != null ? this.mBackupTarget.appInfo.uid : -1;
                        if (proc.thread != null) {
                            proc.thread.scheduleDestroyBackupAgent(appInfo, compatibilityInfoForPackageLocked(appInfo));
                        }
                        this.mBackupTarget = null;
                        this.mBackupAppName = null;
                    } else {
                        Slog.e(TAG, "Unbind of " + appInfo + " but is not the current backup target");
                        this.mBackupTarget = null;
                        this.mBackupAppName = null;
                        resetPriorityAfterLockedSection();
                    }
                } catch (Exception e) {
                    Slog.e(TAG, "Exception when unbinding backup agent:");
                    e.printStackTrace();
                } catch (Throwable th) {
                    this.mBackupTarget = null;
                    this.mBackupAppName = null;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private boolean isInstantApp(ProcessRecord record, String callerPackage, int uid) {
        if (UserHandle.getAppId(uid) < 10000) {
            return false;
        }
        if (record != null) {
            return record.info.isInstantApp();
        }
        if (callerPackage == null) {
            Slog.e(TAG, "isInstantApp with an application's uid, no record, and no package name");
            throw new IllegalArgumentException("Calling application did not provide package name");
        }
        this.mAppOpsService.checkPackage(uid, callerPackage);
        try {
            return AppGlobals.getPackageManager().isInstantApp(callerPackage, UserHandle.getUserId(uid));
        } catch (RemoteException e) {
            Slog.e(TAG, "Error looking up if " + callerPackage + " is an instant app.", e);
            return true;
        }
    }

    boolean isPendingBroadcastProcessLocked(int pid) {
        if (this.mFgBroadcastQueue.isPendingBroadcastProcessLocked(pid) || this.mBgBroadcastQueue.isPendingBroadcastProcessLocked(pid)) {
            return true;
        }
        return OppoBroadcastManager.getInstance(this).isPendingBroadcastProcessLocked(pid);
    }

    void skipPendingBroadcastLocked(int pid) {
        Slog.w(TAG, "Unattached app died before broadcast acknowledged, skipping");
        for (BroadcastQueue queue : this.mBroadcastQueues) {
            queue.skipPendingBroadcastLocked(pid);
        }
    }

    boolean sendPendingBroadcastsLocked(ProcessRecord app) {
        boolean didSomething = false;
        for (BroadcastQueue queue : this.mBroadcastQueues) {
            didSomething |= queue.sendPendingBroadcastsLocked(app);
        }
        return didSomething;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId, int flags) {
        Throwable th;
        enforceNotIsolatedCaller("registerReceiver");
        ArrayList<Intent> stickyIntents = null;
        ProcessRecord callerApp = null;
        boolean visibleToInstantApps = (flags & 1) != 0;
        synchronized (this) {
            try {
                int callingUid;
                int callingPid;
                boostPriorityForLockedSection();
                if (caller != null) {
                    callerApp = getRecordForAppLocked(caller);
                    if (callerApp == null) {
                        throw new SecurityException("Unable to find app for caller " + caller + " (pid=" + Binder.getCallingPid() + ") when registering receiver " + receiver);
                    } else if (callerApp.info.uid == 1000 || (callerApp.pkgList.containsKey(callerPackage) ^ 1) == 0 || ("android".equals(callerPackage) ^ 1) == 0) {
                        callingUid = callerApp.info.uid;
                        callingPid = callerApp.pid;
                    } else {
                        throw new SecurityException("Given caller package " + callerPackage + " is not running in process " + callerApp);
                    }
                }
                callerPackage = null;
                callingUid = Binder.getCallingUid();
                callingPid = Binder.getCallingPid();
                boolean instantApp = isInstantApp(callerApp, callerPackage, callingUid);
                userId = this.mUserController.handleIncomingUser(callingPid, callingUid, userId, true, 2, "registerReceiver", callerPackage);
                Iterator<String> actions = filter.actionsIterator();
                if (actions == null) {
                    ArrayList<String> arrayList = new ArrayList(1);
                    arrayList.add(null);
                    actions = arrayList.iterator();
                }
                int[] userIds = new int[]{-1, UserHandle.getUserId(callingUid)};
                while (actions.hasNext()) {
                    String action = (String) actions.next();
                    int i = 0;
                    int length = userIds.length;
                    ArrayList<Intent> stickyIntents2 = stickyIntents;
                    while (i < length) {
                        try {
                            ArrayMap<String, ArrayList<Intent>> stickies = (ArrayMap) this.mStickyBroadcasts.get(userIds[i]);
                            if (stickies != null) {
                                ArrayList<Intent> intents = (ArrayList) stickies.get(action);
                                if (intents != null) {
                                    if (stickyIntents2 == null) {
                                        stickyIntents = new ArrayList();
                                    } else {
                                        stickyIntents = stickyIntents2;
                                    }
                                    stickyIntents.addAll(intents);
                                    i++;
                                    stickyIntents2 = stickyIntents;
                                }
                            }
                            stickyIntents = stickyIntents2;
                            i++;
                            stickyIntents2 = stickyIntents;
                        } catch (Throwable th2) {
                            th = th2;
                            stickyIntents = stickyIntents2;
                            resetPriorityAfterLockedSection();
                            throw th;
                        }
                    }
                    stickyIntents = stickyIntents2;
                }
            } catch (Throwable th3) {
                th = th3;
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        return null;
    }

    private void logRegisteredReceiversForDebugLocked() {
        if (SystemProperties.getBoolean("persist.sys.assert.panic", false)) {
            if (this.mRegisteredReceivers.size() > 0) {
                int index = 0;
                for (ReceiverList r : this.mRegisteredReceivers.values()) {
                    Slog.e(TAG, "list[" + index + "]:" + r);
                    index++;
                }
            } else {
                Slog.e(TAG, "mRegisteredReceivers empty!");
            }
        }
    }

    public void unregisterReceiver(IIntentReceiver receiver) {
        if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
            Slog.v(TAG_BROADCAST, "Unregister receiver: " + receiver);
        }
        long origId = Binder.clearCallingIdentity();
        boolean doTrim = false;
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ReceiverList rl = (ReceiverList) this.mRegisteredReceivers.get(receiver.asBinder());
                if (rl != null) {
                    BroadcastRecord r = rl.curBroadcast;
                    if (r != null && r == r.queue.getMatchingOrderedReceiver(r) && r.queue.finishReceiverLocked(r, r.resultCode, r.resultData, r.resultExtras, r.resultAbort, false)) {
                        doTrim = true;
                        r.queue.processNextBroadcast(false);
                    }
                    if (rl.app != null) {
                        rl.app.receivers.remove(rl);
                    }
                    removeReceiverLocked(rl);
                    if (rl.linkedToDeath) {
                        rl.linkedToDeath = false;
                        rl.receiver.asBinder().unlinkToDeath(rl, 0);
                    }
                }
            }
            resetPriorityAfterLockedSection();
            if (doTrim) {
                trimApplications();
                Binder.restoreCallingIdentity(origId);
                return;
            }
            Binder.restoreCallingIdentity(origId);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    void removeReceiverLocked(ReceiverList rl) {
        this.mRegisteredReceivers.remove(rl.receiver.asBinder());
        for (int i = rl.size() - 1; i >= 0; i--) {
            this.mReceiverResolver.removeFilter((BroadcastFilter) rl.get(i));
        }
    }

    private final void sendPackageBroadcastLocked(int cmd, String[] packages, int userId) {
        if (cmd != 0 || userId != OppoMultiAppManager.USER_ID) {
            for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                ProcessRecord r = (ProcessRecord) this.mLruProcesses.get(i);
                if (r.thread != null && (userId == -1 || r.userId == userId)) {
                    try {
                        r.thread.dispatchPackageBroadcast(cmd, packages);
                    } catch (RemoteException e) {
                    }
                }
            }
        }
    }

    private List<ResolveInfo> collectReceiverComponents(Intent intent, String resolvedType, int callingUid, int[] users, String callerPackage) {
        int i;
        int[] newUsers;
        int n;
        List<ResolveInfo> receivers = null;
        int callingUserId = UserHandle.getUserId(callingUid);
        int len = users.length;
        boolean hasMultiUser = false;
        boolean hasOwnerUser = false;
        for (i = 0; i < len; i++) {
            if (users[i] == 0) {
                hasOwnerUser = true;
            } else if (users[i] == 999) {
                hasMultiUser = true;
            }
        }
        if (hasMultiUser && (hasOwnerUser ^ 1) != 0) {
            newUsers = new int[(len + 1)];
            for (n = 0; n < len; n++) {
                newUsers[n] = users[n];
            }
            newUsers[len] = 0;
            if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                Slog.d(TAG, "collectReceiverComponents: add user 0!");
            }
            users = newUsers;
        }
        if (!(hasMultiUser || !hasOwnerUser || OppoMultiAppManagerUtil.getInstance().isMultiApp(callerPackage))) {
            newUsers = new int[(len + 1)];
            for (n = 0; n < len; n++) {
                newUsers[n] = users[n];
            }
            newUsers[len] = OppoMultiAppManager.USER_ID;
            if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                Slog.d(TAG, "collectReceiverComponents: add user 999!");
            }
            users = newUsers;
        }
        HashSet<ComponentName> singleUserReceivers = null;
        boolean scannedFirstReceivers = false;
        for (int user : users) {
            if (callingUserId == 0 && user == 999 && OppoMultiAppManagerUtil.getInstance().isMultiApp(callerPackage)) {
                if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                    Slog.d(TAG, "multi app: collectReceiverComponents: continue user 999! callerPackage = " + callerPackage);
                }
            } else if (callingUid != 2000 || !this.mUserController.hasUserRestriction("no_debugging_features", user) || (isPermittedShellBroadcast(intent) ^ 1) == 0) {
                ResolveInfo ri;
                List<ResolveInfo> newReceivers = AppGlobals.getPackageManager().queryIntentReceivers(intent, resolvedType, 268436480, user).getList();
                if (!(user == 0 || newReceivers == null)) {
                    i = 0;
                    while (i < newReceivers.size()) {
                        ri = (ResolveInfo) newReceivers.get(i);
                        if ((ri.activityInfo.flags & 536870912) != 0) {
                            newReceivers.remove(i);
                            i--;
                        } else if (callingUserId == 0 && user == 999 && (OppoMultiAppManagerUtil.getInstance().isMultiApp(ri.activityInfo.packageName) ^ 1) != 0) {
                            newReceivers.remove(i);
                            i--;
                        }
                        i++;
                    }
                }
                if (user == 0 && newReceivers != null) {
                    i = 0;
                    while (i < newReceivers.size()) {
                        ri = (ResolveInfo) newReceivers.get(i);
                        if (callingUserId == 999 && OppoMultiAppManagerUtil.getInstance().isMultiApp(ri.activityInfo.packageName)) {
                            newReceivers.remove(i);
                            i--;
                        }
                        i++;
                    }
                }
                if (newReceivers != null && newReceivers.size() == 0) {
                    newReceivers = null;
                }
                if (receivers == null) {
                    receivers = newReceivers;
                } else if (newReceivers == null) {
                    continue;
                } else {
                    HashSet<ComponentName> singleUserReceivers2;
                    ComponentName cn;
                    if (!scannedFirstReceivers) {
                        scannedFirstReceivers = true;
                        i = 0;
                        while (true) {
                            singleUserReceivers2 = singleUserReceivers;
                            if (i >= receivers.size()) {
                                singleUserReceivers = singleUserReceivers2;
                                break;
                            }
                            ri = (ResolveInfo) receivers.get(i);
                            if ((ri.activityInfo.flags & 1073741824) != 0) {
                                cn = new ComponentName(ri.activityInfo.packageName, ri.activityInfo.name);
                                if (singleUserReceivers2 == null) {
                                    singleUserReceivers = new HashSet();
                                } else {
                                    singleUserReceivers = singleUserReceivers2;
                                }
                                try {
                                    singleUserReceivers.add(cn);
                                } catch (RemoteException e) {
                                }
                            } else {
                                singleUserReceivers = singleUserReceivers2;
                            }
                            i++;
                        }
                    }
                    i = 0;
                    while (true) {
                        try {
                            singleUserReceivers2 = singleUserReceivers;
                            if (i >= newReceivers.size()) {
                                singleUserReceivers = singleUserReceivers2;
                                break;
                            }
                            ri = (ResolveInfo) newReceivers.get(i);
                            if ((ri.activityInfo.flags & 1073741824) != 0) {
                                cn = new ComponentName(ri.activityInfo.packageName, ri.activityInfo.name);
                                if (singleUserReceivers2 == null) {
                                    singleUserReceivers = new HashSet();
                                } else {
                                    singleUserReceivers = singleUserReceivers2;
                                }
                                if (!singleUserReceivers.contains(cn)) {
                                    singleUserReceivers.add(cn);
                                    receivers.add(ri);
                                }
                            } else {
                                receivers.add(ri);
                                singleUserReceivers = singleUserReceivers2;
                            }
                            i++;
                        } catch (RemoteException e2) {
                            singleUserReceivers = singleUserReceivers2;
                        }
                    }
                }
            }
        }
        if (ActivityManagerDebugConfig.DEBUG_BROADCAST && receivers != null) {
            for (i = 0; i < receivers.size(); i++) {
                Slog.d(TAG, "multi app: collectReceiverComponents: i = " + i + "  ResolveInfo = " + ((ResolveInfo) receivers.get(i)) + "  intent = " + intent + "  callingUid = " + callingUid);
            }
        }
        return receivers;
    }

    private boolean isPermittedShellBroadcast(Intent intent) {
        return INTENT_REMOTE_BUGREPORT_FINISHED.equals(intent.getAction());
    }

    private void checkBroadcastFromSystem(Intent intent, ProcessRecord callerApp, String callerPackage, int callingUid, boolean isProtectedBroadcast, List receivers) {
        if ((intent.getFlags() & DumpState.DUMP_CHANGES) == 0) {
            String action = intent.getAction();
            if (!isProtectedBroadcast && !"android.intent.action.CLOSE_SYSTEM_DIALOGS".equals(action) && !"com.android.intent.action.DISMISS_KEYBOARD_SHORTCUTS".equals(action) && !"android.intent.action.MEDIA_BUTTON".equals(action) && !"android.intent.action.MEDIA_SCANNER_SCAN_FILE".equals(action) && !"com.android.intent.action.SHOW_KEYBOARD_SHORTCUTS".equals(action) && !"android.intent.action.MASTER_CLEAR".equals(action) && !"android.intent.action.FACTORY_RESET".equals(action) && !"android.appwidget.action.APPWIDGET_CONFIGURE".equals(action) && !"android.appwidget.action.APPWIDGET_UPDATE".equals(action) && !"android.location.HIGH_POWER_REQUEST_CHANGE".equals(action) && !"com.android.omadm.service.CONFIGURATION_UPDATE".equals(action) && !"android.text.style.SUGGESTION_PICKED".equals(action) && !"android.media.action.OPEN_AUDIO_EFFECT_CONTROL_SESSION".equals(action) && !"android.media.action.CLOSE_AUDIO_EFFECT_CONTROL_SESSION".equals(action)) {
                if (!(receivers == null || receivers.size() <= 0 || (intent.getPackage() == null && intent.getComponent() == null))) {
                    boolean allProtected = true;
                    for (int i = receivers.size() - 1; i >= 0; i--) {
                        ResolveInfo target = receivers.get(i);
                        if (target instanceof ResolveInfo) {
                            ResolveInfo ri = target;
                            if (ri.activityInfo.exported && ri.activityInfo.permission == null) {
                                allProtected = false;
                                break;
                            }
                        } else if (((BroadcastFilter) target).requiredPermission == null) {
                            allProtected = false;
                            break;
                        }
                    }
                    if (allProtected) {
                        return;
                    }
                }
                if (callerApp != null) {
                    if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                        Log.w(TAG, "Sending non-protected broadcast " + action + " from system " + callerApp.toShortString() + " pkg " + callerPackage);
                    }
                } else if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                    Log.w(TAG, "Sending non-protected broadcast " + action + " from system uid " + UserHandle.formatUid(callingUid) + " pkg " + callerPackage);
                }
            }
        }
    }

    final int broadcastIntentLocked(com.android.server.am.ProcessRecord r114, java.lang.String r115, android.content.Intent r116, java.lang.String r117, android.content.IIntentReceiver r118, int r119, java.lang.String r120, android.os.Bundle r121, java.lang.String[] r122, int r123, android.os.Bundle r124, boolean r125, boolean r126, int r127, int r128, int r129) {
        /* JADX: method processing error */
/*
Error: jadx.core.utils.exceptions.JadxRuntimeException: Unknown predecessor block by arg (r37_1 'brOptions' android.app.BroadcastOptions) in PHI: PHI: (r37_2 'brOptions' android.app.BroadcastOptions) = (r37_0 'brOptions' android.app.BroadcastOptions), (r37_1 'brOptions' android.app.BroadcastOptions), (r37_1 'brOptions' android.app.BroadcastOptions) binds: {(r37_0 'brOptions' android.app.BroadcastOptions)=B:57:0x01f6, (r37_1 'brOptions' android.app.BroadcastOptions)=B:59:0x0209, (r37_1 'brOptions' android.app.BroadcastOptions)=B:61:0x021e}
	at jadx.core.dex.instructions.PhiInsn.replaceArg(PhiInsn.java:78)
	at jadx.core.dex.visitors.ModVisitor.processInvoke(ModVisitor.java:222)
	at jadx.core.dex.visitors.ModVisitor.replaceStep(ModVisitor.java:83)
	at jadx.core.dex.visitors.ModVisitor.visit(ModVisitor.java:68)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:27)
	at jadx.core.dex.visitors.DepthTraversal.lambda$visit$1(DepthTraversal.java:14)
	at java.util.ArrayList.forEach(ArrayList.java:1251)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:14)
	at jadx.core.ProcessClass.process(ProcessClass.java:32)
	at jadx.core.ProcessClass.lambda$processDependencies$0(ProcessClass.java:51)
	at java.lang.Iterable.forEach(Iterable.java:75)
	at jadx.core.ProcessClass.processDependencies(ProcessClass.java:51)
	at jadx.core.ProcessClass.process(ProcessClass.java:37)
	at jadx.api.JadxDecompiler.processClass(JadxDecompiler.java:286)
	at jadx.api.JavaClass.decompile(JavaClass.java:62)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
*/
        /*
        r113 = this;
        r28 = new android.content.Intent;
        r0 = r28;
        r1 = r116;
        r0.<init>(r1);
        r0 = r113;
        r1 = r114;
        r2 = r115;
        r3 = r128;
        r33 = r0.isInstantApp(r1, r2, r3);
        if (r33 == 0) goto L_0x0024;
    L_0x0017:
        r4 = r28.getFlags();
        r6 = -2097153; // 0xffffffffffdfffff float:NaN double:NaN;
        r4 = r4 & r6;
        r0 = r28;
        r0.setFlags(r4);
    L_0x0024:
        r4 = 16;
        r0 = r28;
        r0.addFlags(r4);
        r4 = com.android.server.am.OppoAppStartupManager.getInstance();
        r0 = r28;
        r1 = r114;
        r4.handleBroadcastIncludeForceStop(r0, r1);
        r0 = r113;
        r4 = r0.mProcessesReady;
        if (r4 != 0) goto L_0x004c;
    L_0x003c:
        r4 = r28.getFlags();
        r6 = 33554432; // 0x2000000 float:9.403955E-38 double:1.6578092E-316;
        r4 = r4 & r6;
        if (r4 != 0) goto L_0x004c;
    L_0x0045:
        r4 = 1073741824; // 0x40000000 float:2.0 double:5.304989477E-315;
        r0 = r28;
        r0.addFlags(r4);
    L_0x004c:
        r83 = 0;
        r4 = DEBUG_COLOROS_AMS;
        if (r4 == 0) goto L_0x0063;
    L_0x0052:
        r74 = r28.getAction();
        r4 = "oppo.intent.action.BOOT_COMPLETED";
        r0 = r74;
        r4 = r4.equals(r0);
        if (r4 == 0) goto L_0x0063;
    L_0x0061:
        r83 = 1;
    L_0x0063:
        r4 = com.android.server.am.ActivityManagerDebugConfig.DEBUG_BROADCAST_LIGHT;
        if (r4 != 0) goto L_0x0069;
    L_0x0067:
        if (r83 == 0) goto L_0x00ad;
    L_0x0069:
        r6 = TAG_BROADCAST;
        r7 = new java.lang.StringBuilder;
        r7.<init>();
        if (r126 == 0) goto L_0x01ef;
    L_0x0072:
        r4 = "Broadcast sticky: ";
    L_0x0075:
        r4 = r7.append(r4);
        r0 = r28;
        r4 = r4.append(r0);
        r7 = " ordered=";
        r4 = r4.append(r7);
        r0 = r125;
        r4 = r4.append(r0);
        r7 = " userid=";
        r4 = r4.append(r7);
        r0 = r129;
        r4 = r4.append(r0);
        r7 = " resultTo ";
        r4 = r4.append(r7);
        r0 = r118;
        r4 = r4.append(r0);
        r4 = r4.toString();
        android.util.Slog.v(r6, r4);
    L_0x00ad:
        r4 = com.android.server.am.ActivityManagerDebugConfig.DEBUG_BROADCAST;
        if (r4 == 0) goto L_0x00d9;
    L_0x00b1:
        r4 = TAG;
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r7 = "broadcastIntentLocked callingPid: ";
        r6 = r6.append(r7);
        r0 = r127;
        r6 = r6.append(r0);
        r7 = " callingUid=";
        r6 = r6.append(r7);
        r0 = r128;
        r6 = r6.append(r0);
        r6 = r6.toString();
        android.util.Slog.v(r4, r6);
    L_0x00d9:
        if (r118 == 0) goto L_0x0101;
    L_0x00db:
        r4 = r125 ^ 1;
        if (r4 == 0) goto L_0x0101;
    L_0x00df:
        r4 = TAG;
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r7 = "Broadcast ";
        r6 = r6.append(r7);
        r0 = r28;
        r6 = r6.append(r0);
        r7 = " not ordered but result callback requested!";
        r6 = r6.append(r7);
        r6 = r6.toString();
        android.util.Slog.w(r4, r6);
    L_0x0101:
        r0 = r113;
        r4 = r0.mUserController;
        r10 = "broadcast";
        r8 = 1;
        r9 = 0;
        r5 = r127;
        r6 = r128;
        r7 = r129;
        r11 = r115;
        r129 = r4.handleIncomingUser(r5, r6, r7, r8, r9, r10, r11);
        if (r83 == 0) goto L_0x0133;
    L_0x0118:
        r4 = TAG;
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r7 = "isBootCompleteBrodcast, userId after incoming:";
        r6 = r6.append(r7);
        r0 = r129;
        r6 = r6.append(r0);
        r6 = r6.toString();
        android.util.Slog.d(r4, r6);
    L_0x0133:
        r72 = r28.getAction();
        r99 = 0;
        if (r72 == 0) goto L_0x018c;
    L_0x013b:
        r4 = com.android.server.am.OppoMultiAppManagerUtil.getInstance();
        r6 = android.os.UserHandle.getUserId(r128);
        r0 = r115;
        r4 = r4.isMultiApp(r6, r0);
        if (r4 == 0) goto L_0x018c;
    L_0x014b:
        r4 = "com.android.launcher.action.INSTALL_SHORTCUT";
        r0 = r72;
        r4 = r0.equals(r4);
        if (r4 != 0) goto L_0x0161;
    L_0x0156:
        r4 = "com.android.launcher.action.UNINSTALL_SHORTCUT";
        r0 = r72;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x018c;
    L_0x0161:
        r4 = TAG;
        r6 = "multi app: broadcastIntentLocked: multi app is creating shortCut. ";
        android.util.Slog.d(r4, r6);
        r0 = r113;
        r4 = r0.mUserController;
        r129 = r4.getCurrentUserIdLocked();
        r4 = r28.getExtras();
        if (r4 == 0) goto L_0x0182;
    L_0x0177:
        r4 = "android.intent.extra.shortcut.INTENT";
        r0 = r28;
        r99 = r0.getParcelableExtra(r4);
        r99 = (android.content.Intent) r99;
    L_0x0182:
        if (r99 == 0) goto L_0x018c;
    L_0x0184:
        r4 = "com.multiple.launcher";
        r0 = r99;
        r0.addCategory(r4);
    L_0x018c:
        r4 = -1;
        r0 = r129;
        if (r0 == r4) goto L_0x01f4;
    L_0x0191:
        r0 = r113;
        r4 = r0.mUserController;
        r6 = 0;
        r0 = r129;
        r4 = r4.isUserRunningLocked(r0, r6);
        r4 = r4 ^ 1;
        if (r4 == 0) goto L_0x01f4;
    L_0x01a0:
        r4 = 1000; // 0x3e8 float:1.401E-42 double:4.94E-321;
        r0 = r128;
        if (r0 != r4) goto L_0x01af;
    L_0x01a6:
        r4 = r28.getFlags();
        r6 = 33554432; // 0x2000000 float:9.403955E-38 double:1.6578092E-316;
        r4 = r4 & r6;
        if (r4 != 0) goto L_0x01f4;
    L_0x01af:
        r4 = "android.intent.action.ACTION_SHUTDOWN";
        r6 = r28.getAction();
        r4 = r4.equals(r6);
        r4 = r4 ^ 1;
        if (r4 == 0) goto L_0x01f4;
    L_0x01be:
        r4 = TAG;
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r7 = "Skipping broadcast of ";
        r6 = r6.append(r7);
        r0 = r28;
        r6 = r6.append(r0);
        r7 = ": user ";
        r6 = r6.append(r7);
        r0 = r129;
        r6 = r6.append(r0);
        r7 = " is stopped";
        r6 = r6.append(r7);
        r6 = r6.toString();
        android.util.Slog.w(r4, r6);
        r4 = -2;
        return r4;
    L_0x01ef:
        r4 = "Broadcast: ";
        goto L_0x0075;
    L_0x01f4:
        r37 = 0;
        if (r124 == 0) goto L_0x0283;
    L_0x01f8:
        r37 = new android.app.BroadcastOptions;
        r0 = r37;
        r1 = r124;
        r0.<init>(r1);
        r6 = r37.getTemporaryAppWhitelistDuration();
        r8 = 0;
        r4 = (r6 > r8 ? 1 : (r6 == r8 ? 0 : -1));
        if (r4 <= 0) goto L_0x0283;
    L_0x020b:
        r5 = "android.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST";
        r6 = android.os.Binder.getCallingPid();
        r7 = android.os.Binder.getCallingUid();
        r8 = -1;
        r9 = 1;
        r4 = r113;
        r4 = r4.checkComponentPermission(r5, r6, r7, r8, r9);
        if (r4 == 0) goto L_0x0283;
    L_0x0220:
        r4 = new java.lang.StringBuilder;
        r4.<init>();
        r6 = "Permission Denial: ";
        r4 = r4.append(r6);
        r6 = r28.getAction();
        r4 = r4.append(r6);
        r6 = " broadcast from ";
        r4 = r4.append(r6);
        r0 = r115;
        r4 = r4.append(r0);
        r6 = " (pid=";
        r4 = r4.append(r6);
        r0 = r127;
        r4 = r4.append(r0);
        r6 = ", uid=";
        r4 = r4.append(r6);
        r0 = r128;
        r4 = r4.append(r0);
        r6 = ")";
        r4 = r4.append(r6);
        r6 = " requires ";
        r4 = r4.append(r6);
        r6 = "android.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST";
        r4 = r4.append(r6);
        r89 = r4.toString();
        r4 = TAG;
        r0 = r89;
        android.util.Slog.w(r4, r0);
        r4 = new java.lang.SecurityException;
        r0 = r89;
        r4.<init>(r0);
        throw r4;
    L_0x0283:
        r71 = r28.getAction();
        r4 = android.app.AppGlobals.getPackageManager();	 Catch:{ RemoteException -> 0x02e3 }
        r0 = r71;	 Catch:{ RemoteException -> 0x02e3 }
        r24 = r4.isProtectedBroadcast(r0);	 Catch:{ RemoteException -> 0x02e3 }
        r4 = android.os.UserHandle.getAppId(r128);
        switch(r4) {
            case 0: goto L_0x02f0;
            case 1000: goto L_0x02f0;
            case 1001: goto L_0x02f0;
            case 1002: goto L_0x02f0;
            case 1027: goto L_0x02f0;
            default: goto L_0x0298;
        };
    L_0x0298:
        if (r114 == 0) goto L_0x02f3;
    L_0x029a:
        r0 = r114;
        r0 = r0.persistent;
        r84 = r0;
    L_0x02a0:
        if (r84 != 0) goto L_0x039c;
    L_0x02a2:
        if (r24 == 0) goto L_0x02f6;
    L_0x02a4:
        r4 = new java.lang.StringBuilder;
        r4.<init>();
        r6 = "Permission Denial: not allowed to send broadcast ";
        r4 = r4.append(r6);
        r0 = r71;
        r4 = r4.append(r0);
        r6 = " from pid=";
        r4 = r4.append(r6);
        r0 = r127;
        r4 = r4.append(r0);
        r6 = ", uid=";
        r4 = r4.append(r6);
        r0 = r128;
        r4 = r4.append(r0);
        r89 = r4.toString();
        r4 = TAG;
        r0 = r89;
        android.util.Slog.w(r4, r0);
        r4 = new java.lang.SecurityException;
        r0 = r89;
        r4.<init>(r0);
        throw r4;
    L_0x02e3:
        r79 = move-exception;
        r4 = TAG;
        r6 = "Remote exception";
        r0 = r79;
        android.util.Slog.w(r4, r6, r0);
        r4 = 0;
        return r4;
    L_0x02f0:
        r84 = 1;
        goto L_0x02a0;
    L_0x02f3:
        r84 = 0;
        goto L_0x02a0;
    L_0x02f6:
        r4 = "android.appwidget.action.APPWIDGET_CONFIGURE";
        r0 = r71;
        r4 = r4.equals(r0);
        if (r4 != 0) goto L_0x030c;
    L_0x0301:
        r4 = "android.appwidget.action.APPWIDGET_UPDATE";
        r0 = r71;
        r4 = r4.equals(r0);
        if (r4 == 0) goto L_0x039c;
    L_0x030c:
        if (r115 != 0) goto L_0x033a;
    L_0x030e:
        r4 = new java.lang.StringBuilder;
        r4.<init>();
        r6 = "Permission Denial: not allowed to send broadcast ";
        r4 = r4.append(r6);
        r0 = r71;
        r4 = r4.append(r0);
        r6 = " from unknown caller.";
        r4 = r4.append(r6);
        r89 = r4.toString();
        r4 = TAG;
        r0 = r89;
        android.util.Slog.w(r4, r0);
        r4 = new java.lang.SecurityException;
        r0 = r89;
        r4.<init>(r0);
        throw r4;
    L_0x033a:
        r4 = r28.getComponent();
        if (r4 == 0) goto L_0x0395;
    L_0x0340:
        r4 = r28.getComponent();
        r4 = r4.getPackageName();
        r0 = r115;
        r4 = r4.equals(r0);
        if (r4 != 0) goto L_0x039c;
    L_0x0350:
        r4 = new java.lang.StringBuilder;
        r4.<init>();
        r6 = "Permission Denial: not allowed to send broadcast ";
        r4 = r4.append(r6);
        r0 = r71;
        r4 = r4.append(r0);
        r6 = " to ";
        r4 = r4.append(r6);
        r6 = r28.getComponent();
        r6 = r6.getPackageName();
        r4 = r4.append(r6);
        r6 = " from ";
        r4 = r4.append(r6);
        r0 = r115;
        r4 = r4.append(r0);
        r89 = r4.toString();
        r4 = TAG;
        r0 = r89;
        android.util.Slog.w(r4, r0);
        r4 = new java.lang.SecurityException;
        r0 = r89;
        r4.<init>(r0);
        throw r4;
    L_0x0395:
        r0 = r28;
        r1 = r115;
        r0.setPackage(r1);
    L_0x039c:
        if (r71 == 0) goto L_0x0571;
    L_0x039e:
        r4 = r113.getBackgroundLaunchBroadcasts();
        r0 = r71;
        r4 = r4.contains(r0);
        if (r4 == 0) goto L_0x03d7;
    L_0x03aa:
        r4 = com.android.server.am.ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK;
        if (r4 == 0) goto L_0x03d0;
    L_0x03ae:
        r4 = TAG;
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r7 = "Broadcast action ";
        r6 = r6.append(r7);
        r0 = r71;
        r6 = r6.append(r0);
        r7 = " forcing include-background";
        r6 = r6.append(r7);
        r6 = r6.toString();
        android.util.Slog.i(r4, r6);
    L_0x03d0:
        r4 = 16777216; // 0x1000000 float:2.3509887E-38 double:8.289046E-317;
        r0 = r28;
        r0.addFlags(r4);
    L_0x03d7:
        r4 = "android.intent.action.UID_REMOVED";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x0456;
    L_0x03e2:
        r5 = "android.permission.BROADCAST_PACKAGE_REMOVED";
        r8 = -1;
        r9 = 1;
        r4 = r113;
        r6 = r127;
        r7 = r128;
        r4 = r4.checkComponentPermission(r5, r6, r7, r8, r9);
        if (r4 == 0) goto L_0x06fe;
    L_0x03f3:
        r4 = new java.lang.StringBuilder;
        r4.<init>();
        r6 = "Permission Denial: ";
        r4 = r4.append(r6);
        r6 = r28.getAction();
        r4 = r4.append(r6);
        r6 = " broadcast from ";
        r4 = r4.append(r6);
        r0 = r115;
        r4 = r4.append(r0);
        r6 = " (pid=";
        r4 = r4.append(r6);
        r0 = r127;
        r4 = r4.append(r0);
        r6 = ", uid=";
        r4 = r4.append(r6);
        r0 = r128;
        r4 = r4.append(r0);
        r6 = ")";
        r4 = r4.append(r6);
        r6 = " requires ";
        r4 = r4.append(r6);
        r6 = "android.permission.BROADCAST_PACKAGE_REMOVED";
        r4 = r4.append(r6);
        r89 = r4.toString();
        r4 = TAG;
        r0 = r89;
        android.util.Slog.w(r4, r0);
        r4 = new java.lang.SecurityException;
        r0 = r89;
        r4.<init>(r0);
        throw r4;
    L_0x0456:
        r4 = "android.intent.action.PACKAGE_REMOVED";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 != 0) goto L_0x03e2;
    L_0x0461:
        r4 = "android.intent.action.PACKAGE_CHANGED";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 != 0) goto L_0x03e2;
    L_0x046c:
        r4 = "android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 != 0) goto L_0x03e2;
    L_0x0477:
        r4 = "android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 != 0) goto L_0x03e2;
    L_0x0482:
        r4 = "oppo.intent.action.MULTI_APP_PACKAGE_REMOVED";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 != 0) goto L_0x03e2;
    L_0x048d:
        r4 = "android.intent.action.PACKAGES_SUSPENDED";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 != 0) goto L_0x03e2;
    L_0x0498:
        r4 = "android.intent.action.PACKAGES_UNSUSPENDED";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 != 0) goto L_0x03e2;
    L_0x04a3:
        r4 = "android.intent.action.PACKAGE_REPLACED";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x04f1;
    L_0x04ae:
        r78 = r28.getData();
        if (r78 == 0) goto L_0x0532;
    L_0x04b4:
        r5 = r78.getSchemeSpecificPart();
        if (r5 == 0) goto L_0x0532;
    L_0x04ba:
        r70 = 0;
        r4 = android.app.AppGlobals.getPackageManager();	 Catch:{ RemoteException -> 0x0f4a }
        r6 = 0;	 Catch:{ RemoteException -> 0x0f4a }
        r0 = r129;	 Catch:{ RemoteException -> 0x0f4a }
        r70 = r4.getApplicationInfo(r5, r6, r0);	 Catch:{ RemoteException -> 0x0f4a }
    L_0x04c7:
        if (r70 != 0) goto L_0x09a3;
    L_0x04c9:
        r4 = TAG;
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r7 = "Dropping ACTION_PACKAGE_REPLACED for non-existent pkg: ssp=";
        r6 = r6.append(r7);
        r6 = r6.append(r5);
        r7 = " data=";
        r6 = r6.append(r7);
        r0 = r78;
        r6 = r6.append(r0);
        r6 = r6.toString();
        android.util.Slog.w(r4, r6);
        r4 = 0;
        return r4;
    L_0x04f1:
        r4 = "android.intent.action.PACKAGE_ADDED";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x05c2;
    L_0x04fc:
        r78 = r28.getData();
        if (r78 == 0) goto L_0x0532;
    L_0x0502:
        r5 = r78.getSchemeSpecificPart();
        if (r5 == 0) goto L_0x0532;
    L_0x0508:
        r4 = "android.intent.extra.REPLACING";
        r6 = 0;
        r0 = r28;
        r98 = r0.getBooleanExtra(r4, r6);
        r0 = r113;
        r4 = r0.mCompatModePackages;
        r0 = r98;
        r4.handlePackageAddedLocked(r5, r0);
        r4 = android.app.AppGlobals.getPackageManager();	 Catch:{ RemoteException -> 0x0f47 }
        r6 = 0;	 Catch:{ RemoteException -> 0x0f47 }
        r7 = 0;	 Catch:{ RemoteException -> 0x0f47 }
        r73 = r4.getApplicationInfo(r5, r6, r7);	 Catch:{ RemoteException -> 0x0f47 }
        r0 = r113;	 Catch:{ RemoteException -> 0x0f47 }
        r6 = r0.mBatteryStatsService;	 Catch:{ RemoteException -> 0x0f47 }
        if (r73 == 0) goto L_0x09bc;	 Catch:{ RemoteException -> 0x0f47 }
    L_0x052b:
        r0 = r73;	 Catch:{ RemoteException -> 0x0f47 }
        r4 = r0.versionCode;	 Catch:{ RemoteException -> 0x0f47 }
    L_0x052f:
        r6.notePackageInstalled(r5, r4);	 Catch:{ RemoteException -> 0x0f47 }
    L_0x0532:
        r4 = "android.intent.action.PACKAGE_ADDED";
        r0 = r71;
        r4 = r4.equals(r0);
        if (r4 != 0) goto L_0x0553;
    L_0x053d:
        r4 = "android.intent.action.PACKAGE_REMOVED";
        r0 = r71;
        r4 = r4.equals(r0);
        if (r4 != 0) goto L_0x0553;
    L_0x0548:
        r4 = "android.intent.action.PACKAGE_REPLACED";
        r0 = r71;
        r4 = r4.equals(r0);
        if (r4 == 0) goto L_0x0571;
    L_0x0553:
        r0 = r113;
        r1 = r28;
        r108 = r0.getUidFromIntent(r1);
        r4 = -1;
        r0 = r108;
        if (r0 == r4) goto L_0x0571;
    L_0x0560:
        r0 = r113;
        r4 = r0.mActiveUids;
        r0 = r108;
        r109 = r4.get(r0);
        r109 = (com.android.server.am.UidRecord) r109;
        if (r109 == 0) goto L_0x0571;
    L_0x056e:
        r109.updateHasInternetPermission();
    L_0x0571:
        if (r126 == 0) goto L_0x0aef;
    L_0x0573:
        r4 = "android.permission.BROADCAST_STICKY";
        r0 = r113;
        r1 = r127;
        r2 = r128;
        r4 = r0.checkPermission(r4, r1, r2);
        if (r4 == 0) goto L_0x09c2;
    L_0x0582:
        r4 = new java.lang.StringBuilder;
        r4.<init>();
        r6 = "Permission Denial: broadcastIntent() requesting a sticky broadcast from pid=";
        r4 = r4.append(r6);
        r0 = r127;
        r4 = r4.append(r0);
        r6 = ", uid=";
        r4 = r4.append(r6);
        r0 = r128;
        r4 = r4.append(r0);
        r6 = " requires ";
        r4 = r4.append(r6);
        r6 = "android.permission.BROADCAST_STICKY";
        r4 = r4.append(r6);
        r89 = r4.toString();
        r4 = TAG;
        r0 = r89;
        android.util.Slog.w(r4, r0);
        r4 = new java.lang.SecurityException;
        r0 = r89;
        r4.<init>(r0);
        throw r4;
    L_0x05c2:
        r4 = "android.intent.action.PACKAGE_DATA_CLEARED";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x0602;
    L_0x05cd:
        r78 = r28.getData();
        if (r78 == 0) goto L_0x0532;
    L_0x05d3:
        r5 = r78.getSchemeSpecificPart();
        if (r5 == 0) goto L_0x0532;
    L_0x05d9:
        r0 = r113;
        r4 = r0.mUnsupportedDisplaySizeDialog;
        if (r4 == 0) goto L_0x05f9;
    L_0x05df:
        r0 = r113;
        r4 = r0.mUnsupportedDisplaySizeDialog;
        r4 = r4.getPackageName();
        r4 = r5.equals(r4);
        if (r4 == 0) goto L_0x05f9;
    L_0x05ed:
        r0 = r113;
        r4 = r0.mUnsupportedDisplaySizeDialog;
        r4.dismiss();
        r4 = 0;
        r0 = r113;
        r0.mUnsupportedDisplaySizeDialog = r4;
    L_0x05f9:
        r0 = r113;
        r4 = r0.mCompatModePackages;
        r4.handlePackageDataClearedLocked(r5);
        goto L_0x0532;
    L_0x0602:
        r4 = "android.intent.action.TIMEZONE_CHANGED";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x0618;
    L_0x060d:
        r0 = r113;
        r4 = r0.mHandler;
        r6 = 13;
        r4.sendEmptyMessage(r6);
        goto L_0x0532;
    L_0x0618:
        r4 = "android.intent.action.TIME_SET";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x0659;
    L_0x0623:
        r67 = -1;
        r4 = "android.intent.extra.TIME_PREF_24_HOUR_FORMAT";
        r6 = -1;
        r0 = r28;
        r107 = r0.getIntExtra(r4, r6);
        r4 = -1;
        r0 = r107;
        if (r0 == r4) goto L_0x064a;
    L_0x0634:
        r0 = r113;
        r4 = r0.mHandler;
        r6 = 41;
        r7 = 0;
        r0 = r107;
        r110 = r4.obtainMessage(r6, r0, r7);
        r0 = r113;
        r4 = r0.mHandler;
        r0 = r110;
        r4.sendMessage(r0);
    L_0x064a:
        r0 = r113;
        r4 = r0.mBatteryStatsService;
        r103 = r4.getActiveStatistics();
        monitor-enter(r103);
        r103.noteCurrentTimeChangedLocked();	 Catch:{ all -> 0x09bf }
        monitor-exit(r103);
        goto L_0x0532;
    L_0x0659:
        r4 = "android.intent.action.CLEAR_DNS_CACHE";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x066f;
    L_0x0664:
        r0 = r113;
        r4 = r0.mHandler;
        r6 = 28;
        r4.sendEmptyMessage(r6);
        goto L_0x0532;
    L_0x066f:
        r4 = "android.intent.action.PROXY_CHANGE";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x069a;
    L_0x067a:
        r4 = "android.intent.extra.PROXY_INFO";
        r0 = r28;
        r92 = r0.getParcelableExtra(r4);
        r92 = (android.net.ProxyInfo) r92;
        r0 = r113;
        r4 = r0.mHandler;
        r0 = r113;
        r6 = r0.mHandler;
        r7 = 29;
        r0 = r92;
        r6 = r6.obtainMessage(r7, r0);
        r4.sendMessage(r6);
        goto L_0x0532;
    L_0x069a:
        r4 = "android.hardware.action.NEW_PICTURE";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x06ae;
    L_0x06a5:
        r4 = 1073741824; // 0x40000000 float:2.0 double:5.304989477E-315;
        r0 = r28;
        r0.addFlags(r4);
        goto L_0x0532;
    L_0x06ae:
        r4 = "android.hardware.action.NEW_VIDEO";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 != 0) goto L_0x06a5;
    L_0x06b9:
        r4 = "android.security.action.TRUST_STORE_CHANGED";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x06cf;
    L_0x06c4:
        r0 = r113;
        r4 = r0.mHandler;
        r6 = 63;
        r4.sendEmptyMessage(r6);
        goto L_0x0532;
    L_0x06cf:
        r4 = "com.android.launcher.action.INSTALL_SHORTCUT";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x0532;
    L_0x06da:
        r4 = TAG;
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r7 = "Broadcast ";
        r6 = r6.append(r7);
        r0 = r71;
        r6 = r6.append(r0);
        r7 = " no longer supported. It will not be delivered.";
        r6 = r6.append(r7);
        r6 = r6.toString();
        android.util.Log.w(r4, r6);
        r4 = 0;
        return r4;
    L_0x06fe:
        r4 = "android.intent.action.UID_REMOVED";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x0727;
    L_0x0709:
        r0 = r113;
        r1 = r28;
        r108 = r0.getUidFromIntent(r1);
        if (r108 < 0) goto L_0x0532;
    L_0x0713:
        r0 = r113;
        r4 = r0.mBatteryStatsService;
        r0 = r108;
        r4.removeUid(r0);
        r0 = r113;
        r4 = r0.mAppOpsService;
        r0 = r108;
        r4.uidRemoved(r0);
        goto L_0x0532;
    L_0x0727:
        r4 = "android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x0760;
    L_0x0732:
        r4 = "android.intent.extra.changed_package_list";
        r0 = r28;
        r88 = r0.getStringArrayExtra(r4);
        if (r88 == 0) goto L_0x0532;
    L_0x073d:
        r0 = r88;
        r4 = r0.length;
        if (r4 <= 0) goto L_0x0532;
    L_0x0742:
        r80 = 0;
    L_0x0744:
        r0 = r88;
        r4 = r0.length;
        r0 = r80;
        if (r0 >= r4) goto L_0x0917;
    L_0x074b:
        r5 = r88[r80];
        r13 = "storage unmount";
        r6 = -1;
        r7 = 0;
        r8 = 1;
        r9 = 1;
        r10 = 0;
        r11 = 0;
        r4 = r113;
        r12 = r129;
        r4.forceStopPackageLocked(r5, r6, r7, r8, r9, r10, r11, r12, r13);
        r80 = r80 + 1;
        goto L_0x0744;
    L_0x0760:
        r4 = "android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x0775;
    L_0x076b:
        r0 = r113;
        r4 = r0.mRecentTasks;
        r6 = -1;
        r4.cleanupLocked(r6);
        goto L_0x0532;
    L_0x0775:
        r4 = "android.intent.action.PACKAGE_REMOVED";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x083f;
    L_0x0780:
        r78 = r28.getData();
        if (r78 == 0) goto L_0x0532;
    L_0x0786:
        r5 = r78.getSchemeSpecificPart();
        if (r5 == 0) goto L_0x0532;
    L_0x078c:
        r4 = "android.intent.action.PACKAGE_REMOVED";
        r0 = r71;
        r95 = r4.equals(r0);
        r4 = "android.intent.extra.REPLACING";
        r6 = 0;
        r0 = r28;
        r98 = r0.getBooleanExtra(r4, r6);
        r4 = "android.intent.extra.DONT_KILL_APP";
        r6 = 0;
        r0 = r28;
        r4 = r0.getBooleanExtra(r4, r6);
        r86 = r4 ^ 1;
        if (r95 == 0) goto L_0x092b;
    L_0x07ad:
        r11 = r98 ^ 1;
    L_0x07af:
        if (r95 == 0) goto L_0x0937;
    L_0x07b1:
        if (r86 == 0) goto L_0x07d1;
    L_0x07b3:
        r4 = "android.intent.extra.UID";
        r6 = -1;
        r0 = r28;
        r4 = r0.getIntExtra(r4, r6);
        r6 = android.os.UserHandle.getAppId(r4);
        if (r95 == 0) goto L_0x092e;
    L_0x07c3:
        r13 = "pkg removed";
    L_0x07c6:
        r7 = 0;
        r8 = 1;
        r9 = 1;
        r10 = 0;
        r4 = r113;
        r12 = r129;
        r4.forceStopPackageLocked(r5, r6, r7, r8, r9, r10, r11, r12, r13);
    L_0x07d1:
        if (r86 == 0) goto L_0x0933;
    L_0x07d3:
        r75 = 0;
    L_0x07d5:
        r4 = 1;
        r4 = new java.lang.String[r4];
        r6 = 0;
        r4[r6] = r5;
        r0 = r113;
        r1 = r75;
        r2 = r129;
        r0.sendPackageBroadcastLocked(r1, r4, r2);
        if (r11 == 0) goto L_0x0532;
    L_0x07e6:
        r0 = r113;
        r4 = r0.mAppOpsService;
        r6 = "android.intent.extra.UID";
        r7 = -1;
        r0 = r28;
        r6 = r0.getIntExtra(r6, r7);
        r4.packageRemoved(r6, r5);
        r4 = 1;
        r0 = r113;
        r1 = r129;
        r0.removeUriPermissionsForPackageLocked(r5, r1, r4);
        r0 = r113;
        r1 = r129;
        r0.removeTasksByPackageNameLocked(r5, r1);
        r0 = r113;
        r4 = r0.mServices;
        r0 = r129;
        r4.forceStopPackageLocked(r5, r0);
        r0 = r113;
        r4 = r0.mUnsupportedDisplaySizeDialog;
        if (r4 == 0) goto L_0x082f;
    L_0x0815:
        r0 = r113;
        r4 = r0.mUnsupportedDisplaySizeDialog;
        r4 = r4.getPackageName();
        r4 = r5.equals(r4);
        if (r4 == 0) goto L_0x082f;
    L_0x0823:
        r0 = r113;
        r4 = r0.mUnsupportedDisplaySizeDialog;
        r4.dismiss();
        r4 = 0;
        r0 = r113;
        r0.mUnsupportedDisplaySizeDialog = r4;
    L_0x082f:
        r0 = r113;
        r4 = r0.mCompatModePackages;
        r4.handlePackageUninstalledLocked(r5);
        r0 = r113;
        r4 = r0.mBatteryStatsService;
        r4.notePackageUninstalled(r5);
        goto L_0x0532;
    L_0x083f:
        r4 = "android.intent.action.PACKAGE_CHANGED";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 != 0) goto L_0x0780;
    L_0x084a:
        r4 = "oppo.intent.action.MULTI_APP_PACKAGE_REMOVED";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x08ca;
    L_0x0855:
        r4 = DEBUG_COLOROS_AMS;
        if (r4 == 0) goto L_0x0861;
    L_0x0859:
        r4 = TAG;
        r6 = "multi app: AMS dealing with multi app removed.";
        android.util.Slog.d(r4, r6);
    L_0x0861:
        r111 = r28.getData();
        if (r111 == 0) goto L_0x0532;
    L_0x0867:
        r13 = r111.getSchemeSpecificPart();
        if (r13 == 0) goto L_0x0532;
    L_0x086d:
        r4 = "oppo.intent.action.MULTI_APP_PACKAGE_REMOVED";
        r0 = r71;
        r95 = r4.equals(r0);
        if (r95 == 0) goto L_0x0981;
    L_0x0878:
        r4 = "android.intent.extra.REPLACING";
        r6 = 0;
        r0 = r28;
        r4 = r0.getBooleanExtra(r4, r6);
        r11 = r4 ^ 1;
    L_0x0884:
        r4 = "android.intent.extra.DONT_KILL_APP";
        r6 = 0;
        r0 = r28;
        r4 = r0.getBooleanExtra(r4, r6);
        r86 = r4 ^ 1;
        if (r86 == 0) goto L_0x08b5;
    L_0x0892:
        r4 = "android.intent.extra.UID";
        r6 = -1;
        r0 = r28;
        r4 = r0.getIntExtra(r4, r6);
        r14 = android.os.UserHandle.getAppId(r4);
        if (r95 == 0) goto L_0x0984;
    L_0x08a2:
        r21 = "pkg removed";
    L_0x08a5:
        r15 = 0;
        r16 = 1;
        r17 = 1;
        r18 = 0;
        r20 = 999; // 0x3e7 float:1.4E-42 double:4.936E-321;
        r12 = r113;
        r19 = r11;
        r12.forceStopPackageLocked(r13, r14, r15, r16, r17, r18, r19, r20, r21);
    L_0x08b5:
        if (r95 == 0) goto L_0x0989;
    L_0x08b7:
        if (r11 == 0) goto L_0x0532;
    L_0x08b9:
        r4 = 999; // 0x3e7 float:1.4E-42 double:4.936E-321;
        r6 = 1;
        r0 = r113;
        r0.removeUriPermissionsForPackageLocked(r13, r4, r6);
        r4 = 999; // 0x3e7 float:1.4E-42 double:4.936E-321;
        r0 = r113;
        r0.removeTasksByPackageNameLocked(r13, r4);
        goto L_0x0532;
    L_0x08ca:
        r4 = "android.intent.action.PACKAGES_SUSPENDED";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x090b;
    L_0x08d5:
        r4 = "android.intent.action.PACKAGES_SUSPENDED";
        r6 = r28.getAction();
        r106 = r4.equals(r6);
        r4 = "android.intent.extra.changed_package_list";
        r0 = r28;
        r91 = r0.getStringArrayExtra(r4);
        r4 = "android.intent.extra.user_handle";
        r6 = -10000; // 0xffffffffffffd8f0 float:NaN double:NaN;
        r0 = r28;
        r112 = r0.getIntExtra(r4, r6);
        monitor-enter(r113);
        boostPriorityForLockedSection();	 Catch:{ all -> 0x099d }
        r0 = r113;	 Catch:{ all -> 0x099d }
        r4 = r0.mRecentTasks;	 Catch:{ all -> 0x099d }
        r0 = r91;	 Catch:{ all -> 0x099d }
        r1 = r106;	 Catch:{ all -> 0x099d }
        r2 = r112;	 Catch:{ all -> 0x099d }
        r4.onPackagesSuspendedChanged(r0, r1, r2);	 Catch:{ all -> 0x099d }
        monitor-exit(r113);
        resetPriorityAfterLockedSection();
        goto L_0x0532;
    L_0x090b:
        r4 = "android.intent.action.PACKAGES_UNSUSPENDED";
        r0 = r71;
        r4 = r0.equals(r4);
        if (r4 == 0) goto L_0x0532;
    L_0x0916:
        goto L_0x08d5;
    L_0x0917:
        r0 = r113;
        r4 = r0.mRecentTasks;
        r6 = -1;
        r4.cleanupLocked(r6);
        r4 = 1;
        r0 = r113;
        r1 = r88;
        r2 = r129;
        r0.sendPackageBroadcastLocked(r4, r1, r2);
        goto L_0x0532;
    L_0x092b:
        r11 = 0;
        goto L_0x07af;
    L_0x092e:
        r13 = "pkg changed";
        goto L_0x07c6;
    L_0x0933:
        r75 = 2;
        goto L_0x07d5;
    L_0x0937:
        if (r86 == 0) goto L_0x096d;
    L_0x0939:
        r4 = "android.intent.extra.UID";
        r6 = -1;
        r0 = r28;
        r4 = r0.getIntExtra(r4, r6);
        r14 = android.os.UserHandle.getAppId(r4);
        r4 = new java.lang.StringBuilder;
        r4.<init>();
        r6 = "change ";
        r4 = r4.append(r6);
        r4 = r4.append(r5);
        r21 = r4.toString();
        r16 = -10000; // 0xffffffffffffd8f0 float:NaN double:NaN;
        r17 = 0;
        r18 = 1;
        r19 = 1;
        r20 = 0;
        r12 = r113;
        r13 = r5;
        r15 = r129;
        r12.killPackageProcessesLocked(r13, r14, r15, r16, r17, r18, r19, r20, r21);
    L_0x096d:
        r4 = "android.intent.extra.changed_component_name_list";
        r0 = r28;
        r4 = r0.getStringArrayExtra(r4);
        r0 = r113;
        r1 = r129;
        r2 = r86;
        r0.cleanupDisabledPackageComponentsLocked(r5, r1, r2, r4);
        goto L_0x0532;
    L_0x0981:
        r11 = 0;
        goto L_0x0884;
    L_0x0984:
        r21 = "pkg changed";
        goto L_0x08a5;
    L_0x0989:
        r4 = "android.intent.extra.changed_component_name_list";
        r0 = r28;
        r4 = r0.getStringArrayExtra(r4);
        r6 = 999; // 0x3e7 float:1.4E-42 double:4.936E-321;
        r0 = r113;
        r1 = r86;
        r0.cleanupDisabledPackageComponentsLocked(r13, r6, r1, r4);
        goto L_0x0532;
    L_0x099d:
        r4 = move-exception;
        monitor-exit(r113);
        resetPriorityAfterLockedSection();
        throw r4;
    L_0x09a3:
        r0 = r113;
        r4 = r0.mStackSupervisor;
        r0 = r70;
        r4.updateActivityApplicationInfoLocked(r0);
        r4 = 1;
        r4 = new java.lang.String[r4];
        r6 = 0;
        r4[r6] = r5;
        r6 = 3;
        r0 = r113;
        r1 = r129;
        r0.sendPackageBroadcastLocked(r6, r4, r1);
        goto L_0x0532;
    L_0x09bc:
        r4 = 0;
        goto L_0x052f;
    L_0x09bf:
        r4 = move-exception;
        monitor-exit(r103);
        throw r4;
    L_0x09c2:
        if (r122 == 0) goto L_0x09f5;
    L_0x09c4:
        r0 = r122;
        r4 = r0.length;
        if (r4 <= 0) goto L_0x09f5;
    L_0x09c9:
        r4 = TAG;
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r7 = "Can't broadcast sticky intent ";
        r6 = r6.append(r7);
        r0 = r28;
        r6 = r6.append(r0);
        r7 = " and enforce permissions ";
        r6 = r6.append(r7);
        r7 = java.util.Arrays.toString(r122);
        r6 = r6.append(r7);
        r6 = r6.toString();
        android.util.Slog.w(r4, r6);
        r4 = -1;
        return r4;
    L_0x09f5:
        r4 = r28.getComponent();
        if (r4 == 0) goto L_0x0a04;
    L_0x09fb:
        r4 = new java.lang.SecurityException;
        r6 = "Sticky broadcasts can't target a specific component";
        r4.<init>(r6);
        throw r4;
    L_0x0a04:
        r4 = -1;
        r0 = r129;
        if (r0 == r4) goto L_0x0a75;
    L_0x0a09:
        r0 = r113;
        r4 = r0.mStickyBroadcasts;
        r6 = -1;
        r104 = r4.get(r6);
        r104 = (android.util.ArrayMap) r104;
        if (r104 == 0) goto L_0x0a75;
    L_0x0a16:
        r4 = r28.getAction();
        r0 = r104;
        r87 = r0.get(r4);
        r87 = (java.util.ArrayList) r87;
        if (r87 == 0) goto L_0x0a75;
    L_0x0a24:
        r66 = r87.size();
        r80 = 0;
    L_0x0a2a:
        r0 = r80;
        r1 = r66;
        if (r0 >= r1) goto L_0x0a75;
    L_0x0a30:
        r0 = r87;
        r1 = r80;
        r4 = r0.get(r1);
        r4 = (android.content.Intent) r4;
        r0 = r28;
        r4 = r0.filterEquals(r4);
        if (r4 == 0) goto L_0x0a72;
    L_0x0a42:
        r4 = new java.lang.IllegalArgumentException;
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r7 = "Sticky broadcast ";
        r6 = r6.append(r7);
        r0 = r28;
        r6 = r6.append(r0);
        r7 = " for user ";
        r6 = r6.append(r7);
        r0 = r129;
        r6 = r6.append(r0);
        r7 = " conflicts with existing global broadcast";
        r6 = r6.append(r7);
        r6 = r6.toString();
        r4.<init>(r6);
        throw r4;
    L_0x0a72:
        r80 = r80 + 1;
        goto L_0x0a2a;
    L_0x0a75:
        r0 = r113;
        r4 = r0.mStickyBroadcasts;
        r0 = r129;
        r104 = r4.get(r0);
        r104 = (android.util.ArrayMap) r104;
        if (r104 != 0) goto L_0x0a93;
    L_0x0a83:
        r104 = new android.util.ArrayMap;
        r104.<init>();
        r0 = r113;
        r4 = r0.mStickyBroadcasts;
        r0 = r129;
        r1 = r104;
        r4.put(r0, r1);
    L_0x0a93:
        r4 = r28.getAction();
        r0 = r104;
        r87 = r0.get(r4);
        r87 = (java.util.ArrayList) r87;
        if (r87 != 0) goto L_0x0ab1;
    L_0x0aa1:
        r87 = new java.util.ArrayList;
        r87.<init>();
        r4 = r28.getAction();
        r0 = r104;
        r1 = r87;
        r0.put(r4, r1);
    L_0x0ab1:
        r105 = r87.size();
        r80 = 0;
    L_0x0ab7:
        r0 = r80;
        r1 = r105;
        if (r0 >= r1) goto L_0x0add;
    L_0x0abd:
        r0 = r87;
        r1 = r80;
        r4 = r0.get(r1);
        r4 = (android.content.Intent) r4;
        r0 = r28;
        r4 = r0.filterEquals(r4);
        if (r4 == 0) goto L_0x0b45;
    L_0x0acf:
        r4 = new android.content.Intent;
        r0 = r28;
        r4.<init>(r0);
        r0 = r87;
        r1 = r80;
        r0.set(r1, r4);
    L_0x0add:
        r0 = r80;
        r1 = r105;
        if (r0 < r1) goto L_0x0aef;
    L_0x0ae3:
        r4 = new android.content.Intent;
        r0 = r28;
        r4.<init>(r0);
        r0 = r87;
        r0.add(r4);
    L_0x0aef:
        r4 = -1;
        r0 = r129;
        if (r0 != r4) goto L_0x0b49;
    L_0x0af4:
        r0 = r113;
        r4 = r0.mUserController;
        r18 = r4.getStartedUserArrayLocked();
    L_0x0afc:
        r44 = 0;
        r25 = 0;
        r4 = r28.getFlags();
        r6 = 1073741824; // 0x40000000 float:2.0 double:5.304989477E-315;
        r4 = r4 & r6;
        if (r4 != 0) goto L_0x0f51;
    L_0x0b09:
        r14 = r113;
        r15 = r28;
        r16 = r117;
        r17 = r128;
        r19 = r115;
        r44 = r14.collectReceiverComponents(r15, r16, r17, r18, r19);
        r93 = r44;
    L_0x0b19:
        r4 = r28.getComponent();
        if (r4 != 0) goto L_0x0b7f;
    L_0x0b1f:
        r4 = -1;
        r0 = r129;
        if (r0 != r4) goto L_0x0b70;
    L_0x0b24:
        r4 = 2000; // 0x7d0 float:2.803E-42 double:9.88E-321;
        r0 = r128;
        if (r0 != r4) goto L_0x0b70;
    L_0x0b2a:
        r80 = 0;
    L_0x0b2c:
        r0 = r18;
        r4 = r0.length;
        r0 = r80;
        if (r0 >= r4) goto L_0x0b7f;
    L_0x0b33:
        r0 = r113;
        r4 = r0.mUserController;
        r6 = "no_debugging_features";
        r7 = r18[r80];
        r4 = r4.hasUserRestriction(r6, r7);
        if (r4 == 0) goto L_0x0b52;
    L_0x0b42:
        r80 = r80 + 1;
        goto L_0x0b2c;
    L_0x0b45:
        r80 = r80 + 1;
        goto L_0x0ab7;
    L_0x0b49:
        r4 = 1;
        r0 = new int[r4];
        r18 = r0;
        r4 = 0;
        r18[r4] = r129;
        goto L_0x0afc;
    L_0x0b52:
        r0 = r113;
        r4 = r0.mReceiverResolver;
        r6 = r18[r80];
        r7 = 0;
        r0 = r28;
        r1 = r117;
        r94 = r4.queryIntent(r0, r1, r7, r6);
        if (r25 != 0) goto L_0x0b66;
    L_0x0b63:
        r25 = r94;
        goto L_0x0b42;
    L_0x0b66:
        if (r94 == 0) goto L_0x0b42;
    L_0x0b68:
        r0 = r25;
        r1 = r94;
        r0.addAll(r1);
        goto L_0x0b42;
    L_0x0b70:
        r0 = r113;
        r4 = r0.mReceiverResolver;
        r6 = 0;
        r0 = r28;
        r1 = r117;
        r2 = r129;
        r25 = r4.queryIntent(r0, r1, r6, r2);
    L_0x0b7f:
        r4 = r28.getFlags();
        r6 = 536870912; // 0x20000000 float:1.0842022E-19 double:2.652494739E-315;
        r4 = r4 & r6;
        if (r4 == 0) goto L_0x0cf1;
    L_0x0b88:
        r96 = 1;
    L_0x0b8a:
        r4 = com.android.server.am.ActivityManagerDebugConfig.DEBUG_BROADCAST;
        if (r4 == 0) goto L_0x0bb8;
    L_0x0b8e:
        r4 = TAG_BROADCAST;
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r7 = "Enqueueing broadcast: ";
        r6 = r6.append(r7);
        r7 = r28.getAction();
        r6 = r6.append(r7);
        r7 = " replacePending=";
        r6 = r6.append(r7);
        r0 = r96;
        r6 = r6.append(r0);
        r6 = r6.toString();
        android.util.Slog.v(r4, r6);
    L_0x0bb8:
        if (r25 == 0) goto L_0x0cf5;
    L_0x0bba:
        r68 = r25.size();
    L_0x0bbe:
        if (r125 != 0) goto L_0x0c6d;
    L_0x0bc0:
        if (r68 <= 0) goto L_0x0c6d;
    L_0x0bc2:
        if (r84 == 0) goto L_0x0bd1;
    L_0x0bc4:
        r19 = r113;
        r20 = r28;
        r21 = r114;
        r22 = r115;
        r23 = r128;
        r19.checkBroadcastFromSystem(r20, r21, r22, r23, r24, r25);
    L_0x0bd1:
        r4 = 10000; // 0x2710 float:1.4013E-41 double:4.9407E-320;
        r0 = r128;
        if (r0 < r4) goto L_0x0cf9;
    L_0x0bd7:
        r4 = com.android.server.am.OppoBroadcastManager.getInstance(r113);
        r0 = r28;
        r27 = r4.broadcastQueueForIntent(r0);
    L_0x0be1:
        r26 = new com.android.server.am.BroadcastRecord;
        r45 = 0;
        r29 = r114;
        r30 = r115;
        r31 = r127;
        r32 = r128;
        r34 = r117;
        r35 = r122;
        r36 = r123;
        r38 = r25;
        r39 = r118;
        r40 = r119;
        r41 = r120;
        r42 = r121;
        r43 = r125;
        r44 = r126;
        r46 = r129;
        r26.<init>(r27, r28, r29, r30, r31, r32, r33, r34, r35, r36, r37, r38, r39, r40, r41, r42, r43, r44, r45, r46);
        r4 = com.android.server.am.ActivityManagerDebugConfig.DEBUG_BROADCAST;
        if (r4 == 0) goto L_0x0c25;
    L_0x0c0a:
        r4 = TAG_BROADCAST;
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r7 = "Enqueueing parallel broadcast ";
        r6 = r6.append(r7);
        r0 = r26;
        r6 = r6.append(r0);
        r6 = r6.toString();
        android.util.Slog.v(r4, r6);
    L_0x0c25:
        if (r83 == 0) goto L_0x0c4f;
    L_0x0c27:
        r4 = TAG_BROADCAST;
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r7 = "Enqueueing parallel broadcast ";
        r6 = r6.append(r7);
        r0 = r26;
        r6 = r6.append(r0);
        r7 = ", userId:";
        r6 = r6.append(r7);
        r0 = r129;
        r6 = r6.append(r0);
        r6 = r6.toString();
        android.util.Slog.v(r4, r6);
    L_0x0c4f:
        if (r96 == 0) goto L_0x0d07;
    L_0x0c51:
        r0 = r27;
        r1 = r26;
        r4 = r0.replaceParallelBroadcastLocked(r1);
        if (r4 == 0) goto L_0x0d03;
    L_0x0c5b:
        r97 = 1;
    L_0x0c5d:
        if (r97 != 0) goto L_0x0c69;
    L_0x0c5f:
        r0 = r27;
        r1 = r26;
        r0.enqueueParallelBroadcastLocked(r1);
        r27.scheduleBroadcastsLocked();
    L_0x0c69:
        r25 = 0;
        r68 = 0;
    L_0x0c6d:
        r82 = 0;
        if (r93 == 0) goto L_0x0f4d;
    L_0x0c71:
        r102 = 0;
        r4 = "android.intent.action.PACKAGE_ADDED";
        r6 = r28.getAction();
        r4 = r4.equals(r6);
        if (r4 != 0) goto L_0x0c9a;
    L_0x0c80:
        r4 = "android.intent.action.PACKAGE_RESTARTED";
        r6 = r28.getAction();
        r4 = r4.equals(r6);
        if (r4 != 0) goto L_0x0c9a;
    L_0x0c8d:
        r4 = "android.intent.action.PACKAGE_DATA_CLEARED";
        r6 = r28.getAction();
        r4 = r4.equals(r6);
        if (r4 == 0) goto L_0x0d0b;
    L_0x0c9a:
        r78 = r28.getData();
        if (r78 == 0) goto L_0x0cae;
    L_0x0ca0:
        r13 = r78.getSchemeSpecificPart();
        if (r13 == 0) goto L_0x0cae;
    L_0x0ca6:
        r4 = 1;
        r0 = new java.lang.String[r4];
        r102 = r0;
        r4 = 0;
        r102[r4] = r13;
    L_0x0cae:
        if (r102 == 0) goto L_0x0d25;
    L_0x0cb0:
        r0 = r102;
        r4 = r0.length;
        if (r4 <= 0) goto L_0x0d25;
    L_0x0cb5:
        r4 = 0;
        r0 = r102;
        r6 = r0.length;
    L_0x0cb9:
        if (r4 >= r6) goto L_0x0d25;
    L_0x0cbb:
        r101 = r102[r4];
        if (r101 == 0) goto L_0x0d22;
    L_0x0cbf:
        r69 = r93.size();
        r85 = 0;
    L_0x0cc5:
        r0 = r85;
        r1 = r69;
        if (r0 >= r1) goto L_0x0d22;
    L_0x0ccb:
        r0 = r93;
        r1 = r85;
        r77 = r0.get(r1);
        r77 = (android.content.pm.ResolveInfo) r77;
        r0 = r77;
        r7 = r0.activityInfo;
        r7 = r7.packageName;
        r0 = r101;
        r7 = r7.equals(r0);
        if (r7 == 0) goto L_0x0cee;
    L_0x0ce3:
        r0 = r93;
        r1 = r85;
        r0.remove(r1);
        r85 = r85 + -1;
        r69 = r69 + -1;
    L_0x0cee:
        r85 = r85 + 1;
        goto L_0x0cc5;
    L_0x0cf1:
        r96 = 0;
        goto L_0x0b8a;
    L_0x0cf5:
        r68 = 0;
        goto L_0x0bbe;
    L_0x0cf9:
        r0 = r113;
        r1 = r28;
        r27 = r0.broadcastQueueForIntent(r1);
        goto L_0x0be1;
    L_0x0d03:
        r97 = 0;
        goto L_0x0c5d;
    L_0x0d07:
        r97 = 0;
        goto L_0x0c5d;
    L_0x0d0b:
        r4 = "android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE";
        r6 = r28.getAction();
        r4 = r4.equals(r6);
        if (r4 == 0) goto L_0x0cae;
    L_0x0d18:
        r4 = "android.intent.extra.changed_package_list";
        r0 = r28;
        r102 = r0.getStringArrayExtra(r4);
        goto L_0x0cae;
    L_0x0d22:
        r4 = r4 + 1;
        goto L_0x0cb9;
    L_0x0d25:
        if (r93 == 0) goto L_0x0d71;
    L_0x0d27:
        r69 = r93.size();
    L_0x0d2b:
        r85 = 0;
        r77 = 0;
        r76 = 0;
    L_0x0d31:
        r0 = r85;
        r1 = r69;
        if (r0 >= r1) goto L_0x0d74;
    L_0x0d37:
        r0 = r82;
        r1 = r68;
        if (r0 >= r1) goto L_0x0d74;
    L_0x0d3d:
        if (r77 != 0) goto L_0x0d49;
    L_0x0d3f:
        r0 = r93;
        r1 = r85;
        r77 = r0.get(r1);
        r77 = (android.content.pm.ResolveInfo) r77;
    L_0x0d49:
        if (r76 != 0) goto L_0x0d55;
    L_0x0d4b:
        r0 = r25;
        r1 = r82;
        r76 = r0.get(r1);
        r76 = (com.android.server.am.BroadcastFilter) r76;
    L_0x0d55:
        r4 = r76.getPriority();
        r0 = r77;
        r6 = r0.priority;
        if (r4 < r6) goto L_0x0d93;
    L_0x0d5f:
        r0 = r93;
        r1 = r85;
        r2 = r76;
        r0.add(r1, r2);
        r82 = r82 + 1;
        r76 = 0;
        r85 = r85 + 1;
        r69 = r69 + 1;
        goto L_0x0d31;
    L_0x0d71:
        r69 = 0;
        goto L_0x0d2b;
    L_0x0d74:
        r44 = r93;
    L_0x0d76:
        r0 = r82;
        r1 = r68;
        if (r0 >= r1) goto L_0x0d98;
    L_0x0d7c:
        if (r44 != 0) goto L_0x0d83;
    L_0x0d7e:
        r44 = new java.util.ArrayList;
        r44.<init>();
    L_0x0d83:
        r0 = r25;
        r1 = r82;
        r4 = r0.get(r1);
        r0 = r44;
        r0.add(r4);
        r82 = r82 + 1;
        goto L_0x0d76;
    L_0x0d93:
        r85 = r85 + 1;
        r77 = 0;
        goto L_0x0d31;
    L_0x0d98:
        if (r84 == 0) goto L_0x0da9;
    L_0x0d9a:
        r38 = r113;
        r39 = r28;
        r40 = r114;
        r41 = r115;
        r42 = r128;
        r43 = r24;
        r38.checkBroadcastFromSystem(r39, r40, r41, r42, r43, r44);
    L_0x0da9:
        if (r44 == 0) goto L_0x0ed8;
    L_0x0dab:
        r4 = r44.size();
        if (r4 <= 0) goto L_0x0ed8;
    L_0x0db1:
        r4 = 10000; // 0x2710 float:1.4013E-41 double:4.9407E-320;
        r0 = r128;
        if (r0 < r4) goto L_0x0f01;
    L_0x0db7:
        r4 = com.android.server.am.OppoBroadcastManager.getInstance(r113);
        r0 = r28;
        r27 = r4.broadcastQueueForIntent(r0);
    L_0x0dc1:
        r4 = com.android.server.am.OppoBroadcastManager.getInstance(r113);
        r0 = r44;
        r1 = r28;
        r44 = r4.adjustReceiverList(r0, r1);
        r26 = new com.android.server.am.BroadcastRecord;
        r64 = 0;
        r45 = r26;
        r46 = r27;
        r47 = r28;
        r48 = r114;
        r49 = r115;
        r50 = r127;
        r51 = r128;
        r52 = r33;
        r53 = r117;
        r54 = r122;
        r55 = r123;
        r56 = r37;
        r57 = r44;
        r58 = r118;
        r59 = r119;
        r60 = r120;
        r61 = r121;
        r62 = r125;
        r63 = r126;
        r65 = r129;
        r45.<init>(r46, r47, r48, r49, r50, r51, r52, r53, r54, r55, r56, r57, r58, r59, r60, r61, r62, r63, r64, r65);
        if (r83 == 0) goto L_0x0e26;
    L_0x0dfe:
        r4 = TAG_BROADCAST;
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r7 = "Enqueueing ordered broadcast ";
        r6 = r6.append(r7);
        r0 = r26;
        r6 = r6.append(r0);
        r7 = ", userId:";
        r6 = r6.append(r7);
        r0 = r129;
        r6 = r6.append(r0);
        r6 = r6.toString();
        android.util.Slog.v(r4, r6);
    L_0x0e26:
        r100 = 0;
        r0 = r27;
        r4 = r0.mOrderedBroadcasts;
        if (r4 == 0) goto L_0x0e3c;
    L_0x0e2e:
        r0 = r27;
        r4 = r0.mOrderedBroadcasts;
        r4 = r4.size();
        r6 = 100;
        if (r4 <= r6) goto L_0x0e3c;
    L_0x0e3a:
        r100 = 1;
    L_0x0e3c:
        r4 = com.android.server.am.ActivityManagerDebugConfig.DEBUG_BROADCAST;
        if (r4 != 0) goto L_0x0e42;
    L_0x0e40:
        if (r100 == 0) goto L_0x0e70;
    L_0x0e42:
        r4 = TAG_BROADCAST;
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r7 = "Enqueueing ordered broadcast ";
        r6 = r6.append(r7);
        r0 = r26;
        r6 = r6.append(r0);
        r7 = ": prev had ";
        r6 = r6.append(r7);
        r0 = r27;
        r7 = r0.mOrderedBroadcasts;
        r7 = r7.size();
        r6 = r6.append(r7);
        r6 = r6.toString();
        android.util.Slog.v(r4, r6);
    L_0x0e70:
        r4 = com.android.server.am.ActivityManagerDebugConfig.DEBUG_BROADCAST;
        if (r4 == 0) goto L_0x0e95;
    L_0x0e74:
        r4 = TAG_BROADCAST;
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r7 = "Enqueueing broadcast ";
        r6 = r6.append(r7);
        r0 = r26;
        r7 = r0.intent;
        r7 = r7.getAction();
        r6 = r6.append(r7);
        r6 = r6.toString();
        android.util.Slog.i(r4, r6);
    L_0x0e95:
        if (r96 == 0) goto L_0x0f0b;
    L_0x0e97:
        r0 = r27;
        r1 = r26;
        r90 = r0.replaceOrderedBroadcastLocked(r1);
    L_0x0e9f:
        if (r90 == 0) goto L_0x0f3c;
    L_0x0ea1:
        r0 = r90;
        r4 = r0.resultTo;
        if (r4 == 0) goto L_0x0ed6;
    L_0x0ea7:
        r0 = r90;
        r4 = r0.intent;
        r0 = r113;
        r45 = r0.broadcastQueueForIntent(r4);
        r0 = r90;	 Catch:{ RemoteException -> 0x0f0e }
        r0 = r0.callerApp;	 Catch:{ RemoteException -> 0x0f0e }
        r46 = r0;	 Catch:{ RemoteException -> 0x0f0e }
        r0 = r90;	 Catch:{ RemoteException -> 0x0f0e }
        r0 = r0.resultTo;	 Catch:{ RemoteException -> 0x0f0e }
        r47 = r0;	 Catch:{ RemoteException -> 0x0f0e }
        r0 = r90;	 Catch:{ RemoteException -> 0x0f0e }
        r0 = r0.intent;	 Catch:{ RemoteException -> 0x0f0e }
        r48 = r0;	 Catch:{ RemoteException -> 0x0f0e }
        r0 = r90;	 Catch:{ RemoteException -> 0x0f0e }
        r0 = r0.userId;	 Catch:{ RemoteException -> 0x0f0e }
        r54 = r0;	 Catch:{ RemoteException -> 0x0f0e }
        r49 = 0;	 Catch:{ RemoteException -> 0x0f0e }
        r50 = 0;	 Catch:{ RemoteException -> 0x0f0e }
        r51 = 0;	 Catch:{ RemoteException -> 0x0f0e }
        r52 = 0;	 Catch:{ RemoteException -> 0x0f0e }
        r53 = 0;	 Catch:{ RemoteException -> 0x0f0e }
        r45.performReceiveLocked(r46, r47, r48, r49, r50, r51, r52, r53, r54);	 Catch:{ RemoteException -> 0x0f0e }
    L_0x0ed6:
        r4 = 0;
        return r4;
    L_0x0ed8:
        if (r118 != 0) goto L_0x0db1;
    L_0x0eda:
        r4 = r28.getComponent();
        if (r4 != 0) goto L_0x0ed6;
    L_0x0ee0:
        r4 = r28.getPackage();
        if (r4 != 0) goto L_0x0ed6;
    L_0x0ee6:
        r4 = r28.getFlags();
        r6 = 1073741824; // 0x40000000 float:2.0 double:5.304989477E-315;
        r4 = r4 & r6;
        if (r4 != 0) goto L_0x0ed6;
    L_0x0eef:
        r48 = r28.getAction();
        r52 = 0;
        r50 = 0;
        r51 = 0;
        r47 = r113;
        r49 = r115;
        r47.addBroadcastStatLocked(r48, r49, r50, r51, r52);
        goto L_0x0ed6;
    L_0x0f01:
        r0 = r113;
        r1 = r28;
        r27 = r0.broadcastQueueForIntent(r1);
        goto L_0x0dc1;
    L_0x0f0b:
        r90 = 0;
        goto L_0x0e9f;
    L_0x0f0e:
        r79 = move-exception;
        r4 = TAG;
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r7 = "Failure [";
        r6 = r6.append(r7);
        r0 = r27;
        r7 = r0.mQueueName;
        r6 = r6.append(r7);
        r7 = "] sending broadcast result of ";
        r6 = r6.append(r7);
        r0 = r28;
        r6 = r6.append(r0);
        r6 = r6.toString();
        r0 = r79;
        android.util.Slog.w(r4, r6, r0);
        goto L_0x0ed6;
    L_0x0f3c:
        r0 = r27;
        r1 = r26;
        r0.enqueueOrderedBroadcastLocked(r1);
        r27.scheduleBroadcastsLocked();
        goto L_0x0ed6;
    L_0x0f47:
        r79 = move-exception;
        goto L_0x0532;
    L_0x0f4a:
        r81 = move-exception;
        goto L_0x04c7;
    L_0x0f4d:
        r44 = r93;
        goto L_0x0d76;
    L_0x0f51:
        r93 = r44;
        goto L_0x0b19;
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.broadcastIntentLocked(com.android.server.am.ProcessRecord, java.lang.String, android.content.Intent, java.lang.String, android.content.IIntentReceiver, int, java.lang.String, android.os.Bundle, java.lang.String[], int, android.os.Bundle, boolean, boolean, int, int, int):int");
    }

    private int getUidFromIntent(Intent intent) {
        int i = -1;
        if (intent == null) {
            return -1;
        }
        Bundle intentExtras = intent.getExtras();
        if (intent.hasExtra("android.intent.extra.UID")) {
            i = intentExtras.getInt("android.intent.extra.UID");
        }
        return i;
    }

    final void rotateBroadcastStatsIfNeededLocked() {
        long now = SystemClock.elapsedRealtime();
        if (this.mCurBroadcastStats == null || this.mCurBroadcastStats.mStartRealtime + 86400000 < now) {
            this.mLastBroadcastStats = this.mCurBroadcastStats;
            if (this.mLastBroadcastStats != null) {
                this.mLastBroadcastStats.mEndRealtime = SystemClock.elapsedRealtime();
                this.mLastBroadcastStats.mEndUptime = SystemClock.uptimeMillis();
            }
            this.mCurBroadcastStats = new BroadcastStats();
        }
    }

    final void addBroadcastStatLocked(String action, String srcPackage, int receiveCount, int skipCount, long dispatchTime) {
        rotateBroadcastStatsIfNeededLocked();
        this.mCurBroadcastStats.addBroadcast(action, srcPackage, receiveCount, skipCount, dispatchTime);
    }

    final void addBackgroundCheckViolationLocked(String action, String targetPackage) {
        rotateBroadcastStatsIfNeededLocked();
        this.mCurBroadcastStats.addBackgroundCheckViolation(action, targetPackage);
    }

    final Intent verifyBroadcastLocked(Intent intent) {
        if (intent == null || !intent.hasFileDescriptors()) {
            int flags = intent.getFlags();
            if (!this.mProcessesReady && (67108864 & flags) == 0 && (flags & 1073741824) == 0) {
                Slog.wtf(TAG, "Attempt to launch receivers of broadcast intent " + intent + " before boot completion");
                Intent intent2 = new Intent(intent);
                intent2.addFlags(1073741824);
                intent = intent2;
            }
            if ((PhoneWindowManager.SYSTEM_UI_FLAG_APP_CUSTOM_NAVIGATION_BAR & flags) != 0) {
                throw new IllegalArgumentException("Can't use FLAG_RECEIVER_BOOT_UPGRADE here");
            }
            if ((flags & DumpState.DUMP_CHANGES) != 0) {
                switch (Binder.getCallingUid()) {
                    case 0:
                    case OppoArpPeer.ARP_FIRST_RESPONSE_TIMEOUT /*2000*/:
                        break;
                    default:
                        Slog.w(TAG, "Removing FLAG_RECEIVER_FROM_SHELL because caller is UID " + Binder.getCallingUid());
                        intent.removeFlags(DumpState.DUMP_CHANGES);
                        break;
                }
            }
            return intent;
        }
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }

    public final int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean serialized, boolean sticky, int userId) {
        int res;
        enforceNotIsolatedCaller("broadcastIntent");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                intent = verifyBroadcastLocked(intent);
                ProcessRecord callerApp = getRecordForAppLocked(caller);
                int callingPid = Binder.getCallingPid();
                int callingUid = Binder.getCallingUid();
                long origId = Binder.clearCallingIdentity();
                res = broadcastIntentLocked(callerApp, callerApp != null ? callerApp.info.packageName : null, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermissions, appOp, bOptions, serialized, sticky, callingPid, callingUid, userId);
                Binder.restoreCallingIdentity(origId);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return res;
    }

    int broadcastIntentInPackage(String packageName, int uid, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String requiredPermission, Bundle bOptions, boolean serialized, boolean sticky, int userId) {
        int res;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                intent = verifyBroadcastLocked(intent);
                long origId = Binder.clearCallingIdentity();
                res = broadcastIntentLocked(null, packageName, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermission == null ? null : new String[]{requiredPermission}, -1, bOptions, serialized, sticky, -1, uid, userId);
                Binder.restoreCallingIdentity(origId);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return res;
    }

    public final void unbroadcastIntent(IApplicationThread caller, Intent intent, int userId) {
        if (intent == null || !intent.hasFileDescriptors()) {
            userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, true, 0, "removeStickyBroadcast", null);
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (checkCallingPermission("android.permission.BROADCAST_STICKY") != 0) {
                        String msg = "Permission Denial: unbroadcastIntent() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.BROADCAST_STICKY";
                        Slog.w(TAG, msg);
                        throw new SecurityException(msg);
                    }
                    ArrayMap<String, ArrayList<Intent>> stickies = (ArrayMap) this.mStickyBroadcasts.get(userId);
                    if (stickies != null) {
                        ArrayList<Intent> list = (ArrayList) stickies.get(intent.getAction());
                        if (list != null) {
                            int N = list.size();
                            for (int i = 0; i < N; i++) {
                                if (intent.filterEquals((Intent) list.get(i))) {
                                    list.remove(i);
                                    break;
                                }
                            }
                            if (list.size() <= 0) {
                                stickies.remove(intent.getAction());
                            }
                        }
                        if (stickies.size() <= 0) {
                            this.mStickyBroadcasts.remove(userId);
                        }
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return;
        }
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }

    void backgroundServicesFinishedLocked(int userId) {
        for (BroadcastQueue queue : this.mBroadcastQueues) {
            queue.backgroundServicesFinishedLocked(userId);
        }
    }

    public void finishReceiver(IBinder who, int resultCode, String resultData, Bundle resultExtras, boolean resultAbort, int flags) {
        if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
            Slog.v(TAG_BROADCAST, "Finish receiver: " + who);
        }
        if (resultExtras == null || !resultExtras.hasFileDescriptors()) {
            long origId = Binder.clearCallingIdentity();
            boolean doNext = false;
            try {
                BroadcastRecord r;
                synchronized (this) {
                    boostPriorityForLockedSection();
                    BroadcastQueue queue = (DumpState.DUMP_FROZEN & flags) != 0 ? OppoBroadcastManager.getInstance(this).GetQueueFromFlag(flags) : (268435456 & flags) != 0 ? this.mFgBroadcastQueue : this.mBgBroadcastQueue;
                    r = queue.getMatchingOrderedReceiver(who);
                    if (r != null) {
                        doNext = r.queue.finishReceiverLocked(r, resultCode, resultData, resultExtras, resultAbort, true);
                    }
                }
                resetPriorityAfterLockedSection();
                if (doNext) {
                    r.queue.processNextBroadcast(false);
                }
                trimApplications();
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(origId);
            }
        } else {
            throw new IllegalArgumentException("File descriptors passed in Bundle");
        }
    }

    public void finishNotOrderReceiver(IBinder who, int hasCode, int resultCode, String resultData, Bundle resultExtras, boolean resultAbort) {
        if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
            Slog.v(TAG, "Finish not order hasCode: " + hasCode);
        }
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ReceiverRecord mReceiverRecord = broadcastRecordForNotOrderReceiverLocked(who, hasCode);
                if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                    Slog.v(TAG, "mReceiverRecord: " + mReceiverRecord);
                }
                if (mReceiverRecord != null) {
                    mReceiverRecord.cancelBroadcastTimeoutLocked();
                }
            }
            resetPriorityAfterLockedSection();
            this.mFinishBroadcastCount++;
            if (this.mFinishBroadcastCount == 5) {
                if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                    Slog.v(TAG, "trimApplications() ");
                }
                trimApplications();
                this.mFinishBroadcastCount = 0;
            }
            Binder.restoreCallingIdentity(origId);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public boolean startInstrumentation(ComponentName className, String profileFile, int flags, Bundle arguments, IInstrumentationWatcher watcher, IUiAutomationConnection uiAutomationConnection, int userId, String abiOverride) {
        enforceNotIsolatedCaller("startInstrumentation");
        userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "startInstrumentation", null);
        if (arguments == null || !arguments.hasFileDescriptors()) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    InstrumentationInfo instrumentationInfo = null;
                    ApplicationInfo ai = null;
                    try {
                        instrumentationInfo = this.mContext.getPackageManager().getInstrumentationInfo(className, 1024);
                        ai = AppGlobals.getPackageManager().getApplicationInfo(instrumentationInfo.targetPackage, 1024, userId);
                    } catch (NameNotFoundException e) {
                    } catch (RemoteException e2) {
                    }
                    if (instrumentationInfo == null) {
                        reportStartInstrumentationFailureLocked(watcher, className, "Unable to find instrumentation info for: " + className);
                    } else if (ai == null) {
                        reportStartInstrumentationFailureLocked(watcher, className, "Unable to find instrumentation target package: " + instrumentationInfo.targetPackage);
                        resetPriorityAfterLockedSection();
                        return false;
                    } else if (ai.hasCode()) {
                        int match = this.mContext.getPackageManager().checkSignatures(instrumentationInfo.targetPackage, instrumentationInfo.packageName);
                        if (match >= 0 || match == -1) {
                            ActiveInstrumentation activeInstr = new ActiveInstrumentation(this);
                            activeInstr.mClass = className;
                            String defProcess = ai.processName;
                            if (instrumentationInfo.targetProcesses == null) {
                                activeInstr.mTargetProcesses = new String[]{ai.processName};
                            } else if (instrumentationInfo.targetProcesses.equals("*")) {
                                activeInstr.mTargetProcesses = new String[0];
                            } else {
                                activeInstr.mTargetProcesses = instrumentationInfo.targetProcesses.split(",");
                                defProcess = activeInstr.mTargetProcesses[0];
                            }
                            activeInstr.mTargetInfo = ai;
                            activeInstr.mProfileFile = profileFile;
                            activeInstr.mArguments = arguments;
                            activeInstr.mWatcher = watcher;
                            activeInstr.mUiAutomationConnection = uiAutomationConnection;
                            activeInstr.mResultClass = className;
                            long origId = Binder.clearCallingIdentity();
                            forceStopPackageLocked(instrumentationInfo.targetPackage, -1, true, false, true, true, false, userId, "start instr");
                            ProcessRecord app = addAppLocked(ai, defProcess, false, abiOverride);
                            app.instr = activeInstr;
                            activeInstr.mFinished = false;
                            activeInstr.mRunningProcesses.add(app);
                            if (!this.mActiveInstrumentation.contains(activeInstr)) {
                                this.mActiveInstrumentation.add(activeInstr);
                            }
                            Binder.restoreCallingIdentity(origId);
                            resetPriorityAfterLockedSection();
                            return true;
                        }
                        String msg = "Permission Denial: starting instrumentation " + className + " from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingPid() + " not allowed because package " + instrumentationInfo.packageName + " does not have a signature matching the target " + instrumentationInfo.targetPackage;
                        reportStartInstrumentationFailureLocked(watcher, className, msg);
                        throw new SecurityException(msg);
                    } else {
                        reportStartInstrumentationFailureLocked(watcher, className, "Instrumentation target has no code: " + instrumentationInfo.targetPackage);
                        resetPriorityAfterLockedSection();
                        return false;
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        } else {
            throw new IllegalArgumentException("File descriptors passed in Bundle");
        }
        return false;
    }

    private void reportStartInstrumentationFailureLocked(IInstrumentationWatcher watcher, ComponentName cn, String report) {
        Slog.w(TAG, report);
        if (watcher != null) {
            Bundle results = new Bundle();
            results.putString(DecryptTool.UNLOCK_TYPE_ID, "ActivityManagerService");
            results.putString("Error", report);
            this.mInstrumentationReporter.reportStatus(watcher, cn, -1, results);
        }
    }

    void addInstrumentationResultsLocked(ProcessRecord app, Bundle results) {
        if (app.instr == null) {
            Slog.w(TAG, "finishInstrumentation called on non-instrumented: " + app);
            return;
        }
        if (!(app.instr.mFinished || results == null)) {
            if (app.instr.mCurResults == null) {
                app.instr.mCurResults = new Bundle(results);
            } else {
                app.instr.mCurResults.putAll(results);
            }
        }
    }

    public void addInstrumentationResults(IApplicationThread target, Bundle results) {
        int userId = UserHandle.getCallingUserId();
        if (results == null || !results.hasFileDescriptors()) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    ProcessRecord app = getRecordForAppLocked(target);
                    if (app == null) {
                        Slog.w(TAG, "addInstrumentationResults: no app for " + target);
                    } else {
                        long origId = Binder.clearCallingIdentity();
                        addInstrumentationResultsLocked(app, results);
                        Binder.restoreCallingIdentity(origId);
                        resetPriorityAfterLockedSection();
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        } else {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        }
    }

    void finishInstrumentationLocked(ProcessRecord app, int resultCode, Bundle results) {
        if (app.instr == null) {
            Slog.w(TAG, "finishInstrumentation called on non-instrumented: " + app);
            return;
        }
        if (!app.instr.mFinished) {
            if (app.instr.mWatcher != null) {
                Bundle finalResults = app.instr.mCurResults;
                if (finalResults == null) {
                    finalResults = results;
                } else if (!(app.instr.mCurResults == null || results == null)) {
                    finalResults.putAll(results);
                }
                this.mInstrumentationReporter.reportFinished(app.instr.mWatcher, app.instr.mClass, resultCode, finalResults);
            }
            if (app.instr.mUiAutomationConnection != null) {
                this.mHandler.obtainMessage(56, app.instr.mUiAutomationConnection).sendToTarget();
            }
            app.instr.mFinished = true;
        }
        app.instr.removeProcess(app);
        app.instr = null;
        forceStopPackageLocked(app.info.packageName, -1, false, false, true, true, false, app.userId, "finished inst");
    }

    public void finishInstrumentation(IApplicationThread target, int resultCode, Bundle results) {
        int userId = UserHandle.getCallingUserId();
        if (results == null || !results.hasFileDescriptors()) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    ProcessRecord app = getRecordForAppLocked(target);
                    if (app == null) {
                        Slog.w(TAG, "finishInstrumentation: no app for " + target);
                    } else {
                        long origId = Binder.clearCallingIdentity();
                        finishInstrumentationLocked(app, resultCode, results);
                        Binder.restoreCallingIdentity(origId);
                        resetPriorityAfterLockedSection();
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        } else {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        }
    }

    public ConfigurationInfo getDeviceConfigurationInfo() {
        ConfigurationInfo config = new ConfigurationInfo();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                Configuration globalConfig = getGlobalConfiguration();
                config.reqTouchScreen = globalConfig.touchscreen;
                config.reqKeyboardType = globalConfig.keyboard;
                config.reqNavigation = globalConfig.navigation;
                if (globalConfig.navigation == 2 || globalConfig.navigation == 3) {
                    config.reqInputFeatures |= 2;
                }
                if (!(globalConfig.keyboard == 0 || globalConfig.keyboard == 1)) {
                    config.reqInputFeatures |= 1;
                }
                config.reqGlEsVersion = this.GL_ES_VERSION;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return config;
    }

    ActivityStack getFocusedStack() {
        return this.mStackSupervisor.getFocusedStack();
    }

    public int getFocusedStackId() throws RemoteException {
        ActivityStack focusedStack = getFocusedStack();
        if (focusedStack != null) {
            return focusedStack.getStackId();
        }
        return -1;
    }

    public Configuration getConfiguration() {
        Configuration ci;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ci = new Configuration(getGlobalConfiguration());
                ci.userSetLocale = false;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return ci;
    }

    public void suppressResizeConfigChanges(boolean suppress) throws RemoteException {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "suppressResizeConfigChanges()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mSuppressResizeConfigChanges = suppress;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void moveTasksToFullscreenStack(int fromStackId, boolean onTop) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "moveTasksToFullscreenStack()");
        if (StackId.isHomeOrRecentsStack(fromStackId)) {
            throw new IllegalArgumentException("You can't move tasks from the home/recents stack.");
        }
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                origId = Binder.clearCallingIdentity();
                this.mStackSupervisor.moveTasksToFullscreenStackLocked(fromStackId, onTop);
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void updatePersistentConfiguration(Configuration values) {
        enforceCallingPermission("android.permission.CHANGE_CONFIGURATION", "updatePersistentConfiguration()");
        enforceWriteSettingsPermission("updatePersistentConfiguration()");
        if (values == null) {
            throw new NullPointerException("Configuration must not be null");
        }
        int userId = UserHandle.getCallingUserId();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                updatePersistentConfigurationLocked(values, userId);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private void updatePersistentConfigurationLocked(Configuration values, int userId) {
        long origId = Binder.clearCallingIdentity();
        try {
            updateConfigurationLocked(values, null, false, true, userId, false);
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    private void updateFontScaleIfNeeded(int userId) {
        float scaleFactor = System.getFloatForUser(this.mContext.getContentResolver(), "font_scale", 1.0f, userId);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (getGlobalConfiguration().fontScale == scaleFactor) {
                } else {
                    Configuration configuration = this.mWindowManager.computeNewConfiguration(0);
                    configuration.fontScale = scaleFactor;
                    updatePersistentConfigurationLocked(configuration, userId);
                    resetPriorityAfterLockedSection();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private void enforceWriteSettingsPermission(String func) {
        int uid = Binder.getCallingUid();
        if (uid != 0 && !Settings.checkAndNoteWriteSettingsOperation(this.mContext, uid, Settings.getPackageNameForUid(this.mContext, uid), false)) {
            String msg = "Permission Denial: " + func + " from pid=" + Binder.getCallingPid() + ", uid=" + uid + " requires " + "android.permission.WRITE_SETTINGS";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
    }

    public boolean updateConfiguration(Configuration values) {
        boolean z;
        enforceCallingPermission("android.permission.CHANGE_CONFIGURATION", "updateConfiguration()");
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                if (values == null && this.mWindowManager != null) {
                    values = this.mWindowManager.computeNewConfiguration(0);
                }
                if (this.mWindowManager != null) {
                    this.mProcessList.applyDisplaySize(this.mWindowManager);
                }
                origId = Binder.clearCallingIdentity();
                if (values != null) {
                    System.clearConfiguration(values);
                }
                updateConfigurationLocked(values, null, false, false, -10000, false, this.mTmpUpdateConfigurationResult);
                z = this.mTmpUpdateConfigurationResult.changes != 0;
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
        return z;
    }

    void updateUserConfigurationLocked() {
        Configuration configuration = new Configuration(getGlobalConfiguration());
        int currentUserId = this.mUserController.getCurrentUserIdLocked();
        System.adjustConfigurationForUser(this.mContext.getContentResolver(), configuration, currentUserId, System.canWrite(this.mContext));
        updateConfigurationLocked(configuration, null, false, false, currentUserId, false);
    }

    boolean updateConfigurationLocked(Configuration values, ActivityRecord starting, boolean initLocale) {
        return updateConfigurationLocked(values, starting, initLocale, false);
    }

    boolean updateConfigurationLocked(Configuration values, ActivityRecord starting, boolean initLocale, boolean deferResume) {
        return updateConfigurationLocked(values, starting, initLocale, false, -10000, deferResume);
    }

    private boolean updateConfigurationLocked(Configuration values, ActivityRecord starting, boolean initLocale, boolean persistent, int userId, boolean deferResume) {
        return updateConfigurationLocked(values, starting, initLocale, persistent, userId, deferResume, null);
    }

    private boolean updateConfigurationLocked(Configuration values, ActivityRecord starting, boolean initLocale, boolean persistent, int userId, boolean deferResume, UpdateConfigurationResult result) {
        int changes = 0;
        if (this.mWindowManager != null) {
            this.mWindowManager.deferSurfaceLayout();
        }
        if (values != null) {
            try {
                changes = updateGlobalConfiguration(values, initLocale, persistent, userId, deferResume);
            } catch (Throwable th) {
                if (this.mWindowManager != null) {
                    this.mWindowManager.continueSurfaceLayout();
                }
            }
        }
        boolean kept = ensureConfigAndVisibilityAfterUpdate(starting, changes);
        if (this.mWindowManager != null) {
            this.mWindowManager.continueSurfaceLayout();
        }
        if (result != null) {
            result.changes = changes;
            result.activityRelaunched = kept ^ 1;
        }
        return kept;
    }

    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "wurun.zhou@Apps.Theme : Modify for rom theme", property = OppoRomType.ROM)
    private int updateGlobalConfiguration(Configuration values, boolean initLocale, boolean persistent, int userId, boolean deferResume) {
        this.mTempConfig.setTo(getGlobalConfiguration());
        int changes = this.mTempConfig.updateFrom(values);
        if (changes == 0) {
            performDisplayOverrideConfigUpdate(values, deferResume, 0);
            return 0;
        }
        if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_CONFIGURATION) {
            Slog.i(TAG_CONFIGURATION, "Updating global configuration to: " + values);
        }
        EventLog.writeEvent(EventLogTags.CONFIGURATION_CHANGED, changes);
        if (!(initLocale || (values.getLocales().isEmpty() ^ 1) == 0 || !values.userSetLocale)) {
            LocaleList locales = values.getLocales();
            int bestLocaleIndex = 0;
            if (locales.size() > 1) {
                if (this.mSupportedSystemLocales == null) {
                    this.mSupportedSystemLocales = Resources.getSystem().getAssets().getLocales();
                }
                bestLocaleIndex = Math.max(0, locales.getFirstMatchIndex(this.mSupportedSystemLocales));
            }
            SystemProperties.set("persist.sys.locale", locales.get(bestLocaleIndex).toLanguageTag());
            LocaleList.setDefault(locales, bestLocaleIndex);
            this.mHandler.sendMessage(this.mHandler.obtainMessage(47, locales.get(bestLocaleIndex)));
        }
        int i = this.mConfigurationSeq + 1;
        this.mConfigurationSeq = i;
        this.mConfigurationSeq = Math.max(i, 1);
        this.mTempConfig.seq = this.mConfigurationSeq;
        this.mStackSupervisor.onConfigurationChanged(this.mTempConfig);
        Slog.i(TAG, "Config changes=" + Integer.toHexString(changes) + " " + this.mTempConfig);
        this.mUsageStatsService.reportConfigurationChange(this.mTempConfig, this.mUserController.getCurrentUserIdLocked());
        this.mShowDialogs = shouldShowDialogs(this.mTempConfig);
        AttributeCache ac = AttributeCache.instance();
        if (ac != null) {
            ac.updateConfiguration(this.mTempConfig);
        }
        this.mSystemThread.applyConfigurationToResources(this.mTempConfig);
        Configuration configuration = new Configuration(this.mTempConfig);
        if (persistent && System.hasInterestingConfigurationChanges(changes)) {
            Message msg = this.mHandler.obtainMessage(4);
            msg.obj = configuration;
            msg.arg1 = userId;
            this.mHandler.sendMessage(msg);
        }
        for (int i2 = this.mLruProcesses.size() - 1; i2 >= 0; i2--) {
            ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i2);
            if ((134217728 & changes) == 0 || app == null || !OppoThemeUtil.THEME_CHANGED_IGNORE_PKGS.contains(app.processName)) {
                try {
                    if (app.thread != null) {
                        if (ActivityManagerDebugConfig.DEBUG_CONFIGURATION) {
                            Slog.v(TAG_CONFIGURATION, "Sending to proc " + app.processName + " new config " + configuration);
                        }
                        app.thread.scheduleConfigurationChanged(configuration);
                    }
                } catch (Exception e) {
                }
            } else {
                Log.i(TAG, "updateGlobalConfiguration. Not send to ignore apps when skin changed. processName = " + app.processName);
            }
        }
        Intent intent = new Intent("android.intent.action.CONFIGURATION_CHANGED");
        intent.addFlags(1881145344);
        broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, -1, null, false, false, MY_PID, 1000, -1);
        if ((changes & 4) != 0) {
            intent = new Intent("android.intent.action.LOCALE_CHANGED");
            intent.addFlags(287309824);
            if (initLocale || (this.mProcessesReady ^ 1) != 0) {
                intent.addFlags(1073741824);
            }
            broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, -1, null, false, false, MY_PID, 1000, -1);
        }
        if ((134217728 & changes) != 0) {
            Log.e(TAG, "skin is changed, send broadcast to app!!");
            SystemProperties.set("persist.sys.themeflag", Long.toString(configuration.mOppoExtraConfiguration.mThemeChangedFlags));
            broadcastIntentLocked(null, null, new Intent("oppo.intent.action.SKIN_CHANGED"), null, null, 0, null, null, null, -1, null, false, false, MY_PID, 1000, 0);
        }
        OppoThemeHelper.handleExtraConfigurationChanges(changes, configuration, this.mContext, this.mHandler);
        performDisplayOverrideConfigUpdate(this.mStackSupervisor.getConfiguration(), deferResume, 0);
        return changes;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean updateDisplayOverrideConfiguration(Configuration values, int displayId) {
        enforceCallingPermission("android.permission.CHANGE_CONFIGURATION", "updateDisplayOverrideConfiguration()");
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                if (this.mStackSupervisor.isDisplayAdded(displayId)) {
                    if (values == null) {
                        if (this.mWindowManager != null) {
                            values = this.mWindowManager.computeNewConfiguration(displayId);
                        }
                    }
                    if (this.mWindowManager != null) {
                        this.mProcessList.applyDisplaySize(this.mWindowManager);
                    }
                    origId = Binder.clearCallingIdentity();
                    if (values != null) {
                        System.clearConfiguration(values);
                    }
                    updateDisplayOverrideConfigurationLocked(values, null, false, displayId, this.mTmpUpdateConfigurationResult);
                    boolean z = this.mTmpUpdateConfigurationResult.changes != 0;
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return z;
                } else if (ActivityManagerDebugConfig.DEBUG_CONFIGURATION) {
                    Slog.w(TAG, "Trying to update display configuration for non-existing displayId=" + displayId);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    boolean updateDisplayOverrideConfigurationLocked(Configuration values, ActivityRecord starting, boolean deferResume, int displayId) {
        return updateDisplayOverrideConfigurationLocked(values, starting, deferResume, displayId, null);
    }

    private boolean updateDisplayOverrideConfigurationLocked(Configuration values, ActivityRecord starting, boolean deferResume, int displayId, UpdateConfigurationResult result) {
        int changes = 0;
        if (this.mWindowManager != null) {
            this.mWindowManager.deferSurfaceLayout();
        }
        if (values != null) {
            if (displayId == 0) {
                try {
                    changes = updateGlobalConfiguration(values, false, false, -10000, deferResume);
                } catch (Throwable th) {
                    if (this.mWindowManager != null) {
                        this.mWindowManager.continueSurfaceLayout();
                    }
                }
            } else {
                changes = performDisplayOverrideConfigUpdate(values, deferResume, displayId);
            }
        }
        boolean kept = ensureConfigAndVisibilityAfterUpdate(starting, changes);
        if (this.mWindowManager != null) {
            this.mWindowManager.continueSurfaceLayout();
        }
        if (result != null) {
            result.changes = changes;
            result.activityRelaunched = kept ^ 1;
        }
        return kept;
    }

    private int performDisplayOverrideConfigUpdate(Configuration values, boolean deferResume, int displayId) {
        this.mTempConfig.setTo(this.mStackSupervisor.getDisplayOverrideConfiguration(displayId));
        int changes = this.mTempConfig.updateFrom(values);
        if (changes != 0) {
            Slog.i(TAG, "Override config changes=" + Integer.toHexString(changes) + " " + this.mTempConfig + " for displayId=" + displayId);
            this.mStackSupervisor.setDisplayOverrideConfiguration(this.mTempConfig, displayId);
            if (((changes & 4096) != 0) && displayId == 0) {
                this.mUiHandler.sendEmptyMessage(SHOW_UNSUPPORTED_DISPLAY_SIZE_DIALOG_MSG);
                killAllBackgroundProcessesExcept(24, 4);
            }
        }
        if (this.mWindowManager != null) {
            int[] resizedStacks = this.mWindowManager.setNewDisplayOverrideConfiguration(this.mTempConfig, displayId);
            if (resizedStacks != null) {
                for (int stackId : resizedStacks) {
                    resizeStackWithBoundsFromWindowManager(stackId, deferResume);
                }
            }
        }
        return changes;
    }

    private boolean ensureConfigAndVisibilityAfterUpdate(ActivityRecord starting, int changes) {
        ActivityStack mainStack = this.mStackSupervisor.getFocusedStack();
        if (mainStack == null) {
            return true;
        }
        if (changes != 0 && starting == null) {
            starting = mainStack.topRunningActivityLocked();
        }
        if (starting == null) {
            return true;
        }
        boolean kept = starting.ensureActivityConfigurationLocked(changes, false);
        this.mStackSupervisor.ensureActivitiesVisibleLocked(starting, changes, false);
        return kept;
    }

    private void resizeStackWithBoundsFromWindowManager(int stackId, boolean deferResume) {
        Rect rect;
        Rect newStackBounds = new Rect();
        this.mStackSupervisor.getStack(stackId).getBoundsForNewConfiguration(newStackBounds);
        ActivityStackSupervisor activityStackSupervisor = this.mStackSupervisor;
        if (newStackBounds.isEmpty()) {
            rect = null;
        } else {
            rect = newStackBounds;
        }
        activityStackSupervisor.resizeStackLocked(stackId, rect, null, null, false, false, deferResume);
    }

    private static boolean shouldShowDialogs(Configuration config) {
        boolean uiModeSupportsDialogs;
        boolean inputMethodExists = (config.keyboard == 1 && config.touchscreen == 1) ? config.navigation != 1 : true;
        int modeType = config.uiMode & 15;
        if (modeType != 3) {
            int i;
            if (modeType == 6) {
                i = Build.IS_USER;
            } else {
                i = 0;
            }
            if (!((i ^ 1) == 0 || modeType == 4)) {
                uiModeSupportsDialogs = modeType != 7;
                if (inputMethodExists) {
                    return false;
                }
                return uiModeSupportsDialogs;
            }
        }
        uiModeSupportsDialogs = false;
        if (inputMethodExists) {
            return false;
        }
        return uiModeSupportsDialogs;
    }

    public boolean shouldUpRecreateTask(IBinder token, String destAffinity) {
        boolean shouldUpRecreateTaskLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord srec = ActivityRecord.forTokenLocked(token);
                if (srec != null) {
                    shouldUpRecreateTaskLocked = srec.getStack().shouldUpRecreateTaskLocked(srec, destAffinity);
                } else {
                    resetPriorityAfterLockedSection();
                    return false;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return shouldUpRecreateTaskLocked;
    }

    public boolean navigateUpTo(IBinder token, Intent destIntent, int resultCode, Intent resultData) {
        boolean navigateUpToLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.forTokenLocked(token);
                if (r != null) {
                    navigateUpToLocked = r.getStack().navigateUpToLocked(r, destIntent, resultCode, resultData);
                } else {
                    resetPriorityAfterLockedSection();
                    return false;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return navigateUpToLocked;
    }

    public int getLaunchedFromUid(IBinder activityToken) {
        ActivityRecord srec;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                srec = ActivityRecord.forTokenLocked(activityToken);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        if (srec == null) {
            return -1;
        }
        return srec.launchedFromUid;
    }

    public String getLaunchedFromPackage(IBinder activityToken) {
        ActivityRecord srec;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                srec = ActivityRecord.forTokenLocked(activityToken);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        if (srec == null) {
            return null;
        }
        return srec.launchedFromPackage;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private boolean isReceivingBroadcastLocked(ProcessRecord app, ArraySet<BroadcastQueue> receivingQueues) {
        synchronized (app.receiverRecords) {
            int i = 0;
            while (i < app.receiverRecords.size()) {
                ReceiverRecord receiverRecord = (ReceiverRecord) app.receiverRecords.get(i);
                if (receiverRecord == null || receiverRecord.mQueue == null) {
                    i++;
                } else {
                    return true;
                }
            }
        }
    }

    Association startAssociationLocked(int sourceUid, String sourceProcess, int sourceState, int targetUid, ComponentName targetComponent, String targetProcess) {
        if (!this.mTrackingAssociations) {
            return null;
        }
        ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> components = (ArrayMap) this.mAssociations.get(targetUid);
        if (components == null) {
            components = new ArrayMap();
            this.mAssociations.put(targetUid, components);
        }
        SparseArray<ArrayMap<String, Association>> sourceUids = (SparseArray) components.get(targetComponent);
        if (sourceUids == null) {
            sourceUids = new SparseArray();
            components.put(targetComponent, sourceUids);
        }
        ArrayMap<String, Association> sourceProcesses = (ArrayMap) sourceUids.get(sourceUid);
        if (sourceProcesses == null) {
            sourceProcesses = new ArrayMap();
            sourceUids.put(sourceUid, sourceProcesses);
        }
        Association ass = (Association) sourceProcesses.get(sourceProcess);
        if (ass == null) {
            ass = new Association(sourceUid, sourceProcess, targetUid, targetComponent, targetProcess);
            sourceProcesses.put(sourceProcess, ass);
        }
        ass.mCount++;
        ass.mNesting++;
        if (ass.mNesting == 1) {
            long uptimeMillis = SystemClock.uptimeMillis();
            ass.mLastStateUptime = uptimeMillis;
            ass.mStartTime = uptimeMillis;
            ass.mLastState = sourceState;
        }
        return ass;
    }

    void stopAssociationLocked(int sourceUid, String sourceProcess, int targetUid, ComponentName targetComponent) {
        if (this.mTrackingAssociations) {
            ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> components = (ArrayMap) this.mAssociations.get(targetUid);
            if (components != null) {
                SparseArray<ArrayMap<String, Association>> sourceUids = (SparseArray) components.get(targetComponent);
                if (sourceUids != null) {
                    ArrayMap<String, Association> sourceProcesses = (ArrayMap) sourceUids.get(sourceUid);
                    if (sourceProcesses != null) {
                        Association ass = (Association) sourceProcesses.get(sourceProcess);
                        if (ass != null && ass.mNesting > 0) {
                            ass.mNesting--;
                            if (ass.mNesting == 0) {
                                long uptime = SystemClock.uptimeMillis();
                                ass.mTime += uptime - ass.mStartTime;
                                long[] jArr = ass.mStateTimes;
                                int i = ass.mLastState + 0;
                                jArr[i] = jArr[i] + (uptime - ass.mLastStateUptime);
                                ass.mLastState = 20;
                            }
                        }
                    }
                }
            }
        }
    }

    private void noteUidProcessState(int uid, int state) {
        this.mBatteryStatsService.noteUidProcessState(uid, state);
        if (this.mTrackingAssociations) {
            int N1 = this.mAssociations.size();
            for (int i1 = 0; i1 < N1; i1++) {
                ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> targetComponents = (ArrayMap) this.mAssociations.valueAt(i1);
                int N2 = targetComponents.size();
                for (int i2 = 0; i2 < N2; i2++) {
                    ArrayMap<String, Association> sourceProcesses = (ArrayMap) ((SparseArray) targetComponents.valueAt(i2)).get(uid);
                    if (sourceProcesses != null) {
                        int N4 = sourceProcesses.size();
                        for (int i4 = 0; i4 < N4; i4++) {
                            Association ass = (Association) sourceProcesses.valueAt(i4);
                            if (ass.mNesting >= 1) {
                                long uptime = SystemClock.uptimeMillis();
                                long[] jArr = ass.mStateTimes;
                                int i = ass.mLastState + 0;
                                jArr[i] = jArr[i] + (uptime - ass.mLastStateUptime);
                                ass.mLastState = state;
                                ass.mLastStateUptime = uptime;
                            }
                        }
                    }
                }
            }
        }
    }

    private final int computeOomAdjLocked(ProcessRecord app, int cachedAdj, ProcessRecord TOP_APP, boolean doingAll, long now) {
        if (this.mAdjSeq == app.adjSeq) {
            return app.curRawAdj;
        }
        if (app.thread == null) {
            app.adjSeq = this.mAdjSeq;
            app.curSchedGroup = 0;
            app.curProcState = 17;
            app.curRawAdj = 906;
            app.curAdj = 906;
            return 906;
        }
        app.adjTypeCode = 0;
        app.adjSource = null;
        app.adjTarget = null;
        app.empty = false;
        app.cached = false;
        int activitiesSize = app.activities.size();
        int j;
        if (app.maxAdj <= 0) {
            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                Slog.d(TAG, "Making fixed: " + app);
            }
            app.adjType = "fixed";
            app.adjSeq = this.mAdjSeq;
            app.curRawAdj = app.maxAdj;
            app.foregroundActivities = false;
            app.curSchedGroup = 1;
            app.curProcState = 0;
            app.systemNoUi = true;
            if (app == TOP_APP) {
                app.systemNoUi = false;
                app.curSchedGroup = 2;
                app.adjType = "pers-top-activity";
            } else if (app.hasTopUi) {
                app.systemNoUi = false;
                app.curSchedGroup = 2;
                app.adjType = "pers-top-ui";
            } else if (activitiesSize > 0) {
                for (j = 0; j < activitiesSize; j++) {
                    if (((ActivityRecord) app.activities.get(j)).visible) {
                        app.systemNoUi = false;
                    }
                }
            }
            if (!app.systemNoUi) {
                app.curProcState = 1;
            }
            int i = app.maxAdj;
            app.curAdj = i;
            return i;
        }
        int adj;
        int schedGroup;
        int procState;
        int i2;
        ProcessRecord client;
        int clientAdj;
        int clientProcState;
        String adjType;
        app.systemNoUi = false;
        int PROCESS_STATE_CUR_TOP = this.mTopProcessState;
        boolean foregroundActivities = false;
        this.mTmpBroadcastQueue.clear();
        if (app == TOP_APP) {
            adj = 0;
            schedGroup = 2;
            app.adjType = "top-activity";
            foregroundActivities = true;
            procState = PROCESS_STATE_CUR_TOP;
            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                Slog.d(TAG, "Making top: " + app);
            }
        } else if (app.instr != null) {
            adj = 0;
            schedGroup = 1;
            app.adjType = "instrumentation";
            procState = 4;
            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                Slog.d(TAG, "Making instrumentation: " + app);
            }
        } else {
            if (isReceivingBroadcastLocked(app, this.mTmpBroadcastQueue)) {
                adj = 0;
                schedGroup = (this.mTmpBroadcastQueue.contains(this.mFgBroadcastQueue) || this.mTmpBroadcastQueue.contains(OppoBroadcastManager.getInstance(this).mOppoFgBroadcastQueue)) ? 1 : 0;
                app.adjType = "broadcast";
                procState = 12;
                if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                    Slog.d(TAG, "Making broadcast: " + app);
                }
            } else if (app.executingServices.size() > 0) {
                adj = 0;
                schedGroup = app.execServicesFg ? 1 : 0;
                app.adjType = "exec-service";
                procState = 11;
                if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                    Slog.d(TAG, "Making exec-service: " + app);
                }
            } else {
                schedGroup = 0;
                adj = cachedAdj;
                procState = 17;
                app.cached = true;
                app.empty = true;
                app.adjType = "cch-empty";
                if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                    Slog.d(TAG, "Making empty: " + app);
                }
            }
        }
        if (!foregroundActivities && activitiesSize > 0) {
            int minLayer = 99;
            j = 0;
            while (j < activitiesSize) {
                ActivityRecord r = (ActivityRecord) app.activities.get(j);
                if (r.app != app) {
                    Log.e(TAG, "Found activity " + r + " in proc activity list using " + r.app + " instead of expected " + app);
                    if (r.app == null || r.app.uid == app.uid) {
                        r.app = app;
                    } else {
                        j++;
                    }
                }
                if (r.visible) {
                    if (adj > 100) {
                        adj = 100;
                        app.adjType = "vis-activity";
                        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                            Slog.d(TAG, "Raise to vis-activity: " + app);
                        }
                    }
                    if (procState > PROCESS_STATE_CUR_TOP) {
                        procState = PROCESS_STATE_CUR_TOP;
                        app.adjType = "vis-activity";
                        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                            Slog.d(TAG, "Raise to vis-activity: " + app);
                        }
                    }
                    schedGroup = 1;
                    app.cached = false;
                    app.empty = false;
                    foregroundActivities = true;
                    TaskRecord task = r.getTask();
                    if (task != null) {
                        int layer = task.mLayerRank;
                        if (layer >= 0 && 99 > layer) {
                            minLayer = layer;
                        }
                    }
                    if (adj == 100) {
                        adj += minLayer;
                    }
                } else if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
                    if (adj > 200) {
                        adj = 200;
                        app.adjType = "pause-activity";
                        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                            Slog.d(TAG, "Raise to pause-activity: " + app);
                        }
                    }
                    if (procState > PROCESS_STATE_CUR_TOP) {
                        procState = PROCESS_STATE_CUR_TOP;
                        app.adjType = "pause-activity";
                        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                            Slog.d(TAG, "Raise to pause-activity: " + app);
                        }
                    }
                    schedGroup = 1;
                    app.cached = false;
                    app.empty = false;
                    foregroundActivities = true;
                    j++;
                } else {
                    if (r.state == ActivityState.STOPPING) {
                        if (adj > 200) {
                            adj = 200;
                            app.adjType = "stop-activity";
                            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                                Slog.d(TAG, "Raise to stop-activity: " + app);
                            }
                        }
                        if (!r.finishing && procState > 14) {
                            procState = 14;
                            app.adjType = "stop-activity";
                            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                                Slog.d(TAG, "Raise to stop-activity: " + app);
                            }
                        }
                        app.cached = false;
                        app.empty = false;
                        foregroundActivities = true;
                    } else if (procState > 15) {
                        procState = 15;
                        app.adjType = "cch-act";
                        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                            Slog.d(TAG, "Raise to cached activity: " + app);
                        }
                    }
                    j++;
                }
            }
            if (adj == 100) {
                adj += minLayer;
            }
        }
        if (adj > 200 || procState > 4) {
            if (app.foregroundServices) {
                adj = 200;
                procState = 4;
                app.cached = false;
                app.adjType = "fg-service";
                schedGroup = 1;
                if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                    Slog.d(TAG, "Raise to fg service: " + app);
                }
            } else if (app.hasOverlayUi) {
                adj = 200;
                procState = 6;
                app.cached = false;
                app.adjType = "has-overlay-ui";
                schedGroup = 1;
                if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                    Slog.d(TAG, "Raise to overlay ui: " + app);
                }
            }
        }
        if ((adj > 200 || procState > 8) && app.forcingToImportant != null) {
            adj = 200;
            procState = 8;
            app.cached = false;
            app.adjType = "force-imp";
            app.adjSource = app.forcingToImportant;
            schedGroup = 1;
            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                Slog.d(TAG, "Raise to force imp: " + app);
            }
        }
        if (app == this.mHeavyWeightProcess) {
            if (adj > 400) {
                adj = 400;
                schedGroup = 0;
                app.cached = false;
                app.adjType = "heavy";
                if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                    Slog.d(TAG, "Raise to heavy: " + app);
                }
            }
            if (procState > 10) {
                procState = 10;
                app.adjType = "heavy";
                if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                    Slog.d(TAG, "Raise to heavy: " + app);
                }
            }
        }
        if (app == this.mHomeProcess) {
            if (adj > 600) {
                adj = 600;
                schedGroup = 0;
                app.cached = false;
                app.adjType = "home";
                if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                    Slog.d(TAG, "Raise to home: " + app);
                }
            }
            if (procState > 13) {
                procState = 13;
                app.adjType = "home";
                if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                    Slog.d(TAG, "Raise to home: " + app);
                }
            }
        }
        if (app == this.mPreviousProcess && app.activities.size() > 0) {
            if (adj > START_OPPO_SITE_MSG) {
                adj = START_OPPO_SITE_MSG;
                schedGroup = 0;
                app.cached = false;
                app.adjType = "previous";
                if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                    Slog.d(TAG, "Raise to prev: " + app);
                }
            }
            if (procState > 14) {
                procState = 14;
                app.adjType = "previous";
                if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                    Slog.d(TAG, "Raise to prev: " + app);
                }
            }
        }
        app.adjSeq = this.mAdjSeq;
        app.curRawAdj = adj;
        app.hasStartedServices = false;
        if (this.mBackupTarget != null && app == this.mBackupTarget.app) {
            if (adj > 300) {
                if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
                    Slog.v(TAG_BACKUP, "oom BACKUP_APP_ADJ for " + app);
                }
                adj = 300;
                if (procState > 8) {
                    procState = 8;
                }
                app.adjType = "backup";
                if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                    Slog.d(TAG, "Raise to backup: " + app);
                }
                app.cached = false;
            }
            if (procState > 9) {
                procState = 9;
                app.adjType = "backup";
                if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                    Slog.d(TAG, "Raise to backup: " + app);
                }
            }
        }
        boolean mayBeTop = false;
        String mayBeTopType = null;
        Object mayBeTopSource = null;
        Object mayBeTopTarget = null;
        for (int is = app.services.size() - 1; is >= 0 && (adj > 0 || schedGroup == 0 || procState > 2); is--) {
            ServiceRecord s = (ServiceRecord) app.services.valueAt(is);
            if (s.startRequested) {
                app.hasStartedServices = true;
                if (procState > 11) {
                    procState = 11;
                    app.adjType = "started-services";
                    if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                        Slog.d(TAG, "Raise to started service: " + app);
                    }
                }
                if (!app.hasShownUi || app == this.mHomeProcess) {
                    if (now < s.lastActivity + this.mConstants.MAX_SERVICE_INACTIVITY && adj > 500) {
                        adj = 500;
                        app.adjType = "started-services";
                        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                            Slog.d(TAG, "Raise to started service: " + app);
                        }
                        app.cached = false;
                    }
                    if (adj > 500) {
                        app.adjType = "cch-started-services";
                    }
                } else if (adj > 500) {
                    app.adjType = "cch-started-ui-services";
                }
            }
            for (int conni = s.connections.size() - 1; conni >= 0 && (adj > 0 || schedGroup == 0 || procState > 2); conni--) {
                ArrayList<ConnectionRecord> clist = (ArrayList) s.connections.valueAt(conni);
                for (i2 = 0; i2 < clist.size() && (adj > 0 || schedGroup == 0 || procState > 2); i2++) {
                    ConnectionRecord cr = (ConnectionRecord) clist.get(i2);
                    if (cr.binding.client != app) {
                        if ((cr.flags & 32) == 0) {
                            client = cr.binding.client;
                            clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);
                            clientProcState = client.curProcState;
                            if (clientProcState >= 15) {
                                clientProcState = 17;
                            }
                            adjType = null;
                            if ((cr.flags & 16) != 0) {
                                if (app.hasShownUi && app != this.mHomeProcess) {
                                    if (adj > clientAdj) {
                                        adjType = "cch-bound-ui-services";
                                    }
                                    app.cached = false;
                                    clientAdj = adj;
                                    clientProcState = procState;
                                } else if (now >= s.lastActivity + this.mConstants.MAX_SERVICE_INACTIVITY) {
                                    if (adj > clientAdj) {
                                        adjType = "cch-bound-services";
                                    }
                                    clientAdj = adj;
                                }
                            }
                            if (adj > clientAdj) {
                                if (!app.hasShownUi || app == this.mHomeProcess || clientAdj <= 200) {
                                    int newAdj = (cr.flags & 72) != 0 ? clientAdj >= -700 ? clientAdj : -700 : ((cr.flags & 1073741824) == 0 || clientAdj >= 200 || adj <= 200) ? clientAdj >= 200 ? clientAdj : adj > 100 ? Math.max(clientAdj, 100) : adj : 200;
                                    if (!client.cached) {
                                        app.cached = false;
                                    }
                                    if (adj > newAdj) {
                                        adj = newAdj;
                                        adjType = "service";
                                    }
                                } else if (adj >= 900) {
                                    adjType = "cch-bound-ui-services";
                                }
                            }
                            if ((cr.flags & 8388612) == 0) {
                                if (client.curSchedGroup > schedGroup) {
                                    if ((cr.flags & 64) != 0) {
                                        schedGroup = client.curSchedGroup;
                                    } else {
                                        schedGroup = 1;
                                    }
                                }
                                if (clientProcState <= 2) {
                                    if (clientProcState == 2) {
                                        mayBeTop = true;
                                        mayBeTopType = "service";
                                        mayBeTopSource = cr.binding.client;
                                        mayBeTopTarget = s.name;
                                        clientProcState = 17;
                                    } else if ((cr.flags & 67108864) != 0) {
                                        clientProcState = 3;
                                    } else if (this.mWakefulness != 1 || (cr.flags & PhoneWindowManager.SYSTEM_UI_FLAG_APP_CUSTOM_NAVIGATION_BAR) == 0) {
                                        clientProcState = 6;
                                    } else {
                                        clientProcState = 3;
                                    }
                                }
                            } else if ((cr.flags & DumpState.DUMP_VOLUMES) == 0) {
                                if (clientProcState < 8) {
                                    clientProcState = 8;
                                }
                            } else if (clientProcState < 7) {
                                clientProcState = 7;
                            }
                            if (procState > clientProcState) {
                                procState = clientProcState;
                                if (adjType == null) {
                                    adjType = "service";
                                }
                            }
                            if (procState < 7 && (cr.flags & 536870912) != 0) {
                                app.pendingUiClean = true;
                            }
                            if (adjType != null) {
                                app.adjType = adjType;
                                app.adjTypeCode = 2;
                                app.adjSource = cr.binding.client;
                                app.adjSourceProcState = clientProcState;
                                app.adjTarget = s.name;
                                if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                                    Slog.d(TAG, "Raise to " + adjType + ": " + app + ", due to " + cr.binding.client + " adj=" + adj + " procState=" + procState);
                                }
                            }
                        }
                        if ((cr.flags & 134217728) != 0) {
                            app.treatLikeActivity = true;
                        }
                        ActivityRecord a = cr.activity;
                        if ((cr.flags & 128) != 0 && a != null && adj > 0 && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
                            adj = 0;
                            if ((cr.flags & 4) == 0) {
                                if ((cr.flags & 64) != 0) {
                                    schedGroup = 3;
                                } else {
                                    schedGroup = 1;
                                }
                            }
                            app.cached = false;
                            app.adjType = "service";
                            app.adjTypeCode = 2;
                            app.adjSource = a;
                            app.adjSourceProcState = procState;
                            app.adjTarget = s.name;
                            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                                Slog.d(TAG, "Raise to service w/activity: " + app);
                            }
                        }
                    }
                }
            }
        }
        for (int provi = app.pubProviders.size() - 1; provi >= 0 && (adj > 0 || schedGroup == 0 || procState > 2); provi--) {
            ContentProviderRecord cpr = (ContentProviderRecord) app.pubProviders.valueAt(provi);
            for (i2 = cpr.connections.size() - 1; i2 >= 0 && (adj > 0 || schedGroup == 0 || procState > 2); i2--) {
                client = ((ContentProviderConnection) cpr.connections.get(i2)).client;
                if (client != app) {
                    clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);
                    clientProcState = client.curProcState;
                    if (clientProcState >= 15) {
                        clientProcState = 17;
                    }
                    adjType = null;
                    if (adj > clientAdj) {
                        if (!app.hasShownUi || app == this.mHomeProcess || clientAdj <= 200) {
                            adj = clientAdj > 0 ? clientAdj : 0;
                            adjType = "provider";
                        } else {
                            adjType = "cch-ui-provider";
                        }
                        app.cached &= client.cached;
                    }
                    if (clientProcState <= 2) {
                        if (clientProcState == 2) {
                            mayBeTop = true;
                            clientProcState = 17;
                            adjType = "provider-top";
                            mayBeTopType = adjType;
                            mayBeTopSource = client;
                            mayBeTopTarget = cpr.name;
                        } else {
                            clientProcState = 3;
                            if (adjType == null) {
                                adjType = "provider";
                            }
                        }
                    }
                    if (procState > clientProcState) {
                        procState = clientProcState;
                    }
                    if (client.curSchedGroup > schedGroup) {
                        schedGroup = 1;
                    }
                    if (adjType != null) {
                        app.adjType = adjType;
                        app.adjTypeCode = 1;
                        app.adjSource = client;
                        app.adjSourceProcState = clientProcState;
                        app.adjTarget = cpr.name;
                        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                            Slog.d(TAG, "Raise to " + adjType + ": " + app + ", due to " + client + " adj=" + adj + " procState=" + procState);
                        }
                    }
                }
            }
            if (cpr.hasExternalProcessHandles()) {
                if (adj > 0) {
                    adj = 0;
                    schedGroup = 1;
                    app.cached = false;
                    app.adjType = "ext-provider";
                    app.adjTarget = cpr.name;
                    if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                        Slog.d(TAG, "Raise to external provider: " + app);
                    }
                }
                if (procState > 6) {
                    procState = 6;
                }
            }
        }
        if (app.lastProviderTime > 0 && app.lastProviderTime + this.mConstants.CONTENT_PROVIDER_RETAIN_TIME > now) {
            if (adj > START_OPPO_SITE_MSG) {
                adj = START_OPPO_SITE_MSG;
                schedGroup = 0;
                app.cached = false;
                app.adjType = "recent-provider";
                if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                    Slog.d(TAG, "Raise to recent provider: " + app);
                }
            }
            if (procState > 14) {
                procState = 14;
                app.adjType = "recent-provider";
                if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                    Slog.d(TAG, "Raise to recent provider: " + app);
                }
            }
        }
        if (mayBeTop && procState > 2) {
            switch (procState) {
                case 3:
                    break;
                case 6:
                case 7:
                case 8:
                case 11:
                    procState = 3;
                    app.adjType = mayBeTopType;
                    app.adjSource = mayBeTopSource;
                    app.adjTarget = mayBeTopTarget;
                    if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                        Slog.d(TAG, "May be top raise to " + mayBeTopType + ": " + app + ", due to " + mayBeTopSource + " adj=" + adj + " procState=" + 3);
                        break;
                    }
                    break;
                default:
                    procState = 2;
                    app.adjType = mayBeTopType;
                    app.adjSource = mayBeTopSource;
                    app.adjTarget = mayBeTopTarget;
                    if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ_REASON) {
                        Slog.d(TAG, "May be top raise to " + mayBeTopType + ": " + app + ", due to " + mayBeTopSource + " adj=" + adj + " procState=" + 2);
                        break;
                    }
                    break;
            }
        }
        if (procState >= 17) {
            if (app.hasClientActivities) {
                procState = 16;
                app.adjType = "cch-client-act";
            } else if (app.treatLikeActivity) {
                procState = 15;
                app.adjType = "cch-as-act";
            }
        }
        if (adj == 500) {
            if (doingAll) {
                app.serviceb = this.mNewNumAServiceProcs > this.mNumServiceProcs / 3;
                this.mNewNumServiceProcs++;
                if (app.serviceb) {
                    app.serviceHighRam = false;
                } else if (this.mLastMemoryLevel <= 0 || app.lastPss < this.mProcessList.getCachedRestoreThresholdKb()) {
                    this.mNewNumAServiceProcs++;
                } else {
                    app.serviceHighRam = true;
                    app.serviceb = true;
                }
            }
            if (app.serviceb) {
                adj = 800;
            }
        }
        if (app.info.uid == 1000 && app.processName != null) {
            if (isAgingTestTool(app.processName)) {
                adj = 0;
            }
        }
        if (!(app == TOP_APP || app.processName == null)) {
            if (isOppoImportantApp(app.processName) && adj > START_OPPO_SITE_MSG) {
                adj = START_OPPO_SITE_MSG;
                app.adjType = "previous";
                schedGroup = 0;
                app.cached = false;
            }
        }
        app.curRawAdj = adj;
        if (adj > app.maxAdj) {
            adj = app.maxAdj;
            if (app.maxAdj <= 200) {
                schedGroup = 1;
            }
        }
        app.curAdj = app.modifyRawOomAdj(adj);
        app.curSchedGroup = schedGroup;
        app.curProcState = procState;
        app.foregroundActivities = foregroundActivities;
        return app.curRawAdj;
    }

    private boolean isAgingTestTool(String processName) {
        return !processName.contains("com.oppo.qetest") ? processName.contains("com.oppo.qemonitor") : true;
    }

    private boolean isOppoImportantApp(String processName) {
        if (processName.equals(TENCENT_NAME)) {
            return true;
        }
        return false;
    }

    void recordPssSampleLocked(ProcessRecord proc, int procState, long pss, long uss, long swapPss, long now) {
        EventLogTags.writeAmPss(proc.pid, proc.uid, proc.processName, 1024 * pss, 1024 * uss, 1024 * swapPss);
        proc.lastPssTime = now;
        try {
            proc.baseProcessTracker.addPss(pss, uss, true, proc.pkgList);
        } catch (Exception e) {
            Slog.d(TAG_PSS, "PSS of " + proc.toShortString() + ": " + pss + " lastPss=" + proc.lastPss + " state=" + ProcessList.makeProcStateString(procState));
            Slog.d(TAG_PSS, "addPss exception " + e);
        }
        if (ActivityManagerDebugConfig.DEBUG_PSS) {
            Slog.d(TAG_PSS, "PSS of " + proc.toShortString() + ": " + pss + " lastPss=" + proc.lastPss + " state=" + ProcessList.makeProcStateString(procState));
        }
        if (proc.initialIdlePss == 0) {
            proc.initialIdlePss = pss;
        }
        proc.lastPss = pss;
        proc.lastSwapPss = swapPss;
        if (procState >= 13) {
            proc.lastCachedPss = pss;
            proc.lastCachedSwapPss = swapPss;
        }
        SparseArray<Pair<Long, String>> watchUids = (SparseArray) this.mMemWatchProcesses.getMap().get(proc.processName);
        Long l = null;
        if (watchUids != null) {
            Pair<Long, String> val = (Pair) watchUids.get(proc.uid);
            if (val == null) {
                val = (Pair) watchUids.get(0);
            }
            if (val != null) {
                l = val.first;
            }
        }
        if (l != null && 1024 * pss >= l.longValue() && proc.thread != null && this.mMemWatchDumpProcName == null) {
            boolean isDebuggable = LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
            if (!(isDebuggable || (proc.info.flags & 2) == 0)) {
                isDebuggable = true;
            }
            if (isDebuggable) {
                Slog.w(TAG, "Process " + proc + " exceeded pss limit " + l + "; reporting");
                ProcessRecord myProc = proc;
                final File heapdumpFile = DumpHeapProvider.getJavaFile();
                this.mMemWatchDumpProcName = proc.processName;
                this.mMemWatchDumpFile = heapdumpFile.toString();
                this.mMemWatchDumpPid = proc.pid;
                this.mMemWatchDumpUid = proc.uid;
                final ProcessRecord processRecord = proc;
                BackgroundThread.getHandler().post(new Runnable() {
                    public void run() {
                        ActivityManagerService.this.revokeUriPermission(ActivityThread.currentActivityThread().getApplicationThread(), null, DumpHeapActivity.JAVA_URI, 3, UserHandle.myUserId());
                        ParcelFileDescriptor fd = null;
                        try {
                            heapdumpFile.delete();
                            fd = ParcelFileDescriptor.open(heapdumpFile, 771751936);
                            IApplicationThread thread = processRecord.thread;
                            if (thread != null) {
                                try {
                                    if (ActivityManagerDebugConfig.DEBUG_PSS) {
                                        Slog.d(ActivityManagerService.TAG_PSS, "Requesting dump heap from " + processRecord + " to " + heapdumpFile);
                                    }
                                    thread.dumpHeap(true, false, false, heapdumpFile.toString(), fd);
                                } catch (RemoteException e) {
                                }
                            }
                            if (fd != null) {
                                try {
                                    fd.close();
                                } catch (IOException e2) {
                                }
                            }
                        } catch (FileNotFoundException e3) {
                            e3.printStackTrace();
                            if (fd != null) {
                                try {
                                    fd.close();
                                } catch (IOException e4) {
                                }
                            }
                        } catch (Throwable th) {
                            if (fd != null) {
                                try {
                                    fd.close();
                                } catch (IOException e5) {
                                }
                            }
                        }
                    }
                });
                return;
            }
            Slog.w(TAG, "Process " + proc + " exceeded pss limit " + l + ", but debugging not enabled");
        }
    }

    void requestPssLocked(ProcessRecord proc, int procState) {
        if (!this.mPendingPssProcesses.contains(proc)) {
            if (this.mPendingPssProcesses.size() == 0) {
                this.mBgHandler.sendEmptyMessage(1);
            }
            if (ActivityManagerDebugConfig.DEBUG_PSS) {
                Slog.d(TAG_PSS, "Requesting PSS of: " + proc);
            }
            proc.pssProcState = procState;
            this.mPendingPssProcesses.add(proc);
        }
    }

    void requestPssAllProcsLocked(long now, boolean always, boolean memLowered) {
        if (!always) {
            long j;
            long j2 = this.mLastFullPssTime;
            if (memLowered) {
                j = this.mConstants.FULL_PSS_LOWERED_INTERVAL;
            } else {
                j = this.mConstants.FULL_PSS_MIN_INTERVAL;
            }
            if (now < j + j2) {
                return;
            }
        }
        if (ActivityManagerDebugConfig.DEBUG_PSS) {
            Slog.d(TAG_PSS, "Requesting PSS of all procs!  memLowered=" + memLowered);
        }
        this.mLastFullPssTime = now;
        this.mFullPssPending = true;
        this.mPendingPssProcesses.ensureCapacity(this.mLruProcesses.size());
        this.mPendingPssProcesses.clear();
        for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
            if (!(app.thread == null || app.curProcState == 18 || (!memLowered && now <= app.lastStateTime + LocationFudger.FASTEST_INTERVAL_MS))) {
                app.pssProcState = app.setProcState;
                app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, true, this.mTestPssMode, isSleepingLocked(), now);
                this.mPendingPssProcesses.add(app);
            }
        }
        this.mBgHandler.sendEmptyMessage(1);
    }

    public void setTestPssMode(boolean enabled) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mTestPssMode = enabled;
                if (enabled) {
                    requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, true);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    final void performAppGcLocked(ProcessRecord app) {
        try {
            app.lastRequestedGc = SystemClock.uptimeMillis();
            if (app.thread == null) {
                return;
            }
            if (app.reportLowMemory) {
                app.reportLowMemory = false;
                app.thread.scheduleLowMemory();
                return;
            }
            app.thread.processInBackground();
        } catch (Exception e) {
        }
    }

    private final boolean canGcNowLocked() {
        boolean processingBroadcasts = false;
        for (BroadcastQueue q : this.mBroadcastQueues) {
            if (q.mParallelBroadcasts.size() != 0 || q.mOrderedBroadcasts.size() != 0) {
                processingBroadcasts = true;
            }
        }
        if (processingBroadcasts) {
            return false;
        }
        return !isSleepingLocked() ? this.mStackSupervisor.allResumedActivitiesIdle() : true;
    }

    final void performAppGcsLocked() {
        if (this.mProcessesToGc.size() > 0 && canGcNowLocked()) {
            while (this.mProcessesToGc.size() > 0) {
                ProcessRecord proc = (ProcessRecord) this.mProcessesToGc.remove(0);
                if (proc.curRawAdj <= 200) {
                    if (proc.reportLowMemory) {
                    }
                }
                if (proc.lastRequestedGc + this.mConstants.GC_MIN_INTERVAL <= SystemClock.uptimeMillis()) {
                    performAppGcLocked(proc);
                    scheduleAppGcsLocked();
                    return;
                }
                addProcessToGcListLocked(proc);
                scheduleAppGcsLocked();
            }
            scheduleAppGcsLocked();
        }
    }

    final void performAppGcsIfAppropriateLocked() {
        if (canGcNowLocked()) {
            performAppGcsLocked();
        } else {
            scheduleAppGcsLocked();
        }
    }

    final void scheduleAppGcsLocked() {
        this.mHandler.removeMessages(5);
        if (this.mProcessesToGc.size() > 0) {
            ProcessRecord proc = (ProcessRecord) this.mProcessesToGc.get(0);
            Message msg = this.mHandler.obtainMessage(5);
            long when = proc.lastRequestedGc + this.mConstants.GC_MIN_INTERVAL;
            long now = SystemClock.uptimeMillis();
            if (when < this.mConstants.GC_TIMEOUT + now) {
                when = now + this.mConstants.GC_TIMEOUT;
            }
            this.mHandler.sendMessageAtTime(msg, when);
        }
    }

    final void addProcessToGcListLocked(ProcessRecord proc) {
        boolean added = false;
        for (int i = this.mProcessesToGc.size() - 1; i >= 0; i--) {
            if (((ProcessRecord) this.mProcessesToGc.get(i)).lastRequestedGc < proc.lastRequestedGc) {
                added = true;
                this.mProcessesToGc.add(i + 1, proc);
                break;
            }
        }
        if (!added) {
            this.mProcessesToGc.add(0, proc);
        }
    }

    final void scheduleAppGcLocked(ProcessRecord app) {
        if (app.lastRequestedGc + this.mConstants.GC_MIN_INTERVAL <= SystemClock.uptimeMillis() && !this.mProcessesToGc.contains(app)) {
            addProcessToGcListLocked(app);
            scheduleAppGcsLocked();
        }
    }

    final void checkExcessivePowerUsageLocked() {
        updateCpuStatsNow();
        BatteryStatsImpl stats = this.mBatteryStatsService.getActiveStatistics();
        boolean doCpuKills = true;
        if (this.mLastPowerCheckUptime == 0) {
            doCpuKills = false;
        }
        long curUptime = SystemClock.uptimeMillis();
        long uptimeSince = curUptime - this.mLastPowerCheckUptime;
        this.mLastPowerCheckUptime = curUptime;
        int i = this.mLruProcesses.size();
        while (i > 0) {
            i--;
            ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
            if (app.setProcState >= 13 && app.lastCpuTime > 0) {
                long cputimeUsed = app.curCpuTime - app.lastCpuTime;
                if (ActivityManagerDebugConfig.DEBUG_POWER) {
                    StringBuilder stringBuilder = new StringBuilder(128);
                    stringBuilder.append("CPU for ");
                    app.toShortString(stringBuilder);
                    stringBuilder.append(": over ");
                    TimeUtils.formatDuration(uptimeSince, stringBuilder);
                    stringBuilder.append(" used ");
                    TimeUtils.formatDuration(cputimeUsed, stringBuilder);
                    stringBuilder.append(" (");
                    stringBuilder.append((100 * cputimeUsed) / uptimeSince);
                    stringBuilder.append("%)");
                    Slog.i(TAG_POWER, stringBuilder.toString());
                }
                if (doCpuKills && uptimeSince > 0) {
                    int cpuLimit;
                    long checkDur = curUptime - app.whenUnimportant;
                    if (checkDur <= this.mConstants.POWER_CHECK_INTERVAL) {
                        cpuLimit = this.mConstants.POWER_CHECK_MAX_CPU_1;
                    } else if (checkDur <= this.mConstants.POWER_CHECK_INTERVAL * 2 || app.setProcState <= 13) {
                        cpuLimit = this.mConstants.POWER_CHECK_MAX_CPU_2;
                    } else if (checkDur <= this.mConstants.POWER_CHECK_INTERVAL * 3) {
                        cpuLimit = this.mConstants.POWER_CHECK_MAX_CPU_3;
                    } else {
                        cpuLimit = this.mConstants.POWER_CHECK_MAX_CPU_4;
                    }
                    if ((100 * cputimeUsed) / uptimeSince >= ((long) cpuLimit)) {
                        synchronized (stats) {
                            stats.reportExcessiveCpuLocked(app.info.uid, app.processName, uptimeSince, cputimeUsed);
                        }
                        app.kill("excessive cpu " + cputimeUsed + " during " + uptimeSince + " dur=" + checkDur + " limit=" + cpuLimit, true);
                        try {
                            if (app.baseProcessTracker != null) {
                                app.baseProcessTracker.reportExcessiveCpu(app.pkgList);
                            }
                        } catch (Exception e) {
                            Slog.v(TAG, "Exception " + e + " app " + app);
                        }
                    }
                }
                app.lastCpuTime = app.curCpuTime;
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "ZhiYong.Lin@Plf.Framework, modify for BPM", property = OppoRomType.ROM)
    private final boolean applyOomAdjLocked(ProcessRecord app, boolean doingAll, long now, long nowElapsed) {
        boolean success = true;
        if (app.curRawAdj != app.setRawAdj) {
            int i;
            StringBuilder append = new StringBuilder().append("app_uid=").append(app.uid).append(",app_pid=").append(app.pid).append(",oom_adj=").append(app.curAdj).append(",setAdj=").append(app.setAdj).append(",hasShownUi=").append(app.hasShownUi ? 1 : 0).append(",cached=").append(app.cached ? 1 : 0).append(",fA=").append(app.foregroundActivities ? 1 : 0).append(",fS=");
            if (app.foregroundServices) {
                i = 1;
            } else {
                i = 0;
            }
            append = append.append(i).append(",systemNoUi=");
            if (app.systemNoUi) {
                i = 1;
            } else {
                i = 0;
            }
            append = append.append(i).append(",curSchedGroup=").append(app.curSchedGroup).append(",curProcState=").append(app.curProcState).append(",setProcState=").append(app.setProcState).append(",killed=");
            if (app.killed) {
                i = 1;
            } else {
                i = 0;
            }
            append = append.append(i).append(",killedByAm=");
            if (app.killedByAm) {
                i = 1;
            } else {
                i = 0;
            }
            append = append.append(i).append(",debugging=");
            if (app.debugging) {
                i = 1;
            } else {
                i = 0;
            }
            SeempLog.record_str(385, append.append(i).toString());
            app.setRawAdj = app.curRawAdj;
        }
        int changes = 0;
        boolean isAdjUnChanged = true;
        if (app.curAdj != app.setAdj) {
            ProcessList.setOomAdj(app.pid, app.uid, app.curAdj);
            OppoProcessManagerHelper.updateProcessState(app);
            isAdjUnChanged = false;
            if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ || this.mCurOomAdjUid == app.info.uid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Set " + app.pid + " " + app.processName + " adj " + app.curAdj + ": " + app.adjType);
            }
            app.setAdj = app.curAdj;
            app.verifiedAdj = -10000;
        }
        if (app.setSchedGroup != app.curSchedGroup) {
            if (isAdjUnChanged && app.adjType != null && "top-activity".equals(app.adjType)) {
                OppoProcessManagerHelper.updateProcessState(app);
                Slog.v("OppoProcessManager", app.pid + " " + app.processName + " curadj " + app.curAdj + ": " + app.adjType + ": setAdj = " + app.setAdj);
            }
            int oldSchedGroup = app.setSchedGroup;
            app.setSchedGroup = app.curSchedGroup;
            if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ || this.mCurOomAdjUid == app.uid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Setting sched group of " + app.processName + " to " + app.curSchedGroup);
            }
            if (app.waitingToKill != null && app.curReceivers.isEmpty() && app.setSchedGroup == 0) {
                app.kill(app.waitingToKill, true);
                success = false;
            } else {
                int processGroup;
                switch (app.curSchedGroup) {
                    case 0:
                        processGroup = 0;
                        break;
                    case 2:
                    case 3:
                        processGroup = 5;
                        break;
                    default:
                        processGroup = -1;
                        break;
                }
                long oldId = Binder.clearCallingIdentity();
                try {
                    Process.setProcessGroup(app.pid, processGroup);
                    if (app.curSchedGroup == 2) {
                        if (oldSchedGroup != 2) {
                            this.mVrController.onTopProcChangedLocked(app);
                            if (this.mUseFifoUiScheduling) {
                                app.savedPriority = Process.getThreadPriority(app.pid);
                                scheduleAsFifoPriority(app.pid, true);
                                if (app.renderThreadTid != 0) {
                                    scheduleAsFifoPriority(app.renderThreadTid, true);
                                    if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                        Slog.d("UI_FIFO", "Set RenderThread (TID " + app.renderThreadTid + ") to FIFO");
                                    }
                                } else if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                    Slog.d("UI_FIFO", "Not setting RenderThread TID");
                                }
                            } else {
                                Process.setThreadPriority(app.pid, -10);
                                if (app.renderThreadTid != 0) {
                                    try {
                                        Process.setThreadPriority(app.renderThreadTid, -10);
                                    } catch (IllegalArgumentException e) {
                                    }
                                }
                            }
                        }
                    } else if (oldSchedGroup == 2) {
                        if (app.curSchedGroup != 2) {
                            this.mVrController.onTopProcChangedLocked(app);
                            if (this.mUseFifoUiScheduling) {
                                try {
                                    Process.setThreadScheduler(app.pid, 0, 0);
                                    Process.setThreadPriority(app.pid, app.savedPriority);
                                    if (app.renderThreadTid != 0) {
                                        Process.setThreadScheduler(app.renderThreadTid, 0, 0);
                                        Process.setThreadPriority(app.renderThreadTid, -4);
                                    }
                                } catch (IllegalArgumentException e2) {
                                    Slog.w(TAG, "Failed to set scheduling policy, thread does not exist:\n" + e2);
                                } catch (SecurityException e3) {
                                    Slog.w(TAG, "Failed to set scheduling policy, not allowed:\n" + e3);
                                }
                            } else {
                                Process.setThreadPriority(app.pid, 0);
                                if (app.renderThreadTid != 0) {
                                    Process.setThreadPriority(app.renderThreadTid, 0);
                                }
                            }
                        }
                    }
                    Binder.restoreCallingIdentity(oldId);
                } catch (Exception e4) {
                } catch (Throwable th) {
                    Binder.restoreCallingIdentity(oldId);
                }
            }
        }
        if (app.repForegroundActivities != app.foregroundActivities) {
            app.repForegroundActivities = app.foregroundActivities;
            changes = 1;
        }
        if (app.repProcState != app.curProcState) {
            app.repProcState = app.curProcState;
            if (app.thread != null) {
                try {
                    app.thread.setProcessState(app.repProcState);
                } catch (RemoteException e5) {
                }
            }
        }
        if (app.setProcState == 18 || ProcessList.procStatesDifferForMem(app.curProcState, app.setProcState)) {
            app.lastStateTime = now;
            app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, true, this.mTestPssMode, isSleepingLocked(), now);
            if (ActivityManagerDebugConfig.DEBUG_PSS) {
                Slog.d(TAG_PSS, "Process state change from " + ProcessList.makeProcStateString(app.setProcState) + " to " + ProcessList.makeProcStateString(app.curProcState) + " next pss in " + (app.nextPssTime - now) + ": " + app);
            }
        } else if (now > app.nextPssTime || (now > app.lastPssTime + 1800000 && now > app.lastStateTime + ProcessList.minTimeFromStateChange(this.mTestPssMode))) {
            requestPssLocked(app, app.setProcState);
            app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, false, this.mTestPssMode, isSleepingLocked(), now);
        }
        if (app.setProcState != app.curProcState) {
            if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ || this.mCurOomAdjUid == app.uid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Proc state change of " + app.processName + " to " + app.curProcState);
            }
            boolean setImportant = app.setProcState < 11;
            boolean curImportant = app.curProcState < 11;
            if (setImportant && (curImportant ^ 1) != 0) {
                app.whenUnimportant = now;
                app.lastCpuTime = 0;
            }
            maybeUpdateUsageStatsLocked(app, nowElapsed);
            app.setProcState = app.curProcState;
            if (app.setProcState >= 13) {
                app.notCachedSinceIdle = false;
            }
            if (doingAll) {
                app.procStateChanged = true;
            } else {
                setProcessTrackerStateLocked(app, this.mProcessStats.getMemFactorLocked(), now);
            }
        } else if (app.reportedInteraction && nowElapsed - app.interactionEventTime > this.mConstants.USAGE_STATS_INTERACTION_INTERVAL) {
            maybeUpdateUsageStatsLocked(app, nowElapsed);
        }
        if (changes != 0) {
            if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                Slog.i(TAG_PROCESS_OBSERVERS, "Changes in " + app + ": " + changes);
            }
            int i2 = this.mPendingProcessChanges.size() - 1;
            ProcessChangeItem item = null;
            while (i2 >= 0) {
                item = (ProcessChangeItem) this.mPendingProcessChanges.get(i2);
                if (item.pid == app.pid) {
                    if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                        Slog.i(TAG_PROCESS_OBSERVERS, "Re-using existing item: " + item);
                    }
                    if (i2 < 0) {
                        int NA = this.mAvailProcessChanges.size();
                        if (NA > 0) {
                            item = (ProcessChangeItem) this.mAvailProcessChanges.remove(NA - 1);
                            if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                                Slog.i(TAG_PROCESS_OBSERVERS, "Retrieving available item: " + item);
                            }
                        } else {
                            item = new ProcessChangeItem();
                            if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                                Slog.i(TAG_PROCESS_OBSERVERS, "Allocating new item: " + item);
                            }
                        }
                        item.changes = 0;
                        item.pid = app.pid;
                        item.uid = app.info.uid;
                        if (this.mPendingProcessChanges.size() == 0) {
                            if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                                Slog.i(TAG_PROCESS_OBSERVERS, "*** Enqueueing dispatch processes changed!");
                            }
                            this.mUiHandler.obtainMessage(31).sendToTarget();
                        }
                        this.mPendingProcessChanges.add(item);
                    }
                    item.changes |= changes;
                    item.foregroundActivities = app.repForegroundActivities;
                    if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                        Slog.i(TAG_PROCESS_OBSERVERS, "Item " + Integer.toHexString(System.identityHashCode(item)) + " " + app.toShortString() + ": changes=" + item.changes + " foreground=" + item.foregroundActivities + " type=" + app.adjType + " source=" + app.adjSource + " target=" + app.adjTarget);
                    }
                } else {
                    i2--;
                }
            }
            if (i2 < 0) {
                int NA2 = this.mAvailProcessChanges.size();
                if (NA2 > 0) {
                    item = (ProcessChangeItem) this.mAvailProcessChanges.remove(NA2 - 1);
                    if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                        Slog.i(TAG_PROCESS_OBSERVERS, "Retrieving available item: " + item);
                    }
                } else {
                    item = new ProcessChangeItem();
                    if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                        Slog.i(TAG_PROCESS_OBSERVERS, "Allocating new item: " + item);
                    }
                }
                item.changes = 0;
                item.pid = app.pid;
                item.uid = app.info.uid;
                if (this.mPendingProcessChanges.size() == 0) {
                    if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                        Slog.i(TAG_PROCESS_OBSERVERS, "*** Enqueueing dispatch processes changed!");
                    }
                    this.mUiHandler.obtainMessage(31).sendToTarget();
                }
                this.mPendingProcessChanges.add(item);
            }
            item.changes |= changes;
            item.foregroundActivities = app.repForegroundActivities;
            if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                Slog.i(TAG_PROCESS_OBSERVERS, "Item " + Integer.toHexString(System.identityHashCode(item)) + " " + app.toShortString() + ": changes=" + item.changes + " foreground=" + item.foregroundActivities + " type=" + app.adjType + " source=" + app.adjSource + " target=" + app.adjTarget);
            }
        }
        return success;
    }

    private boolean isEphemeralLocked(int uid) {
        String[] packages = this.mContext.getPackageManager().getPackagesForUid(uid);
        if (packages == null || packages.length != 1) {
            return false;
        }
        return getPackageManagerInternalLocked().isPackageEphemeral(UserHandle.getUserId(uid), packages[0]);
    }

    final void enqueueUidChangeLocked(UidRecord uidRec, int uid, int change) {
        ChangeItem pendingChange;
        if (uidRec == null || uidRec.pendingChange == null) {
            int i;
            if (this.mPendingUidChanges.size() == 0) {
                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                    Slog.i(TAG_UID_OBSERVERS, "*** Enqueueing dispatch uid changed!");
                }
                this.mUiHandler.obtainMessage(53).sendToTarget();
            }
            int NA = this.mAvailUidChanges.size();
            if (NA > 0) {
                pendingChange = (ChangeItem) this.mAvailUidChanges.remove(NA - 1);
                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                    Slog.i(TAG_UID_OBSERVERS, "Retrieving available item: " + pendingChange);
                }
            } else {
                pendingChange = new ChangeItem();
                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                    Slog.i(TAG_UID_OBSERVERS, "Allocating new item: " + pendingChange);
                }
            }
            if (uidRec != null) {
                uidRec.pendingChange = pendingChange;
                if (!((change & 1) == 0 || (uidRec.idle ^ 1) == 0)) {
                    change |= 2;
                }
            } else if (uid < 0) {
                throw new IllegalArgumentException("No UidRecord or uid");
            }
            pendingChange.uidRecord = uidRec;
            if (uidRec != null) {
                i = uidRec.uid;
            } else {
                i = uid;
            }
            pendingChange.uid = i;
            this.mPendingUidChanges.add(pendingChange);
        } else {
            pendingChange = uidRec.pendingChange;
            if ((change & 6) == 0) {
                change |= pendingChange.change & 6;
            }
            if ((change & 24) == 0) {
                change |= pendingChange.change & 24;
            }
            if ((change & 1) != 0) {
                change &= -13;
                if (!uidRec.idle) {
                    change |= 2;
                }
            }
        }
        pendingChange.change = change;
        pendingChange.processState = uidRec != null ? uidRec.setProcState : 18;
        pendingChange.ephemeral = uidRec != null ? uidRec.ephemeral : isEphemeralLocked(uid);
        pendingChange.procStateSeq = uidRec != null ? uidRec.curProcStateSeq : 0;
        if (uidRec != null) {
            uidRec.lastReportedChange = change;
            uidRec.updateLastDispatchedProcStateSeq(change);
        }
        if (this.mLocalPowerManager != null) {
            if ((change & 4) != 0) {
                this.mLocalPowerManager.uidActive(pendingChange.uid);
            }
            if ((change & 2) != 0) {
                this.mLocalPowerManager.uidIdle(pendingChange.uid);
            }
            if ((change & 1) != 0) {
                this.mLocalPowerManager.uidGone(pendingChange.uid);
            } else {
                this.mLocalPowerManager.updateUidProcState(pendingChange.uid, pendingChange.processState);
            }
        }
    }

    private void maybeUpdateProviderUsageStatsLocked(ProcessRecord app, String providerPkgName, String authority) {
        if (app != null && app.curProcState <= 6) {
            UserState userState = this.mUserController.getStartedUserStateLocked(app.userId);
            if (userState != null) {
                long now = SystemClock.elapsedRealtime();
                Long lastReported = (Long) userState.mProviderLastReportedFg.get(authority);
                if (lastReported == null || lastReported.longValue() < now - 60000) {
                    if (this.mSystemReady) {
                        this.mUsageStatsService.reportContentProviderUsage(authority, providerPkgName, app.userId);
                    }
                    userState.mProviderLastReportedFg.put(authority, Long.valueOf(now));
                }
            }
        }
    }

    private void maybeUpdateUsageStatsLocked(ProcessRecord app, long nowElapsed) {
        if (ActivityManagerDebugConfig.DEBUG_USAGE_STATS) {
            Slog.d(TAG, "Checking proc [" + Arrays.toString(app.getPackageList()) + "] state changes: old = " + app.setProcState + ", new = " + app.curProcState);
        }
        if (this.mUsageStatsService != null) {
            boolean isInteraction;
            if (app.curProcState <= 3) {
                isInteraction = true;
                app.fgInteractionTime = 0;
            } else if (app.curProcState > 5) {
                isInteraction = app.curProcState <= 6;
                app.fgInteractionTime = 0;
            } else if (app.fgInteractionTime == 0) {
                app.fgInteractionTime = nowElapsed;
                isInteraction = false;
            } else {
                isInteraction = nowElapsed > app.fgInteractionTime + this.mConstants.SERVICE_USAGE_INTERACTION_TIME;
            }
            if (isInteraction && (!app.reportedInteraction || nowElapsed - app.interactionEventTime > this.mConstants.USAGE_STATS_INTERACTION_INTERVAL)) {
                app.interactionEventTime = nowElapsed;
                String[] packages = app.getPackageList();
                if (packages != null) {
                    for (String reportEvent : packages) {
                        this.mUsageStatsService.reportEvent(reportEvent, app.userId, 6);
                    }
                }
            }
            app.reportedInteraction = isInteraction;
            if (!isInteraction) {
                app.interactionEventTime = 0;
            }
        }
    }

    private final void setProcessTrackerStateLocked(ProcessRecord proc, int memFactor, long now) {
        if (proc.thread != null && proc.baseProcessTracker != null) {
            try {
                proc.baseProcessTracker.setState(proc.repProcState, memFactor, now, proc.pkgList);
            } catch (Exception e) {
                Slog.d(TAG, "repProcState " + proc.repProcState + " memFactor " + memFactor + " pkgList " + proc.pkgList);
                Slog.d(TAG, "setState Exception " + e);
            }
        }
    }

    private final boolean updateOomAdjLocked(ProcessRecord app, int cachedAdj, ProcessRecord TOP_APP, boolean doingAll, long now) {
        if (app.thread == null) {
            return false;
        }
        computeOomAdjLocked(app, cachedAdj, TOP_APP, doingAll, now);
        return applyOomAdjLocked(app, doingAll, now, SystemClock.elapsedRealtime());
    }

    final void updateProcessForegroundLocked(ProcessRecord proc, boolean isForeground, boolean oomAdj) {
        if (isForeground != proc.foregroundServices) {
            proc.foregroundServices = isForeground;
            ArrayList<ProcessRecord> curProcs = (ArrayList) this.mForegroundPackages.get(proc.info.packageName, proc.info.uid);
            if (isForeground) {
                if (curProcs == null) {
                    curProcs = new ArrayList();
                    this.mForegroundPackages.put(proc.info.packageName, proc.info.uid, curProcs);
                }
                if (!curProcs.contains(proc)) {
                    curProcs.add(proc);
                    this.mBatteryStatsService.noteEvent(OppoBrightUtils.ADJUSTMENT_VIDEO_OUT, proc.info.packageName, proc.info.uid);
                }
            } else if (curProcs != null && curProcs.remove(proc)) {
                this.mBatteryStatsService.noteEvent(OppoBrightUtils.ADJUSTMENT_VIDEO_IN, proc.info.packageName, proc.info.uid);
                if (curProcs.size() <= 0) {
                    this.mForegroundPackages.remove(proc.info.packageName, proc.info.uid);
                }
            }
            if (oomAdj) {
                updateOomAdjLocked();
            }
        }
    }

    private final ActivityRecord resumedAppLocked() {
        String pkg;
        int uid;
        ActivityRecord act = this.mStackSupervisor.getResumedActivityLocked();
        if (act != null) {
            pkg = act.packageName;
            uid = act.info.applicationInfo.uid;
        } else {
            pkg = null;
            uid = -1;
        }
        if (uid != this.mCurResumedUid || (pkg != this.mCurResumedPackage && (pkg == null || (pkg.equals(this.mCurResumedPackage) ^ 1) != 0))) {
            if (this.mCurResumedPackage != null) {
                this.mBatteryStatsService.noteEvent(16387, this.mCurResumedPackage, this.mCurResumedUid);
            }
            this.mCurResumedPackage = pkg;
            this.mCurResumedUid = uid;
            if (this.mCurResumedPackage != null) {
                this.mBatteryStatsService.noteEvent(32771, this.mCurResumedPackage, this.mCurResumedUid);
            }
        }
        return act;
    }

    final boolean updateOomAdjLocked(ProcessRecord app, boolean oomAdjAll) {
        ActivityRecord TOP_ACT = resumedAppLocked();
        ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;
        boolean wasCached = app.cached;
        this.mAdjSeq++;
        boolean success = updateOomAdjLocked(app, app.curRawAdj >= 900 ? app.curRawAdj : 1001, TOP_APP, false, SystemClock.uptimeMillis());
        if (oomAdjAll && (wasCached != app.cached || app.curRawAdj == 1001)) {
            updateOomAdjLocked();
        }
        return success;
    }

    final ActivityRecord resumedAppLockedForBroadcast() {
        return resumedAppLocked();
    }

    private boolean isQeTestTool(String processName) {
        return !"com.oppo.qetest".equals(processName) ? "com.oppo.qemonitor".equals(processName) : true;
    }

    final void updateOomAdjLocked() {
        int i;
        ProcessRecord app;
        UidRecord uidRec;
        int memFactor;
        ActivityRecord TOP_ACT = resumedAppLocked();
        ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;
        long now = SystemClock.uptimeMillis();
        long nowElapsed = SystemClock.elapsedRealtime();
        long oldTime = now - 1800000;
        int N = this.mLruProcesses.size();
        for (i = this.mActiveUids.size() - 1; i >= 0; i--) {
            ((UidRecord) this.mActiveUids.valueAt(i)).reset();
        }
        this.mStackSupervisor.rankTaskLayersIfNeeded();
        this.mAdjSeq++;
        this.mNewNumServiceProcs = 0;
        this.mNewNumAServiceProcs = 0;
        int emptyProcessLimit = this.mConstants.CUR_MAX_EMPTY_PROCESSES;
        int cachedProcessLimit = this.mConstants.CUR_MAX_CACHED_PROCESSES - emptyProcessLimit;
        int numEmptyProcs = (N - this.mNumNonCachedProcs) - this.mNumCachedHiddenProcs;
        if (numEmptyProcs > cachedProcessLimit) {
            numEmptyProcs = cachedProcessLimit;
        }
        int emptyFactor = numEmptyProcs / 3;
        if (emptyFactor < 1) {
            emptyFactor = 1;
        }
        int cachedFactor = (this.mNumCachedHiddenProcs > 0 ? this.mNumCachedHiddenProcs : 1) / 3;
        if (cachedFactor < 1) {
            cachedFactor = 1;
        }
        int stepCached = 0;
        int stepEmpty = 0;
        int numCached = 0;
        int numEmpty = 0;
        int numTrimming = 0;
        this.mNumNonCachedProcs = 0;
        this.mNumCachedHiddenProcs = 0;
        int curCachedAdj = 900;
        int nextCachedAdj = 901;
        int curEmptyAdj = 900;
        int nextEmptyAdj = 902;
        ProcessRecord selectedAppRecord = null;
        long serviceLastActivity = 0;
        int numBServices = 0;
        for (i = N - 1; i >= 0; i--) {
            app = (ProcessRecord) this.mLruProcesses.get(i);
            if (this.mEnableBServicePropagation && app.serviceb && app.curAdj == 800) {
                numBServices++;
                for (int s = app.services.size() - 1; s >= 0; s--) {
                    ServiceRecord sr = (ServiceRecord) app.services.valueAt(s);
                    if (SystemClock.uptimeMillis() - sr.lastActivity < ((long) this.mMinBServiceAgingTime)) {
                        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                            Slog.d(TAG, "Not aged enough!!!");
                        }
                    } else if (serviceLastActivity == 0) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    } else if (sr.lastActivity < serviceLastActivity) {
                        serviceLastActivity = sr.lastActivity;
                        selectedAppRecord = app;
                    }
                }
            }
            if (!(app.killedByAm || app.thread == null)) {
                app.procStateChanged = false;
                computeOomAdjLocked(app, 1001, TOP_APP, true, now);
                if (app.curAdj >= 1001) {
                    boolean z;
                    switch (app.curProcState) {
                        case 15:
                        case 16:
                            app.curRawAdj = curCachedAdj;
                            app.curAdj = app.modifyRawOomAdj(curCachedAdj);
                            z = ActivityManagerDebugConfig.DEBUG_LRU;
                            if (curCachedAdj != nextCachedAdj) {
                                stepCached++;
                                if (stepCached >= cachedFactor) {
                                    stepCached = 0;
                                    curCachedAdj = nextCachedAdj;
                                    nextCachedAdj += 2;
                                    if (nextCachedAdj > 906) {
                                        nextCachedAdj = 906;
                                        break;
                                    }
                                }
                            }
                            break;
                        default:
                            app.curRawAdj = curEmptyAdj;
                            app.curAdj = app.modifyRawOomAdj(curEmptyAdj);
                            z = ActivityManagerDebugConfig.DEBUG_LRU;
                            if (curEmptyAdj != nextEmptyAdj) {
                                stepEmpty++;
                                if (stepEmpty >= emptyFactor) {
                                    stepEmpty = 0;
                                    curEmptyAdj = nextEmptyAdj;
                                    nextEmptyAdj += 2;
                                    if (nextEmptyAdj > 906) {
                                        nextEmptyAdj = 906;
                                        break;
                                    }
                                }
                            }
                            break;
                    }
                }
                applyOomAdjLocked(app, true, now, nowElapsed);
                switch (app.curProcState) {
                    case 15:
                    case 16:
                        this.mNumCachedHiddenProcs++;
                        numCached++;
                        if (numCached > cachedProcessLimit) {
                            app.kill("cached #" + numCached, true);
                            break;
                        }
                        break;
                    case 17:
                        boolean ignoreProces;
                        boolean isAcoreProcess = "android.process.acore".equals(app.processName);
                        boolean isAlarmProcess = "com.coloros.alarmclock".equals(app.processName);
                        boolean isContactsProcess = "android.process.contacts".equals(app.processName);
                        boolean isNewsimProcess = "com.coloros.newsimdetect".equals(app.processName);
                        boolean isYellowPage = "com.coloros.lives".equals(app.processName);
                        boolean isTeleRelative;
                        if ("com.redteamobile.roaming".equals(app.processName) || "com.android.vendors.bridge.softsim".equals(app.processName)) {
                            isTeleRelative = true;
                        } else {
                            isTeleRelative = "com.redteamobile.virtual.softsim".equals(app.processName);
                        }
                        boolean isSelfProtectProcess = false;
                        if (!(app.info == null || app.info.packageName == null)) {
                            isSelfProtectProcess = OppoListManager.getInstance().getStageProtectList().contains(app.info.packageName);
                        }
                        boolean isOppoTestTool = false;
                        if (!(app.info == null || app.info.packageName == null)) {
                            isOppoTestTool = OppoListManager.getInstance().getOppoTestToolList(this.mContext).contains(app.info.packageName);
                        }
                        if (isAcoreProcess || isAlarmProcess || isContactsProcess || isNewsimProcess || isYellowPage || isQeTestTool(app.processName) || isTeleRelative || isSelfProtectProcess) {
                            ignoreProces = true;
                        } else {
                            ignoreProces = isOppoTestTool;
                        }
                        if (!ignoreProces) {
                            if (numEmpty > this.mConstants.CUR_TRIM_EMPTY_PROCESSES && app.lastActivityTime < oldTime) {
                                app.kill("empty for " + (((1800000 + oldTime) - app.lastActivityTime) / 1000) + "s", true);
                                break;
                            }
                            numEmpty++;
                            boolean isMmsProcess = "com.android.mms".equals(app.processName);
                            boolean isCalendarProcess = "com.android.providers.calendar".equals(app.processName);
                            boolean isLineProcess = "jp.naver.line.android".equals(app.processName);
                            if (!(isMmsProcess || (isCalendarProcess ^ 1) == 0 || numEmpty <= emptyProcessLimit)) {
                                if (isLineProcess && getSystemRuntime() < ColorOSDeviceIdleHelper.ALARM_WINDOW_LENGTH) {
                                    if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                        Slog.d(TAG, app.processName + " kill(empty #) skipped before system start 3mins");
                                        break;
                                    }
                                }
                                app.kill("empty #" + numEmpty, true);
                                break;
                            }
                        }
                        break;
                    default:
                        this.mNumNonCachedProcs++;
                        break;
                }
                if (!app.isolated || app.services.size() > 0) {
                    uidRec = app.uidRecord;
                    if (uidRec != null) {
                        uidRec.ephemeral = app.info.isInstantApp();
                        if (uidRec.curProcState > app.curProcState) {
                            uidRec.curProcState = app.curProcState;
                        }
                        if (app.foregroundServices) {
                            uidRec.foregroundServices = true;
                        }
                    }
                } else {
                    app.kill("isolated not needed", true);
                }
                if (app.curProcState >= 13 && (app.killedByAm ^ 1) != 0) {
                    numTrimming++;
                }
            }
        }
        if (numBServices > this.mBServiceAppThreshold && this.mAllowLowerMemLevel && selectedAppRecord != null) {
            if (selectedAppRecord.curAdj >= 800) {
                ProcessList.setOomAdj(selectedAppRecord.pid, selectedAppRecord.info.uid, 906);
                selectedAppRecord.setAdj = selectedAppRecord.curAdj;
                if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                    Slog.d(TAG, "app.processName = " + selectedAppRecord.processName + " app.pid = " + selectedAppRecord.pid + " app.curAdj = " + selectedAppRecord.curAdj + " is moved to higher adj");
                }
            } else if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                Slog.d(TAG, "app.processName = " + selectedAppRecord.processName + " app.pid = " + selectedAppRecord.pid + " app.curAdj = " + selectedAppRecord.curAdj + " is NOT moved to higher adj");
            }
        }
        incrementProcStateSeqAndNotifyAppsLocked();
        this.mNumServiceProcs = this.mNewNumServiceProcs;
        int numCachedAndEmpty = numCached + numEmpty;
        if (numCached > this.mConstants.CUR_TRIM_CACHED_PROCESSES || numEmpty > this.mConstants.CUR_TRIM_EMPTY_PROCESSES) {
            memFactor = 0;
        } else if (numCachedAndEmpty <= 3) {
            memFactor = 3;
        } else if (numCachedAndEmpty <= 5) {
            memFactor = 2;
        } else {
            memFactor = 1;
        }
        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
            Slog.d(TAG_OOM_ADJ, "oom: memFactor=" + memFactor + " last=" + this.mLastMemoryLevel + " allowLow=" + this.mAllowLowerMemLevel + " numProcs=" + this.mLruProcesses.size() + " last=" + this.mLastNumProcesses);
        }
        if (memFactor > this.mLastMemoryLevel && (!this.mAllowLowerMemLevel || this.mLruProcesses.size() >= this.mLastNumProcesses)) {
            memFactor = this.mLastMemoryLevel;
            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                Slog.d(TAG_OOM_ADJ, "Keeping last mem factor!");
            }
        }
        if (memFactor != this.mLastMemoryLevel) {
            EventLogTags.writeAmMemFactor(memFactor, this.mLastMemoryLevel);
        }
        this.mLastMemoryLevel = memFactor;
        this.mLastNumProcesses = this.mLruProcesses.size();
        boolean allChanged = this.mProcessStats.setMemFactorLocked(memFactor, isSleepingLocked() ^ 1, now);
        int trackerMemFactor = this.mProcessStats.getMemFactorLocked();
        if (memFactor != 0) {
            int fgTrimLevel;
            if (this.mLowRamStartTime == 0) {
                this.mLowRamStartTime = now;
            }
            int step = 0;
            switch (memFactor) {
                case 2:
                    fgTrimLevel = 10;
                    break;
                case 3:
                    fgTrimLevel = 15;
                    break;
                default:
                    fgTrimLevel = 5;
                    break;
            }
            int factor = numTrimming / 3;
            int minFactor = 2;
            if (this.mHomeProcess != null) {
                minFactor = 3;
            }
            if (this.mPreviousProcess != null) {
                minFactor++;
            }
            if (factor < minFactor) {
                factor = minFactor;
            }
            int curLevel = 80;
            for (i = N - 1; i >= 0; i--) {
                app = (ProcessRecord) this.mLruProcesses.get(i);
                if (allChanged || app.procStateChanged) {
                    setProcessTrackerStateLocked(app, trackerMemFactor, now);
                    app.procStateChanged = false;
                }
                if (app.curProcState >= 13 && (app.killedByAm ^ 1) != 0) {
                    if (app.trimMemoryLevel < curLevel && app.thread != null) {
                        try {
                            if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                Slog.v(TAG_OOM_ADJ, "Trimming memory of " + app.processName + " to " + curLevel);
                            }
                            app.thread.scheduleTrimMemory(curLevel);
                        } catch (RemoteException e) {
                        }
                    }
                    app.trimMemoryLevel = curLevel;
                    step++;
                    if (step >= factor) {
                        step = 0;
                        switch (curLevel) {
                            case 60:
                                curLevel = 40;
                                break;
                            case 80:
                                curLevel = 60;
                                break;
                            default:
                                break;
                        }
                    }
                } else if (app.curProcState == 10) {
                    if (app.trimMemoryLevel < 40 && app.thread != null) {
                        try {
                            if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                Slog.v(TAG_OOM_ADJ, "Trimming memory of heavy-weight " + app.processName + " to " + 40);
                            }
                            app.thread.scheduleTrimMemory(40);
                        } catch (RemoteException e2) {
                        }
                    }
                    app.trimMemoryLevel = 40;
                } else {
                    if ((app.curProcState >= 7 || app.systemNoUi) && app.pendingUiClean) {
                        if (app.trimMemoryLevel < 20 && app.thread != null) {
                            try {
                                if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                    Slog.v(TAG_OOM_ADJ, "Trimming memory of bg-ui " + app.processName + " to " + 20);
                                }
                                app.thread.scheduleTrimMemory(20);
                            } catch (RemoteException e3) {
                            }
                        }
                        app.pendingUiClean = false;
                    }
                    if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
                        try {
                            if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                Slog.v(TAG_OOM_ADJ, "Trimming memory of fg " + app.processName + " to " + fgTrimLevel);
                            }
                            app.thread.scheduleTrimMemory(fgTrimLevel);
                        } catch (RemoteException e4) {
                        }
                    }
                    app.trimMemoryLevel = fgTrimLevel;
                }
            }
        } else {
            if (this.mLowRamStartTime != 0) {
                this.mLowRamTimeSinceLastIdle += now - this.mLowRamStartTime;
                this.mLowRamStartTime = 0;
            }
            for (i = N - 1; i >= 0; i--) {
                app = (ProcessRecord) this.mLruProcesses.get(i);
                if (allChanged || app.procStateChanged) {
                    setProcessTrackerStateLocked(app, trackerMemFactor, now);
                    app.procStateChanged = false;
                }
                if ((app.curProcState >= 7 || app.systemNoUi) && app.pendingUiClean) {
                    if (app.trimMemoryLevel < 20 && app.thread != null) {
                        try {
                            if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                Slog.v(TAG_OOM_ADJ, "Trimming memory of ui hidden " + app.processName + " to " + 20);
                            }
                            app.thread.scheduleTrimMemory(20);
                        } catch (RemoteException e5) {
                        }
                    }
                    app.pendingUiClean = false;
                }
                app.trimMemoryLevel = 0;
            }
        }
        if (this.mAlwaysFinishActivities) {
            this.mStackSupervisor.scheduleDestroyAllActivities(null, "always-finish");
        }
        if (allChanged) {
            requestPssAllProcsLocked(now, false, this.mProcessStats.isMemFactorLowered());
        }
        ArrayList becameIdle = null;
        if (this.mLocalPowerManager != null) {
            this.mLocalPowerManager.startUidChanges();
        }
        for (i = this.mActiveUids.size() - 1; i >= 0; i--) {
            uidRec = (UidRecord) this.mActiveUids.valueAt(i);
            int uidChange = 0;
            if (!(uidRec.curProcState == 18 || (uidRec.setProcState == uidRec.curProcState && uidRec.setWhitelist == uidRec.curWhitelist))) {
                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                    Slog.i(TAG_UID_OBSERVERS, "Changes in " + uidRec + ": proc state from " + uidRec.setProcState + " to " + uidRec.curProcState + ", whitelist from " + uidRec.setWhitelist + " to " + uidRec.curWhitelist);
                }
                if (!ActivityManager.isProcStateBackground(uidRec.curProcState) || (uidRec.curWhitelist ^ 1) == 0) {
                    if (uidRec.idle) {
                        uidChange = 4;
                        EventLogTags.writeAmUidActive(uidRec.uid);
                        uidRec.idle = false;
                    }
                    uidRec.lastBackgroundTime = 0;
                } else {
                    if (!ActivityManager.isProcStateBackground(uidRec.setProcState) || uidRec.setWhitelist) {
                        uidRec.lastBackgroundTime = nowElapsed;
                        if (!this.mHandler.hasMessages(58)) {
                            this.mHandler.sendEmptyMessageDelayed(58, this.mConstants.BACKGROUND_SETTLE_TIME);
                        }
                    }
                    if (uidRec.idle && (uidRec.setIdle ^ 1) != 0) {
                        uidChange = 2;
                        if (becameIdle == null) {
                            becameIdle = new ArrayList();
                        }
                        becameIdle.add(uidRec);
                    }
                }
                boolean wasCached = uidRec.setProcState > 12;
                boolean isCached = uidRec.curProcState > 12;
                if (wasCached != isCached || uidRec.setProcState == 18) {
                    uidChange |= isCached ? 8 : 16;
                }
                uidRec.setProcState = uidRec.curProcState;
                uidRec.setWhitelist = uidRec.curWhitelist;
                uidRec.setIdle = uidRec.idle;
                enqueueUidChangeLocked(uidRec, -1, uidChange);
                noteUidProcessState(uidRec.uid, uidRec.curProcState);
                if (uidRec.foregroundServices) {
                    this.mServices.foregroundServiceProcStateChangedLocked(uidRec);
                }
            }
        }
        if (this.mLocalPowerManager != null) {
            this.mLocalPowerManager.finishUidChanges();
        }
        if (becameIdle != null) {
            for (i = becameIdle.size() - 1; i >= 0; i--) {
                this.mServices.stopInBackgroundLocked(((UidRecord) becameIdle.get(i)).uid);
            }
        }
        if (this.mProcessStats.shouldWriteNowLocked(now)) {
            this.mHandler.post(new Runnable() {
                public void run() {
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            ActivityManagerService.this.mProcessStats.writeStateAsyncLocked();
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                }
            });
        }
        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
            Slog.d(TAG_OOM_ADJ, "Did OOM ADJ in " + (SystemClock.uptimeMillis() - now) + "ms");
        }
    }

    public void makePackageIdle(String packageName, int userId) {
        if (checkCallingPermission("android.permission.FORCE_STOP_PACKAGES") != 0) {
            String msg = "Permission Denial: makePackageIdle() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.FORCE_STOP_PACKAGES";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, true, 2, "makePackageIdle", null);
        long callingId = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int pkgUid = -1;
                try {
                    pkgUid = AppGlobals.getPackageManager().getPackageUid(packageName, 268443648, 0);
                } catch (RemoteException e) {
                }
                if (pkgUid == -1) {
                    throw new IllegalArgumentException("Unknown package name " + packageName);
                }
                if (this.mLocalPowerManager != null) {
                    this.mLocalPowerManager.startUidChanges();
                }
                int appId = UserHandle.getAppId(pkgUid);
                for (int i = this.mActiveUids.size() - 1; i >= 0; i--) {
                    UidRecord uidRec = (UidRecord) this.mActiveUids.valueAt(i);
                    if (uidRec.lastBackgroundTime > 0 && (uidRec.idle ^ 1) != 0 && UserHandle.getAppId(uidRec.uid) == appId && (userId == -1 || userId == UserHandle.getUserId(uidRec.uid))) {
                        EventLogTags.writeAmUidIdle(uidRec.uid);
                        uidRec.idle = true;
                        uidRec.setIdle = true;
                        Slog.w(TAG, "Idling uid " + UserHandle.formatUid(uidRec.uid) + " from package " + packageName + " user " + userId);
                        doStopUidLocked(uidRec.uid, uidRec);
                    }
                }
                if (this.mLocalPowerManager != null) {
                    this.mLocalPowerManager.finishUidChanges();
                }
                Binder.restoreCallingIdentity(callingId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    final void idleUids() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int N = this.mActiveUids.size();
                if (N <= 0) {
                } else {
                    long nowElapsed = SystemClock.elapsedRealtime();
                    long maxBgTime = nowElapsed - this.mConstants.BACKGROUND_SETTLE_TIME;
                    long nextTime = 0;
                    if (this.mLocalPowerManager != null) {
                        this.mLocalPowerManager.startUidChanges();
                    }
                    for (int i = N - 1; i >= 0; i--) {
                        UidRecord uidRec = (UidRecord) this.mActiveUids.valueAt(i);
                        long bgTime = uidRec.lastBackgroundTime;
                        if (bgTime > 0 && (uidRec.idle ^ 1) != 0) {
                            if (bgTime <= maxBgTime) {
                                EventLogTags.writeAmUidIdle(uidRec.uid);
                                uidRec.idle = true;
                                uidRec.setIdle = true;
                                doStopUidLocked(uidRec.uid, uidRec);
                            } else if (nextTime == 0 || nextTime > bgTime) {
                                nextTime = bgTime;
                            }
                        }
                    }
                    if (this.mLocalPowerManager != null) {
                        this.mLocalPowerManager.finishUidChanges();
                    }
                    if (nextTime > 0) {
                        this.mHandler.removeMessages(58);
                        this.mHandler.sendEmptyMessageDelayed(58, (this.mConstants.BACKGROUND_SETTLE_TIME + nextTime) - nowElapsed);
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    @GuardedBy("this")
    void incrementProcStateSeqAndNotifyAppsLocked() {
        Throwable th;
        if (this.mWaitForNetworkTimeoutMs > 0) {
            UidRecord uidRec;
            int i = this.mActiveUids.size() - 1;
            ArrayList<Integer> blockingUids = null;
            while (i >= 0) {
                ArrayList<Integer> blockingUids2;
                uidRec = (UidRecord) this.mActiveUids.valueAt(i);
                if (!this.mInjector.isNetworkRestrictedForUid(uidRec.uid)) {
                    blockingUids2 = blockingUids;
                } else if (!UserHandle.isApp(uidRec.uid) || (uidRec.hasInternetPermission ^ 1) != 0) {
                    blockingUids2 = blockingUids;
                } else if (uidRec.setProcState == uidRec.curProcState) {
                    blockingUids2 = blockingUids;
                } else {
                    int blockState = getBlockStateForUid(uidRec);
                    if (blockState == 0) {
                        blockingUids2 = blockingUids;
                    } else {
                        synchronized (uidRec.networkStateLock) {
                            try {
                                long j = this.mProcStateSeqCounter + 1;
                                this.mProcStateSeqCounter = j;
                                uidRec.curProcStateSeq = j;
                                if (blockState == 1) {
                                    if (blockingUids == null) {
                                        blockingUids2 = new ArrayList();
                                    } else {
                                        blockingUids2 = blockingUids;
                                    }
                                    try {
                                        blockingUids2.add(Integer.valueOf(uidRec.uid));
                                    } catch (Throwable th2) {
                                        th = th2;
                                    }
                                } else {
                                    if (ActivityManagerDebugConfig.DEBUG_NETWORK) {
                                        Slog.d(TAG_NETWORK, "uid going to background, notifying all blocking threads for uid: " + uidRec);
                                    }
                                    if (uidRec.waitingForNetwork) {
                                        uidRec.networkStateLock.notifyAll();
                                        blockingUids2 = blockingUids;
                                    } else {
                                        blockingUids2 = blockingUids;
                                    }
                                }
                            } catch (Throwable th3) {
                                th = th3;
                                blockingUids2 = blockingUids;
                                throw th;
                            }
                        }
                    }
                }
                i--;
                blockingUids = blockingUids2;
            }
            if (blockingUids != null) {
                for (i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                    ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
                    if (!(!blockingUids.contains(Integer.valueOf(app.uid)) || app.killedByAm || app.thread == null)) {
                        uidRec = (UidRecord) this.mActiveUids.get(app.uid);
                        try {
                            if (ActivityManagerDebugConfig.DEBUG_NETWORK) {
                                Slog.d(TAG_NETWORK, "Informing app thread that it needs to block: " + uidRec);
                            }
                            app.thread.setNetworkBlockSeq(uidRec.curProcStateSeq);
                        } catch (RemoteException e) {
                        }
                    }
                }
            }
        }
    }

    int getBlockStateForUid(UidRecord uidRec) {
        boolean wasAllowed;
        int isAllowed;
        if (NetworkPolicyManager.isProcStateAllowedWhileIdleOrPowerSaveMode(uidRec.curProcState)) {
            isAllowed = 1;
        } else {
            isAllowed = NetworkPolicyManager.isProcStateAllowedWhileOnRestrictBackground(uidRec.curProcState);
        }
        if (NetworkPolicyManager.isProcStateAllowedWhileIdleOrPowerSaveMode(uidRec.setProcState)) {
            wasAllowed = true;
        } else {
            wasAllowed = NetworkPolicyManager.isProcStateAllowedWhileOnRestrictBackground(uidRec.setProcState);
        }
        if (!wasAllowed && isAllowed != 0) {
            return 1;
        }
        if (!wasAllowed || (isAllowed ^ 1) == 0) {
            return 0;
        }
        return 2;
    }

    final void runInBackgroundDisabled(int uid) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                UidRecord uidRec = (UidRecord) this.mActiveUids.get(uid);
                if (uidRec == null) {
                    doStopUidLocked(uid, null);
                } else if (uidRec.idle) {
                    doStopUidLocked(uidRec.uid, uidRec);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    final void doStopUidLocked(int uid, UidRecord uidRec) {
        this.mServices.stopInBackgroundLocked(uid);
        enqueueUidChangeLocked(uidRec, uid, 2);
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    void tempWhitelistForPendingIntentLocked(int callerPid, int callerUid, int targetUid, long duration, String tag) {
        if (ActivityManagerDebugConfig.DEBUG_WHITELISTS) {
            Slog.d(TAG, "tempWhitelistForPendingIntentLocked(" + callerPid + ", " + callerUid + ", " + targetUid + ", " + duration + ")");
        }
        synchronized (this.mPidsSelfLocked) {
            ProcessRecord pr = (ProcessRecord) this.mPidsSelfLocked.get(callerPid);
            if (pr == null) {
                Slog.w(TAG, "tempWhitelistForPendingIntentLocked() no ProcessRecord for pid " + callerPid);
            } else if (pr.whitelistManager || checkPermission("android.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST", callerPid, callerUid) == 0) {
            } else if (ActivityManagerDebugConfig.DEBUG_WHITELISTS) {
                Slog.d(TAG, "tempWhitelistForPendingIntentLocked() for target " + targetUid + ": pid " + callerPid + " is not allowed");
            }
        }
    }

    void tempWhitelistUidLocked(int targetUid, long duration, String tag) {
        this.mPendingTempWhitelist.put(targetUid, new PendingTempWhitelist(targetUid, duration, tag));
        setUidTempWhitelistStateLocked(targetUid, true);
        this.mUiHandler.obtainMessage(68).sendToTarget();
    }

    void pushTempWhitelist() {
        synchronized (this) {
            try {
                int i;
                PendingTempWhitelist ptw;
                boostPriorityForLockedSection();
                int N = this.mPendingTempWhitelist.size();
                PendingTempWhitelist[] list = new PendingTempWhitelist[N];
                for (i = 0; i < N; i++) {
                    list[i] = (PendingTempWhitelist) this.mPendingTempWhitelist.valueAt(i);
                }
                for (i = 0; i < N; i++) {
                    ptw = list[i];
                    this.mLocalDeviceIdleController.addPowerSaveTempWhitelistAppDirect(ptw.targetUid, ptw.duration, true, ptw.tag);
                }
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        for (i = 0; i < N; i++) {
                            ptw = list[i];
                            int index = this.mPendingTempWhitelist.indexOfKey(ptw.targetUid);
                            if (index >= 0 && this.mPendingTempWhitelist.valueAt(index) == ptw) {
                                this.mPendingTempWhitelist.removeAt(index);
                            }
                        }
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    final void setAppIdTempWhitelistStateLocked(int appId, boolean onWhitelist) {
        boolean changed = false;
        for (int i = this.mActiveUids.size() - 1; i >= 0; i--) {
            UidRecord uidRec = (UidRecord) this.mActiveUids.valueAt(i);
            if (UserHandle.getAppId(uidRec.uid) == appId && uidRec.curWhitelist != onWhitelist) {
                uidRec.curWhitelist = onWhitelist;
                changed = true;
            }
        }
        if (changed) {
            updateOomAdjLocked();
        }
    }

    final void setUidTempWhitelistStateLocked(int uid, boolean onWhitelist) {
        UidRecord uidRec = (UidRecord) this.mActiveUids.get(uid);
        if (uidRec != null && uidRec.curWhitelist != onWhitelist) {
            uidRec.curWhitelist = onWhitelist;
            updateOomAdjLocked();
        }
    }

    private long getSystemRuntime() {
        long currentSystemTime = System.currentTimeMillis();
        long fisrtBootTime = Long.parseLong(SystemProperties.get("ro.runtime.firstboot", "0"));
        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
            Slog.d(TAG, "currentSystemTime = " + currentSystemTime + "; fisrtBootTime = " + fisrtBootTime);
        }
        return currentSystemTime - fisrtBootTime;
    }

    final void trimApplications() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                for (int i = this.mRemovedProcesses.size() - 1; i >= 0; i--) {
                    ProcessRecord app = (ProcessRecord) this.mRemovedProcesses.get(i);
                    int size = app.receiverRecords.size();
                    if (app.activities.size() == 0 && app.curReceivers.isEmpty() && size == 0 && app.services.size() == 0) {
                        Slog.i(TAG, "Exiting empty application process " + app.toShortString() + " (" + (app.thread != null ? app.thread.asBinder() : null) + ")\n");
                        if (app.pid <= 0 || app.pid == MY_PID) {
                            try {
                                app.thread.scheduleExit();
                            } catch (Exception e) {
                            }
                        } else {
                            app.kill("empty", false);
                        }
                        cleanUpApplicationRecordLocked(app, false, true, -1, false);
                        this.mRemovedProcesses.remove(i);
                        if (app.persistent) {
                            addAppLocked(app.info, null, false, null);
                        }
                    }
                }
                updateOomAdjLocked();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void signalPersistentProcesses(int sig) throws RemoteException {
        if (sig != 10) {
            throw new SecurityException("Only SIGNAL_USR1 is allowed");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (checkCallingPermission("android.permission.SIGNAL_PERSISTENT_PROCESSES") != 0) {
                    throw new SecurityException("Requires permission android.permission.SIGNAL_PERSISTENT_PROCESSES");
                }
                for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                    ProcessRecord r = (ProcessRecord) this.mLruProcesses.get(i);
                    if (r.thread != null && r.persistent) {
                        Process.sendSignal(r.pid, sig);
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    private void stopProfilerLocked(ProcessRecord proc, int profileType) {
        if (proc == null || proc == this.mProfileProc) {
            proc = this.mProfileProc;
            profileType = this.mProfileType;
            clearProfilerLocked();
        }
        if (proc != null) {
            try {
                proc.thread.profilerControl(false, null, profileType);
            } catch (RemoteException e) {
                throw new IllegalStateException("Process disappeared");
            }
        }
    }

    private void clearProfilerLocked() {
        if (!(this.mProfilerInfo == null || this.mProfilerInfo.profileFd == null)) {
            try {
                this.mProfilerInfo.profileFd.close();
            } catch (IOException e) {
            }
        }
        this.mProfileApp = null;
        this.mProfileProc = null;
        this.mProfilerInfo = null;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean profileControl(String process, int userId, boolean start, ProfilerInfo profilerInfo, int profileType) throws RemoteException {
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
                    throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
                }
                if (start) {
                    if (profilerInfo != null) {
                    }
                    throw new IllegalArgumentException("null profile info or fd");
                }
                ProcessRecord proc = null;
                if (process != null) {
                    proc = findProcessLocked(process, userId, "profileControl");
                }
                if (start && (proc == null || proc.thread == null)) {
                    throw new IllegalArgumentException("Unknown process: " + process);
                }
                if (start) {
                    ParcelFileDescriptor fd;
                    stopProfilerLocked(null, 0);
                    setProfileApp(proc.info, proc.processName, profilerInfo);
                    this.mProfileProc = proc;
                    this.mProfileType = profileType;
                    try {
                        fd = profilerInfo.profileFd.dup();
                    } catch (IOException e) {
                        fd = null;
                    }
                    profilerInfo.profileFd = fd;
                    proc.thread.profilerControl(start, profilerInfo, profileType);
                    try {
                        this.mProfilerInfo.profileFd.close();
                    } catch (IOException e2) {
                    }
                    this.mProfilerInfo.profileFd = null;
                } else {
                    stopProfilerLocked(proc, profileType);
                    if (!(profilerInfo == null || profilerInfo.profileFd == null)) {
                        try {
                            profilerInfo.profileFd.close();
                        } catch (IOException e3) {
                        }
                    }
                }
            }
            resetPriorityAfterLockedSection();
            if (!(profilerInfo == null || profilerInfo.profileFd == null)) {
                try {
                    profilerInfo.profileFd.close();
                } catch (IOException e4) {
                }
            }
            return true;
        } catch (RemoteException e5) {
            try {
                throw new IllegalStateException("Process disappeared");
            } catch (Throwable th) {
                if (!(profilerInfo == null || profilerInfo.profileFd == null)) {
                    try {
                        profilerInfo.profileFd.close();
                    } catch (IOException e6) {
                    }
                }
            }
        } catch (Throwable th2) {
            resetPriorityAfterLockedSection();
        }
    }

    private ProcessRecord findProcessLocked(String process, int userId, String callName) {
        userId = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, true, 2, callName, null);
        ProcessRecord proc = null;
        try {
            int pid = Integer.parseInt(process);
            synchronized (this.mPidsSelfLocked) {
                proc = (ProcessRecord) this.mPidsSelfLocked.get(pid);
            }
        } catch (NumberFormatException e) {
        }
        if (proc != null) {
            return proc;
        }
        SparseArray<ProcessRecord> procs = (SparseArray) this.mProcessNames.getMap().get(process);
        if (procs == null || procs.size() <= 0) {
            return proc;
        }
        proc = (ProcessRecord) procs.valueAt(0);
        if (userId == -1 || proc.userId == userId) {
            return proc;
        }
        for (int i = 1; i < procs.size(); i++) {
            ProcessRecord thisProc = (ProcessRecord) procs.valueAt(i);
            if (thisProc.userId == userId) {
                return thisProc;
            }
        }
        return proc;
    }

    public boolean dumpHeap(String process, int userId, boolean managed, boolean mallocInfo, boolean runGc, String path, ParcelFileDescriptor fd) throws RemoteException {
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
                    throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
                } else if (fd == null) {
                    throw new IllegalArgumentException("null fd");
                } else {
                    ProcessRecord proc = findProcessLocked(process, userId, "dumpHeap");
                    if (proc == null || proc.thread == null) {
                        throw new IllegalArgumentException("Unknown process: " + process);
                    }
                    if (!LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0")) && (proc.info.flags & 2) == 0) {
                        boolean isDebugOpen = SystemProperties.getBoolean("persist.sys.assert.panic", false);
                        boolean isSpecialTarget = TENCENT_NAME.equals(proc.info.packageName);
                        if (!(isDebugOpen && isSpecialTarget)) {
                            throw new SecurityException("Process not debuggable: " + proc);
                        }
                    }
                    proc.thread.dumpHeap(managed, mallocInfo, runGc, path, fd);
                    fd = null;
                }
            }
            resetPriorityAfterLockedSection();
            return true;
        } catch (RemoteException e) {
            try {
                throw new IllegalStateException("Process disappeared");
            } catch (Throwable th) {
                if (fd != null) {
                    try {
                        fd.close();
                    } catch (IOException e2) {
                    }
                }
            }
        } catch (Throwable th2) {
            resetPriorityAfterLockedSection();
        }
    }

    public void setDumpHeapDebugLimit(String processName, int uid, long maxMemSize, String reportPackage) {
        if (processName != null) {
            enforceCallingPermission("android.permission.SET_DEBUG_APP", "setDumpHeapDebugLimit()");
        } else {
            synchronized (this.mPidsSelfLocked) {
                ProcessRecord proc = (ProcessRecord) this.mPidsSelfLocked.get(Binder.getCallingPid());
                if (proc == null) {
                    throw new SecurityException("No process found for calling pid " + Binder.getCallingPid());
                } else if (Build.IS_DEBUGGABLE || (proc.info.flags & 2) != 0) {
                    processName = proc.processName;
                    uid = proc.uid;
                    if (reportPackage == null || (proc.pkgList.containsKey(reportPackage) ^ 1) == 0) {
                    } else {
                        throw new SecurityException("Package " + reportPackage + " is not running in " + proc);
                    }
                } else {
                    throw new SecurityException("Not running a debuggable build");
                }
            }
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (maxMemSize > 0) {
                    this.mMemWatchProcesses.put(processName, uid, new Pair(Long.valueOf(maxMemSize), reportPackage));
                } else if (uid != 0) {
                    this.mMemWatchProcesses.remove(processName, uid);
                } else {
                    this.mMemWatchProcesses.getMap().remove(processName);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void dumpHeapFinished(String path) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (Binder.getCallingPid() != this.mMemWatchDumpPid) {
                    Slog.w(TAG, "dumpHeapFinished: Calling pid " + Binder.getCallingPid() + " does not match last pid " + this.mMemWatchDumpPid);
                } else if (this.mMemWatchDumpFile == null || (this.mMemWatchDumpFile.equals(path) ^ 1) != 0) {
                    Slog.w(TAG, "dumpHeapFinished: Calling path " + path + " does not match last path " + this.mMemWatchDumpFile);
                    resetPriorityAfterLockedSection();
                } else {
                    if (ActivityManagerDebugConfig.DEBUG_PSS) {
                        Slog.d(TAG_PSS, "Dump heap finished for " + path);
                    }
                    this.mHandler.sendEmptyMessage(50);
                    Runtime.getRuntime().gc();
                    resetPriorityAfterLockedSection();
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void monitor() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    void onCoreSettingsChange(Bundle settings) {
        for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord processRecord = (ProcessRecord) this.mLruProcesses.get(i);
            try {
                if (processRecord.thread != null) {
                    processRecord.thread.setCoreSettings(settings);
                }
            } catch (RemoteException e) {
            }
        }
    }

    public boolean startUserInBackground(int userId) {
        return this.mUserController.startUser(userId, false);
    }

    public boolean unlockUser(int userId, byte[] token, byte[] secret, IProgressListener listener) {
        return this.mUserController.unlockUser(userId, token, secret, listener);
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean switchUser(int targetUserId) {
        enforceShellRestriction("no_debugging_features", targetUserId);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int currentUserId = this.mUserController.getCurrentUserIdLocked();
                UserInfo targetUserInfo = this.mUserController.getUserInfo(targetUserId);
                if (targetUserId == currentUserId) {
                    Slog.i(TAG, "user #" + targetUserId + " is already the current user");
                } else if (targetUserInfo == null) {
                    Slog.w(TAG, "No user info for user #" + targetUserId);
                    resetPriorityAfterLockedSection();
                    return false;
                } else if (!targetUserInfo.isDemo() && UserManager.isDeviceInDemoMode(this.mContext)) {
                    Slog.w(TAG, "Cannot switch to non-demo user #" + targetUserId + " when device is in demo mode");
                    resetPriorityAfterLockedSection();
                    return false;
                } else if (!targetUserInfo.supportsSwitchTo()) {
                    Slog.w(TAG, "Cannot switch to User #" + targetUserId + ": not supported");
                    resetPriorityAfterLockedSection();
                    return false;
                } else if (targetUserInfo.isManagedProfile()) {
                    Slog.w(TAG, "Cannot switch to User #" + targetUserId + ": not a full user");
                    resetPriorityAfterLockedSection();
                    return false;
                } else {
                    this.mUserController.setTargetUserIdLocked(targetUserId);
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return true;
    }

    void scheduleStartProfilesLocked() {
        if (!this.mHandler.hasMessages(40)) {
            this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(40), 1000);
        }
    }

    public int stopUser(int userId, boolean force, IStopUserCallback callback) {
        return this.mUserController.stopUser(userId, force, callback);
    }

    public UserInfo getCurrentUser() {
        return this.mUserController.getCurrentUser();
    }

    String getStartedUserState(int userId) {
        String stateToString;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                stateToString = UserState.stateToString(this.mUserController.getStartedUserStateLocked(userId).state);
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return stateToString;
    }

    public boolean isUserRunning(int userId, int flags) {
        if (this.mUserController.isSameProfileGroup(userId, UserHandle.getCallingUserId()) || checkCallingPermission("android.permission.INTERACT_ACROSS_USERS") == 0) {
            boolean isUserRunningLocked;
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    isUserRunningLocked = this.mUserController.isUserRunningLocked(userId, flags);
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            return isUserRunningLocked;
        }
        String msg = "Permission Denial: isUserRunning() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.INTERACT_ACROSS_USERS";
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }

    public int[] getRunningUserIds() {
        if (checkCallingPermission("android.permission.INTERACT_ACROSS_USERS") != 0) {
            String msg = "Permission Denial: isUserRunning() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + "android.permission.INTERACT_ACROSS_USERS";
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        int[] startedUserArrayLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                startedUserArrayLocked = this.mUserController.getStartedUserArrayLocked();
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return startedUserArrayLocked;
    }

    public void registerUserSwitchObserver(IUserSwitchObserver observer, String name) {
        this.mUserController.registerUserSwitchObserver(observer, name);
    }

    public void unregisterUserSwitchObserver(IUserSwitchObserver observer) {
        this.mUserController.unregisterUserSwitchObserver(observer);
    }

    ApplicationInfo getAppInfoForUser(ApplicationInfo info, int userId) {
        if (info == null) {
            return null;
        }
        ApplicationInfo newInfo = new ApplicationInfo(info);
        newInfo.initForUser(userId);
        return newInfo;
    }

    public boolean isUserStopped(int userId) {
        boolean z;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                z = this.mUserController.getStartedUserStateLocked(userId) == null;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return z;
    }

    ActivityInfo getActivityInfoForUser(ActivityInfo aInfo, int userId) {
        if (aInfo == null || (userId < 1 && aInfo.applicationInfo.uid < 100000)) {
            return aInfo;
        }
        ActivityInfo info = new ActivityInfo(aInfo);
        info.applicationInfo = getAppInfoForUser(info.applicationInfo, userId);
        return info;
    }

    private boolean processSanityChecksLocked(ProcessRecord process) {
        if (process == null || process.thread == null) {
            return false;
        }
        if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0")) || (process.info.flags & 2) != 0) {
            return true;
        }
        return false;
    }

    public boolean startBinderTracking() throws RemoteException {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mBinderTransactionTrackingEnabled = true;
                if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
                    throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
                }
                for (int i = 0; i < this.mLruProcesses.size(); i++) {
                    ProcessRecord process = (ProcessRecord) this.mLruProcesses.get(i);
                    if (processSanityChecksLocked(process)) {
                        process.thread.startBinderTracking();
                    }
                }
            } catch (RemoteException e) {
                Log.v(TAG, "Process disappared");
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
        return true;
    }

    public boolean stopBinderTrackingAndDump(ParcelFileDescriptor fd) throws RemoteException {
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                this.mBinderTransactionTrackingEnabled = false;
                if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
                    throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
                } else if (fd == null) {
                    throw new IllegalArgumentException("null fd");
                } else {
                    PrintWriter pw = new FastPrintWriter(new FileOutputStream(fd.getFileDescriptor()));
                    pw.println("Binder transaction traces for all processes.\n");
                    for (ProcessRecord process : this.mLruProcesses) {
                        if (processSanityChecksLocked(process)) {
                            pw.println("Traces for process: " + process.processName);
                            pw.flush();
                            TransferPipe tp;
                            try {
                                tp = new TransferPipe();
                                process.thread.stopBinderTrackingAndDump(tp.getWriteFd());
                                tp.go(fd.getFileDescriptor());
                                tp.kill();
                            } catch (IOException e) {
                                pw.println("Failure while dumping IPC traces from " + process + ".  Exception: " + e);
                                pw.flush();
                            } catch (RemoteException e2) {
                                pw.println("Got a RemoteException while dumping IPC traces from " + process + ".  Exception: " + e2);
                                pw.flush();
                            } catch (Throwable th) {
                                tp.kill();
                            }
                        }
                    }
                    fd = null;
                }
            }
            resetPriorityAfterLockedSection();
            return true;
        } catch (Throwable th2) {
            if (fd != null) {
                try {
                    fd.close();
                } catch (IOException e3) {
                }
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void waitForNetworkStateUpdate(long procStateSeq) {
        int callingUid = Binder.getCallingUid();
        if (ActivityManagerDebugConfig.DEBUG_NETWORK) {
            Slog.d(TAG_NETWORK, "Called from " + callingUid + " to wait for seq: " + procStateSeq);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                UidRecord record = (UidRecord) this.mActiveUids.get(callingUid);
                if (record == null) {
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return;
    }

    public void waitForBroadcastIdle(PrintWriter pw) {
        enforceCallingPermission("android.permission.DUMP", "waitForBroadcastIdle()");
        while (true) {
            String msg;
            boolean idle = true;
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    for (BroadcastQueue queue : this.mBroadcastQueues) {
                        if (!queue.isIdle()) {
                            msg = "Waiting for queue " + queue + " to become idle...";
                            pw.println(msg);
                            pw.flush();
                            Slog.v(TAG, msg);
                            idle = false;
                        }
                    }
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            if (idle) {
                msg = "All broadcast queues are idle!";
                pw.println("All broadcast queues are idle!");
                pw.flush();
                Slog.v(TAG, "All broadcast queues are idle!");
                return;
            }
            SystemClock.sleep(1000);
        }
    }

    public int getLastResumedActivityUserId() {
        int currentUserIdLocked;
        enforceCallingPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "getLastResumedActivityUserId()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (this.mLastResumedActivity == null) {
                    currentUserIdLocked = this.mUserController.getCurrentUserIdLocked();
                } else {
                    currentUserIdLocked = this.mLastResumedActivity.userId;
                    resetPriorityAfterLockedSection();
                    return currentUserIdLocked;
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return currentUserIdLocked;
    }

    public boolean addDisallowedRunningApp(List<String> appPkgNamesList) {
        if (!this.mContext.getPackageManager().hasSystemFeature(FEATURE_DISALLOW_APP_RUN_STR) || appPkgNamesList == null || appPkgNamesList.size() <= 0) {
            return false;
        }
        boolean result;
        synchronized (this.mDisallowedRuningAppListLock) {
            int size = appPkgNamesList.size();
            for (int index = 0; index < size; index++) {
                String pkgName = (String) appPkgNamesList.get(index);
                if (!(pkgName == null || pkgName.length() <= 0 || this.mDisallowedRuningAppList.contains(pkgName))) {
                    this.mDisallowedRuningAppList.add(pkgName);
                }
            }
            result = saveDisallowAppListFile(this.mDisallowedRuningAppList);
        }
        return result;
    }

    public boolean removeDisallowedRunningApp(List<String> appPkgNamesList) {
        if (!this.mContext.getPackageManager().hasSystemFeature(FEATURE_DISALLOW_APP_RUN_STR) || appPkgNamesList == null || appPkgNamesList.size() <= 0) {
            return false;
        }
        synchronized (this.mDisallowedRuningAppListLock) {
            int size = appPkgNamesList.size();
            for (int index = 0; index < size; index++) {
                String pkgName = (String) appPkgNamesList.get(index);
                if (pkgName != null && pkgName.length() > 0 && this.mDisallowedRuningAppList.contains(pkgName)) {
                    this.mDisallowedRuningAppList.remove(pkgName);
                }
            }
        }
        return true;
    }

    public List<String> getDisallowedRunningApp() {
        return new ArrayList(this.mDisallowedRuningAppList);
    }

    public boolean isInDisallowedRunningAppList(String pkgName) {
        if (pkgName == null || pkgName.length() <= 0) {
            return false;
        }
        return this.mDisallowedRuningAppList.contains(pkgName);
    }

    public void showDisallowedRunningAppDialog() {
        Message msg = Message.obtain();
        msg.what = SHOW_NOT_ALLOW_DIALOG_MSG;
        this.mUiHandler.sendMessage(msg);
    }

    private boolean saveDisallowAppListFile(List<String> packages) {
        try {
            BufferedOutputStream str = new BufferedOutputStream(new FileOutputStream(this.mNotAllowAppFilename));
            XmlSerializer serializer = new FastXmlSerializer();
            String strUtf8 = "utf-8";
            String strPackages = "packages";
            String strName = "name";
            String strPackage = "package";
            serializer.setOutput(str, "utf-8");
            serializer.startDocument(null, Boolean.valueOf(true));
            serializer.startTag(null, "packages");
            int size = packages.size();
            for (int index = 0; index < size; index++) {
                String pkgName = (String) packages.get(index);
                serializer.startTag(null, "package");
                serializer.attribute(null, "name", pkgName);
                serializer.endTag(null, "package");
            }
            serializer.endTag(null, "packages");
            serializer.endDocument();
            str.flush();
            str.close();
            return true;
        } catch (IOException e) {
            Slog.w(TAG, "Unable to write not allow running package, current changes will be lost at reboot", e);
            return false;
        } catch (Exception e2) {
            Slog.w(TAG, "Unable to write not allow running package, current changes will be lost at reboot", e2);
            return false;
        }
    }

    private boolean readDisallowAppListFile() {
        try {
            if (!this.mNotAllowAppFilename.exists()) {
                return false;
            }
            FileInputStream str = new FileInputStream(this.mNotAllowAppFilename);
            XmlPullParser parser = Xml.newPullParser();
            parser.setInput(str, null);
            String strPackage = "package";
            String strName = "name";
            int type;
            do {
                type = parser.next();
                if (type == 2) {
                    if ("package".equals(parser.getName())) {
                        String name = parser.getAttributeValue(null, "name");
                        if (!(name == null || (this.mDisallowedRuningAppList.contains(name) ^ 1) == 0)) {
                            this.mDisallowedRuningAppList.add(name);
                            continue;
                        }
                    } else {
                        continue;
                    }
                }
            } while (type != 1);
            return true;
        } catch (IOException e) {
            Slog.w(TAG, "Error reading not allow running package", e);
            return false;
        } catch (Exception e2) {
            Slog.w(TAG, "Error reading not allow running package", e2);
            return false;
        }
    }

    private List<String> loadCustomizeWhiteList(String path) {
        IOException e;
        NullPointerException e2;
        NumberFormatException e3;
        XmlPullParserException e4;
        IndexOutOfBoundsException e5;
        Throwable th;
        ArrayList<String> emptyList = new ArrayList();
        File file = new File(path);
        if (file.exists()) {
            ArrayList<String> ret = new ArrayList();
            FileInputStream listFileInputStream = null;
            boolean success = false;
            try {
                FileInputStream listFileInputStream2 = new FileInputStream(file);
                try {
                    XmlPullParser parser = Xml.newPullParser();
                    parser.setInput(listFileInputStream2, null);
                    String strTagP = OppoCrashClearManager.CRASH_CLEAR_NAME;
                    String strTagAtt = "att";
                    int type;
                    do {
                        type = parser.next();
                        if (type == 2) {
                            if (OppoCrashClearManager.CRASH_CLEAR_NAME.equals(parser.getName())) {
                                String value = parser.getAttributeValue(null, "att");
                                if (value != null) {
                                    ret.add(value);
                                }
                            }
                        }
                    } while (type != 1);
                    success = true;
                    if (listFileInputStream2 != null) {
                        try {
                            listFileInputStream2.close();
                        } catch (IOException e6) {
                            e6.printStackTrace();
                        }
                    }
                    listFileInputStream = listFileInputStream2;
                } catch (NullPointerException e7) {
                    e2 = e7;
                    listFileInputStream = listFileInputStream2;
                    Slog.w(TAG, "failed parsing ", e2);
                    if (listFileInputStream != null) {
                        try {
                            listFileInputStream.close();
                        } catch (IOException e62) {
                            e62.printStackTrace();
                        }
                    }
                    if (!success) {
                        return ret;
                    }
                    Slog.w(TAG, path + " file failed parsing!");
                    return emptyList;
                } catch (NumberFormatException e8) {
                    e3 = e8;
                    listFileInputStream = listFileInputStream2;
                    Slog.w(TAG, "failed parsing ", e3);
                    if (listFileInputStream != null) {
                        try {
                            listFileInputStream.close();
                        } catch (IOException e622) {
                            e622.printStackTrace();
                        }
                    }
                    if (!success) {
                        return ret;
                    }
                    Slog.w(TAG, path + " file failed parsing!");
                    return emptyList;
                } catch (XmlPullParserException e9) {
                    e4 = e9;
                    listFileInputStream = listFileInputStream2;
                    Slog.w(TAG, "failed parsing ", e4);
                    if (listFileInputStream != null) {
                        try {
                            listFileInputStream.close();
                        } catch (IOException e6222) {
                            e6222.printStackTrace();
                        }
                    }
                    if (!success) {
                        return ret;
                    }
                    Slog.w(TAG, path + " file failed parsing!");
                    return emptyList;
                } catch (IOException e10) {
                    e6222 = e10;
                    listFileInputStream = listFileInputStream2;
                    Slog.w(TAG, "failed parsing ", e6222);
                    if (listFileInputStream != null) {
                        try {
                            listFileInputStream.close();
                        } catch (IOException e62222) {
                            e62222.printStackTrace();
                        }
                    }
                    if (!success) {
                        return ret;
                    }
                    Slog.w(TAG, path + " file failed parsing!");
                    return emptyList;
                } catch (IndexOutOfBoundsException e11) {
                    e5 = e11;
                    listFileInputStream = listFileInputStream2;
                    try {
                        Slog.w(TAG, "failed parsing ", e5);
                        if (listFileInputStream != null) {
                            try {
                                listFileInputStream.close();
                            } catch (IOException e622222) {
                                e622222.printStackTrace();
                            }
                        }
                        if (!success) {
                            return ret;
                        }
                        Slog.w(TAG, path + " file failed parsing!");
                        return emptyList;
                    } catch (Throwable th2) {
                        th = th2;
                        if (listFileInputStream != null) {
                            try {
                                listFileInputStream.close();
                            } catch (IOException e6222222) {
                                e6222222.printStackTrace();
                            }
                        }
                        throw th;
                    }
                } catch (Throwable th3) {
                    th = th3;
                    listFileInputStream = listFileInputStream2;
                    if (listFileInputStream != null) {
                        try {
                            listFileInputStream.close();
                        } catch (IOException e62222222) {
                            e62222222.printStackTrace();
                        }
                    }
                    throw th;
                }
            } catch (NullPointerException e12) {
                e2 = e12;
                Slog.w(TAG, "failed parsing ", e2);
                if (listFileInputStream != null) {
                    try {
                        listFileInputStream.close();
                    } catch (IOException e622222222) {
                        e622222222.printStackTrace();
                    }
                }
                if (!success) {
                    return ret;
                }
                Slog.w(TAG, path + " file failed parsing!");
                return emptyList;
            } catch (NumberFormatException e13) {
                e3 = e13;
                Slog.w(TAG, "failed parsing ", e3);
                if (listFileInputStream != null) {
                    try {
                        listFileInputStream.close();
                    } catch (IOException e6222222222) {
                        e6222222222.printStackTrace();
                    }
                }
                if (!success) {
                    return ret;
                }
                Slog.w(TAG, path + " file failed parsing!");
                return emptyList;
            } catch (XmlPullParserException e14) {
                e4 = e14;
                Slog.w(TAG, "failed parsing ", e4);
                if (listFileInputStream != null) {
                    try {
                        listFileInputStream.close();
                    } catch (IOException e62222222222) {
                        e62222222222.printStackTrace();
                    }
                }
                if (!success) {
                    return ret;
                }
                Slog.w(TAG, path + " file failed parsing!");
                return emptyList;
            } catch (IOException e15) {
                e62222222222 = e15;
                Slog.w(TAG, "failed parsing ", e62222222222);
                if (listFileInputStream != null) {
                    try {
                        listFileInputStream.close();
                    } catch (IOException e622222222222) {
                        e622222222222.printStackTrace();
                    }
                }
                if (!success) {
                    return ret;
                }
                Slog.w(TAG, path + " file failed parsing!");
                return emptyList;
            } catch (IndexOutOfBoundsException e16) {
                e5 = e16;
                Slog.w(TAG, "failed parsing ", e5);
                if (listFileInputStream != null) {
                    try {
                        listFileInputStream.close();
                    } catch (IOException e6222222222222) {
                        e6222222222222.printStackTrace();
                    }
                }
                if (!success) {
                    return ret;
                }
                Slog.w(TAG, path + " file failed parsing!");
                return emptyList;
            }
            if (!success) {
                return ret;
            }
            Slog.w(TAG, path + " file failed parsing!");
            return emptyList;
        }
        Slog.w(TAG, path + " file don't exist!");
        return emptyList;
    }

    private boolean checkWhiteList(String packageName) {
        if (this.mCustomizeList == null || this.mCustomizeList.size() <= 0 || packageName == null) {
            return false;
        }
        try {
            for (String pkg : this.mCustomizeList) {
                if (pkg.equalsIgnoreCase(packageName)) {
                    return true;
                }
            }
            return false;
        } catch (Exception e) {
            Slog.w(TAG, "check white list has exception! ", e);
            return false;
        }
    }

    private boolean checkProtectAppList(String packageName) {
        if (!this.mContext.getPackageManager().hasSystemFeature("oppo.customize.function.addprotectapp")) {
            return false;
        }
        List<String> protectApplist = loadCustomizeWhiteList("/data/system/custom_protect_app.xml");
        if (protectApplist == null || (protectApplist.isEmpty() ^ 1) == 0 || !protectApplist.contains(packageName)) {
            return false;
        }
        return true;
    }

    public void allowToUseSdcard(boolean allow) {
        String propStrExStoreage = "persist.sys.exStorage_support";
        String enableStr = LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON;
        if (allow != SystemProperties.get("persist.sys.exStorage_support", LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON).equals(LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON)) {
            SystemProperties.set("persist.sys.exStorage_support", allow ? LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON : "0");
        }
    }

    private boolean isImportantPersistProc(String processName) {
        if ("com.android.systemui".equals(processName)) {
            return true;
        }
        return KEYGUARD_PROC_NAME.equals(processName);
    }

    private boolean restartAfterStartTimeout(String processName) {
        if ("com.android.systemui".equals(processName)) {
            this.mHandler.postDelayed(new Runnable() {
                public void run() {
                    try {
                        ActivityManagerService.this.startSystemUi(ActivityManagerService.this.mContext);
                    } catch (Exception e) {
                        Slog.e(ActivityManagerService.TAG, "restartAfterStartTimeout startSystemUi failed!", e);
                    }
                }
            }, 2000);
            return true;
        } else if (!KEYGUARD_PROC_NAME.equals(processName)) {
            return false;
        } else {
            this.mHandler.postDelayed(new Runnable() {
                public void run() {
                    try {
                        ActivityManagerService.this.notifyKeyguardStartProcTimeout(ActivityManagerService.this.mContext);
                    } catch (Exception e) {
                        Slog.e(ActivityManagerService.TAG, "restartAfterStartTimeout notifyKeyguardStartProcTimeout failed!", e);
                    }
                }
            }, 2000);
            return true;
        }
    }

    private void startSystemUi(Context context) {
        Intent intent = new Intent();
        intent.setComponent(new ComponentName("com.android.systemui", "com.android.systemui.SystemUIService"));
        Slog.d(TAG, "Starting systemui service: " + intent);
        context.startServiceAsUser(intent, UserHandle.OWNER);
    }

    private void notifyKeyguardStartProcTimeout(Context context) {
        if (this.mSystemReady) {
            Slog.d(TAG, "notifyKeyguardStartProcTimeout: send broadcast android.intent.action.KEYGUARD_TIMEOUT");
            context.sendBroadcast(new Intent(KEYGUARD_STARTPROC_TIMEOUT_ACTION));
            return;
        }
        Slog.d(TAG, "notifyKeyguardStartProcTimeout: system not ready, ignore!");
    }

    @OppoHook(level = OppoHookType.NEW_METHOD, note = "ZhiYong.Lin@Plf.Framework, add for permission intercept", property = OppoRomType.ROM)
    public void permissionInterceptPolicyReady() {
    }

    public int forceTrimMemory(int level, List<String> protectList) {
        int result = 0;
        for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
            if (app != null) {
                ApplicationInfo info = app.info;
                if (info != null) {
                    String pkgName = info.packageName;
                    if (protectList != null && protectList.contains(pkgName)) {
                        Slog.d(TAG, "forceTrimMemory skip protect name=" + pkgName);
                    }
                }
                if (app.thread != null) {
                    try {
                        app.thread.scheduleTrimMemory(level);
                    } catch (RemoteException e) {
                        result = -1;
                    }
                }
            }
        }
        Slog.d(TAG, "forceTrimMemory() level = " + level + ", result = " + result);
        return result;
    }

    public boolean isPkgInRecentTasks(String pkg) {
        if (pkg == null || this.mRecentTasks == null) {
            return false;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int recentsCount = this.mRecentTasks.size();
                int i = 0;
                while (i < recentsCount) {
                    TaskRecord tr = (TaskRecord) this.mRecentTasks.get(i);
                    if (tr.getBaseIntent() == null || tr.getBaseIntent().getComponent() == null || tr.getBaseIntent().getComponent().getPackageName() == null || !pkg.equals(tr.getBaseIntent().getComponent().getPackageName())) {
                        i++;
                    }
                }
                resetPriorityAfterLockedSection();
                return false;
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return true;
    }

    public ArraySet<Integer> getPidsForPackage(String pkg) {
        ArraySet<Integer> tempSet = new ArraySet();
        if (pkg == null || pkg.isEmpty()) {
            return tempSet;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                    ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
                    if (!(app == null || app.pkgList == null || !app.pkgList.containsKey(pkg))) {
                        tempSet.add(Integer.valueOf(app.pid));
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
        return tempSet;
    }

    final int broadcastOppoBootComleteLocked(Intent intent, IIntentReceiver resultTo, int userId) {
        return broadcastIntentLocked(null, null, intent, null, resultTo, 0, null, null, new String[]{"android.permission.RECEIVE_BOOT_COMPLETED"}, -1, null, true, false, MY_PID, 1000, userId);
    }

    public void killPackageDependents(String packageName, int userId) {
        enforceCallingPermission("android.permission.KILL_UID", "killPackageDependents()");
        if (packageName == null) {
            throw new NullPointerException("Cannot kill the dependents of a package without its name.");
        }
        long callingId = Binder.clearCallingIdentity();
        IPackageManager pm = AppGlobals.getPackageManager();
        Slog.d(TAG, "killPackageDependents : callingPid = " + Binder.getCallingPid() + ", callingUid = " + Binder.getCallingUid());
        int pkgUid = -1;
        try {
            pkgUid = pm.getPackageUid(packageName, 268435456, userId);
        } catch (RemoteException e) {
        }
        if (userId == -1 || pkgUid != -1) {
            try {
                synchronized (this) {
                    boostPriorityForLockedSection();
                    killPackageProcessesLocked(packageName, UserHandle.getAppId(pkgUid), userId, 0, false, true, true, false, "dep: " + packageName);
                }
                resetPriorityAfterLockedSection();
                Binder.restoreCallingIdentity(callingId);
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(callingId);
            }
        } else {
            throw new IllegalArgumentException("Cannot kill dependents of non-existing package " + packageName);
        }
    }

    private void oppoCreateFileInData() {
        this.mHandler.removeCallbacks(this.mCreateDataReserveFile);
        File file = new File(DATA_RESERVE_PATH);
        if (!file.exists()) {
            int dataAviSize = getAvaiDataSize() - 40;
            Slog.d(TAG, "free data size is:" + dataAviSize);
            if (dataAviSize > 64) {
                Slog.d(TAG, "create a reserve file 64M");
                createReserveFile(file, 64);
            } else if (dataAviSize > 64 || dataAviSize <= 16) {
                Slog.e(TAG, "data size is less than 16M");
            } else {
                createReserveFile(file, dataAviSize);
                Slog.d(TAG, "create a reserve file dataFreeSize:" + dataAviSize + " finish!");
            }
        }
    }

    private void createReserveFile(File file, int size) {
        Throwable th;
        FileOutputStream fos = null;
        try {
            FileOutputStream fos2 = new FileOutputStream(file, true);
            try {
                byte[] buf = new byte[1024];
                int large = size * 1024;
                for (long i = 0; i < ((long) large); i++) {
                    fos2.write(buf);
                }
                fos2.flush();
                try {
                    fos2.close();
                } catch (IOException e) {
                    Slog.e(TAG, "fos close fatal error:" + e);
                }
                fos = fos2;
            } catch (IOException e2) {
                fos = fos2;
                try {
                    Slog.e(TAG, "reserve.log create faile!!!");
                    try {
                        fos.close();
                    } catch (IOException e3) {
                        Slog.e(TAG, "fos close fatal error:" + e3);
                    }
                } catch (Throwable th2) {
                    th = th2;
                    try {
                        fos.close();
                    } catch (IOException e32) {
                        Slog.e(TAG, "fos close fatal error:" + e32);
                    }
                    throw th;
                }
            } catch (Throwable th3) {
                th = th3;
                fos = fos2;
                fos.close();
                throw th;
            }
        } catch (IOException e4) {
            Slog.e(TAG, "reserve.log create faile!!!");
            fos.close();
        }
    }

    private int getAvaiDataSize() {
        StatFs sf = new StatFs("/data");
        return (int) ((sf.getBlockSizeLong() * sf.getAvailableBlocksLong()) / 1048576);
    }

    public void dismissKeyguard(IBinder token, IKeyguardDismissCallback callback) throws RemoteException {
        long callingId = Binder.clearCallingIdentity();
        try {
            this.mKeyguardController.dismissKeyguard(token, callback);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public int restartUserInBackground(int userId) {
        return this.mUserController.restartUser(userId, false);
    }

    public void scheduleApplicationInfoChanged(List<String> packageNames, int userId) {
        enforceCallingPermission("android.permission.CHANGE_CONFIGURATION", "scheduleApplicationInfoChanged()");
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                origId = Binder.clearCallingIdentity();
                updateApplicationInfoLocked(packageNames, userId);
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
        resetPriorityAfterLockedSection();
    }

    void updateApplicationInfoLocked(List<String> packagesToUpdate, int userId) {
        boolean updateFrameworkRes = packagesToUpdate.contains("android");
        for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
            if (app.thread != null && (userId == -1 || app.userId == userId)) {
                int packageCount = app.pkgList.size();
                for (int j = 0; j < packageCount; j++) {
                    String packageName = (String) app.pkgList.keyAt(j);
                    if (updateFrameworkRes || packagesToUpdate.contains(packageName)) {
                        try {
                            ApplicationInfo ai = AppGlobals.getPackageManager().getApplicationInfo(packageName, 1024, app.userId);
                            if (ai != null) {
                                app.thread.scheduleApplicationInfoChanged(ai);
                            }
                        } catch (RemoteException e) {
                            Slog.w(TAG, String.format("Failed to update %s ApplicationInfo for %s", new Object[]{packageName, app}));
                        }
                    }
                }
            }
        }
    }

    public void attachAgent(String process, String path) {
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ProcessRecord proc = findProcessLocked(process, 0, "attachAgent");
                if (proc == null || proc.thread == null) {
                    throw new IllegalArgumentException("Unknown process: " + process);
                } else if (LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0")) || (proc.info.flags & 2) != 0) {
                    proc.thread.attachAgent(path);
                } else {
                    throw new SecurityException("Process not debuggable: " + proc);
                }
            }
            resetPriorityAfterLockedSection();
        } catch (RemoteException e) {
            throw new IllegalStateException("Process disappeared");
        } catch (Throwable th) {
            resetPriorityAfterLockedSection();
        }
    }

    public ComponentName getTopAppName() {
        return this.mStackSupervisor.getTopAppName();
    }

    public void setShowWhenLocked(IBinder token, boolean showWhenLocked) throws RemoteException {
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                origId = Binder.clearCallingIdentity();
                r.setShowWhenLocked(showWhenLocked);
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void setTurnScreenOn(IBinder token, boolean turnScreenOn) throws RemoteException {
        synchronized (this) {
            long origId;
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                origId = Binder.clearCallingIdentity();
                r.setTurnScreenOn(turnScreenOn);
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public boolean adjustSplitScreen(int action, int from) {
        return false;
    }

    public ComponentName getDockTopAppName() {
        return this.mStackSupervisor.getDockTopAppName();
    }

    public List<String> getAllTopPkgName() {
        return this.mStackSupervisor.getAllTopPkgName();
    }

    public ApplicationInfo getFreeFormAppInfo() {
        return this.mStackSupervisor.getFreeFormAppInfo();
    }

    public boolean getSupportsFreeformWindowManagement() {
        return this.mSupportsFreeformWindowManagement;
    }

    public void setSupportsFreeformWindowManagement(boolean supportsFreeformWindowManagement) {
        this.mSupportsFreeformWindowManagement = supportsFreeformWindowManagement;
    }

    protected void dynamicallyConfigLogTag(PrintWriter pw, String[] args, int opti) {
        pw.println("dynamicallyConfigLogTag, opti:" + opti + ", args.length:" + args.length);
        for (int index = 0; index < args.length; index++) {
            pw.println("dynamicallyConfigLogTag, args[" + index + "]:" + args[index]);
        }
        if (args.length != 3) {
            pw.println("********** Invalid argument! Get detail help as bellow: **********");
            logoutTagConfigHelp(pw);
            return;
        }
        String tag = args[1];
        boolean on = LocationManagerService.OPPO_FAKE_LOCATOIN_SWITCH_ON.equals(args[2]);
        pw.println("dynamicallyConfigLogTag, tag:" + tag + ", on:" + on);
        if ("life".equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_SWITCH = on;
            ActivityManagerDebugConfig.DEBUG_PAUSE = on;
            ActivityManagerDebugConfig.DEBUG_RESULTS = on;
            OppoSplitWindowAppReader.getInstance().handleDynamicLog(on);
            ActivityManagerDebugConfig.DEBUG_CLEANUP = on;
            ActivityManagerDebugConfig.DEBUG_USER_LEAVING = on;
        } else if ("visibility".equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_FOCUS = on;
            ActivityManagerDebugConfig.DEBUG_VISIBILITY = on;
            ActivityManagerDebugConfig.DEBUG_VISIBLE_BEHIND = on;
            ActivityManagerDebugConfig.DEBUG_TRANSITION = on;
        } else if ("config".equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_CONFIGURATION = on;
        } else if ("task".equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_TASKS = on;
            ActivityManagerDebugConfig.DEBUG_CLEANUP = on;
        } else if ("broadcast".equals(tag)) {
            ActivityManagerDebugConfig.DEBUG_BROADCAST = on;
            ActivityManagerDebugConfig.DEBUG_BROADCAST_BACKGROUND = on;
            ActivityManagerDebugConfig.DEBUG_BROADCAST_LIGHT = on;
            OppoBroadcastManager.getInstance(this).handleDynamicLog(on);
        } else if ("oppobroadcast".equals(tag)) {
            OppoBroadcastManager.getInstance(this).handleDynamicLog(on);
        } else if (!"multiwindow".equals(tag)) {
            if ("oppofreeform".equals(tag)) {
                ActivityManagerDebugConfig.DEBUG_OPPO_FREEFORM = on;
            } else if ("service".equals(tag)) {
                ActivityManagerDebugConfig.DEBUG_SERVICE = on;
                ActivityManagerDebugConfig.DEBUG_SERVICE_EXECUTING = on;
                ActivityManagerDebugConfig.DEBUG_MU = on;
                ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK = on;
                ActivityManagerDebugConfig.DEBUG_FOREGROUND_SERVICE = on;
                this.mServices.dynaicallyUpdateLogTag(on);
            } else if ("provider".equals(tag)) {
                ActivityManagerDebugConfig.DEBUG_PROVIDER = on;
                ActivityManagerDebugConfig.DEBUG_URI_PERMISSION = on;
                ActivityManagerDebugConfig.DEBUG_MU = on;
            } else if ("backup".equals(tag)) {
                ActivityManagerDebugConfig.DEBUG_BACKUP = on;
            } else if ("stack".equals(tag)) {
                ActivityManagerDebugConfig.DEBUG_STACK = on;
                ActivityManagerDebugConfig.DEBUG_ADD_REMOVE = on;
                ActivityManagerDebugConfig.DEBUG_APP = on;
                ActivityManagerDebugConfig.DEBUG_CONTAINERS = on;
                ActivityManagerDebugConfig.DEBUG_IDLE = on;
                ActivityManagerDebugConfig.DEBUG_RELEASE = on;
                ActivityManagerDebugConfig.DEBUG_SAVED_STATE = on;
                ActivityManagerDebugConfig.DEBUG_SCREENSHOTS = on;
                ActivityManagerDebugConfig.DEBUG_STATES = on;
            } else if ("process".equals(tag)) {
                ActivityManagerDebugConfig.DEBUG_PROCESSES = on;
                ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS = on;
            } else if ("other".equals(tag)) {
                ActivityManagerDebugConfig.DEBUG_POWER = on;
                ActivityManagerDebugConfig.DEBUG_THUMBNAILS = on;
                ActivityManagerDebugConfig.DEBUG_OOM_ADJ = on;
                ActivityManagerDebugConfig.DEBUG_PSS = on;
                ActivityManagerDebugConfig.DEBUG_LRU = on;
                ActivityManagerDebugConfig.DEBUG_LOCKSCREEN = on;
                ActivityManagerDebugConfig.DEBUG_RECENTS = on;
                if (on) {
                    SystemProperties.set("sys.activity.thread.log", "true");
                } else {
                    SystemProperties.set("sys.activity.thread.log", "false");
                }
                for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                    ProcessRecord app = (ProcessRecord) this.mLruProcesses.get(i);
                    if (app.thread != null) {
                        Slog.v(TAG, "app.thread.openActivityLog app " + app + " on " + on);
                        try {
                            app.thread.openActivityLog(on);
                        } catch (RemoteException e) {
                            Slog.w(TAG, "Got a RemoteException while open the activity log ");
                        }
                    }
                }
            } else if ("fstrim".equals(tag)) {
                ActivityManagerDebugConfig.DEBUG_FSTRIM = on;
            } else if ("permission".equals(tag)) {
                ActivityManagerDebugConfig.DEBUG_PERMISSION = on;
            } else if (OppoJunkRecorder.JUNK_RECORD_BASEDIR.equals(tag)) {
                ActivityManagerDebugConfig.DEBUG_JUNK = on;
            } else {
                pw.println("Failed! Invalid argument! Type cmd for help: dumpsys activity log");
            }
        }
    }

    protected void dynamicGetValue(PrintWriter pw, String[] args) {
        if (args.length == 1 || args.length == 2) {
            new DumpObject().dumpValue(pw, this, args.length == 2 ? args[1] : "");
            return;
        }
        pw.println("get_value usage:");
        pw.println("dumpsys activity get_value");
        pw.println("or");
        pw.println("dumpsys activity get_value variable");
    }

    protected void logoutTagConfigHelp(PrintWriter pw) {
        pw.println("********************** Help begin:**********************");
        pw.println("1 Activity life circle:DEBUG_SWITCH | DEBUG_PAUSE DEBUG_RESULTS | DEBUG_CLEANUP | DEBUG_STATES");
        pw.println("cmd: dumpsys activity log life 0/1");
        pw.println("----------------------------------");
        pw.println("2 App visibility:DEBUG_VISIBILITY | DEBUG_TRANSITION | DEBUG_FOCUS");
        pw.println("cmd: dumpsys activity log visibility 0/1");
        pw.println("----------------------------------");
        pw.println("3 Config process:DEBUG_CONFIGURATION");
        pw.println("cmd: dumpsys activity log config 0/1");
        pw.println("----------------------------------");
        pw.println("4 Task manage:DEBUG_TASKS | DEBUG_CLEANUP | DEBUG_ADD_REMOVE | DEBUG_SAVED_STATE");
        pw.println("cmd: dumpsys activity log task 0/1");
        pw.println("----------------------------------");
        pw.println("5 Broadcast manage:DEBUG_BROADCAST | DEBUG_BROADCAST_BACKGROUND | DEBUG_BROADCAST_LIGHT");
        pw.println("cmd: dumpsys activity log broadcast 0/1");
        pw.println("----------------------------------");
        pw.println("6 Service manage:DEBUG_SERVICE | DEBUG_SERVICE_EXECUTING | DEBUG_MU | ActiveServices's Log");
        pw.println("cmd: dumpsys activity log service 0/1");
        pw.println("----------------------------------");
        pw.println("7 Provider manage:DEBUG_PROVIDER | DEBUG_URI_PERMISSION | DEBUG_MU");
        pw.println("cmd: dumpsys activity log provider 0/1");
        pw.println("----------------------------------");
        pw.println("8 backup manage:DEBUG_BACKUP");
        pw.println("cmd: dumpsys activity log backup 0/1");
        pw.println("----------------------------------");
        pw.println("9 stack manager log:Ams stack & ActivityStackSupervisor & ActivityStack");
        pw.println("cmd: dumpsys activity log stack 0/1");
        pw.println("----------------------------------");
        pw.println("10 process manage:DEBUG_PROCESSES | DEBUG_PROCESS_OBSERVERS");
        pw.println("cmd: dumpsys activity log process 0/1");
        pw.println("----------------------------------");
        pw.println("11 oppoBroadcast manage:DEBUG_JUMP_QUEUE | DEBUG_ADJUST_PB_REC_QUE | DEBUG_ADJUST_OB_REC_QUE | DEBUG_BROADCAST_FIREWALL ");
        pw.println("cmd: dumpsys activity log oppobroadcast 0/1");
        pw.println("----------------------------------");
        pw.println("12 other not in common use:DEBUG_POWER | DEBUG_THUMBNAILS | DEBUG_OOM_ADJ | DEBUG_LOCKSCREEN | DEBUG_LRU | DEBUG_PSS ");
        pw.println("cmd: dumpsys activity log other 0/1");
        pw.println("----------------------------------");
        pw.println("13 fstrim:DEBUG_FSTRIM");
        pw.println("cmd: dumpsys activity log fstrim 0/1");
        pw.println("----------------------------------");
        pw.println("14 fstrim:DEBUG_PERMISSION");
        pw.println("cmd: dumpsys activity log permission 0/1");
        pw.println("----------------------------------");
        pw.println("15 junk:DEBUG_JUNK");
        pw.println("cmd: dumpsys activity log junk 0/1");
        pw.println("----------------------------------");
        pw.println("********************** Help end.  **********************");
    }

    protected void dumpDynamicallyLogSwitch(PrintWriter pw, String[] args, int opti) {
        boolean z = false;
        StringBuilder append;
        if (args.length == 1) {
            StringBuilder append2 = new StringBuilder().append("  life=");
            boolean z2 = (ActivityManagerDebugConfig.DEBUG_SWITCH && ActivityManagerDebugConfig.DEBUG_PAUSE && ActivityManagerDebugConfig.DEBUG_RESULTS) ? ActivityManagerDebugConfig.DEBUG_CLEANUP : false;
            append2 = append2.append(z2).append(" visibility=");
            if (ActivityManagerDebugConfig.DEBUG_FOCUS && ActivityManagerDebugConfig.DEBUG_VISIBILITY) {
                z2 = ActivityManagerDebugConfig.DEBUG_TRANSITION;
            } else {
                z2 = false;
            }
            append2 = append2.append(z2).append(" config=").append(ActivityManagerDebugConfig.DEBUG_CONFIGURATION).append(" task=");
            if (ActivityManagerDebugConfig.DEBUG_TASKS) {
                z2 = ActivityManagerDebugConfig.DEBUG_CLEANUP;
            } else {
                z2 = false;
            }
            append2 = append2.append(z2).append(" broadcast=");
            if (ActivityManagerDebugConfig.DEBUG_BROADCAST && ActivityManagerDebugConfig.DEBUG_BROADCAST_BACKGROUND) {
                z2 = ActivityManagerDebugConfig.DEBUG_BROADCAST_LIGHT;
            } else {
                z2 = false;
            }
            append2 = append2.append(z2).append(" service=");
            if (ActivityManagerDebugConfig.DEBUG_SERVICE && ActivityManagerDebugConfig.DEBUG_SERVICE_EXECUTING) {
                z2 = ActivityManagerDebugConfig.DEBUG_MU;
            } else {
                z2 = false;
            }
            append2 = append2.append(z2).append(" provider=");
            if (ActivityManagerDebugConfig.DEBUG_PROVIDER && ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                z2 = ActivityManagerDebugConfig.DEBUG_MU;
            } else {
                z2 = false;
            }
            append2 = append2.append(z2).append(" backup=").append(ActivityManagerDebugConfig.DEBUG_BACKUP).append(" stack=").append(ActivityManagerDebugConfig.DEBUG_STACK).append(" process=");
            if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                z2 = ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS;
            } else {
                z2 = false;
            }
            append = append2.append(z2).append(" other=");
            if (ActivityManagerDebugConfig.DEBUG_POWER && ActivityManagerDebugConfig.DEBUG_THUMBNAILS && ActivityManagerDebugConfig.DEBUG_OOM_ADJ && ActivityManagerDebugConfig.DEBUG_PSS && ActivityManagerDebugConfig.DEBUG_LRU) {
                z = ActivityManagerDebugConfig.DEBUG_LOCKSCREEN;
            }
            pw.println(append.append(z).append(" fstrim=").append(ActivityManagerDebugConfig.DEBUG_FSTRIM).toString());
        } else if (args.length == 2) {
            String tag = args[1];
            if ("life".equals(tag)) {
                append = new StringBuilder().append("  life=");
                if (ActivityManagerDebugConfig.DEBUG_SWITCH && ActivityManagerDebugConfig.DEBUG_PAUSE && ActivityManagerDebugConfig.DEBUG_RESULTS) {
                    z = ActivityManagerDebugConfig.DEBUG_CLEANUP;
                }
                pw.println(append.append(z).toString());
            } else if ("visibility".equals(tag)) {
                append = new StringBuilder().append("  visibility=");
                if (ActivityManagerDebugConfig.DEBUG_FOCUS && ActivityManagerDebugConfig.DEBUG_VISIBILITY) {
                    z = ActivityManagerDebugConfig.DEBUG_TRANSITION;
                }
                pw.println(append.append(z).toString());
            } else if ("config".equals(tag)) {
                pw.println("  config=" + ActivityManagerDebugConfig.DEBUG_CONFIGURATION);
            } else if ("task".equals(tag)) {
                append = new StringBuilder().append("  task=");
                if (ActivityManagerDebugConfig.DEBUG_TASKS) {
                    z = ActivityManagerDebugConfig.DEBUG_CLEANUP;
                }
                pw.println(append.append(z).toString());
            } else if ("broadcast".equals(tag)) {
                append = new StringBuilder().append("  broadcast=");
                if (ActivityManagerDebugConfig.DEBUG_BROADCAST && ActivityManagerDebugConfig.DEBUG_BROADCAST_BACKGROUND) {
                    z = ActivityManagerDebugConfig.DEBUG_BROADCAST_LIGHT;
                }
                pw.println(append.append(z).toString());
            } else if ("service".equals(tag)) {
                append = new StringBuilder().append("  service=");
                if (ActivityManagerDebugConfig.DEBUG_SERVICE && ActivityManagerDebugConfig.DEBUG_SERVICE_EXECUTING) {
                    z = ActivityManagerDebugConfig.DEBUG_MU;
                }
                pw.println(append.append(z).toString());
            } else if ("provider".equals(tag)) {
                append = new StringBuilder().append("  provider=");
                if (ActivityManagerDebugConfig.DEBUG_PROVIDER && ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                    z = ActivityManagerDebugConfig.DEBUG_MU;
                }
                pw.println(append.append(z).toString());
            } else if ("backup".equals(tag)) {
                pw.println("  backup=" + ActivityManagerDebugConfig.DEBUG_BACKUP);
            } else if ("stack".equals(tag)) {
                pw.println("  stack=" + ActivityManagerDebugConfig.DEBUG_STACK);
            } else if ("process".equals(tag)) {
                pw.println("  process=" + ActivityManagerDebugConfig.DEBUG_PROCESSES);
            } else if ("other".equals(tag)) {
                append = new StringBuilder().append("  other=");
                if (ActivityManagerDebugConfig.DEBUG_POWER && ActivityManagerDebugConfig.DEBUG_THUMBNAILS && ActivityManagerDebugConfig.DEBUG_OOM_ADJ && ActivityManagerDebugConfig.DEBUG_PSS && ActivityManagerDebugConfig.DEBUG_LRU) {
                    z = ActivityManagerDebugConfig.DEBUG_LOCKSCREEN;
                }
                pw.println(append.append(z).toString());
            } else if ("fstrim".equals(tag)) {
                pw.println("  fstrim=" + ActivityManagerDebugConfig.DEBUG_FSTRIM);
            } else {
                pw.println("Failed! Invalid argument!");
            }
        }
    }

    private void debugActionIfNecessary(Intent serviceIntent) {
        if (DEBUG_COLOROS_AMS && DEBUG_WECHAT) {
            boolean takeActionToDebug = false;
            if (!(serviceIntent == null || serviceIntent.getComponent() == null)) {
                String serviceCompName = serviceIntent.getComponent().flattenToString();
                Slog.d(TAG, "serviceCompName:" + serviceCompName);
                if (CMP_NAME_SCREENSHOT.equals(serviceCompName)) {
                    ComponentName currTopActComp = getTopAppName();
                    if (currTopActComp != null) {
                        String topAppPkgName = currTopActComp.flattenToString();
                        Slog.d(TAG, "topAppPkgName:" + topAppPkgName);
                        if (CMP_NAME_MM_UI.equals(topAppPkgName) || CMP_NAME_MM_SNS.equals(topAppPkgName)) {
                            Slog.d(TAG, "takeActionToDebug...");
                            takeActionToDebug = true;
                        }
                    }
                }
            }
            Slog.d(TAG, "takeActionToDebug:" + takeActionToDebug);
            if (takeActionToDebug) {
                new DebugActionThread(this).start();
            }
        }
    }

    @OppoHook(level = OppoHookType.NEW_METHOD, note = "Jianhua.Lin@Plf.SDK, 2017-08-22 : Add for EAP collects app error info", property = OppoRomType.ROM)
    private void collectErrorInfo(String dropboxTag, String eventType, ProcessRecord process, String processName, ActivityRecord activity, String subject, CrashInfo crashInfo) {
        try {
            if (dropboxTag.contains("app_crash") || dropboxTag.contains("app_anr")) {
                Intent errorIntent = new Intent("oppo.intent.action.EAP_APP_ERROR");
                errorIntent.setFlags(67108864);
                errorIntent.putExtra("eventType", eventType);
                errorIntent.putExtra("processName", this.mErrorPkgName);
                errorIntent.putExtra("fileId", this.mErrorTime);
                if (process != null) {
                    errorIntent.putExtra("foreground", process.isInterestingToUserLocked());
                }
                if (activity != null) {
                    errorIntent.putExtra(OppoAppStartupManager.TYPE_ACTIVITY, activity.shortComponentName);
                }
                if ("anr".equals(eventType)) {
                    errorIntent.putExtra("message", subject);
                }
                if ("crash".equals(eventType) && crashInfo != null) {
                    errorIntent.putExtra("className", crashInfo.exceptionClassName);
                    errorIntent.putExtra("message", crashInfo.exceptionMessage);
                    errorIntent.putExtra("stackTrace", crashInfo.stackTrace);
                }
                this.mContext.sendBroadcast(errorIntent);
            }
        } catch (Exception e) {
            Log.e(TAG, "fail to collect app error info, " + e);
        }
    }

    @OppoHook(level = OppoHookType.NEW_METHOD, note = "Jianhua.Lin@Plf.SDK, 2017-08-22 : Add for EAP collects app error info", property = OppoRomType.ROM)
    private void appendCpuInfo(StringBuilder sb, String eventType) {
        try {
            if ("crash".equals(eventType)) {
                long anrTime = SystemClock.uptimeMillis();
                updateCpuStatsNow();
                synchronized (this.mProcessCpuTracker) {
                    String cpuInfo = this.mProcessCpuTracker.printCurrentState(anrTime);
                    if (cpuInfo != null && cpuInfo.length() > OppoArpPeer.ARP_FIRST_RESPONSE_TIMEOUT) {
                        cpuInfo = cpuInfo.substring(0, OppoArpPeer.ARP_FIRST_RESPONSE_TIMEOUT);
                    }
                    sb.append("\n").append(cpuInfo).append("\n");
                }
            }
        } catch (Exception e) {
            Log.e(TAG, "fail to add cpu info, " + e);
        }
    }
}
