package com.android.server.pm;

import android.annotation.OppoHook;
import android.annotation.OppoHook.OppoHookType;
import android.annotation.OppoHook.OppoRomType;
import android.app.ActivityManager;
import android.app.ActivityManagerNative;
import android.app.AppOpsManager;
import android.app.IActivityManager;
import android.app.ResourcesManager;
import android.app.admin.IDevicePolicyManager;
import android.app.admin.SecurityLog;
import android.app.backup.IBackupManager;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.IIntentReceiver;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.IntentFilter.AuthorityEntry;
import android.content.IntentSender;
import android.content.IntentSender.SendIntentException;
import android.content.ServiceConnection;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.AppsQueryHelper;
import android.content.pm.AuxiliaryResolveInfo;
import android.content.pm.ChangedPackages;
import android.content.pm.FeatureInfo;
import android.content.pm.IDexModuleRegisterCallback;
import android.content.pm.IOnPermissionsChangeListener;
import android.content.pm.IPackageDataObserver;
import android.content.pm.IPackageDeleteObserver;
import android.content.pm.IPackageDeleteObserver2;
import android.content.pm.IPackageInstallObserver2;
import android.content.pm.IPackageInstaller;
import android.content.pm.IPackageManager.Stub;
import android.content.pm.IPackageManagerNative;
import android.content.pm.IPackageMoveObserver;
import android.content.pm.IPackageStatsObserver;
import android.content.pm.InstantAppInfo;
import android.content.pm.InstantAppRequest;
import android.content.pm.InstantAppResolveInfo;
import android.content.pm.InstrumentationInfo;
import android.content.pm.IntentFilterVerificationInfo;
import android.content.pm.KeySet;
import android.content.pm.LauncherActivityInfo;
import android.content.pm.LauncherApps;
import android.content.pm.PackageCleanItem;
import android.content.pm.PackageInfo;
import android.content.pm.PackageInfoLite;
import android.content.pm.PackageInstaller.SessionInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.LegacyPackageDeleteObserver;
import android.content.pm.PackageManagerInternal;
import android.content.pm.PackageManagerInternal.ExternalSourcesPolicy;
import android.content.pm.PackageManagerInternal.PackagesProvider;
import android.content.pm.PackageManagerInternal.SyncAdapterPackagesProvider;
import android.content.pm.PackageParser;
import android.content.pm.PackageParser.Activity;
import android.content.pm.PackageParser.ActivityIntentInfo;
import android.content.pm.PackageParser.Callback;
import android.content.pm.PackageParser.Instrumentation;
import android.content.pm.PackageParser.NewPermissionInfo;
import android.content.pm.PackageParser.Package;
import android.content.pm.PackageParser.PackageLite;
import android.content.pm.PackageParser.PackageParserException;
import android.content.pm.PackageParser.Permission;
import android.content.pm.PackageParser.PermissionGroup;
import android.content.pm.PackageParser.Provider;
import android.content.pm.PackageParser.ProviderIntentInfo;
import android.content.pm.PackageParser.Service;
import android.content.pm.PackageParser.ServiceIntentInfo;
import android.content.pm.PackageStats;
import android.content.pm.PackageUserState;
import android.content.pm.ParceledListSlice;
import android.content.pm.PermissionGroupInfo;
import android.content.pm.PermissionInfo;
import android.content.pm.ProviderInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.ServiceInfo;
import android.content.pm.SharedLibraryInfo;
import android.content.pm.Signature;
import android.content.pm.UserInfo;
import android.content.pm.VerifierDeviceIdentity;
import android.content.pm.VerifierInfo;
import android.content.pm.VersionedPackage;
import android.database.ContentObserver;
import android.graphics.Bitmap;
import android.graphics.Bitmap.Config;
import android.graphics.Canvas;
import android.graphics.Matrix;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.hardware.display.DisplayManager;
import android.net.Uri;
import android.os.Binder;
import android.os.Build;
import android.os.Build.VERSION;
import android.os.Bundle;
import android.os.Debug;
import android.os.Environment;
import android.os.Environment.UserEnvironment;
import android.os.FileObserver;
import android.os.FileUtils;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.os.Message;
import android.os.OppoManager;
import android.os.OppoUsageManager;
import android.os.Parcel;
import android.os.ParcelFileDescriptor;
import android.os.Process;
import android.os.RemoteCallbackList;
import android.os.RemoteException;
import android.os.ResultReceiver;
import android.os.SELinux;
import android.os.ServiceManager;
import android.os.ShellCallback;
import android.os.SystemClock;
import android.os.SystemProperties;
import android.os.Trace;
import android.os.UserHandle;
import android.os.UserManager;
import android.os.UserManagerInternal;
import android.os.storage.IStorageManager;
import android.os.storage.StorageEventListener;
import android.os.storage.StorageManager;
import android.os.storage.StorageManagerInternal;
import android.os.storage.StorageManagerInternal.ExternalStorageMountPolicy;
import android.os.storage.VolumeInfo;
import android.provider.Settings.Global;
import android.provider.Settings.Secure;
import android.security.KeyStore;
import android.security.SystemKeyStore;
import android.system.ErrnoException;
import android.system.Os;
import android.system.OsConstants;
import android.telephony.TelephonyManager;
import android.text.TextUtils;
import android.util.ArrayMap;
import android.util.ArraySet;
import android.util.Base64;
import android.util.DisplayMetrics;
import android.util.EventLog;
import android.util.ExceptionUtils;
import android.util.Log;
import android.util.LogPrinter;
import android.util.MathUtils;
import android.util.PackageUtils;
import android.util.Pair;
import android.util.PrintStreamPrinter;
import android.util.SeempLog;
import android.util.Slog;
import android.util.SparseArray;
import android.util.SparseBooleanArray;
import android.util.SparseIntArray;
import android.util.TimingsTraceLog;
import android.util.Xml;
import android.util.jar.StrictJarFile;
import android.util.proto.ProtoOutputStream;
import android.widget.Toast;
import com.android.internal.annotations.GuardedBy;
import com.android.internal.app.IMediaContainerService;
import com.android.internal.app.IntentForwarderActivity;
import com.android.internal.app.OppoAppScaleHelper;
import com.android.internal.app.ResolverActivity;
import com.android.internal.content.NativeLibraryHelper;
import com.android.internal.content.NativeLibraryHelper.Handle;
import com.android.internal.content.PackageHelper;
import com.android.internal.logging.MetricsLogger;
import com.android.internal.os.IParcelFileDescriptorFactory;
import com.android.internal.os.RegionalizationEnvironment;
import com.android.internal.os.RoSystemProperties;
import com.android.internal.os.SomeArgs;
import com.android.internal.telephony.CarrierAppUtils;
import com.android.internal.util.ArrayUtils;
import com.android.internal.util.ConcurrentUtils;
import com.android.internal.util.DumpUtils;
import com.android.internal.util.FastPrintWriter;
import com.android.internal.util.FastXmlSerializer;
import com.android.internal.util.IndentingPrintWriter;
import com.android.internal.util.Preconditions;
import com.android.internal.util.XmlUtils;
import com.android.server.AttributeCache;
import com.android.server.DeviceIdleController.LocalService;
import com.android.server.EventLogTags;
import com.android.server.IntentResolver;
import com.android.server.LocalServices;
import com.android.server.ServiceThread;
import com.android.server.SystemConfig;
import com.android.server.am.ActivityManagerService;
import com.android.server.am.OppoAppStartupManager;
import com.android.server.am.OppoCrashClearManager;
import com.android.server.am.OppoMultiAppManager;
import com.android.server.am.OppoMultiAppManagerUtil;
import com.android.server.am.OppoPermissionConstants;
import com.android.server.coloros.OppoListManager;
import com.android.server.display.OppoBrightUtils;
import com.android.server.display.OppoDPSHelper;
import com.android.server.face.FaceDaemonWrapper;
import com.android.server.fingerprint.HealthState;
import com.android.server.net.NetworkPolicyManagerInternal;
import com.android.server.pm.Installer.InstallerException;
import com.android.server.pm.PackageDexOptimizer.ForcedUpdatePackageDexOptimizer;
import com.android.server.pm.PermissionsState.PermissionState;
import com.android.server.pm.Settings.VersionInfo;
import com.android.server.pm.dex.DexManager;
import com.android.server.pm.dex.DexManager.RegisterDexModuleResult;
import com.android.server.pm.dex.DexoptOptions;
import com.android.server.policy.PhoneWindowManager;
import com.android.server.storage.DeviceStorageMonitorInternal;
import com.android.server.usage.UnixCalendar;
import com.android.server.usb.descriptors.UsbTerminalTypes;
import com.oppo.hypnus.Hypnus;
import dalvik.system.CloseGuard;
import dalvik.system.VMRuntime;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.nio.charset.StandardCharsets;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.zip.GZIPInputStream;
import libcore.io.IoUtils;
import libcore.io.Streams;
import libcore.util.EmptyArray;
import oppo.content.res.OppoFontUtils;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.XmlSerializer;

public class PackageManagerService extends Stub implements PackageSender {
    private static final List<String> ALL_DANGEROUS_PERMISSIONS = Arrays.asList(new String[]{OppoPermissionConstants.PERMISSION_READ_CALENDAR, OppoPermissionConstants.PERMISSION_WRITE_CALENDAR, OppoPermissionConstants.PERMISSION_CAMERA, OppoPermissionConstants.PERMISSION_READ_CONTACTS, OppoPermissionConstants.PERMISSION_WRITE_CONTACTS, OppoPermissionConstants.PERMISSION_GET_ACCOUNTS, OppoPermissionConstants.PERMISSION_ACCESS, "android.permission.ACCESS_COARSE_LOCATION", OppoPermissionConstants.PERMISSION_RECORD_AUDIO, OppoPermissionConstants.PERMISSION_READ_PHONE_STATE, OppoPermissionConstants.PERMISSION_CALL_PHONE, OppoPermissionConstants.PERMISSION_READ_CALL_LOG, OppoPermissionConstants.PERMISSION_WRITE_CALL_LOG, OppoPermissionConstants.PERMISSION_ADD_VOICEMAIL, OppoPermissionConstants.PERMISSION_USE_SIP, OppoPermissionConstants.PERMISSION_PROCESS_OUTGOING_CALLS, "android.permission.READ_CELL_BROADCASTS", OppoPermissionConstants.PERMISSION_SENSORS, OppoPermissionConstants.PERMISSION_SEND_SMS, OppoPermissionConstants.PERMISSION_RECEIVE_SMS, OppoPermissionConstants.PERMISSION_READ_SMS, OppoPermissionConstants.PERMISSION_RECEIVE_WAP_PUSH, OppoPermissionConstants.PERMISSION_RECEIVE_MMS, "android.permission.READ_EXTERNAL_STORAGE", "android.permission.WRITE_EXTERNAL_STORAGE", "android.permission.READ_PHONE_NUMBERS", "android.permission.ANSWER_PHONE_CALLS"});
    private static final String ATTR_IS_GRANTED = "g";
    private static final String ATTR_PACKAGE_NAME = "pkg";
    private static final String ATTR_PERMISSION_NAME = "name";
    private static final String ATTR_REVOKE_ON_UPGRADE = "rou";
    private static final String ATTR_USER_FIXED = "fixed";
    private static final String ATTR_USER_SET = "set";
    private static final int BLUETOOTH_UID = 1002;
    static final int BROADCAST_DELAY = 10000;
    static final int CHECK_PENDING_VERIFICATION = 16;
    private static final String CHROME_BROWSER_PKG_NAME = "com.android.chrome";
    static final boolean CLEAR_RUNTIME_PERMISSIONS_ON_UPGRADE = false;
    private static final String COMPRESSED_EXTENSION = ".gz";
    private static final int DATA_FREE_SIZE_THRESHOLD = 16;
    static boolean DEBUG_ABI_SELECTION = false;
    private static final boolean DEBUG_APP_DATA = false;
    private static final boolean DEBUG_BACKUP = false;
    static boolean DEBUG_BROADCASTS = false;
    private static final boolean DEBUG_COMPRESSION = Build.IS_DEBUGGABLE;
    static boolean DEBUG_DEXOPT = (DEBUG_PMS);
    static final boolean DEBUG_DEXOPT_BACKUP = false;
    static final boolean DEBUG_DOMAIN_VERIFICATION = false;
    private static final boolean DEBUG_EPHEMERAL = Build.IS_DEBUGGABLE;
    private static final boolean DEBUG_FILTERS = false;
    static boolean DEBUG_FOR_PERMISSION = SystemProperties.getBoolean("persist.sys.debug.perm", true);
    static boolean DEBUG_INSTALL = false;
    static boolean DEBUG_INTENT_MATCHING = false;
    static boolean DEBUG_PACKAGE_INFO = false;
    static boolean DEBUG_PACKAGE_SCANNING = false;
    private static final boolean DEBUG_PERMISSIONS = false;
    static boolean DEBUG_PMS = true;
    static boolean DEBUG_PREFERRED = false;
    static boolean DEBUG_REMOVE = false;
    static boolean DEBUG_SD_INSTALL = DEBUG_PMS;
    static boolean DEBUG_SETTINGS = false;
    private static final boolean DEBUG_SHARED_LIBRARIES = false;
    static boolean DEBUG_SHOW_INFO = false;
    private static final boolean DEBUG_TRIAGED_MISSING = false;
    static boolean DEBUG_UPGRADE = false;
    static boolean DEBUG_VERIFY = false;
    static final ComponentName DEFAULT_CONTAINER_COMPONENT = new ComponentName(DEFAULT_CONTAINER_PACKAGE, "com.android.defcontainer.DefaultContainerService");
    static final String DEFAULT_CONTAINER_PACKAGE = "com.android.defcontainer";
    private static final long DEFAULT_MANDATORY_FSTRIM_INTERVAL = 259200000;
    private static final boolean DEFAULT_PACKAGE_PARSER_CACHE_ENABLED = true;
    private static final long DEFAULT_UNUSED_STATIC_SHARED_LIB_MIN_CACHE_PERIOD = 7200000;
    private static final int DEFAULT_VERIFICATION_RESPONSE = 1;
    private static final long DEFAULT_VERIFICATION_TIMEOUT = 10000;
    private static final boolean DEFAULT_VERIFY_ENABLE = true;
    private static final int[] EMPTY_INT_ARRAY = new int[0];
    private static final boolean ENABLE_FREE_CACHE_V2 = SystemProperties.getBoolean("fw.free_cache_v2", true);
    static final int END_COPY = 4;
    static final boolean EXP_VERSION = SystemProperties.get("ro.oppo.version", "CN").equalsIgnoreCase("US");
    static final int FIND_INSTALL_LOC = 8;
    static final int FLAGS_REMOVE_CHATTY = Integer.MIN_VALUE;
    private static final String GAME_CENTER_PKGNAME = "com.nearme.gamecenter";
    private static final String GAME_CENTER_SYSTEM_APP = "com.nearme.deamon";
    private static final int GRANT_DENIED = 1;
    private static final int GRANT_INSTALL = 2;
    private static final int GRANT_RUNTIME = 3;
    private static final int GRANT_UPGRADE = 4;
    private static final boolean HIDE_EPHEMERAL_APIS = false;
    static final int INIT_COPY = 5;
    private static final String INSTALL_PACKAGE_SUFFIX = "-";
    static final int INSTANT_APP_RESOLUTION_PHASE_TWO = 20;
    static final int INTENT_FILTER_VERIFIED = 18;
    private static final String KILL_APP_REASON_GIDS_CHANGED = "permission grant or revoke changed gids";
    private static final String KILL_APP_REASON_PERMISSIONS_REVOKED = "permissions revoked";
    private static final int LOG_UID = 1007;
    private static final int MAX_PERMISSION_TREE_FOOTPRINT = 32768;
    static final int MCS_BOUND = 3;
    static final int MCS_GIVE_UP = 11;
    static final int MCS_RECONNECT = 10;
    static final int MCS_UNBIND = 6;
    static final int MSG_CACHE_ICON_INIT = 23;
    static final int MSG_PACAKGE_ADDED = 21;
    static final int MSG_PACKAGE_REMOVED = 22;
    private static final int NFC_UID = 1027;
    private static final String OPPO_BROWSER_PKG_NAME = "com.android.browser";
    private static final String OPPO_DEFAULT_BROWSER_FEATURE = "oppo.exp.default.browser";
    private static final String OPPO_LOWRAM_FEATURE = "oppo.rom.lowram.support";
    private static final String OPPO_SECURITYPAY_FEATURE = "oppo.securitypay.support";
    private static final String PACKAGE_MIME_TYPE = "application/vnd.android.package-archive";
    private static final String PACKAGE_PARSER_CACHE_VERSION = "1";
    private static final String PACKAGE_SCHEME = "package";
    static final int PACKAGE_VERIFIED = 15;
    static final String PLATFORM_PACKAGE_NAME = "android";
    static final int POST_INSTALL = 9;
    private static final Set<String> PROTECTED_ACTIONS = new ArraySet();
    private static final int RADIO_UID = 1001;
    private static final int READ_SYSTEM_DEFAULT_DELAY_TIME = 20000;
    public static final int REASON_AB_OTA = 4;
    public static final int REASON_BACKGROUND_DEXOPT = 3;
    public static final int REASON_BOOT = 1;
    public static final int REASON_CORE_APP = 7;
    public static final int REASON_FIRST_BOOT = 0;
    public static final int REASON_INACTIVE_PACKAGE_DOWNGRADE = 5;
    public static final int REASON_INSTALL = 2;
    public static final int REASON_LAST = 7;
    public static final int REASON_SHARED = 6;
    private static final String REGION_INDIA = "IN";
    private static final String SCANSTAGE_PROPERTY = "persist.sys.oppo.scanstage";
    static final int SCAN_AS_FULL_APP = 262144;
    static final int SCAN_AS_INSTANT_APP = 131072;
    static final int SCAN_AS_VIRTUAL_PRELOAD = 524288;
    static final int SCAN_BOOTING = 64;
    static final int SCAN_CHECK_ONLY = 8192;
    static final int SCAN_DELETE_DATA_ON_FAILURES = 256;
    static final int SCAN_DONT_KILL_APP = 16384;
    static final int SCAN_FIRST_BOOT_OR_UPGRADE = 65536;
    static final int SCAN_FORCE_DEX = 4;
    static final int SCAN_IGNORE_FROZEN = 32768;
    static final int SCAN_INITIAL = 4096;
    static final int SCAN_MOVE = 2048;
    static final int SCAN_NEW_INSTALL = 16;
    static final int SCAN_NO_DEX = 2;
    static final int SCAN_REPLACING = 512;
    static final int SCAN_REQUIRE_KNOWN = 1024;
    static final int SCAN_TRUSTED_OVERLAY = 128;
    static final int SCAN_UPDATE_SIGNATURE = 8;
    static final int SCAN_UPDATE_TIME = 32;
    private static final String SD_ENCRYPTION_ALGORITHM = "AES";
    private static final String SD_ENCRYPTION_KEYSTORE_NAME = "AppsOnSD";
    static final int SEND_PENDING_BROADCAST = 1;
    private static final int SHELL_UID = 2000;
    static final int START_CLEANING_PACKAGE = 7;
    static final int START_INTENT_FILTER_VERIFICATIONS = 17;
    private static final String STATIC_SHARED_LIB_DELIMITER = "_";
    private static final String STUB_SUFFIX = "-Stub";
    private static final int SYSTEM_RUNTIME_GRANT_MASK = 52;
    static final String TAG = "PackageManager";
    private static final String TAG_ALL_GRANTS = "rt-grants";
    private static final String TAG_DEFAULT_APPS = "da";
    private static final String TAG_GRANT = "grant";
    private static final String TAG_INTENT_FILTER_VERIFICATION = "iv";
    private static final String TAG_PERMISSION = "perm";
    private static final String TAG_PERMISSION_BACKUP = "perm-grant-backup";
    private static final String TAG_PREFERRED_BACKUP = "pa";
    private static final int TYPE_ACTIVITY = 1;
    private static final int TYPE_PROVIDER = 4;
    private static final int TYPE_RECEIVER = 2;
    private static final int TYPE_SERVICE = 3;
    private static final int TYPE_UNKNOWN = 0;
    static final int UPDATED_MEDIA_STATUS = 12;
    static final int UPDATE_PERMISSIONS_ALL = 1;
    static final int UPDATE_PERMISSIONS_REPLACE_ALL = 4;
    static final int UPDATE_PERMISSIONS_REPLACE_PKG = 2;
    private static final int USER_RUNTIME_GRANT_MASK = 11;
    private static final String VENDOR_OVERLAY_DIR = "/vendor/overlay";
    static final long WATCHDOG_TIMEOUT = 600000;
    static final int WRITE_PACKAGE_LIST = 19;
    static final int WRITE_PACKAGE_RESTRICTIONS = 14;
    static final int WRITE_SETTINGS = 13;
    static final int WRITE_SETTINGS_DELAY = 10000;
    private static ConcurrentHashMap<String, Bitmap> mActivityIconsCache = new ConcurrentHashMap();
    private static ConcurrentHashMap<String, Bitmap> mAppIconsCache = new ConcurrentHashMap();
    private static ConcurrentHashMap<String, Bitmap> mAppIconsCacheCompress = new ConcurrentHashMap();
    private static CompatibilityHelper mCompatibilityHelper = null;
    private static Hypnus mHyp = null;
    static final String mNetLock = SystemProperties.get("ro.oppo.region.netlock", "");
    static final String mOperator = SystemProperties.get("ro.oppo.operator", "oppo");
    private static final Comparator<ProviderInfo> mProviderInitOrderSorter = new Comparator<ProviderInfo>() {
        public int compare(ProviderInfo p1, ProviderInfo p2) {
            int v1 = p1.initOrder;
            int v2 = p2.initOrder;
            if (v1 > v2) {
                return -1;
            }
            return v1 < v2 ? 1 : 0;
        }
    };
    static final String mRegion = SystemProperties.get("persist.sys.oppo.region", "CN");
    static final String mRegionMark = SystemProperties.get("ro.oppo.regionmark", "");
    private static final Comparator<ResolveInfo> mResolvePrioritySorter = new Comparator<ResolveInfo>() {
        public int compare(ResolveInfo r1, ResolveInfo r2) {
            int i = -1;
            int v1 = r1.priority;
            int v2 = r2.priority;
            if (v1 != v2) {
                if (v1 <= v2) {
                    i = 1;
                }
                return i;
            }
            v1 = r1.preferredOrder;
            v2 = r2.preferredOrder;
            if (v1 != v2) {
                if (v1 <= v2) {
                    i = 1;
                }
                return i;
            } else if (r1.isDefault != r2.isDefault) {
                if (!r1.isDefault) {
                    i = 1;
                }
                return i;
            } else {
                v1 = r1.match;
                v2 = r2.match;
                if (v1 != v2) {
                    if (v1 <= v2) {
                        i = 1;
                    }
                    return i;
                } else if (r1.system != r2.system) {
                    if (!r1.system) {
                        i = 1;
                    }
                    return i;
                } else if (r1.activityInfo != null) {
                    return r1.activityInfo.packageName.compareTo(r2.activityInfo.packageName);
                } else {
                    if (r1.serviceInfo != null) {
                        return r1.serviceInfo.packageName.compareTo(r2.serviceInfo.packageName);
                    }
                    if (r1.providerInfo != null) {
                        return r1.providerInfo.packageName.compareTo(r2.providerInfo.packageName);
                    }
                    return 0;
                }
            }
        }
    };
    private static final Comparator<ResolveInfo> mSystemAppPrioritySorter = new Comparator<ResolveInfo>() {
        public int compare(ResolveInfo r1, ResolveInfo r2) {
            int i = -1;
            int v1 = r1.priority;
            int v2 = r2.priority;
            if (v1 != v2) {
                if (v1 <= v2) {
                    i = 1;
                }
                return i;
            }
            v1 = r1.preferredOrder;
            v2 = r2.preferredOrder;
            if (v1 != v2) {
                if (v1 <= v2) {
                    i = 1;
                }
                return i;
            } else if (r1.isDefault != r2.isDefault) {
                if (!r1.isDefault) {
                    i = 1;
                }
                return i;
            } else {
                boolean isSystemApp1 = r1.system;
                boolean isSystemApp2 = r2.system;
                if (!(r1.activityInfo == null || (r1.system ^ 1) == 0 || !ColorPackageManagerHelper.isSystemDataApp(r1.activityInfo.packageName))) {
                    isSystemApp1 = true;
                }
                if (!(r2.activityInfo == null || (r2.system ^ 1) == 0 || !ColorPackageManagerHelper.isSystemDataApp(r2.activityInfo.packageName))) {
                    isSystemApp2 = true;
                }
                if (isSystemApp1 == isSystemApp2) {
                    return 0;
                }
                if (!isSystemApp1) {
                    i = 1;
                }
                return i;
            }
        }
    };
    private static final Intent sBrowserIntent = new Intent();
    static UserManagerService sUserManager;
    private final String CUSTOMIZE_LIST_PATH;
    private final String CUSTOMIZE_SYSTEM_APP_BLACKLIST_PATH;
    final ActivityIntentResolver mActivities;
    ApplicationInfo mAndroidApplication;
    File mAppChanelFile;
    List<String> mAppChannelArrayList;
    final File mAppInstallDir;
    private File mAppLib32InstallDir;
    final ArrayMap<String, ArraySet<String>> mAppOpPermissionPackages;
    final String mAsecInternalPath;
    @GuardedBy("mAvailableFeatures")
    final ArrayMap<String, FeatureInfo> mAvailableFeatures;
    private BlackAppInstallHelper mBlackAppInstallHelper;
    private File mCacheDir;
    @GuardedBy("mPackages")
    final SparseArray<SparseArray<String>> mChangedPackages;
    @GuardedBy("mPackages")
    int mChangedPackagesSequenceNumber;
    @GuardedBy("mPackages")
    final SparseArray<Map<String, Integer>> mChangedPackagesSequenceNumbers;
    private final Runnable mClearSystemApp;
    private final CompilerStats mCompilerStats;
    private IMediaContainerService mContainerService;
    final Context mContext;
    ComponentName mCustomResolverComponentName;
    private List<String> mCustomizeList;
    private List<String> mCustomizeSystemAppBlacklist;
    List<String> mDataAppArrayList;
    File mDataAppDir;
    File mDataAppPathNameFile;
    File mDataAppPkgNameFile;
    File mDataEngineermodeDir;
    private final DefaultContainerConnection mDefContainerConn;
    final int mDefParseFlags;
    @GuardedBy("mPackages")
    boolean mDefaultContainerWhitelisted = false;
    final DefaultPermissionGrantPolicy mDefaultPermissionPolicy;
    private boolean mDeferProtectedFilters;
    private LocalService mDeviceIdleController;
    String mDeviceType;
    private final DexManager mDexManager;
    @GuardedBy("mPackages")
    private boolean mDexOptDialogShown;
    private ArraySet<Integer> mDirtyUsers;
    final File mDrmAppPrivateInstallDir;
    private volatile boolean mEphemeralAppsDisabled;
    private final ArraySet<String> mExistingSystemPackages;
    private final ArrayMap<String, File> mExpectingBetter;
    ExternalSourcesPolicy mExternalSourcesPolicy;
    final boolean mFactoryTest;
    boolean mFirstBoot;
    boolean mFoundPolicyFile;
    @GuardedBy("mPackages")
    final ArraySet<String> mFrozenPackages;
    final int[] mGlobalGids;
    final PackageHandler mHandler;
    final ServiceThread mHandlerThread;
    volatile boolean mHasSystemUidErrors;
    final Object mInstallLock;
    @GuardedBy("mInstallLock")
    final Installer mInstaller;
    final PackageInstallerService mInstallerService;
    ActivityInfo mInstantAppInstallerActivity;
    final ResolveInfo mInstantAppInstallerInfo;
    private final InstantAppRegistry mInstantAppRegistry;
    final EphemeralResolverConnection mInstantAppResolverConnection;
    final ComponentName mInstantAppResolverSettingsComponent;
    final ArrayMap<ComponentName, Instrumentation> mInstrumentation;
    final SparseArray<IntentFilterVerificationState> mIntentFilterVerificationStates;
    private int mIntentFilterVerificationToken;
    private final IntentFilterVerifier<ActivityIntentInfo> mIntentFilterVerifier;
    private final ComponentName mIntentFilterVerifierComponent;
    boolean mIsCtsAppInstall;
    final boolean mIsPreNMR1Upgrade;
    final boolean mIsPreNUpgrade;
    final boolean mIsUpgrade;
    @GuardedBy("mPackages")
    final SparseIntArray mIsolatedOwners;
    private List<String> mKeepUninstalledPackages;
    final ArrayMap<String, Set<String>> mKnownCodebase;
    @GuardedBy("mLoadedVolumes")
    final ArraySet<String> mLoadedVolumes;
    private boolean mLowRamFeature;
    private boolean mMediaMounted;
    final DisplayMetrics mMetrics;
    private final MoveCallbacks mMoveCallbacks;
    File mNetLockExpAppPathNameFile;
    File mNetLockExpAppPkgNameFile;
    int mNextInstallToken;
    private AtomicInteger mNextMoveId;
    private final OnPermissionChangeListeners mOnPermissionChangeListeners;
    final boolean mOnlyCore;
    File mOperatorExpAppPathNameFile;
    File mOperatorExpAppPkgNameFile;
    private OppoAppScaleHelper mOppoAppScaleHelper;
    ArrayMap<String, FeatureInfo> mOppoAvailableFeatures;
    private OppoDPSHelper mOppoDPSHelper;
    public ArrayList<OppoAdbInstallerEntry> mOppoPackageInstallerList;
    private OppoDcimProtectionService mOppoScimProtection;
    final String mOptionalVerifierPackage;
    private HashMap<Integer, IPackageDeleteObserver> mPackageDeleteList;
    private final PackageDexOptimizer mPackageDexOptimizer;
    private final String[] mPackageInstaller;
    final Callback mPackageParserCallback;
    private final PackageUsage mPackageUsage;
    @GuardedBy("mPackages")
    final ArrayMap<String, Package> mPackages;
    File mPackagexmlFile;
    final ParallelPackageParserCallback mParallelPackageParserCallback;
    final PendingPackageBroadcasts mPendingBroadcasts;
    final SparseArray<PackageVerificationState> mPendingVerification;
    private int mPendingVerificationToken;
    final ArrayMap<String, PermissionGroup> mPermissionGroups;
    final boolean mPermissionReviewRequired;
    Package mPlatformPackage;
    private ArrayList<Message> mPostSystemReadyMessages;
    private Future<?> mPrepareAppDataFuture;
    private ArraySet<String> mPrivappPermissionsViolations;
    private final ProcessLoggingHandler mProcessLoggingHandler;
    boolean mPromoteSystemApps;
    @GuardedBy("mProtectedBroadcasts")
    final ArraySet<String> mProtectedBroadcasts;
    private final List<ActivityIntentInfo> mProtectedFilters;
    final ProtectedPackages mProtectedPackages;
    final ProviderIntentResolver mProviders;
    final ArrayMap<String, Provider> mProvidersByAuthority;
    private final Runnable mReadSystemDefaultApp;
    final ActivityIntentResolver mReceivers;
    final File mRegionalizationAppInstallDir;
    final String mRequiredInstallerPackage;
    final String mRequiredUninstallerPackage;
    final String mRequiredVerifierPackage;
    final ActivityInfo mResolveActivity;
    ComponentName mResolveComponentName;
    final ResolveInfo mResolveInfo;
    boolean mResolverReplaced;
    private ArrayMap<OriginInfo, String> mRunningInstallerPkgName;
    final SparseArray<PostInstallData> mRunningInstalls;
    volatile boolean mSafeMode;
    final int mSdkVersion;
    final String[] mSeparateProcesses;
    final ServiceIntentResolver mServices;
    final String mServicesSystemSharedLibraryPackageName;
    @GuardedBy("mPackages")
    final Settings mSettings;
    final String mSetupWizardPackage;
    final ArrayMap<String, SparseArray<SharedLibraryEntry>> mSharedLibraries;
    final String mSharedSystemSharedLibraryPackageName;
    private BroadcastReceiver mSkinChangedReceiver;
    final ArrayMap<String, SparseArray<SharedLibraryEntry>> mStaticLibsByDeclaringPackage;
    private StorageEventListener mStorageListener;
    final String mStorageManagerPackage;
    List<String> mSystemAppArrayList;
    File mSystemAppPkgFileName;
    File mSystemEtcDir;
    final SparseArray<ArraySet<String>> mSystemPermissions;
    volatile boolean mSystemReady;
    private boolean mThemeIconsChanged;
    private FileObserver mThemeIconsFileObserver;
    final ArraySet<String> mTransferedPackages;
    private UserManagerInternal mUserManagerInternal;
    SparseBooleanArray mUserNeedsBadging;

    final class ActivityIntentResolver extends IntentResolver<ActivityIntentInfo, ResolveInfo> {
        private final ArrayMap<ComponentName, Activity> mActivities = new ArrayMap();
        private int mFlags;

        public class IterGenerator<E> {
            public Iterator<E> generate(ActivityIntentInfo info) {
                return null;
            }
        }

        public class ActionIterGenerator extends IterGenerator<String> {
            public ActionIterGenerator() {
                super();
            }

            public Iterator<String> generate(ActivityIntentInfo info) {
                return info.actionsIterator();
            }
        }

        public class CategoriesIterGenerator extends IterGenerator<String> {
            public CategoriesIterGenerator() {
                super();
            }

            public Iterator<String> generate(ActivityIntentInfo info) {
                return info.categoriesIterator();
            }
        }

        public class AuthoritiesIterGenerator extends IterGenerator<AuthorityEntry> {
            public AuthoritiesIterGenerator() {
                super();
            }

            public Iterator<AuthorityEntry> generate(ActivityIntentInfo info) {
                return info.authoritiesIterator();
            }
        }

        public class SchemesIterGenerator extends IterGenerator<String> {
            public SchemesIterGenerator() {
                super();
            }

            public Iterator<String> generate(ActivityIntentInfo info) {
                return info.schemesIterator();
            }
        }

        ActivityIntentResolver() {
        }

        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            this.mFlags = defaultOnly ? 65536 : 0;
            return super.queryIntent(intent, resolvedType, defaultOnly, userId);
        }

        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, int flags, int userId) {
            boolean z = false;
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            this.mFlags = flags;
            if ((65536 & flags) != 0) {
                z = true;
            }
            return super.queryIntent(intent, resolvedType, z, userId);
        }

        public List<ResolveInfo> queryIntentForPackage(Intent intent, String resolvedType, int flags, ArrayList<Activity> packageActivities, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId) || packageActivities == null) {
                return null;
            }
            this.mFlags = flags;
            boolean defaultOnly = (65536 & flags) != 0;
            int N = packageActivities.size();
            ArrayList<ActivityIntentInfo[]> listCut = new ArrayList(N);
            for (int i = 0; i < N; i++) {
                ArrayList<ActivityIntentInfo> intentFilters = ((Activity) packageActivities.get(i)).intents;
                if (intentFilters != null && intentFilters.size() > 0) {
                    ActivityIntentInfo[] array = new ActivityIntentInfo[intentFilters.size()];
                    intentFilters.toArray(array);
                    listCut.add(array);
                }
            }
            return super.queryIntentFromList(intent, resolvedType, defaultOnly, listCut, userId);
        }

        private Activity findMatchingActivity(List<Activity> activityList, ActivityInfo activityInfo) {
            for (Activity sysActivity : activityList) {
                if (sysActivity.info.name.equals(activityInfo.name) || sysActivity.info.name.equals(activityInfo.targetActivity)) {
                    return sysActivity;
                }
                if (sysActivity.info.targetActivity != null && (sysActivity.info.targetActivity.equals(activityInfo.name) || sysActivity.info.targetActivity.equals(activityInfo.targetActivity))) {
                    return sysActivity;
                }
            }
            return null;
        }

        private <T> void getIntentListSubset(List<ActivityIntentInfo> intentList, IterGenerator<T> generator, Iterator<T> searchIterator) {
            while (searchIterator.hasNext() && intentList.size() != 0) {
                T searchAction = searchIterator.next();
                Iterator<ActivityIntentInfo> intentIter = intentList.iterator();
                while (intentIter.hasNext()) {
                    boolean selectionFound = false;
                    Iterator<T> intentSelectionIter = generator.generate((ActivityIntentInfo) intentIter.next());
                    while (intentSelectionIter != null && intentSelectionIter.hasNext()) {
                        T intentSelection = intentSelectionIter.next();
                        if (intentSelection != null && intentSelection.equals(searchAction)) {
                            selectionFound = true;
                            break;
                        }
                    }
                    if (!selectionFound) {
                        intentIter.remove();
                    }
                }
            }
        }

        private boolean isProtectedAction(ActivityIntentInfo filter) {
            Iterator<String> actionsIter = filter.actionsIterator();
            while (actionsIter != null && actionsIter.hasNext()) {
                if (PackageManagerService.PROTECTED_ACTIONS.contains((String) actionsIter.next())) {
                    return true;
                }
            }
            return false;
        }

        private void adjustPriority(List<Activity> systemActivities, ActivityIntentInfo intent) {
            if (intent.getPriority() > 0) {
                ActivityInfo activityInfo = intent.activity.info;
                if (!((activityInfo.applicationInfo.privateFlags & 8) != 0)) {
                    intent.setPriority(0);
                } else if (systemActivities != null) {
                    Activity foundActivity = findMatchingActivity(systemActivities, activityInfo);
                    if (foundActivity == null) {
                        intent.setPriority(0);
                        return;
                    }
                    List<ActivityIntentInfo> intentListCopy = new ArrayList(foundActivity.intents);
                    List<ActivityIntentInfo> foundFilters = findFilters(intent);
                    Iterator<String> actionsIterator = intent.actionsIterator();
                    if (actionsIterator != null) {
                        getIntentListSubset(intentListCopy, new ActionIterGenerator(), actionsIterator);
                        if (intentListCopy.size() == 0) {
                            intent.setPriority(0);
                            return;
                        }
                    }
                    Iterator<String> categoriesIterator = intent.categoriesIterator();
                    if (categoriesIterator != null) {
                        getIntentListSubset(intentListCopy, new CategoriesIterGenerator(), categoriesIterator);
                        if (intentListCopy.size() == 0) {
                            intent.setPriority(0);
                            return;
                        }
                    }
                    Iterator<String> schemesIterator = intent.schemesIterator();
                    if (schemesIterator != null) {
                        getIntentListSubset(intentListCopy, new SchemesIterGenerator(), schemesIterator);
                        if (intentListCopy.size() == 0) {
                            intent.setPriority(0);
                            return;
                        }
                    }
                    Iterator<AuthorityEntry> authoritiesIterator = intent.authoritiesIterator();
                    if (authoritiesIterator != null) {
                        getIntentListSubset(intentListCopy, new AuthoritiesIterGenerator(), authoritiesIterator);
                        if (intentListCopy.size() == 0) {
                            intent.setPriority(0);
                            return;
                        }
                    }
                    int cappedPriority = 0;
                    for (int i = intentListCopy.size() - 1; i >= 0; i--) {
                        cappedPriority = Math.max(cappedPriority, ((ActivityIntentInfo) intentListCopy.get(i)).getPriority());
                    }
                    if (intent.getPriority() > cappedPriority) {
                        intent.setPriority(cappedPriority);
                    }
                } else if (!isProtectedAction(intent)) {
                } else {
                    if (PackageManagerService.this.mDeferProtectedFilters) {
                        PackageManagerService.this.mProtectedFilters.add(intent);
                    } else if (!intent.activity.info.packageName.equals(PackageManagerService.this.mSetupWizardPackage)) {
                        intent.setPriority(0);
                    }
                }
            }
        }

        public final void addActivity(Activity a, String type) {
            this.mActivities.put(a.getComponentName(), a);
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                Log.v(PackageManagerService.TAG, "  " + type + " " + (a.info.nonLocalizedLabel != null ? a.info.nonLocalizedLabel : a.info.name) + ":");
            }
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                Log.v(PackageManagerService.TAG, "    Class=" + a.info.name);
            }
            int NI = a.intents.size();
            for (int j = 0; j < NI; j++) {
                ActivityIntentInfo intent = (ActivityIntentInfo) a.intents.get(j);
                if (OppoAppStartupManager.TYPE_ACTIVITY.equals(type)) {
                    PackageSetting ps = PackageManagerService.this.mSettings.getDisabledSystemPkgLPr(intent.activity.info.packageName);
                    List systemActivities = (ps == null || ps.pkg == null) ? null : ps.pkg.activities;
                    adjustPriority(systemActivities, intent);
                }
                if (PackageManagerService.DEBUG_SHOW_INFO) {
                    Log.v(PackageManagerService.TAG, "    IntentFilter:");
                    intent.dump(new LogPrinter(2, PackageManagerService.TAG), "      ");
                }
                if (!intent.debugCheck()) {
                    Log.w(PackageManagerService.TAG, "==> For Activity " + a.info.name);
                }
                addFilter(intent);
            }
        }

        public final void removeActivity(Activity a, String type) {
            this.mActivities.remove(a.getComponentName());
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                Object obj;
                String str = PackageManagerService.TAG;
                StringBuilder append = new StringBuilder().append("  ").append(type).append(" ");
                if (a.info.nonLocalizedLabel != null) {
                    obj = a.info.nonLocalizedLabel;
                } else {
                    obj = a.info.name;
                }
                Log.v(str, append.append(obj).append(":").toString());
                Log.v(PackageManagerService.TAG, "    Class=" + a.info.name);
            }
            int NI = a.intents.size();
            for (int j = 0; j < NI; j++) {
                ActivityIntentInfo intent = (ActivityIntentInfo) a.intents.get(j);
                if (PackageManagerService.DEBUG_SHOW_INFO) {
                    Log.v(PackageManagerService.TAG, "    IntentFilter:");
                    intent.dump(new LogPrinter(2, PackageManagerService.TAG), "      ");
                }
                removeFilter(intent);
            }
        }

        protected boolean allowFilterResult(ActivityIntentInfo filter, List<ResolveInfo> dest) {
            ActivityInfo filterAi = filter.activity.info;
            for (int i = dest.size() - 1; i >= 0; i--) {
                ActivityInfo destAi = ((ResolveInfo) dest.get(i)).activityInfo;
                if (destAi.name == filterAi.name && destAi.packageName == filterAi.packageName) {
                    return false;
                }
            }
            return true;
        }

        protected ActivityIntentInfo[] newArray(int size) {
            return new ActivityIntentInfo[size];
        }

        protected boolean isFilterStopped(ActivityIntentInfo filter, int userId) {
            boolean z = false;
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return true;
            }
            Package p = filter.activity.owner;
            if (p != null) {
                PackageSetting ps = p.mExtras;
                if (ps != null) {
                    if ((ps.pkgFlags & 1) == 0) {
                        z = ps.getStopped(userId);
                    }
                    return z;
                }
            }
            return false;
        }

        protected boolean isPackageForFilter(String packageName, ActivityIntentInfo info) {
            return packageName.equals(info.activity.owner.packageName);
        }

        protected ResolveInfo newResult(ActivityIntentInfo info, int match, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            if (!PackageManagerService.this.mSettings.isEnabledAndMatchLPr(info.activity.info, this.mFlags, userId)) {
                return null;
            }
            Activity activity = info.activity;
            PackageSetting ps = activity.owner.mExtras;
            if (ps == null) {
                return null;
            }
            PackageUserState userState = ps.readUserState(userId);
            ActivityInfo ai = PackageParser.generateActivityInfo(activity, this.mFlags, userState, userId);
            if (ai == null) {
                return null;
            }
            if (userId == OppoMultiAppManager.USER_ID && ai == null) {
                ai = PackageParser.generateActivityInfo(activity, this.mFlags, ps.readUserState(0), 0);
                if (PackageManagerService.DEBUG_PMS) {
                    Slog.v(PackageManagerService.TAG, "multi app: userId changed from 999 to 0");
                }
            }
            boolean matchExplicitlyVisibleOnly = (this.mFlags & PhoneWindowManager.SYSTEM_UI_FLAG_APP_CUSTOM_NAVIGATION_BAR) != 0;
            boolean matchVisibleToInstantApp = (this.mFlags & 16777216) != 0;
            boolean componentVisible = (matchVisibleToInstantApp && info.isVisibleToInstantApp()) ? matchExplicitlyVisibleOnly ? info.isExplicitlyVisibleToInstantApp() : true : false;
            boolean matchInstantApp = (this.mFlags & DumpState.DUMP_VOLUMES) != 0;
            if (matchVisibleToInstantApp) {
                if (((!componentVisible ? userState.instantApp : 1) ^ 1) != 0) {
                    return null;
                }
            }
            if (!matchInstantApp && userState.instantApp) {
                return null;
            }
            if (userState.instantApp && ps.isUpdateAvailable()) {
                return null;
            }
            ResolveInfo res = new ResolveInfo();
            res.activityInfo = ai;
            if ((this.mFlags & 64) != 0) {
                res.filter = info;
            }
            if (info != null) {
                res.handleAllWebDataURI = info.handleAllWebDataURI();
            }
            res.priority = info.getPriority();
            res.preferredOrder = activity.owner.mPreferredOrder;
            res.match = match;
            res.isDefault = info.hasDefault;
            res.labelRes = info.labelRes;
            res.nonLocalizedLabel = info.nonLocalizedLabel;
            if (PackageManagerService.this.userNeedsBadging(userId)) {
                res.noResourceId = true;
            } else {
                res.icon = info.icon;
            }
            res.iconResourceId = info.icon;
            res.system = res.activityInfo.applicationInfo.isSystemApp();
            res.isInstantAppAvailable = userState.instantApp;
            return res;
        }

        protected void sortResults(List<ResolveInfo> results) {
            Collections.sort(results, PackageManagerService.mResolvePrioritySorter);
        }

        protected void dumpFilter(PrintWriter out, String prefix, ActivityIntentInfo filter) {
            out.print(prefix);
            out.print(Integer.toHexString(System.identityHashCode(filter.activity)));
            out.print(' ');
            filter.activity.printComponentShortName(out);
            out.print(" filter ");
            out.println(Integer.toHexString(System.identityHashCode(filter)));
        }

        protected Object filterToLabel(ActivityIntentInfo filter) {
            return filter.activity;
        }

        protected void dumpFilterLabel(PrintWriter out, String prefix, Object label, int count) {
            Activity activity = (Activity) label;
            out.print(prefix);
            out.print(Integer.toHexString(System.identityHashCode(activity)));
            out.print(' ');
            activity.printComponentShortName(out);
            if (count > 1) {
                out.print(" (");
                out.print(count);
                out.print(" filters)");
            }
            out.println();
        }
    }

    class DefaultContainerConnection implements ServiceConnection {
        DefaultContainerConnection() {
        }

        public void onServiceConnected(ComponentName name, IBinder service) {
            if (PackageManagerService.DEBUG_SD_INSTALL) {
                Log.i(PackageManagerService.TAG, "onServiceConnected");
            }
            PackageManagerService.this.mHandler.sendMessage(PackageManagerService.this.mHandler.obtainMessage(3, IMediaContainerService.Stub.asInterface(Binder.allowBlocking(service))));
        }

        public void onServiceDisconnected(ComponentName name) {
            if (PackageManagerService.DEBUG_SD_INSTALL) {
                Log.i(PackageManagerService.TAG, "onServiceDisconnected");
            }
        }
    }

    private static class MoveCallbacks extends Handler {
        private static final int MSG_CREATED = 1;
        private static final int MSG_STATUS_CHANGED = 2;
        private final RemoteCallbackList<IPackageMoveObserver> mCallbacks = new RemoteCallbackList();
        private final SparseIntArray mLastStatus = new SparseIntArray();

        public MoveCallbacks(Looper looper) {
            super(looper);
        }

        public void register(IPackageMoveObserver callback) {
            this.mCallbacks.register(callback);
        }

        public void unregister(IPackageMoveObserver callback) {
            this.mCallbacks.unregister(callback);
        }

        public void handleMessage(Message msg) {
            SomeArgs args = msg.obj;
            int n = this.mCallbacks.beginBroadcast();
            for (int i = 0; i < n; i++) {
                try {
                    invokeCallback((IPackageMoveObserver) this.mCallbacks.getBroadcastItem(i), msg.what, args);
                } catch (RemoteException e) {
                }
            }
            this.mCallbacks.finishBroadcast();
            args.recycle();
        }

        private void invokeCallback(IPackageMoveObserver callback, int what, SomeArgs args) throws RemoteException {
            switch (what) {
                case 1:
                    callback.onCreated(args.argi1, (Bundle) args.arg2);
                    return;
                case 2:
                    callback.onStatusChanged(args.argi1, args.argi2, ((Long) args.arg3).longValue());
                    return;
                default:
                    return;
            }
        }

        private void notifyCreated(int moveId, Bundle extras) {
            Slog.v(PackageManagerService.TAG, "Move " + moveId + " created " + extras.toString());
            SomeArgs args = SomeArgs.obtain();
            args.argi1 = moveId;
            args.arg2 = extras;
            obtainMessage(1, args).sendToTarget();
        }

        private void notifyStatusChanged(int moveId, int status) {
            notifyStatusChanged(moveId, status, -1);
        }

        private void notifyStatusChanged(int moveId, int status, long estMillis) {
            Slog.v(PackageManagerService.TAG, "Move " + moveId + " status " + status);
            SomeArgs args = SomeArgs.obtain();
            args.argi1 = moveId;
            args.argi2 = status;
            args.arg3 = Long.valueOf(estMillis);
            obtainMessage(2, args).sendToTarget();
            synchronized (this.mLastStatus) {
                this.mLastStatus.put(moveId, status);
            }
        }
    }

    private static final class OnPermissionChangeListeners extends Handler {
        private static final int MSG_ON_PERMISSIONS_CHANGED = 1;
        private final RemoteCallbackList<IOnPermissionsChangeListener> mPermissionListeners = new RemoteCallbackList();

        public OnPermissionChangeListeners(Looper looper) {
            super(looper);
        }

        public void handleMessage(Message msg) {
            switch (msg.what) {
                case 1:
                    handleOnPermissionsChanged(msg.arg1);
                    return;
                default:
                    return;
            }
        }

        public void addListenerLocked(IOnPermissionsChangeListener listener) {
            this.mPermissionListeners.register(listener);
        }

        public void removeListenerLocked(IOnPermissionsChangeListener listener) {
            this.mPermissionListeners.unregister(listener);
        }

        public void onPermissionsChanged(int uid) {
            if (this.mPermissionListeners.getRegisteredCallbackCount() > 0) {
                obtainMessage(1, uid, 0).sendToTarget();
            }
        }

        private void handleOnPermissionsChanged(int uid) {
            int count = this.mPermissionListeners.beginBroadcast();
            for (int i = 0; i < count; i++) {
                try {
                    ((IOnPermissionsChangeListener) this.mPermissionListeners.getBroadcastItem(i)).onPermissionsChanged(uid);
                } catch (RemoteException e) {
                    Log.e(PackageManagerService.TAG, "Permission listener is dead", e);
                } catch (Throwable th) {
                    this.mPermissionListeners.finishBroadcast();
                }
            }
            this.mPermissionListeners.finishBroadcast();
        }
    }

    class PackageHandler extends Handler {
        private boolean mBound = false;
        final ArrayList<HandlerParams> mPendingInstalls = new ArrayList();

        private boolean connectToService() {
            if (PackageManagerService.DEBUG_SD_INSTALL) {
                Log.i(PackageManagerService.TAG, "Trying to bind to DefaultContainerService");
            }
            Intent service = new Intent().setComponent(PackageManagerService.DEFAULT_CONTAINER_COMPONENT);
            Process.setThreadPriority(0);
            if (PackageManagerService.this.mContext.bindServiceAsUser(service, PackageManagerService.this.mDefContainerConn, 1, UserHandle.SYSTEM)) {
                Process.setThreadPriority(10);
                this.mBound = true;
                return true;
            }
            Process.setThreadPriority(10);
            return false;
        }

        private void disconnectService() {
            PackageManagerService.this.mContainerService = null;
            this.mBound = false;
            Process.setThreadPriority(0);
            PackageManagerService.this.mContext.unbindService(PackageManagerService.this.mDefContainerConn);
            Process.setThreadPriority(10);
        }

        PackageHandler(Looper looper) {
            super(looper);
        }

        public void handleMessage(Message msg) {
            try {
                doHandleMessage(msg);
            } finally {
                Process.setThreadPriority(10);
            }
        }

        /* JADX WARNING: inconsistent code. */
        /* Code decompiled incorrectly, please refer to instructions dump. */
        void doHandleMessage(Message msg) {
            int i;
            int uid;
            HandlerParams params;
            Iterator params$iterator;
            int userId;
            InstallArgs args;
            int verificationId;
            PackageVerificationState state;
            Uri originUri;
            int ret;
            switch (msg.what) {
                case 1:
                    Process.setThreadPriority(0);
                    synchronized (PackageManagerService.this.mPackages) {
                        if (PackageManagerService.this.mPendingBroadcasts != null) {
                            int size = PackageManagerService.this.mPendingBroadcasts.size();
                            if (size > 0) {
                                String[] packages = new String[size];
                                ArrayList<String>[] components = new ArrayList[size];
                                int[] uids = new int[size];
                                i = 0;
                                for (int n = 0; n < PackageManagerService.this.mPendingBroadcasts.userIdCount(); n++) {
                                    int packageUserId = PackageManagerService.this.mPendingBroadcasts.userIdAt(n);
                                    Iterator<Entry<String, ArrayList<String>>> it = PackageManagerService.this.mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
                                    while (it.hasNext() && i < size) {
                                        Entry<String, ArrayList<String>> ent = (Entry) it.next();
                                        packages[i] = (String) ent.getKey();
                                        components[i] = (ArrayList) ent.getValue();
                                        PackageSetting ps = (PackageSetting) PackageManagerService.this.mSettings.mPackages.get(ent.getKey());
                                        if (ps != null) {
                                            uid = UserHandle.getUid(packageUserId, ps.appId);
                                        } else {
                                            uid = -1;
                                        }
                                        uids[i] = uid;
                                        i++;
                                    }
                                }
                                size = i;
                                PackageManagerService.this.mPendingBroadcasts.clear();
                                break;
                            }
                            return;
                        }
                        return;
                    }
                case 3:
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Slog.i(PackageManagerService.TAG, "mcs_bound");
                    }
                    if (msg.obj != null) {
                        PackageManagerService.this.mContainerService = (IMediaContainerService) msg.obj;
                        Trace.asyncTraceEnd(262144, "bindingMCS", System.identityHashCode(PackageManagerService.this.mHandler));
                    }
                    if (PackageManagerService.this.mContainerService != null) {
                        if (this.mPendingInstalls.size() <= 0) {
                            Slog.w(PackageManagerService.TAG, "Empty queue");
                            break;
                        }
                        params = (HandlerParams) this.mPendingInstalls.get(0);
                        if (params != null) {
                            Trace.asyncTraceEnd(262144, "queueInstall", System.identityHashCode(params));
                            Trace.traceBegin(262144, "startCopy");
                            if (params.startCopy()) {
                                if (PackageManagerService.DEBUG_SD_INSTALL) {
                                    Log.i(PackageManagerService.TAG, "Checking for more work or unbind...");
                                }
                                if (this.mPendingInstalls.size() > 0) {
                                    this.mPendingInstalls.remove(0);
                                }
                                if (this.mPendingInstalls.size() != 0) {
                                    if (PackageManagerService.DEBUG_SD_INSTALL) {
                                        Log.i(PackageManagerService.TAG, "Posting MCS_BOUND for next work");
                                    }
                                    PackageManagerService.this.mHandler.sendEmptyMessage(3);
                                } else if (this.mBound) {
                                    if (PackageManagerService.DEBUG_SD_INSTALL) {
                                        Log.i(PackageManagerService.TAG, "Posting delayed MCS_UNBIND");
                                    }
                                    removeMessages(6);
                                    sendMessageDelayed(obtainMessage(6), 10000);
                                }
                            }
                            Trace.traceEnd(262144);
                            break;
                        }
                    } else if (!this.mBound) {
                        Slog.e(PackageManagerService.TAG, "Cannot bind to media container service");
                        params$iterator = this.mPendingInstalls.iterator();
                        if (!params$iterator.hasNext()) {
                            this.mPendingInstalls.clear();
                            break;
                        }
                        params = (HandlerParams) params$iterator.next();
                        params.serviceError();
                        Trace.asyncTraceEnd(262144, "queueInstall", System.identityHashCode(params));
                        if (params.traceMethod != null) {
                            Trace.asyncTraceEnd(262144, params.traceMethod, params.traceCookie);
                        }
                        return;
                    } else {
                        Slog.w(PackageManagerService.TAG, "Waiting to connect to media container service");
                        break;
                    }
                    break;
                case 5:
                    params = msg.obj;
                    int idx = this.mPendingInstalls.size();
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Slog.i(PackageManagerService.TAG, "init_copy idx=" + idx + ": " + params);
                    }
                    if (PackageManagerService.mHyp == null) {
                        PackageManagerService.mHyp = Hypnus.getHypnus();
                    }
                    if (!(PackageManagerService.mHyp == null || params.toString().indexOf("InstallParams") == -1)) {
                        PackageManagerService.mHyp.hypnusSetAction(15, OppoBrightUtils.HIGH_BRIGHTNESS_MAX_LUX);
                    }
                    if (!this.mBound) {
                        Trace.asyncTraceBegin(262144, "bindingMCS", System.identityHashCode(PackageManagerService.this.mHandler));
                        if (connectToService()) {
                            this.mPendingInstalls.add(idx, params);
                            break;
                        }
                        Slog.e(PackageManagerService.TAG, "Failed to bind to media container service");
                        params.serviceError();
                        Trace.asyncTraceEnd(262144, "bindingMCS", System.identityHashCode(PackageManagerService.this.mHandler));
                        if (params.traceMethod != null) {
                            Trace.asyncTraceEnd(262144, params.traceMethod, params.traceCookie);
                        }
                        return;
                    }
                    this.mPendingInstalls.add(idx, params);
                    if (idx == 0) {
                        PackageManagerService.this.mHandler.sendEmptyMessage(3);
                        break;
                    }
                    break;
                case 6:
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Slog.i(PackageManagerService.TAG, "mcs_unbind");
                    }
                    if (this.mPendingInstalls.size() != 0 || PackageManagerService.this.mPendingVerification.size() != 0) {
                        if (this.mPendingInstalls.size() > 0) {
                            PackageManagerService.this.mHandler.sendEmptyMessage(3);
                            break;
                        }
                    } else if (this.mBound) {
                        if (PackageManagerService.DEBUG_INSTALL) {
                            Slog.i(PackageManagerService.TAG, "calling disconnectService()");
                        }
                        disconnectService();
                        break;
                    }
                    break;
                case 7:
                    Process.setThreadPriority(0);
                    String packageName = msg.obj;
                    userId = msg.arg1;
                    boolean andCode = msg.arg2 != 0;
                    synchronized (PackageManagerService.this.mPackages) {
                        if (userId == -1) {
                            for (int user : PackageManagerService.sUserManager.getUserIds()) {
                                PackageManagerService.this.mSettings.addPackageToCleanLPw(new PackageCleanItem(user, packageName, andCode));
                            }
                        } else {
                            PackageManagerService.this.mSettings.addPackageToCleanLPw(new PackageCleanItem(userId, packageName, andCode));
                        }
                    }
                    Process.setThreadPriority(10);
                    PackageManagerService.this.startCleaningPackages();
                    break;
                case 9:
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Log.v(PackageManagerService.TAG, "Handling post-install for " + msg.arg1);
                    }
                    if (PackageManagerService.mHyp != null) {
                        PackageManagerService.mHyp.hypnusSetAction(15, 0);
                    }
                    PostInstallData data = (PostInstallData) PackageManagerService.this.mRunningInstalls.get(msg.arg1);
                    boolean didRestore = msg.arg2 != 0;
                    PackageManagerService.this.mRunningInstalls.delete(msg.arg1);
                    if (data != null) {
                        args = data.args;
                        PackageInstalledInfo parentRes = data.res;
                        boolean grantPermissions = (args.installFlags & 256) != 0;
                        boolean killApp = (args.installFlags & 4096) == 0;
                        boolean virtualPreload = (args.installFlags & 65536) != 0;
                        String[] grantedPermissions = args.installGrantPermissions;
                        PackageManagerService.this.handlePackagePostInstall(parentRes, grantPermissions, killApp, virtualPreload, grantedPermissions, didRestore, args.installerPackageName, args.observer);
                        try {
                            if (parentRes.returnCode < 0) {
                                String str;
                                Slog.v(PackageManagerService.TAG, "install fail");
                                StringBuilder stringBuilder = new StringBuilder(512);
                                if (args.origin == null) {
                                    str = "origin:null\r\n";
                                } else {
                                    str = "origin:" + args.origin.file + "\r\n";
                                }
                                StringBuilder log = stringBuilder.append(str).append("apk install fail ").append("apk name = ").append(parentRes.name).append(" returnCode = ").append(parentRes.returnCode).append(" returnMsg = ").append(parentRes.returnMsg);
                                if (parentRes.pkg != null) {
                                    log.append(" package = ").append(parentRes.pkg.packageName).append(" versionCode = ").append(parentRes.pkg.mVersionCode).append(" versionName = ").append(parentRes.pkg.mVersionName);
                                }
                                OppoManager.writeLogToPartition(OppoManager.TYPE_ANDROID_INSTALL_FAILD, log.toString(), "ANDROID", "install_fail", PackageManagerService.this.mContext.getString(17040990));
                                Slog.v(PackageManagerService.TAG, "record end");
                            }
                        } catch (Exception e) {
                            Slog.v(PackageManagerService.TAG, "record install fail event e = " + e.toString());
                        }
                        int childCount = parentRes.addedChildPackages != null ? parentRes.addedChildPackages.size() : 0;
                        if (PackageManagerService.EXP_VERSION && parentRes.returnCode == 1) {
                            PackageManagerService.this.sendNonSilentInstallBroadcastExp(args.installerPackageName, args.origin, parentRes, childCount, -1);
                        }
                        for (i = 0; i < childCount; i++) {
                            PackageInstalledInfo childRes = (PackageInstalledInfo) parentRes.addedChildPackages.valueAt(i);
                            PackageManagerService.this.handlePackagePostInstall(childRes, grantPermissions, killApp, virtualPreload, grantedPermissions, false, args.installerPackageName, args.observer);
                            if (PackageManagerService.EXP_VERSION && childRes.returnCode == 1) {
                                PackageManagerService.this.sendNonSilentInstallBroadcastExp(args.installerPackageName, args.origin, childRes, childCount, i);
                            }
                        }
                        if (args.traceMethod != null) {
                            Trace.asyncTraceEnd(262144, args.traceMethod, args.traceCookie);
                        }
                    } else {
                        Slog.e(PackageManagerService.TAG, "Bogus post-install token " + msg.arg1);
                    }
                    Trace.asyncTraceEnd(262144, "postInstall", msg.arg1);
                    break;
                case 10:
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Slog.i(PackageManagerService.TAG, "mcs_reconnect");
                    }
                    if (this.mPendingInstalls.size() > 0) {
                        if (this.mBound) {
                            disconnectService();
                        }
                        if (!connectToService()) {
                            Slog.e(PackageManagerService.TAG, "Failed to bind to media container service");
                            for (HandlerParams params2 : this.mPendingInstalls) {
                                params2.serviceError();
                                Trace.asyncTraceEnd(262144, "queueInstall", System.identityHashCode(params2));
                            }
                            this.mPendingInstalls.clear();
                            break;
                        }
                    }
                    break;
                case 11:
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Slog.i(PackageManagerService.TAG, "mcs_giveup too many retries");
                    }
                    if (this.mPendingInstalls.size() > 0) {
                        Trace.asyncTraceEnd(262144, "queueInstall", System.identityHashCode((HandlerParams) this.mPendingInstalls.remove(0)));
                        break;
                    }
                    break;
                case 12:
                    if (PackageManagerService.DEBUG_SD_INSTALL) {
                        Log.i(PackageManagerService.TAG, "Got message UPDATED_MEDIA_STATUS");
                    }
                    boolean reportStatus = msg.arg1 == 1;
                    boolean doGc = msg.arg2 == 1;
                    if (PackageManagerService.DEBUG_SD_INSTALL) {
                        Log.i(PackageManagerService.TAG, "reportStatus=" + reportStatus + ", doGc = " + doGc);
                    }
                    if (doGc) {
                        Runtime.getRuntime().gc();
                    }
                    if (msg.obj != null) {
                        Set<AsecInstallArgs> args2 = msg.obj;
                        if (PackageManagerService.DEBUG_SD_INSTALL) {
                            Log.i(PackageManagerService.TAG, "Unloading all containers");
                        }
                        PackageManagerService.this.unloadAllContainers(args2);
                    }
                    if (reportStatus) {
                        try {
                            if (PackageManagerService.DEBUG_SD_INSTALL) {
                                Log.i(PackageManagerService.TAG, "Invoking StorageManagerService call back");
                            }
                            PackageHelper.getStorageManager().finishMediaUpdate();
                            break;
                        } catch (RemoteException e2) {
                            Log.e(PackageManagerService.TAG, "StorageManagerService not running?");
                            break;
                        }
                    }
                    break;
                case 13:
                    Process.setThreadPriority(0);
                    synchronized (PackageManagerService.this.mPackages) {
                        removeMessages(13);
                        removeMessages(14);
                        PackageManagerService.this.mSettings.writeLPr();
                        PackageManagerService.this.mDirtyUsers.clear();
                    }
                    Process.setThreadPriority(10);
                    break;
                case 14:
                    Process.setThreadPriority(0);
                    synchronized (PackageManagerService.this.mPackages) {
                        removeMessages(14);
                        for (Integer intValue : PackageManagerService.this.mDirtyUsers) {
                            PackageManagerService.this.mSettings.writePackageRestrictionsLPr(intValue.intValue());
                        }
                        PackageManagerService.this.mDirtyUsers.clear();
                    }
                    Process.setThreadPriority(10);
                    break;
                case 15:
                    verificationId = msg.arg1;
                    state = (PackageVerificationState) PackageManagerService.this.mPendingVerification.get(verificationId);
                    if (state != null) {
                        PackageVerificationResponse response = msg.obj;
                        state.setVerifierResponse(response.callerUid, response.code);
                        if (state.isVerificationComplete()) {
                            PackageManagerService.this.mPendingVerification.remove(verificationId);
                            args = state.getInstallArgs();
                            originUri = Uri.fromFile(args.origin.resolvedFile);
                            if (state.isInstallAllowed()) {
                                ret = -110;
                                PackageManagerService.this.broadcastPackageVerified(verificationId, originUri, response.code, state.getInstallArgs().getUser());
                                try {
                                    ret = args.copyApk(PackageManagerService.this.mContainerService, true);
                                } catch (RemoteException e3) {
                                    Slog.e(PackageManagerService.TAG, "Could not contact the ContainerService");
                                }
                            } else {
                                ret = -22;
                            }
                            Trace.asyncTraceEnd(262144, "verification", verificationId);
                            PackageManagerService.this.processPendingInstall(args, ret);
                            PackageManagerService.this.mHandler.sendEmptyMessage(6);
                            break;
                        }
                    }
                    Slog.w(PackageManagerService.TAG, "Invalid verification token " + verificationId + " received");
                    break;
                    break;
                case 16:
                    verificationId = msg.arg1;
                    state = (PackageVerificationState) PackageManagerService.this.mPendingVerification.get(verificationId);
                    if (!(state == null || (state.timeoutExtended() ^ 1) == 0)) {
                        args = state.getInstallArgs();
                        originUri = Uri.fromFile(args.origin.resolvedFile);
                        Slog.i(PackageManagerService.TAG, "Verification timed out for " + originUri);
                        PackageManagerService.this.mPendingVerification.remove(verificationId);
                        ret = -22;
                        UserHandle user2 = args.getUser();
                        if (PackageManagerService.this.getDefaultVerificationResponse(user2) == 1) {
                            Slog.i(PackageManagerService.TAG, "Continuing with installation of " + originUri);
                            state.setVerifierResponse(Binder.getCallingUid(), 2);
                            PackageManagerService.this.broadcastPackageVerified(verificationId, originUri, 1, user2);
                            try {
                                ret = args.copyApk(PackageManagerService.this.mContainerService, true);
                            } catch (RemoteException e4) {
                                Slog.e(PackageManagerService.TAG, "Could not contact the ContainerService");
                            }
                        } else {
                            PackageManagerService.this.broadcastPackageVerified(verificationId, originUri, -1, user2);
                        }
                        Trace.asyncTraceEnd(262144, "verification", verificationId);
                        PackageManagerService.this.processPendingInstall(args, ret);
                        PackageManagerService.this.mHandler.sendEmptyMessage(6);
                        break;
                    }
                case 17:
                    IFVerificationParams params3 = msg.obj;
                    PackageManagerService.this.verifyIntentFiltersIfNeeded(params3.userId, params3.verifierUid, params3.replacing, params3.pkg);
                    break;
                case 18:
                    verificationId = msg.arg1;
                    IntentFilterVerificationState state2 = (IntentFilterVerificationState) PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
                    if (state2 != null) {
                        userId = state2.getUserId();
                        IntentFilterVerificationResponse response2 = msg.obj;
                        state2.setVerifierResponse(response2.callerUid, response2.code);
                        uid = response2.code;
                        if (state2.isVerificationComplete()) {
                            PackageManagerService.this.mIntentFilterVerifier.receiveVerificationResponse(verificationId);
                            break;
                        }
                    }
                    Slog.w(PackageManagerService.TAG, "Invalid IntentFilter verification token " + verificationId + " received");
                    break;
                    break;
                case 19:
                    Process.setThreadPriority(0);
                    synchronized (PackageManagerService.this.mPackages) {
                        removeMessages(19);
                        PackageManagerService.this.mSettings.writePackageListLPr(msg.arg1);
                    }
                    Process.setThreadPriority(10);
                    break;
                case 20:
                    InstantAppResolver.doInstantAppResolutionPhaseTwo(PackageManagerService.this.mContext, PackageManagerService.this.mInstantAppResolverConnection, (InstantAppRequest) msg.obj, PackageManagerService.this.mInstantAppInstallerActivity, PackageManagerService.this.mHandler);
                    break;
                case 21:
                    PackageManagerService.this.onPackageAdded((String) msg.obj);
                    break;
                case 22:
                    PackageManagerService.this.onPackageRemoved((String) msg.obj);
                    break;
                case 23:
                    PackageManagerService.this.cacheActivityIconsData(null);
                    PackageManagerService.this.cacheAppIconsData();
                    break;
            }
        }
    }

    class PackageParserCallback implements Callback {
        PackageParserCallback() {
        }

        public final boolean hasFeature(String feature) {
            return PackageManagerService.this.hasSystemFeature(feature, 0);
        }

        final List<Package> getStaticOverlayPackagesLocked(Collection<Package> allPackages, String targetPackageName) {
            List<Package> overlayPackages = null;
            for (Package p : allPackages) {
                if (targetPackageName.equals(p.mOverlayTarget) && p.mIsStaticOverlay) {
                    if (overlayPackages == null) {
                        overlayPackages = new ArrayList();
                    }
                    overlayPackages.add(p);
                }
            }
            if (overlayPackages != null) {
                Collections.sort(overlayPackages, new Comparator<Package>() {
                    public int compare(Package p1, Package p2) {
                        return p1.mOverlayPriority - p2.mOverlayPriority;
                    }
                });
            }
            return overlayPackages;
        }

        final String[] getStaticOverlayPathsLocked(Collection<Package> allPackages, String targetPackageName, String targetPath) {
            String[] strArr = null;
            if (PackageManagerService.PLATFORM_PACKAGE_NAME.equals(targetPackageName)) {
                return null;
            }
            List<Package> overlayPackages = getStaticOverlayPackagesLocked(allPackages, targetPackageName);
            if (overlayPackages == null || overlayPackages.isEmpty()) {
                return null;
            }
            List overlayPathList = null;
            for (Package overlayPackage : overlayPackages) {
                if (targetPath == null) {
                    if (overlayPathList == null) {
                        overlayPathList = new ArrayList();
                    }
                    overlayPathList.add(overlayPackage.baseCodePath);
                } else {
                    try {
                        PackageManagerService.this.mInstaller.idmap(targetPath, overlayPackage.baseCodePath, UserHandle.getSharedAppGid(UserHandle.getUserGid(0)));
                        if (overlayPathList == null) {
                            overlayPathList = new ArrayList();
                        }
                        overlayPathList.add(overlayPackage.baseCodePath);
                    } catch (InstallerException e) {
                        Slog.e(PackageManagerService.TAG, "Failed to generate idmap for " + targetPath + " and " + overlayPackage.baseCodePath);
                    }
                }
            }
            if (overlayPathList != null) {
                strArr = (String[]) overlayPathList.toArray(new String[0]);
            }
            return strArr;
        }

        String[] getStaticOverlayPaths(String targetPackageName, String targetPath) {
            String[] staticOverlayPathsLocked;
            synchronized (PackageManagerService.this.mPackages) {
                staticOverlayPathsLocked = getStaticOverlayPathsLocked(PackageManagerService.this.mPackages.values(), targetPackageName, targetPath);
            }
            return staticOverlayPathsLocked;
        }

        public final String[] getOverlayApks(String targetPackageName) {
            return getStaticOverlayPaths(targetPackageName, null);
        }

        public final String[] getOverlayPaths(String targetPackageName, String targetPath) {
            return getStaticOverlayPaths(targetPackageName, targetPath);
        }
    }

    class ParallelPackageParserCallback extends PackageParserCallback {
        List<Package> mOverlayPackages = null;

        ParallelPackageParserCallback() {
            super();
        }

        void findStaticOverlayPackages() {
            synchronized (PackageManagerService.this.mPackages) {
                for (Package p : PackageManagerService.this.mPackages.values()) {
                    if (p.mIsStaticOverlay) {
                        if (this.mOverlayPackages == null) {
                            this.mOverlayPackages = new ArrayList();
                        }
                        this.mOverlayPackages.add(p);
                    }
                }
            }
        }

        synchronized String[] getStaticOverlayPaths(String targetPackageName, String targetPath) {
            String[] strArr = null;
            synchronized (this) {
                if (this.mOverlayPackages != null) {
                    strArr = getStaticOverlayPathsLocked(this.mOverlayPackages, targetPackageName, targetPath);
                }
            }
            return strArr;
        }
    }

    static class PendingPackageBroadcasts {
        final SparseArray<ArrayMap<String, ArrayList<String>>> mUidMap = new SparseArray(2);

        public ArrayList<String> get(int userId, String packageName) {
            return (ArrayList) getOrAllocate(userId).get(packageName);
        }

        public void put(int userId, String packageName, ArrayList<String> components) {
            getOrAllocate(userId).put(packageName, components);
        }

        public void remove(int userId, String packageName) {
            ArrayMap<String, ArrayList<String>> packages = (ArrayMap) this.mUidMap.get(userId);
            if (packages != null) {
                packages.remove(packageName);
            }
        }

        public void remove(int userId) {
            this.mUidMap.remove(userId);
        }

        public int userIdCount() {
            return this.mUidMap.size();
        }

        public int userIdAt(int n) {
            return this.mUidMap.keyAt(n);
        }

        public ArrayMap<String, ArrayList<String>> packagesForUserId(int userId) {
            return (ArrayMap) this.mUidMap.get(userId);
        }

        public int size() {
            int num = 0;
            for (int i = 0; i < this.mUidMap.size(); i++) {
                num += ((ArrayMap) this.mUidMap.valueAt(i)).size();
            }
            return num;
        }

        public void clear() {
            this.mUidMap.clear();
        }

        private ArrayMap<String, ArrayList<String>> getOrAllocate(int userId) {
            ArrayMap<String, ArrayList<String>> map = (ArrayMap) this.mUidMap.get(userId);
            if (map != null) {
                return map;
            }
            map = new ArrayMap();
            this.mUidMap.put(userId, map);
            return map;
        }
    }

    private final class ProviderIntentResolver extends IntentResolver<ProviderIntentInfo, ResolveInfo> {
        private int mFlags;
        private final ArrayMap<ComponentName, Provider> mProviders;

        /* synthetic */ ProviderIntentResolver(PackageManagerService this$0, ProviderIntentResolver -this1) {
            this();
        }

        private ProviderIntentResolver() {
            this.mProviders = new ArrayMap();
        }

        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) {
            this.mFlags = defaultOnly ? 65536 : 0;
            return super.queryIntent(intent, resolvedType, defaultOnly, userId);
        }

        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, int flags, int userId) {
            boolean z = false;
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            this.mFlags = flags;
            if ((65536 & flags) != 0) {
                z = true;
            }
            return super.queryIntent(intent, resolvedType, z, userId);
        }

        public List<ResolveInfo> queryIntentForPackage(Intent intent, String resolvedType, int flags, ArrayList<Provider> packageProviders, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId) || packageProviders == null) {
                return null;
            }
            this.mFlags = flags;
            boolean defaultOnly = (65536 & flags) != 0;
            int N = packageProviders.size();
            ArrayList<ProviderIntentInfo[]> listCut = new ArrayList(N);
            for (int i = 0; i < N; i++) {
                ArrayList<ProviderIntentInfo> intentFilters = ((Provider) packageProviders.get(i)).intents;
                if (intentFilters != null && intentFilters.size() > 0) {
                    ProviderIntentInfo[] array = new ProviderIntentInfo[intentFilters.size()];
                    intentFilters.toArray(array);
                    listCut.add(array);
                }
            }
            return super.queryIntentFromList(intent, resolvedType, defaultOnly, listCut, userId);
        }

        public final void addProvider(Provider p) {
            if (this.mProviders.containsKey(p.getComponentName())) {
                Slog.w(PackageManagerService.TAG, "Provider " + p.getComponentName() + " already defined; ignoring");
                return;
            }
            this.mProviders.put(p.getComponentName(), p);
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                Object obj;
                String str = PackageManagerService.TAG;
                StringBuilder append = new StringBuilder().append("  ");
                if (p.info.nonLocalizedLabel != null) {
                    obj = p.info.nonLocalizedLabel;
                } else {
                    obj = p.info.name;
                }
                Log.v(str, append.append(obj).append(":").toString());
                Log.v(PackageManagerService.TAG, "    Class=" + p.info.name);
            }
            int NI = p.intents.size();
            for (int j = 0; j < NI; j++) {
                ProviderIntentInfo intent = (ProviderIntentInfo) p.intents.get(j);
                if (PackageManagerService.DEBUG_SHOW_INFO) {
                    Log.v(PackageManagerService.TAG, "    IntentFilter:");
                    intent.dump(new LogPrinter(2, PackageManagerService.TAG), "      ");
                }
                if (!intent.debugCheck()) {
                    Log.w(PackageManagerService.TAG, "==> For Provider " + p.info.name);
                }
                addFilter(intent);
            }
        }

        public final void removeProvider(Provider p) {
            this.mProviders.remove(p.getComponentName());
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                Object obj;
                String str = PackageManagerService.TAG;
                StringBuilder append = new StringBuilder().append("  ");
                if (p.info.nonLocalizedLabel != null) {
                    obj = p.info.nonLocalizedLabel;
                } else {
                    obj = p.info.name;
                }
                Log.v(str, append.append(obj).append(":").toString());
                Log.v(PackageManagerService.TAG, "    Class=" + p.info.name);
            }
            int NI = p.intents.size();
            for (int j = 0; j < NI; j++) {
                ProviderIntentInfo intent = (ProviderIntentInfo) p.intents.get(j);
                if (PackageManagerService.DEBUG_SHOW_INFO) {
                    Log.v(PackageManagerService.TAG, "    IntentFilter:");
                    intent.dump(new LogPrinter(2, PackageManagerService.TAG), "      ");
                }
                removeFilter(intent);
            }
        }

        protected boolean allowFilterResult(ProviderIntentInfo filter, List<ResolveInfo> dest) {
            ProviderInfo filterPi = filter.provider.info;
            for (int i = dest.size() - 1; i >= 0; i--) {
                ProviderInfo destPi = ((ResolveInfo) dest.get(i)).providerInfo;
                if (destPi.name == filterPi.name && destPi.packageName == filterPi.packageName) {
                    return false;
                }
            }
            return true;
        }

        protected ProviderIntentInfo[] newArray(int size) {
            return new ProviderIntentInfo[size];
        }

        protected boolean isFilterStopped(ProviderIntentInfo filter, int userId) {
            boolean z = false;
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return true;
            }
            Package p = filter.provider.owner;
            if (p != null) {
                PackageSetting ps = p.mExtras;
                if (ps != null) {
                    if ((ps.pkgFlags & 1) == 0) {
                        z = ps.getStopped(userId);
                    }
                    return z;
                }
            }
            return false;
        }

        protected boolean isPackageForFilter(String packageName, ProviderIntentInfo info) {
            return packageName.equals(info.provider.owner.packageName);
        }

        protected ResolveInfo newResult(ProviderIntentInfo filter, int match, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            ProviderIntentInfo info = filter;
            if (!PackageManagerService.this.mSettings.isEnabledAndMatchLPr(filter.provider.info, this.mFlags, userId)) {
                return null;
            }
            Provider provider = filter.provider;
            PackageSetting ps = provider.owner.mExtras;
            if (ps == null) {
                return null;
            }
            PackageUserState userState = ps.readUserState(userId);
            boolean matchVisibleToInstantApp = (this.mFlags & 16777216) != 0;
            boolean isInstantApp = (this.mFlags & DumpState.DUMP_VOLUMES) != 0;
            if (matchVisibleToInstantApp) {
                if (((!filter.isVisibleToInstantApp() ? userState.instantApp : 1) ^ 1) != 0) {
                    return null;
                }
            }
            if (!isInstantApp && userState.instantApp) {
                return null;
            }
            if (userState.instantApp && ps.isUpdateAvailable()) {
                return null;
            }
            ProviderInfo pi = PackageParser.generateProviderInfo(provider, this.mFlags, userState, userId);
            if (pi == null) {
                return null;
            }
            ResolveInfo res = new ResolveInfo();
            res.providerInfo = pi;
            if ((this.mFlags & 64) != 0) {
                res.filter = filter;
            }
            res.priority = filter.getPriority();
            res.preferredOrder = provider.owner.mPreferredOrder;
            res.match = match;
            res.isDefault = filter.hasDefault;
            res.labelRes = filter.labelRes;
            res.nonLocalizedLabel = filter.nonLocalizedLabel;
            res.icon = filter.icon;
            res.system = res.providerInfo.applicationInfo.isSystemApp();
            return res;
        }

        protected void sortResults(List<ResolveInfo> results) {
            Collections.sort(results, PackageManagerService.mResolvePrioritySorter);
        }

        protected void dumpFilter(PrintWriter out, String prefix, ProviderIntentInfo filter) {
            out.print(prefix);
            out.print(Integer.toHexString(System.identityHashCode(filter.provider)));
            out.print(' ');
            filter.provider.printComponentShortName(out);
            out.print(" filter ");
            out.println(Integer.toHexString(System.identityHashCode(filter)));
        }

        protected Object filterToLabel(ProviderIntentInfo filter) {
            return filter.provider;
        }

        protected void dumpFilterLabel(PrintWriter out, String prefix, Object label, int count) {
            Provider provider = (Provider) label;
            out.print(prefix);
            out.print(Integer.toHexString(System.identityHashCode(provider)));
            out.print(' ');
            provider.printComponentShortName(out);
            if (count > 1) {
                out.print(" (");
                out.print(count);
                out.print(" filters)");
            }
            out.println();
        }
    }

    private final class ServiceIntentResolver extends IntentResolver<ServiceIntentInfo, ResolveInfo> {
        private int mFlags;
        private final ArrayMap<ComponentName, Service> mServices;

        /* synthetic */ ServiceIntentResolver(PackageManagerService this$0, ServiceIntentResolver -this1) {
            this();
        }

        private ServiceIntentResolver() {
            this.mServices = new ArrayMap();
        }

        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) {
            this.mFlags = defaultOnly ? 65536 : 0;
            return super.queryIntent(intent, resolvedType, defaultOnly, userId);
        }

        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, int flags, int userId) {
            boolean z = false;
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            this.mFlags = flags;
            if ((65536 & flags) != 0) {
                z = true;
            }
            return super.queryIntent(intent, resolvedType, z, userId);
        }

        public List<ResolveInfo> queryIntentForPackage(Intent intent, String resolvedType, int flags, ArrayList<Service> packageServices, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId) || packageServices == null) {
                return null;
            }
            this.mFlags = flags;
            boolean defaultOnly = (65536 & flags) != 0;
            int N = packageServices.size();
            ArrayList<ServiceIntentInfo[]> listCut = new ArrayList(N);
            for (int i = 0; i < N; i++) {
                ArrayList<ServiceIntentInfo> intentFilters = ((Service) packageServices.get(i)).intents;
                if (intentFilters != null && intentFilters.size() > 0) {
                    ServiceIntentInfo[] array = new ServiceIntentInfo[intentFilters.size()];
                    intentFilters.toArray(array);
                    listCut.add(array);
                }
            }
            return super.queryIntentFromList(intent, resolvedType, defaultOnly, listCut, userId);
        }

        public final void addService(Service s) {
            this.mServices.put(s.getComponentName(), s);
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                Object obj;
                String str = PackageManagerService.TAG;
                StringBuilder append = new StringBuilder().append("  ");
                if (s.info.nonLocalizedLabel != null) {
                    obj = s.info.nonLocalizedLabel;
                } else {
                    obj = s.info.name;
                }
                Log.v(str, append.append(obj).append(":").toString());
                Log.v(PackageManagerService.TAG, "    Class=" + s.info.name);
            }
            int NI = s.intents.size();
            for (int j = 0; j < NI; j++) {
                ServiceIntentInfo intent = (ServiceIntentInfo) s.intents.get(j);
                if (PackageManagerService.DEBUG_SHOW_INFO) {
                    Log.v(PackageManagerService.TAG, "    IntentFilter:");
                    intent.dump(new LogPrinter(2, PackageManagerService.TAG), "      ");
                }
                if (!intent.debugCheck()) {
                    Log.w(PackageManagerService.TAG, "==> For Service " + s.info.name);
                }
                addFilter(intent);
            }
        }

        public final void removeService(Service s) {
            this.mServices.remove(s.getComponentName());
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                Object obj;
                String str = PackageManagerService.TAG;
                StringBuilder append = new StringBuilder().append("  ");
                if (s.info.nonLocalizedLabel != null) {
                    obj = s.info.nonLocalizedLabel;
                } else {
                    obj = s.info.name;
                }
                Log.v(str, append.append(obj).append(":").toString());
                Log.v(PackageManagerService.TAG, "    Class=" + s.info.name);
            }
            int NI = s.intents.size();
            for (int j = 0; j < NI; j++) {
                ServiceIntentInfo intent = (ServiceIntentInfo) s.intents.get(j);
                if (PackageManagerService.DEBUG_SHOW_INFO) {
                    Log.v(PackageManagerService.TAG, "    IntentFilter:");
                    intent.dump(new LogPrinter(2, PackageManagerService.TAG), "      ");
                }
                removeFilter(intent);
            }
        }

        protected boolean allowFilterResult(ServiceIntentInfo filter, List<ResolveInfo> dest) {
            ServiceInfo filterSi = filter.service.info;
            for (int i = dest.size() - 1; i >= 0; i--) {
                ServiceInfo destAi = ((ResolveInfo) dest.get(i)).serviceInfo;
                if (destAi.name == filterSi.name && destAi.packageName == filterSi.packageName) {
                    return false;
                }
            }
            return true;
        }

        protected ServiceIntentInfo[] newArray(int size) {
            return new ServiceIntentInfo[size];
        }

        protected boolean isFilterStopped(ServiceIntentInfo filter, int userId) {
            boolean z = false;
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return true;
            }
            Package p = filter.service.owner;
            if (p != null) {
                PackageSetting ps = p.mExtras;
                if (ps != null) {
                    if ((ps.pkgFlags & 1) == 0) {
                        z = ps.getStopped(userId);
                    }
                    return z;
                }
            }
            return false;
        }

        protected boolean isPackageForFilter(String packageName, ServiceIntentInfo info) {
            return packageName.equals(info.service.owner.packageName);
        }

        protected ResolveInfo newResult(ServiceIntentInfo filter, int match, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            ServiceIntentInfo info = filter;
            if (!PackageManagerService.this.mSettings.isEnabledAndMatchLPr(filter.service.info, this.mFlags, userId)) {
                return null;
            }
            Service service = filter.service;
            PackageSetting ps = service.owner.mExtras;
            if (ps == null) {
                return null;
            }
            PackageUserState userState = ps.readUserState(userId);
            ServiceInfo si = PackageParser.generateServiceInfo(service, this.mFlags, userState, userId);
            if (si == null) {
                return null;
            }
            boolean matchVisibleToInstantApp = (this.mFlags & 16777216) != 0;
            boolean isInstantApp = (this.mFlags & DumpState.DUMP_VOLUMES) != 0;
            if (matchVisibleToInstantApp) {
                if (((!filter.isVisibleToInstantApp() ? userState.instantApp : 1) ^ 1) != 0) {
                    return null;
                }
            }
            if (!isInstantApp && userState.instantApp) {
                return null;
            }
            if (userState.instantApp && ps.isUpdateAvailable()) {
                return null;
            }
            ResolveInfo res = new ResolveInfo();
            res.serviceInfo = si;
            if ((this.mFlags & 64) != 0) {
                res.filter = filter;
            }
            res.priority = filter.getPriority();
            res.preferredOrder = service.owner.mPreferredOrder;
            res.match = match;
            res.isDefault = filter.hasDefault;
            res.labelRes = filter.labelRes;
            res.nonLocalizedLabel = filter.nonLocalizedLabel;
            res.icon = filter.icon;
            res.system = res.serviceInfo.applicationInfo.isSystemApp();
            return res;
        }

        protected void sortResults(List<ResolveInfo> results) {
            Collections.sort(results, PackageManagerService.mResolvePrioritySorter);
        }

        protected void dumpFilter(PrintWriter out, String prefix, ServiceIntentInfo filter) {
            out.print(prefix);
            out.print(Integer.toHexString(System.identityHashCode(filter.service)));
            out.print(' ');
            filter.service.printComponentShortName(out);
            out.print(" filter ");
            out.println(Integer.toHexString(System.identityHashCode(filter)));
        }

        protected Object filterToLabel(ServiceIntentInfo filter) {
            return filter.service;
        }

        protected void dumpFilterLabel(PrintWriter out, String prefix, Object label, int count) {
            Service service = (Service) label;
            out.print(prefix);
            out.print(Integer.toHexString(System.identityHashCode(service)));
            out.print(' ');
            service.printComponentShortName(out);
            if (count > 1) {
                out.print(" (");
                out.print(count);
                out.print(" filters)");
            }
            out.println();
        }
    }

    public static final class SharedLibraryEntry {
        public final String apk;
        public final SharedLibraryInfo info;
        public final String path;

        SharedLibraryEntry(String _path, String _apk, String name, int version, int type, String declaringPackageName, int declaringPackageVersionCode) {
            this.path = _path;
            this.apk = _apk;
            this.info = new SharedLibraryInfo(name, version, type, new VersionedPackage(declaringPackageName, declaringPackageVersionCode), null);
        }
    }

    private interface BlobXmlRestorer {
        void apply(XmlPullParser xmlPullParser, int i) throws IOException, XmlPullParserException;
    }

    static abstract class InstallArgs {
        String abiOverride;
        final Certificate[][] certificates;
        final int installFlags;
        final String[] installGrantPermissions;
        final int installReason;
        final String installerPackageName;
        String[] instructionSets;
        final MoveInfo move;
        final IPackageInstallObserver2 observer;
        final OriginInfo origin;
        final int traceCookie;
        final String traceMethod;
        final UserHandle user;
        final String volumeUuid;

        abstract void cleanUpResourcesLI();

        abstract int copyApk(IMediaContainerService iMediaContainerService, boolean z) throws RemoteException;

        abstract boolean doPostDeleteLI(boolean z);

        abstract int doPostInstall(int i, int i2);

        abstract int doPreInstall(int i);

        abstract boolean doRename(int i, Package packageR, String str);

        abstract String getCodePath();

        abstract String getResourcePath();

        InstallArgs(OriginInfo origin, MoveInfo move, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, String volumeUuid, UserHandle user, String[] instructionSets, String abiOverride, String[] installGrantPermissions, String traceMethod, int traceCookie, Certificate[][] certificates, int installReason) {
            this.origin = origin;
            this.move = move;
            this.installFlags = installFlags;
            this.observer = observer;
            this.installerPackageName = installerPackageName;
            this.volumeUuid = volumeUuid;
            this.user = user;
            this.instructionSets = instructionSets;
            this.abiOverride = abiOverride;
            this.installGrantPermissions = installGrantPermissions;
            this.traceMethod = traceMethod;
            this.traceCookie = traceCookie;
            this.certificates = certificates;
            this.installReason = installReason;
        }

        int doPreCopy() {
            return 1;
        }

        int doPostCopy(int uid) {
            return 1;
        }

        protected boolean isFwdLocked() {
            return (this.installFlags & 1) != 0;
        }

        protected boolean isExternalAsec() {
            return (this.installFlags & 8) != 0;
        }

        protected boolean isEphemeral() {
            return (this.installFlags & 2048) != 0;
        }

        UserHandle getUser() {
            return this.user;
        }
    }

    class AsecInstallArgs extends InstallArgs {
        static final String PUBLIC_RES_FILE_NAME = "res.zip";
        static final String RES_FILE_NAME = "pkg.apk";
        String cid;
        String packagePath;
        String resourcePath;

        AsecInstallArgs(InstallParams params) {
            super(params.origin, params.move, params.observer, params.installFlags, params.installerPackageName, params.volumeUuid, params.getUser(), null, params.packageAbiOverride, params.grantedRuntimePermissions, params.traceMethod, params.traceCookie, params.certificates, params.installReason);
        }

        AsecInstallArgs(String fullCodePath, String[] instructionSets, boolean isExternal, boolean isForwardLocked) {
            super(OriginInfo.fromNothing(), null, null, (isExternal ? 8 : 0) | (isForwardLocked ? 1 : 0), null, null, null, instructionSets, null, null, null, 0, null, 0);
            if (!fullCodePath.endsWith(RES_FILE_NAME)) {
                fullCodePath = new File(fullCodePath, RES_FILE_NAME).getAbsolutePath();
            }
            int eidx = fullCodePath.lastIndexOf("/");
            String subStr1 = fullCodePath.substring(0, eidx);
            this.cid = subStr1.substring(subStr1.lastIndexOf("/") + 1, eidx);
            setMountPath(subStr1);
        }

        AsecInstallArgs(String cid, String[] instructionSets, boolean isForwardLocked) {
            super(OriginInfo.fromNothing(), null, null, (PackageManagerService.this.isAsecExternal(cid) ? 8 : 0) | (isForwardLocked ? 1 : 0), null, null, null, instructionSets, null, null, null, 0, null, 0);
            this.cid = cid;
            setMountPath(PackageHelper.getSdDir(cid));
        }

        void createCopyFile() {
            this.cid = PackageManagerService.this.mInstallerService.allocateExternalStageCidLegacy();
        }

        int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException {
            if (!this.origin.staged || this.origin.cid == null) {
                if (temp) {
                    createCopyFile();
                } else {
                    PackageHelper.destroySdDir(this.cid);
                }
                String newMountPath = imcs.copyPackageToContainer(this.origin.file.getAbsolutePath(), this.cid, PackageManagerService.getEncryptKey(), isExternalAsec(), isFwdLocked(), PackageManagerService.deriveAbiOverride(this.abiOverride, null));
                if (newMountPath == null) {
                    return -18;
                }
                setMountPath(newMountPath);
                return 1;
            }
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.d(PackageManagerService.TAG, this.origin.cid + " already staged; skipping copy");
            }
            this.cid = this.origin.cid;
            setMountPath(PackageHelper.getSdDir(this.cid));
            return 1;
        }

        String getCodePath() {
            return this.packagePath;
        }

        String getResourcePath() {
            return this.resourcePath;
        }

        int doPreInstall(int status) {
            if (status != 1) {
                PackageHelper.destroySdDir(this.cid);
            } else if (!PackageHelper.isContainerMounted(this.cid)) {
                String newMountPath = PackageHelper.mountSdDir(this.cid, PackageManagerService.getEncryptKey(), 1000);
                if (newMountPath == null) {
                    return -18;
                }
                setMountPath(newMountPath);
            }
            return status;
        }

        boolean doRename(int status, Package pkg, String oldCodePath) {
            String newCacheId = PackageManagerService.getNextCodePath(oldCodePath, pkg.packageName, "/pkg.apk");
            if (!PackageHelper.isContainerMounted(this.cid) || PackageHelper.unMountSdDir(this.cid)) {
                String newMountPath;
                if (!PackageHelper.renameSdDir(this.cid, newCacheId)) {
                    Slog.e(PackageManagerService.TAG, "Failed to rename " + this.cid + " to " + newCacheId + " which might be stale. Will try to clean up.");
                    if (!PackageHelper.destroySdDir(newCacheId)) {
                        Slog.e(PackageManagerService.TAG, "Very strange. Cannot clean up stale container " + newCacheId);
                        return false;
                    } else if (!PackageHelper.renameSdDir(this.cid, newCacheId)) {
                        Slog.e(PackageManagerService.TAG, "Failed to rename " + this.cid + " to " + newCacheId + " inspite of cleaning it up.");
                        return false;
                    }
                }
                if (PackageHelper.isContainerMounted(newCacheId)) {
                    newMountPath = PackageHelper.getSdDir(newCacheId);
                } else {
                    Slog.w(PackageManagerService.TAG, "Mounting container " + newCacheId);
                    newMountPath = PackageHelper.mountSdDir(newCacheId, PackageManagerService.getEncryptKey(), 1000);
                }
                if (newMountPath == null) {
                    Slog.w(PackageManagerService.TAG, "Failed to get cache path for  " + newCacheId);
                    return false;
                }
                Log.i(PackageManagerService.TAG, "Succesfully renamed " + this.cid + " to " + newCacheId + " at new path: " + newMountPath);
                this.cid = newCacheId;
                File beforeCodeFile = new File(this.packagePath);
                setMountPath(newMountPath);
                File afterCodeFile = new File(this.packagePath);
                pkg.setCodePath(afterCodeFile.getAbsolutePath());
                pkg.setBaseCodePath(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.baseCodePath));
                pkg.setSplitCodePaths(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.splitCodePaths));
                pkg.setApplicationVolumeUuid(pkg.volumeUuid);
                pkg.setApplicationInfoCodePath(pkg.codePath);
                pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
                pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
                pkg.setApplicationInfoResourcePath(pkg.codePath);
                pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);
                pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
                return true;
            }
            Slog.i(PackageManagerService.TAG, "Failed to unmount " + this.cid + " before renaming");
            return false;
        }

        private void setMountPath(String mountPath) {
            File mountFile = new File(mountPath);
            File monolithicFile = new File(mountFile, RES_FILE_NAME);
            if (monolithicFile.exists()) {
                this.packagePath = monolithicFile.getAbsolutePath();
                if (isFwdLocked()) {
                    this.resourcePath = new File(mountFile, PUBLIC_RES_FILE_NAME).getAbsolutePath();
                    return;
                } else {
                    this.resourcePath = this.packagePath;
                    return;
                }
            }
            this.packagePath = mountFile.getAbsolutePath();
            this.resourcePath = this.packagePath;
        }

        int doPostInstall(int status, int uid) {
            if (status != 1) {
                cleanUp();
            } else {
                int groupOwner;
                String protectedFile;
                if (isFwdLocked()) {
                    groupOwner = UserHandle.getSharedAppGid(uid);
                    protectedFile = RES_FILE_NAME;
                } else {
                    groupOwner = -1;
                    protectedFile = null;
                }
                if (uid < 10000 || (PackageHelper.fixSdPermissions(this.cid, groupOwner, protectedFile) ^ 1) != 0) {
                    Slog.e(PackageManagerService.TAG, "Failed to finalize " + this.cid);
                    PackageHelper.destroySdDir(this.cid);
                    return -18;
                } else if (!PackageHelper.isContainerMounted(this.cid)) {
                    PackageHelper.mountSdDir(this.cid, PackageManagerService.getEncryptKey(), Process.myUid());
                }
            }
            return status;
        }

        private void cleanUp() {
            if (PackageManagerService.DEBUG_SD_INSTALL) {
                Slog.i(PackageManagerService.TAG, HealthState.CLEANUP);
            }
            PackageHelper.destroySdDir(this.cid);
        }

        private List<String> getAllCodePaths() {
            File codeFile = new File(getCodePath());
            if (codeFile != null && codeFile.exists()) {
                try {
                    return PackageParser.parsePackageLite(codeFile, 0).getAllCodePaths();
                } catch (PackageParserException e) {
                }
            }
            return Collections.EMPTY_LIST;
        }

        void cleanUpResourcesLI() {
            cleanUpResourcesLI(getAllCodePaths());
        }

        private void cleanUpResourcesLI(List<String> allCodePaths) {
            cleanUp();
            PackageManagerService.this.removeDexFiles(allCodePaths, this.instructionSets);
        }

        String getPackageName() {
            return PackageManagerService.getAsecPackageName(this.cid);
        }

        boolean doPostDeleteLI(boolean delete) {
            if (PackageManagerService.DEBUG_SD_INSTALL) {
                Slog.i(PackageManagerService.TAG, "doPostDeleteLI() del=" + delete);
            }
            List<String> allCodePaths = getAllCodePaths();
            int mounted = PackageHelper.isContainerMounted(this.cid);
            if (mounted != 0 && PackageHelper.unMountSdDir(this.cid)) {
                mounted = 0;
            }
            if (mounted == 0 && delete) {
                cleanUpResourcesLI(allCodePaths);
            }
            return mounted ^ 1;
        }

        int doPreCopy() {
            if (!isFwdLocked() || PackageHelper.fixSdPermissions(this.cid, PackageManagerService.this.getPackageUid(PackageManagerService.DEFAULT_CONTAINER_PACKAGE, DumpState.DUMP_DEXOPT, 0), RES_FILE_NAME)) {
                return 1;
            }
            return -18;
        }

        int doPostCopy(int uid) {
            if (!isFwdLocked() || (uid >= 10000 && (PackageHelper.fixSdPermissions(this.cid, UserHandle.getSharedAppGid(uid), RES_FILE_NAME) ^ 1) == 0)) {
                return 1;
            }
            Slog.e(PackageManagerService.TAG, "Failed to finalize " + this.cid);
            PackageHelper.destroySdDir(this.cid);
            return -18;
        }
    }

    private final class ClearStorageConnection implements ServiceConnection {
        IMediaContainerService mContainerService;

        /* synthetic */ ClearStorageConnection(PackageManagerService this$0, ClearStorageConnection -this1) {
            this();
        }

        private ClearStorageConnection() {
        }

        public void onServiceConnected(ComponentName name, IBinder service) {
            synchronized (this) {
                this.mContainerService = IMediaContainerService.Stub.asInterface(Binder.allowBlocking(service));
                notifyAll();
            }
        }

        public void onServiceDisconnected(ComponentName name) {
        }
    }

    @Retention(RetentionPolicy.SOURCE)
    public @interface ComponentType {
    }

    private static class CrossProfileDomainInfo {
        int bestDomainVerificationStatus;
        ResolveInfo resolveInfo;

        /* synthetic */ CrossProfileDomainInfo(CrossProfileDomainInfo -this0) {
            this();
        }

        private CrossProfileDomainInfo() {
        }
    }

    static class DumpState {
        public static final int DUMP_ACTIVITY_RESOLVERS = 4;
        public static final int DUMP_CHANGES = 4194304;
        public static final int DUMP_COMPILER_STATS = 2097152;
        public static final int DUMP_CONTENT_RESOLVERS = 32;
        public static final int DUMP_DEXOPT = 1048576;
        public static final int DUMP_DOMAIN_PREFERRED = 262144;
        public static final int DUMP_FEATURES = 2;
        public static final int DUMP_FROZEN = 524288;
        public static final int DUMP_INSTALLS = 65536;
        public static final int DUMP_INTENT_FILTER_VERIFIERS = 131072;
        public static final int DUMP_KEYSETS = 16384;
        public static final int DUMP_LIBS = 1;
        public static final int DUMP_MESSAGES = 512;
        public static final int DUMP_PACKAGES = 128;
        public static final int DUMP_PERMISSIONS = 64;
        public static final int DUMP_PREFERRED = 4096;
        public static final int DUMP_PREFERRED_XML = 8192;
        public static final int DUMP_PROVIDERS = 1024;
        public static final int DUMP_RECEIVER_RESOLVERS = 16;
        public static final int DUMP_SERVICE_RESOLVERS = 8;
        public static final int DUMP_SHARED_USERS = 256;
        public static final int DUMP_VERIFIERS = 2048;
        public static final int DUMP_VERSION = 32768;
        public static final int DUMP_VOLUMES = 8388608;
        public static final int OPTION_SHOW_FILTERS = 1;
        private int mOptions;
        private SharedUserSetting mSharedUser;
        private boolean mTitlePrinted;
        private int mTypes;

        DumpState() {
        }

        public boolean isDumping(int type) {
            boolean z = true;
            if (this.mTypes == 0 && type != 8192) {
                return true;
            }
            if ((this.mTypes & type) == 0) {
                z = false;
            }
            return z;
        }

        public void setDump(int type) {
            this.mTypes |= type;
        }

        public boolean isOptionEnabled(int option) {
            return (this.mOptions & option) != 0;
        }

        public void setOptionEnabled(int option) {
            this.mOptions |= option;
        }

        public boolean onTitlePrinted() {
            boolean printed = this.mTitlePrinted;
            this.mTitlePrinted = true;
            return printed;
        }

        public boolean getTitlePrinted() {
            return this.mTitlePrinted;
        }

        public void setTitlePrinted(boolean enabled) {
            this.mTitlePrinted = enabled;
        }

        public SharedUserSetting getSharedUser() {
            return this.mSharedUser;
        }

        public void setSharedUser(SharedUserSetting user) {
            this.mSharedUser = user;
        }
    }

    static final class EphemeralIntentResolver extends IntentResolver<AuxiliaryResolveInfo, AuxiliaryResolveInfo> {
        final ArrayMap<String, Pair<Integer, InstantAppResolveInfo>> mOrderResult = new ArrayMap();

        EphemeralIntentResolver() {
        }

        protected AuxiliaryResolveInfo[] newArray(int size) {
            return new AuxiliaryResolveInfo[size];
        }

        protected boolean isPackageForFilter(String packageName, AuxiliaryResolveInfo responseObj) {
            return true;
        }

        protected AuxiliaryResolveInfo newResult(AuxiliaryResolveInfo responseObj, int match, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            String packageName = responseObj.resolveInfo.getPackageName();
            Integer order = Integer.valueOf(responseObj.getOrder());
            Pair<Integer, InstantAppResolveInfo> lastOrderResult = (Pair) this.mOrderResult.get(packageName);
            if (lastOrderResult != null && ((Integer) lastOrderResult.first).intValue() >= order.intValue()) {
                return null;
            }
            InstantAppResolveInfo res = responseObj.resolveInfo;
            if (order.intValue() > 0) {
                this.mOrderResult.put(packageName, new Pair(order, res));
            }
            return responseObj;
        }

        protected void filterResults(List<AuxiliaryResolveInfo> results) {
            if (this.mOrderResult.size() != 0) {
                int resultSize = results.size();
                int i = 0;
                while (i < resultSize) {
                    InstantAppResolveInfo info = ((AuxiliaryResolveInfo) results.get(i)).resolveInfo;
                    String packageName = info.getPackageName();
                    Pair<Integer, InstantAppResolveInfo> savedInfo = (Pair) this.mOrderResult.get(packageName);
                    if (savedInfo != null) {
                        if (savedInfo.second == info) {
                            this.mOrderResult.remove(packageName);
                            if (this.mOrderResult.size() == 0) {
                                break;
                            }
                        } else {
                            results.remove(i);
                            resultSize--;
                            i--;
                        }
                    }
                    i++;
                }
            }
        }
    }

    class FileInstallArgs extends InstallArgs {
        private File codeFile;
        private File resourceFile;

        FileInstallArgs(InstallParams params) {
            super(params.origin, params.move, params.observer, params.installFlags, params.installerPackageName, params.volumeUuid, params.getUser(), null, params.packageAbiOverride, params.grantedRuntimePermissions, params.traceMethod, params.traceCookie, params.certificates, params.installReason);
            if (isFwdLocked()) {
                throw new IllegalArgumentException("Forward locking only supported in ASEC");
            }
        }

        FileInstallArgs(String codePath, String resourcePath, String[] instructionSets) {
            super(OriginInfo.fromNothing(), null, null, 0, null, null, null, instructionSets, null, null, null, 0, null, 0);
            this.codeFile = codePath != null ? new File(codePath) : null;
            this.resourceFile = resourcePath != null ? new File(resourcePath) : null;
        }

        int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException {
            Trace.traceBegin(262144, "copyApk");
            try {
                int doCopyApk = doCopyApk(imcs, temp);
                return doCopyApk;
            } finally {
                Trace.traceEnd(262144);
            }
        }

        private int doCopyApk(IMediaContainerService imcs, boolean temp) throws RemoteException {
            if (this.origin.staged) {
                if (PackageManagerService.DEBUG_INSTALL) {
                    Slog.d(PackageManagerService.TAG, this.origin.file + " already staged; skipping copy");
                }
                this.codeFile = this.origin.file;
                this.resourceFile = this.origin.file;
                return 1;
            }
            try {
                File tempDir = PackageManagerService.this.mInstallerService.allocateStageDirLegacy(this.volumeUuid, (this.installFlags & 2048) != 0);
                this.codeFile = tempDir;
                this.resourceFile = tempDir;
                int ret = imcs.copyPackage(this.origin.file.getAbsolutePath(), new IParcelFileDescriptorFactory.Stub() {
                    public ParcelFileDescriptor open(String name, int mode) throws RemoteException {
                        if (FileUtils.isValidExtFilename(name)) {
                            try {
                                File file = new File(FileInstallArgs.this.codeFile, name);
                                FileDescriptor fd = Os.open(file.getAbsolutePath(), OsConstants.O_RDWR | OsConstants.O_CREAT, 420);
                                Os.chmod(file.getAbsolutePath(), 420);
                                return new ParcelFileDescriptor(fd);
                            } catch (ErrnoException e) {
                                throw new RemoteException("Failed to open: " + e.getMessage());
                            }
                        }
                        throw new IllegalArgumentException("Invalid filename: " + name);
                    }
                });
                if (ret != 1) {
                    Slog.e(PackageManagerService.TAG, "Failed to copy package");
                    return ret;
                }
                File libraryRoot = new File(this.codeFile, "lib");
                AutoCloseable autoCloseable = null;
                try {
                    autoCloseable = Handle.create(this.codeFile);
                    ret = NativeLibraryHelper.copyNativeBinariesWithOverride(autoCloseable, libraryRoot, this.abiOverride);
                    IoUtils.closeQuietly(autoCloseable);
                } catch (IOException e) {
                    Slog.e(PackageManagerService.TAG, "Copying native libraries failed", e);
                    ret = -110;
                    IoUtils.closeQuietly(autoCloseable);
                } catch (Throwable th) {
                    IoUtils.closeQuietly(autoCloseable);
                    throw th;
                }
                return ret;
            } catch (IOException e2) {
                Slog.w(PackageManagerService.TAG, "Failed to create copy file: " + e2);
                return -4;
            }
        }

        int doPreInstall(int status) {
            if (status != 1) {
                cleanUp();
            }
            return status;
        }

        boolean doRename(int status, Package pkg, String oldCodePath) {
            if (status != 1) {
                cleanUp();
                return false;
            }
            File targetDir = this.codeFile.getParentFile();
            File beforeCodeFile = this.codeFile;
            File afterCodeFile = PackageManagerService.this.getNextCodePath(targetDir, pkg.packageName);
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.d(PackageManagerService.TAG, "Renaming " + beforeCodeFile + " to " + afterCodeFile);
            }
            try {
                Os.rename(beforeCodeFile.getAbsolutePath(), afterCodeFile.getAbsolutePath());
                if (SELinux.restoreconRecursive(afterCodeFile)) {
                    this.codeFile = afterCodeFile;
                    this.resourceFile = afterCodeFile;
                    pkg.setCodePath(afterCodeFile.getAbsolutePath());
                    pkg.setBaseCodePath(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.baseCodePath));
                    pkg.setSplitCodePaths(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.splitCodePaths));
                    pkg.setApplicationVolumeUuid(pkg.volumeUuid);
                    pkg.setApplicationInfoCodePath(pkg.codePath);
                    pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
                    pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
                    pkg.setApplicationInfoResourcePath(pkg.codePath);
                    pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);
                    pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
                    return true;
                }
                Slog.w(PackageManagerService.TAG, "Failed to restorecon");
                return false;
            } catch (ErrnoException e) {
                Slog.w(PackageManagerService.TAG, "Failed to rename", e);
                return false;
            }
        }

        int doPostInstall(int status, int uid) {
            if (status != 1) {
                cleanUp();
            }
            return status;
        }

        String getCodePath() {
            return this.codeFile != null ? this.codeFile.getAbsolutePath() : null;
        }

        String getResourcePath() {
            return this.resourceFile != null ? this.resourceFile.getAbsolutePath() : null;
        }

        private boolean cleanUp() {
            if (this.codeFile == null || (this.codeFile.exists() ^ 1) != 0) {
                return false;
            }
            PackageManagerService.this.removeCodePathLI(this.codeFile);
            if (!(this.resourceFile == null || (FileUtils.contains(this.codeFile, this.resourceFile) ^ 1) == 0)) {
                this.resourceFile.delete();
            }
            return true;
        }

        void cleanUpResourcesLI() {
            List<String> allCodePaths = Collections.EMPTY_LIST;
            if (this.codeFile != null && this.codeFile.exists()) {
                try {
                    allCodePaths = PackageParser.parsePackageLite(this.codeFile, 0).getAllCodePaths();
                } catch (PackageParserException e) {
                }
            }
            cleanUp();
            PackageManagerService.this.removeDexFiles(allCodePaths, this.instructionSets);
        }

        boolean doPostDeleteLI(boolean delete) {
            cleanUpResourcesLI();
            return true;
        }
    }

    private abstract class HandlerParams {
        private static final int MAX_RETRIES = 4;
        private int mRetries = 0;
        private final UserHandle mUser;
        int traceCookie;
        String traceMethod;

        abstract void handleReturnCode();

        abstract void handleServiceError();

        abstract void handleStartCopy() throws RemoteException;

        HandlerParams(UserHandle user) {
            this.mUser = user;
        }

        UserHandle getUser() {
            return this.mUser;
        }

        HandlerParams setTraceMethod(String traceMethod) {
            this.traceMethod = traceMethod;
            return this;
        }

        HandlerParams setTraceCookie(int traceCookie) {
            this.traceCookie = traceCookie;
            return this;
        }

        final boolean startCopy() {
            boolean res;
            try {
                if (PackageManagerService.DEBUG_INSTALL) {
                    Slog.i(PackageManagerService.TAG, "startCopy " + this.mUser + ": " + this);
                }
                int i = this.mRetries + 1;
                this.mRetries = i;
                if (i > 4) {
                    Slog.w(PackageManagerService.TAG, "Failed to invoke remote methods on default container service. Giving up");
                    PackageManagerService.this.mHandler.sendEmptyMessage(11);
                    handleServiceError();
                    return false;
                }
                handleStartCopy();
                res = true;
                handleReturnCode();
                return res;
            } catch (RemoteException e) {
                if (PackageManagerService.DEBUG_INSTALL) {
                    Slog.i(PackageManagerService.TAG, "Posting install MCS_RECONNECT");
                }
                PackageManagerService.this.mHandler.sendEmptyMessage(10);
                res = false;
            }
        }

        final void serviceError() {
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.i(PackageManagerService.TAG, "serviceError");
            }
            handleServiceError();
            handleReturnCode();
        }
    }

    private static class IFVerificationParams {
        Package pkg;
        boolean replacing;
        int userId;
        int verifierUid;

        public IFVerificationParams(Package _pkg, boolean _replacing, int _userId, int _verifierUid) {
            this.pkg = _pkg;
            this.replacing = _replacing;
            this.userId = _userId;
            this.replacing = _replacing;
            this.verifierUid = _verifierUid;
        }
    }

    class InstallParams extends HandlerParams {
        final Certificate[][] certificates;
        final String[] grantedRuntimePermissions;
        int installFlags;
        final int installReason;
        final String installerPackageName;
        private InstallArgs mArgs;
        private int mRet;
        final MoveInfo move;
        final IPackageInstallObserver2 observer;
        final OriginInfo origin;
        final String packageAbiOverride;
        final VerificationInfo verificationInfo;
        final String volumeUuid;

        InstallParams(OriginInfo origin, MoveInfo move, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, String volumeUuid, VerificationInfo verificationInfo, UserHandle user, String packageAbiOverride, String[] grantedPermissions, Certificate[][] certificates, int installReason) {
            super(user);
            this.origin = origin;
            this.move = move;
            this.observer = observer;
            this.installFlags = installFlags;
            this.installerPackageName = installerPackageName;
            this.volumeUuid = volumeUuid;
            this.verificationInfo = verificationInfo;
            this.packageAbiOverride = packageAbiOverride;
            this.grantedRuntimePermissions = grantedPermissions;
            this.certificates = certificates;
            this.installReason = installReason;
        }

        public String toString() {
            return "InstallParams{" + Integer.toHexString(System.identityHashCode(this)) + " file=" + this.origin.file + " cid=" + this.origin.cid + "}";
        }

        /* JADX WARNING: inconsistent code. */
        /* Code decompiled incorrectly, please refer to instructions dump. */
        private int installLocationPolicy(PackageInfoLite pkgLite) {
            String packageName = pkgLite.packageName;
            int installLocation = pkgLite.installLocation;
            boolean onSd = (this.installFlags & 8) != 0;
            synchronized (PackageManagerService.this.mPackages) {
                Package installedPkg = (Package) PackageManagerService.this.mPackages.get(packageName);
                Package dataOwnerPkg = installedPkg;
                if (installedPkg == null) {
                    PackageSetting ps = (PackageSetting) PackageManagerService.this.mSettings.mPackages.get(packageName);
                    if (ps != null) {
                        dataOwnerPkg = ps.pkg;
                    }
                }
                if (dataOwnerPkg != null) {
                    boolean downgradePermitted = (this.installFlags & 128) != 0 ? !Build.IS_DEBUGGABLE ? (dataOwnerPkg.applicationInfo.flags & 2) != 0 : true : false;
                    if (!downgradePermitted) {
                        try {
                            PackageManagerService.checkDowngrade(dataOwnerPkg, pkgLite);
                        } catch (PackageManagerException e) {
                            Slog.w(PackageManagerService.TAG, "Downgrade detected: " + e.getMessage());
                            return -7;
                        }
                    }
                }
                if (installedPkg != null) {
                    if ((this.installFlags & 2) == 0) {
                        return -4;
                    } else if ((installedPkg.applicationInfo.flags & 1) != 0) {
                        if (onSd) {
                            Slog.w(PackageManagerService.TAG, "Cannot install update to system app on sdcard");
                            return -3;
                        }
                        return 1;
                    } else if (onSd) {
                        return 2;
                    } else if (installLocation == 1) {
                        return 1;
                    } else if (installLocation != 2) {
                        if (PackageManagerService.isExternal(installedPkg)) {
                            return 2;
                        }
                        return 1;
                    }
                }
            }
        }

        public void handleStartCopy() throws RemoteException {
            int ret = 1;
            if (this.origin.staged) {
                if (this.origin.file != null) {
                    this.installFlags |= 16;
                    this.installFlags &= -9;
                } else if (this.origin.cid != null) {
                    this.installFlags |= 8;
                    this.installFlags &= -17;
                } else {
                    throw new IllegalStateException("Invalid stage location");
                }
            }
            boolean onSd = (this.installFlags & 8) != 0;
            boolean onInt = (this.installFlags & 16) != 0;
            boolean ephemeral = (this.installFlags & 2048) != 0;
            PackageInfoLite pkgLite = null;
            if (onInt && onSd) {
                Slog.w(PackageManagerService.TAG, "Conflicting flags specified for installing on both internal and external");
                ret = -19;
            } else if (onSd && ephemeral) {
                Slog.w(PackageManagerService.TAG, "Conflicting flags specified for installing ephemeral on external");
                ret = -19;
            } else {
                pkgLite = PackageManagerService.this.mContainerService.getMinimalPackageInfo(this.origin.resolvedPath, this.installFlags, this.packageAbiOverride);
                if (PackageManagerService.DEBUG_EPHEMERAL && ephemeral) {
                    Slog.v(PackageManagerService.TAG, "pkgLite for install: " + pkgLite);
                }
                if (!this.origin.staged && pkgLite.recommendedInstallLocation == -1) {
                    try {
                        PackageManagerService.this.mInstaller.freeCache(null, PackageManagerService.this.mContainerService.calculateInstalledSize(this.origin.resolvedPath, isForwardLocked(), this.packageAbiOverride) + StorageManager.from(PackageManagerService.this.mContext).getStorageLowBytes(Environment.getDataDirectory()), 0, 0);
                        pkgLite = PackageManagerService.this.mContainerService.getMinimalPackageInfo(this.origin.resolvedPath, this.installFlags, this.packageAbiOverride);
                    } catch (Throwable e) {
                        Slog.w(PackageManagerService.TAG, "Failed to free cache", e);
                    }
                    if (pkgLite.recommendedInstallLocation == -6) {
                        pkgLite.recommendedInstallLocation = -1;
                    }
                }
            }
            if (PackageManagerService.EXP_VERSION && !PackageManagerService.this.checkAppInstallPermission(pkgLite.packageName)) {
                Slog.i(PackageManagerService.TAG, pkgLite.packageName + " checked failed!");
                ret = -2;
            }
            String OPPO_MARKET = "com.oppo.market";
            String OPPO_GAME_CENTER = PackageManagerService.GAME_CENTER_PKGNAME;
            try {
                String frontPackage = SystemProperties.get("oppo.dex.front.package");
                if ((("com.oppo.market".equals(this.installerPackageName) && "com.oppo.market".equals(frontPackage)) || (PackageManagerService.GAME_CENTER_PKGNAME.equals(this.installerPackageName) && PackageManagerService.GAME_CENTER_PKGNAME.equals(frontPackage))) && Secure.getInt(PackageManagerService.this.mContext.getContentResolver(), "settings_install_authentication", 0) == 1 && pkgLite != null && pkgLite.packageName != null && PackageManagerService.this.mSettings.mPackages.get(pkgLite.packageName) == null) {
                    boolean frequencyAlways = Secure.getInt(PackageManagerService.this.mContext.getContentResolver(), "settings_install_authentication_frequency", 0) == 0;
                    long lastVerifyTime = Secure.getLong(PackageManagerService.this.mContext.getContentResolver(), "account_verify_time", -1);
                    long interval = SystemClock.elapsedRealtime() - lastVerifyTime;
                    boolean needVerify = true;
                    if (!(frequencyAlways || lastVerifyTime == -1 || interval > 900000)) {
                        needVerify = false;
                    }
                    if (needVerify) {
                        this.mRet = -111;
                        if (this.observer != null) {
                            this.observer.onPackageInstalled("", this.mRet, null, null);
                        }
                        ColorPackageManagerHelper.sendOppoInstallFailBro(pkgLite.packageName, this.installerPackageName, 0);
                        return;
                    }
                }
            } catch (Throwable e2) {
                Slog.w(PackageManagerService.TAG, "Failed to restrict oppo market", e2);
            }
            if (ret == 1) {
                int loc = pkgLite.recommendedInstallLocation;
                if (loc == -3) {
                    ret = -19;
                } else if (loc == -4) {
                    ret = -1;
                } else if (loc == -1) {
                    ret = -4;
                } else if (loc == -2) {
                    ret = -2;
                } else if (loc == -6) {
                    ret = -3;
                } else if (loc == -5) {
                    ret = -20;
                } else {
                    loc = installLocationPolicy(pkgLite);
                    if (loc == -7) {
                        ret = -25;
                    } else if (!(onSd || (onInt ^ 1) == 0)) {
                        if (loc == 2) {
                            this.installFlags |= 8;
                            this.installFlags &= -17;
                        } else if (loc == 3) {
                            if (PackageManagerService.DEBUG_EPHEMERAL) {
                                Slog.v(PackageManagerService.TAG, "...setting INSTALL_EPHEMERAL install flag");
                            }
                            this.installFlags |= 2048;
                            this.installFlags &= -25;
                        } else {
                            this.installFlags |= 16;
                            this.installFlags &= -9;
                        }
                    }
                }
            }
            InstallArgs args = PackageManagerService.this.createInstallArgs(this);
            args.abiOverride = PackageManagerService.mCompatibilityHelper.abiOverride(args.abiOverride, pkgLite.packageName);
            this.mArgs = args;
            if (ret == 1) {
                int requiredUid;
                int optionalUid;
                UserHandle verifierUser = getUser();
                if (verifierUser == UserHandle.ALL) {
                    verifierUser = UserHandle.SYSTEM;
                }
                if (PackageManagerService.this.mRequiredVerifierPackage == null) {
                    requiredUid = -1;
                } else {
                    requiredUid = PackageManagerService.this.getPackageUid(PackageManagerService.this.mRequiredVerifierPackage, 268435456, verifierUser.getIdentifier());
                }
                if (PackageManagerService.this.mOptionalVerifierPackage == null) {
                    optionalUid = -1;
                } else {
                    optionalUid = PackageManagerService.this.getPackageUid(PackageManagerService.this.mOptionalVerifierPackage, 268435456, verifierUser.getIdentifier());
                }
                int installerUid = this.verificationInfo == null ? -1 : this.verificationInfo.installerUid;
                if (this.origin.existing || ((requiredUid == -1 && optionalUid == -1) || !PackageManagerService.this.isVerificationEnabled(verifierUser.getIdentifier(), this.installFlags, installerUid))) {
                    ret = args.copyApk(PackageManagerService.this.mContainerService, true);
                } else {
                    final int i;
                    Intent verification = new Intent("android.intent.action.PACKAGE_NEEDS_VERIFICATION");
                    verification.addFlags(268435456);
                    verification.setDataAndType(Uri.fromFile(new File(this.origin.resolvedPath)), PackageManagerService.PACKAGE_MIME_TYPE);
                    verification.addFlags(1);
                    List<ResolveInfo> receivers = PackageManagerService.this.queryIntentReceiversInternal(verification, PackageManagerService.PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(), false);
                    if (PackageManagerService.DEBUG_VERIFY) {
                        Slog.d(PackageManagerService.TAG, "Found " + receivers.size() + " verifiers for intent " + verification.toString() + " with " + pkgLite.verifiers.length + " optional verifiers");
                    }
                    PackageManagerService packageManagerService = PackageManagerService.this;
                    int verificationId = packageManagerService.mPendingVerificationToken;
                    packageManagerService.mPendingVerificationToken = verificationId + 1;
                    verification.putExtra("android.content.pm.extra.VERIFICATION_ID", verificationId);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_INSTALLER_PACKAGE", this.installerPackageName);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_INSTALL_FLAGS", this.installFlags);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_PACKAGE_NAME", pkgLite.packageName);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_VERSION_CODE", pkgLite.versionCode);
                    if (this.verificationInfo != null) {
                        if (this.verificationInfo.originatingUri != null) {
                            verification.putExtra("android.intent.extra.ORIGINATING_URI", this.verificationInfo.originatingUri);
                        }
                        if (this.verificationInfo.referrer != null) {
                            verification.putExtra("android.intent.extra.REFERRER", this.verificationInfo.referrer);
                        }
                        if (this.verificationInfo.originatingUid >= 0) {
                            verification.putExtra("android.intent.extra.ORIGINATING_UID", this.verificationInfo.originatingUid);
                        }
                        if (this.verificationInfo.installerUid >= 0) {
                            verification.putExtra("android.content.pm.extra.VERIFICATION_INSTALLER_UID", this.verificationInfo.installerUid);
                        }
                    }
                    PackageVerificationState packageVerificationState = new PackageVerificationState(requiredUid, args);
                    PackageManagerService.this.mPendingVerification.append(verificationId, packageVerificationState);
                    List<ComponentName> sufficientVerifiers = PackageManagerService.this.matchVerifiers(pkgLite, receivers, packageVerificationState);
                    LocalService idleController = PackageManagerService.this.getDeviceIdleController();
                    long idleDuration = PackageManagerService.this.getVerificationTimeout();
                    if (sufficientVerifiers != null) {
                        int N = sufficientVerifiers.size();
                        if (N == 0) {
                            Slog.i(PackageManagerService.TAG, "Additional verifiers required, but none installed.");
                            ret = -22;
                        } else {
                            for (int i2 = 0; i2 < N; i2++) {
                                ComponentName verifierComponent = (ComponentName) sufficientVerifiers.get(i2);
                                idleController.addPowerSaveTempWhitelistApp(Process.myUid(), verifierComponent.getPackageName(), idleDuration, verifierUser.getIdentifier(), false, "package verifier");
                                Intent intent = new Intent(verification);
                                intent.setComponent(verifierComponent);
                                PackageManagerService.this.mContext.sendBroadcastAsUser(intent, verifierUser);
                            }
                        }
                    }
                    if (PackageManagerService.this.mOptionalVerifierPackage != null) {
                        Intent optionalIntent = new Intent(verification);
                        optionalIntent.setAction("com.qualcomm.qti.intent.action.PACKAGE_NEEDS_OPTIONAL_VERIFICATION");
                        optionalIntent.setComponent(PackageManagerService.this.matchComponentForVerifier(PackageManagerService.this.mOptionalVerifierPackage, PackageManagerService.this.queryIntentReceiversInternal(optionalIntent, PackageManagerService.PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(), false)));
                        packageVerificationState.addOptionalVerifier(optionalUid);
                        if (PackageManagerService.this.mRequiredVerifierPackage != null) {
                            PackageManagerService.this.mContext.sendBroadcastAsUser(optionalIntent, verifierUser, "android.permission.PACKAGE_VERIFICATION_AGENT");
                        } else {
                            i = verificationId;
                            PackageManagerService.this.mContext.sendOrderedBroadcastAsUser(optionalIntent, verifierUser, "android.permission.PACKAGE_VERIFICATION_AGENT", new BroadcastReceiver() {
                                public void onReceive(Context context, Intent intent) {
                                    Message msg = PackageManagerService.this.mHandler.obtainMessage(16);
                                    msg.arg1 = i;
                                    PackageManagerService.this.mHandler.sendMessageDelayed(msg, PackageManagerService.this.getVerificationTimeout());
                                }
                            }, null, 0, null, null);
                            this.mArgs = null;
                        }
                    }
                    ComponentName requiredVerifierComponent = PackageManagerService.this.matchComponentForVerifier(PackageManagerService.this.mRequiredVerifierPackage, receivers);
                    if (ret == 1 && PackageManagerService.this.mRequiredVerifierPackage != null) {
                        Trace.asyncTraceBegin(262144, "verification", verificationId);
                        verification.setComponent(requiredVerifierComponent);
                        idleController.addPowerSaveTempWhitelistApp(Process.myUid(), PackageManagerService.this.mRequiredVerifierPackage, idleDuration, verifierUser.getIdentifier(), false, "package verifier");
                        i = verificationId;
                        PackageManagerService.this.mContext.sendOrderedBroadcastAsUser(verification, verifierUser, "android.permission.PACKAGE_VERIFICATION_AGENT", new BroadcastReceiver() {
                            public void onReceive(Context context, Intent intent) {
                                Message msg = PackageManagerService.this.mHandler.obtainMessage(16);
                                msg.arg1 = i;
                                PackageManagerService.this.mHandler.sendMessageDelayed(msg, PackageManagerService.this.getVerificationTimeout());
                            }
                        }, null, 0, null, null);
                        this.mArgs = null;
                    }
                }
            }
            this.mRet = ret;
        }

        void handleReturnCode() {
            if (this.mArgs != null) {
                PackageManagerService.this.processPendingInstall(this.mArgs, this.mRet);
            }
        }

        void handleServiceError() {
            this.mArgs = PackageManagerService.this.createInstallArgs(this);
            this.mRet = -110;
        }

        public boolean isForwardLocked() {
            return (this.installFlags & 1) != 0;
        }
    }

    private interface IntentFilterVerifier<T extends IntentFilter> {
        boolean addOneIntentFilterVerification(int i, int i2, int i3, T t, String str);

        void receiveVerificationResponse(int i);

        void startVerifications(int i);
    }

    private class IntentVerifierProxy implements IntentFilterVerifier<ActivityIntentInfo> {
        private Context mContext;
        private ArrayList<Integer> mCurrentIntentFilterVerifications = new ArrayList();
        private ComponentName mIntentFilterVerifierComponent;

        public IntentVerifierProxy(Context context, ComponentName verifierComponent) {
            this.mContext = context;
            this.mIntentFilterVerifierComponent = verifierComponent;
        }

        private String getDefaultScheme() {
            return "https";
        }

        public void startVerifications(int userId) {
            int count = this.mCurrentIntentFilterVerifications.size();
            for (int n = 0; n < count; n++) {
                int verificationId = ((Integer) this.mCurrentIntentFilterVerifications.get(n)).intValue();
                IntentFilterVerificationState ivs = (IntentFilterVerificationState) PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
                String packageName = ivs.getPackageName();
                ArrayList<ActivityIntentInfo> filters = ivs.getFilters();
                int filterCount = filters.size();
                ArraySet<String> domainsSet = new ArraySet();
                for (int m = 0; m < filterCount; m++) {
                    domainsSet.addAll(((ActivityIntentInfo) filters.get(m)).getHostsList());
                }
                synchronized (PackageManagerService.this.mPackages) {
                    if (PackageManagerService.this.mSettings.createIntentFilterVerificationIfNeededLPw(packageName, domainsSet) != null) {
                        PackageManagerService.this.scheduleWriteSettingsLocked();
                    }
                }
                sendVerificationRequest(verificationId, ivs);
            }
            this.mCurrentIntentFilterVerifications.clear();
        }

        private void sendVerificationRequest(int verificationId, IntentFilterVerificationState ivs) {
            Intent verificationIntent = new Intent("android.intent.action.INTENT_FILTER_NEEDS_VERIFICATION");
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_ID", verificationId);
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_URI_SCHEME", getDefaultScheme());
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_HOSTS", ivs.getHostsString());
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_PACKAGE_NAME", ivs.getPackageName());
            verificationIntent.setComponent(this.mIntentFilterVerifierComponent);
            verificationIntent.addFlags(268435456);
            PackageManagerService.this.getDeviceIdleController().addPowerSaveTempWhitelistApp(Process.myUid(), this.mIntentFilterVerifierComponent.getPackageName(), PackageManagerService.this.getVerificationTimeout(), 0, true, "intent filter verifier");
            this.mContext.sendBroadcastAsUser(verificationIntent, UserHandle.SYSTEM);
        }

        public void receiveVerificationResponse(int verificationId) {
            IntentFilterVerificationInfo ivi;
            IntentFilterVerificationState ivs = (IntentFilterVerificationState) PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
            boolean verified = ivs.isVerified();
            ArrayList<ActivityIntentInfo> filters = ivs.getFilters();
            int count = filters.size();
            for (int n = 0; n < count; n++) {
                ((ActivityIntentInfo) filters.get(n)).setVerified(verified);
            }
            PackageManagerService.this.mIntentFilterVerificationStates.remove(verificationId);
            String packageName = ivs.getPackageName();
            synchronized (PackageManagerService.this.mPackages) {
                ivi = PackageManagerService.this.mSettings.getIntentFilterVerificationLPr(packageName);
            }
            if (ivi == null) {
                Slog.w(PackageManagerService.TAG, "IntentFilterVerificationInfo not found for verificationId:" + verificationId + " packageName:" + packageName);
                return;
            }
            synchronized (PackageManagerService.this.mPackages) {
                if (verified) {
                    ivi.setStatus(2);
                } else {
                    ivi.setStatus(1);
                }
                PackageManagerService.this.scheduleWriteSettingsLocked();
                int userId = ivs.getUserId();
                if (userId != -1) {
                    int updatedStatus = 0;
                    boolean needUpdate = false;
                    switch (PackageManagerService.this.mSettings.getIntentFilterVerificationStatusLPr(packageName, userId)) {
                        case 0:
                            if (verified) {
                                updatedStatus = 2;
                            } else {
                                updatedStatus = 1;
                            }
                            needUpdate = true;
                            break;
                        case 1:
                            if (verified) {
                                updatedStatus = 2;
                                needUpdate = true;
                                break;
                            }
                            break;
                    }
                    if (needUpdate) {
                        PackageManagerService.this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, updatedStatus, userId);
                        PackageManagerService.this.scheduleWritePackageRestrictionsLocked(userId);
                    }
                }
            }
        }

        public boolean addOneIntentFilterVerification(int verifierUid, int userId, int verificationId, ActivityIntentInfo filter, String packageName) {
            if (!PackageManagerService.hasValidDomains(filter)) {
                return false;
            }
            IntentFilterVerificationState ivs = (IntentFilterVerificationState) PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
            if (ivs == null) {
                ivs = createDomainVerificationState(verifierUid, userId, verificationId, packageName);
            }
            ivs.addFilter(filter);
            return true;
        }

        private IntentFilterVerificationState createDomainVerificationState(int verifierUid, int userId, int verificationId, String packageName) {
            IntentFilterVerificationState ivs = new IntentFilterVerificationState(verifierUid, userId, packageName);
            ivs.setPendingState();
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mIntentFilterVerificationStates.append(verificationId, ivs);
                this.mCurrentIntentFilterVerifications.add(Integer.valueOf(verificationId));
            }
            return ivs;
        }
    }

    static class MoveInfo {
        final int appId;
        final String dataAppName;
        final String fromUuid;
        final int moveId;
        final String packageName;
        final String seinfo;
        final int targetSdkVersion;
        final String toUuid;

        public MoveInfo(int moveId, String fromUuid, String toUuid, String packageName, String dataAppName, int appId, String seinfo, int targetSdkVersion) {
            this.moveId = moveId;
            this.fromUuid = fromUuid;
            this.toUuid = toUuid;
            this.packageName = packageName;
            this.dataAppName = dataAppName;
            this.appId = appId;
            this.seinfo = seinfo;
            this.targetSdkVersion = targetSdkVersion;
        }
    }

    class MoveInstallArgs extends InstallArgs {
        private File codeFile;
        private File resourceFile;

        MoveInstallArgs(InstallParams params) {
            super(params.origin, params.move, params.observer, params.installFlags, params.installerPackageName, params.volumeUuid, params.getUser(), null, params.packageAbiOverride, params.grantedRuntimePermissions, params.traceMethod, params.traceCookie, params.certificates, params.installReason);
        }

        int copyApk(IMediaContainerService imcs, boolean temp) {
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.d(PackageManagerService.TAG, "Moving " + this.move.packageName + " from " + this.move.fromUuid + " to " + this.move.toUuid);
            }
            synchronized (PackageManagerService.this.mInstaller) {
                try {
                    PackageManagerService.this.mInstaller.moveCompleteApp(this.move.fromUuid, this.move.toUuid, this.move.packageName, this.move.dataAppName, this.move.appId, this.move.seinfo, this.move.targetSdkVersion);
                } catch (InstallerException e) {
                    Slog.w(PackageManagerService.TAG, "Failed to move app", e);
                    return -110;
                }
            }
            this.codeFile = new File(Environment.getDataAppDirectory(this.move.toUuid), this.move.dataAppName);
            this.resourceFile = this.codeFile;
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.d(PackageManagerService.TAG, "codeFile after move is " + this.codeFile);
            }
            return 1;
        }

        int doPreInstall(int status) {
            if (status != 1) {
                cleanUp(this.move.toUuid);
            }
            return status;
        }

        boolean doRename(int status, Package pkg, String oldCodePath) {
            if (status != 1) {
                cleanUp(this.move.toUuid);
                return false;
            }
            pkg.setApplicationVolumeUuid(pkg.volumeUuid);
            pkg.setApplicationInfoCodePath(pkg.codePath);
            pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
            pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
            pkg.setApplicationInfoResourcePath(pkg.codePath);
            pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);
            pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
            return true;
        }

        int doPostInstall(int status, int uid) {
            if (status == 1) {
                cleanUp(this.move.fromUuid);
            } else {
                cleanUp(this.move.toUuid);
            }
            return status;
        }

        String getCodePath() {
            return this.codeFile != null ? this.codeFile.getAbsolutePath() : null;
        }

        String getResourcePath() {
            return this.resourceFile != null ? this.resourceFile.getAbsolutePath() : null;
        }

        private boolean cleanUp(String volumeUuid) {
            File codeFile = new File(Environment.getDataAppDirectory(volumeUuid), this.move.dataAppName);
            Slog.d(PackageManagerService.TAG, "Cleaning up " + this.move.packageName + " on " + volumeUuid);
            synchronized (PackageManagerService.this.mInstallLock) {
                for (int userId : PackageManagerService.sUserManager.getUserIds()) {
                    try {
                        PackageManagerService.this.mInstaller.destroyAppData(volumeUuid, this.move.packageName, userId, 3, 0);
                    } catch (InstallerException e) {
                        Slog.w(PackageManagerService.TAG, String.valueOf(e));
                    }
                }
                PackageManagerService.this.removeCodePathLI(codeFile);
            }
            return true;
        }

        void cleanUpResourcesLI() {
            throw new UnsupportedOperationException();
        }

        boolean doPostDeleteLI(boolean delete) {
            throw new UnsupportedOperationException();
        }
    }

    static class OriginInfo {
        final String cid;
        final boolean existing;
        final File file;
        final File resolvedFile;
        final String resolvedPath;
        final boolean staged;

        static OriginInfo fromNothing() {
            return new OriginInfo(null, null, false, false);
        }

        static OriginInfo fromUntrustedFile(File file) {
            return new OriginInfo(file, null, false, false);
        }

        static OriginInfo fromExistingFile(File file) {
            return new OriginInfo(file, null, false, true);
        }

        static OriginInfo fromStagedFile(File file) {
            return new OriginInfo(file, null, true, false);
        }

        static OriginInfo fromStagedContainer(String cid) {
            return new OriginInfo(null, cid, true, false);
        }

        private OriginInfo(File file, String cid, boolean staged, boolean existing) {
            this.file = file;
            this.cid = cid;
            this.staged = staged;
            this.existing = existing;
            if (cid != null) {
                this.resolvedPath = PackageHelper.getSdDir(cid);
                this.resolvedFile = new File(this.resolvedPath);
            } else if (file != null) {
                this.resolvedPath = file.getAbsolutePath();
                this.resolvedFile = file;
            } else {
                this.resolvedPath = null;
                this.resolvedFile = null;
            }
        }
    }

    private class PackageFreezer implements AutoCloseable {
        private final PackageFreezer[] mChildren;
        private final CloseGuard mCloseGuard;
        private final AtomicBoolean mClosed;
        private final String mPackageName;
        private final boolean mWeFroze;

        public PackageFreezer() {
            this.mClosed = new AtomicBoolean();
            this.mCloseGuard = CloseGuard.get();
            this.mPackageName = null;
            this.mChildren = null;
            this.mWeFroze = false;
            this.mCloseGuard.open("close");
        }

        public PackageFreezer(String packageName, int userId, String killReason) {
            this.mClosed = new AtomicBoolean();
            this.mCloseGuard = CloseGuard.get();
            synchronized (PackageManagerService.this.mPackages) {
                this.mPackageName = packageName;
                this.mWeFroze = PackageManagerService.this.mFrozenPackages.add(this.mPackageName);
                PackageSetting ps = (PackageSetting) PackageManagerService.this.mSettings.mPackages.get(this.mPackageName);
                if (ps != null) {
                    PackageManagerService.this.killApplication(ps.name, ps.appId, userId, killReason);
                }
                Package p = (Package) PackageManagerService.this.mPackages.get(packageName);
                if (p == null || p.childPackages == null) {
                    this.mChildren = null;
                } else {
                    int N = p.childPackages.size();
                    this.mChildren = new PackageFreezer[N];
                    for (int i = 0; i < N; i++) {
                        this.mChildren[i] = new PackageFreezer(((Package) p.childPackages.get(i)).packageName, userId, killReason);
                    }
                }
            }
            this.mCloseGuard.open("close");
        }

        protected void finalize() throws Throwable {
            try {
                if (this.mCloseGuard != null) {
                    this.mCloseGuard.warnIfOpen();
                }
                close();
            } finally {
                super.finalize();
            }
        }

        public void close() {
            int i = 0;
            this.mCloseGuard.close();
            if (this.mClosed.compareAndSet(false, true)) {
                synchronized (PackageManagerService.this.mPackages) {
                    if (this.mWeFroze) {
                        PackageManagerService.this.mFrozenPackages.remove(this.mPackageName);
                    }
                    if (this.mChildren != null) {
                        PackageFreezer[] packageFreezerArr = this.mChildren;
                        int length = packageFreezerArr.length;
                        while (i < length) {
                            packageFreezerArr[i].close();
                            i++;
                        }
                    }
                }
            }
        }
    }

    static class PackageInstalledInfo {
        ArrayMap<String, PackageInstalledInfo> addedChildPackages;
        String installerPackageName;
        String name;
        int[] newUsers;
        String origPackage;
        String origPermission;
        int[] origUsers;
        Package pkg;
        PackageRemovedInfo removedInfo;
        int returnCode;
        String returnMsg;
        int uid;

        PackageInstalledInfo() {
        }

        public void setError(int code, String msg) {
            setReturnCode(code);
            setReturnMessage(msg);
            Slog.w(PackageManagerService.TAG, msg);
        }

        public void setError(String msg, PackageParserException e) {
            setReturnCode(e.error);
            setReturnMessage(ExceptionUtils.getCompleteMessage(msg, e));
            int childCount = this.addedChildPackages != null ? this.addedChildPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                ((PackageInstalledInfo) this.addedChildPackages.valueAt(i)).setError(msg, e);
            }
            Slog.w(PackageManagerService.TAG, msg, e);
        }

        public void setError(String msg, PackageManagerException e) {
            this.returnCode = e.error;
            setReturnMessage(ExceptionUtils.getCompleteMessage(msg, e));
            int childCount = this.addedChildPackages != null ? this.addedChildPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                ((PackageInstalledInfo) this.addedChildPackages.valueAt(i)).setError(msg, e);
            }
            Slog.w(PackageManagerService.TAG, msg, e);
        }

        public void setReturnCode(int returnCode) {
            this.returnCode = returnCode;
            int childCount = this.addedChildPackages != null ? this.addedChildPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                ((PackageInstalledInfo) this.addedChildPackages.valueAt(i)).returnCode = returnCode;
            }
        }

        private void setReturnMessage(String returnMsg) {
            this.returnMsg = returnMsg;
            int childCount = this.addedChildPackages != null ? this.addedChildPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                ((PackageInstalledInfo) this.addedChildPackages.valueAt(i)).returnMsg = returnMsg;
            }
        }
    }

    private class PackageManagerInternalImpl extends PackageManagerInternal {
        /* synthetic */ PackageManagerInternalImpl(PackageManagerService this$0, PackageManagerInternalImpl -this1) {
            this();
        }

        private PackageManagerInternalImpl() {
        }

        public void setLocationPackagesProvider(PackagesProvider provider) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mDefaultPermissionPolicy.setLocationPackagesProviderLPw(provider);
            }
        }

        public void setVoiceInteractionPackagesProvider(PackagesProvider provider) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mDefaultPermissionPolicy.setVoiceInteractionPackagesProviderLPw(provider);
            }
        }

        public void setSmsAppPackagesProvider(PackagesProvider provider) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mDefaultPermissionPolicy.setSmsAppPackagesProviderLPw(provider);
            }
        }

        public void setDialerAppPackagesProvider(PackagesProvider provider) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mDefaultPermissionPolicy.setDialerAppPackagesProviderLPw(provider);
            }
        }

        public void setSimCallManagerPackagesProvider(PackagesProvider provider) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mDefaultPermissionPolicy.setSimCallManagerPackagesProviderLPw(provider);
            }
        }

        public void setSyncAdapterPackagesprovider(SyncAdapterPackagesProvider provider) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mDefaultPermissionPolicy.setSyncAdapterPackagesProviderLPw(provider);
            }
        }

        public void grantDefaultPermissionsToDefaultSmsApp(String packageName, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultSmsAppLPr(packageName, userId);
            }
        }

        public void grantDefaultPermissionsToDefaultDialerApp(String packageName, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mSettings.setDefaultDialerPackageNameLPw(packageName, userId);
                PackageManagerService.this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultDialerAppLPr(packageName, userId);
            }
        }

        public void grantDefaultPermissionsToDefaultSimCallManager(String packageName, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultSimCallManagerLPr(packageName, userId);
            }
        }

        /* JADX WARNING: inconsistent code. */
        /* Code decompiled incorrectly, please refer to instructions dump. */
        public void setKeepUninstalledPackages(List<String> packageList) {
            Throwable th;
            Preconditions.checkNotNull(packageList);
            List list = null;
            synchronized (PackageManagerService.this.mPackages) {
                int i;
                if (PackageManagerService.this.mKeepUninstalledPackages != null) {
                    int packagesCount = PackageManagerService.this.mKeepUninstalledPackages.size();
                    i = 0;
                    List<String> removedFromList = null;
                    while (i < packagesCount) {
                        List<String> removedFromList2;
                        try {
                            String oldPackage = (String) PackageManagerService.this.mKeepUninstalledPackages.get(i);
                            if (packageList == null || !packageList.contains(oldPackage)) {
                                if (removedFromList == null) {
                                    removedFromList2 = new ArrayList();
                                } else {
                                    removedFromList2 = removedFromList;
                                }
                                try {
                                    removedFromList2.add(oldPackage);
                                } catch (Throwable th2) {
                                    th = th2;
                                }
                            } else {
                                removedFromList2 = removedFromList;
                            }
                            i++;
                            removedFromList = removedFromList2;
                        } catch (Throwable th3) {
                            th = th3;
                            removedFromList2 = removedFromList;
                            throw th;
                        }
                    }
                    list = removedFromList;
                }
                PackageManagerService.this.mKeepUninstalledPackages = new ArrayList(packageList);
                if (list != null) {
                    int removedCount = list.size();
                    for (i = 0; i < removedCount; i++) {
                        PackageManagerService.this.deletePackageIfUnusedLPr((String) list.get(i));
                    }
                }
            }
        }

        public boolean isPermissionsReviewRequired(String packageName, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                if (PackageManagerService.this.mPermissionReviewRequired) {
                    PackageSetting packageSetting = (PackageSetting) PackageManagerService.this.mSettings.mPackages.get(packageName);
                    if (packageSetting == null) {
                        return false;
                    } else if (packageSetting.pkg.applicationInfo.targetSdkVersion >= 23) {
                        return false;
                    } else {
                        boolean isPermissionReviewRequired = packageSetting.getPermissionsState().isPermissionReviewRequired(userId);
                        return isPermissionReviewRequired;
                    }
                }
                return false;
            }
        }

        public PackageInfo getPackageInfo(String packageName, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getPackageInfoInternal(packageName, -1, flags, filterCallingUid, userId);
        }

        public ApplicationInfo getApplicationInfo(String packageName, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getApplicationInfoInternal(packageName, flags, filterCallingUid, userId);
        }

        public ActivityInfo getActivityInfo(ComponentName component, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getActivityInfoInternal(component, flags, filterCallingUid, userId);
        }

        public List<ResolveInfo> queryIntentActivities(Intent intent, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.queryIntentActivitiesInternal(intent, intent.resolveTypeIfNeeded(PackageManagerService.this.mContext.getContentResolver()), flags, filterCallingUid, userId, false, true);
        }

        public ComponentName getHomeActivitiesAsUser(List<ResolveInfo> allHomeCandidates, int userId) {
            return PackageManagerService.this.getHomeActivitiesAsUser(allHomeCandidates, userId);
        }

        public void setDeviceAndProfileOwnerPackages(int deviceOwnerUserId, String deviceOwnerPackage, SparseArray<String> profileOwnerPackages) {
            PackageManagerService.this.mProtectedPackages.setDeviceAndProfileOwnerPackages(deviceOwnerUserId, deviceOwnerPackage, profileOwnerPackages);
        }

        public boolean isPackageDataProtected(int userId, String packageName) {
            return PackageManagerService.this.mProtectedPackages.isPackageDataProtected(userId, packageName);
        }

        public boolean isPackageEphemeral(int userId, String packageName) {
            boolean instantApp;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = (PackageSetting) PackageManagerService.this.mSettings.mPackages.get(packageName);
                instantApp = ps != null ? ps.getInstantApp(userId) : false;
            }
            return instantApp;
        }

        public boolean wasPackageEverLaunched(String packageName, int userId) {
            boolean wasPackageEverLaunchedLPr;
            synchronized (PackageManagerService.this.mPackages) {
                wasPackageEverLaunchedLPr = PackageManagerService.this.mSettings.wasPackageEverLaunchedLPr(packageName, userId);
            }
            return wasPackageEverLaunchedLPr;
        }

        public void grantRuntimePermission(String packageName, String name, int userId, boolean overridePolicy) {
            PackageManagerService.this.grantRuntimePermission(packageName, name, userId, overridePolicy);
        }

        public void revokeRuntimePermission(String packageName, String name, int userId, boolean overridePolicy) {
            PackageManagerService.this.revokeRuntimePermission(packageName, name, userId, overridePolicy);
        }

        public String getNameForUid(int uid) {
            return PackageManagerService.this.getNameForUid(uid);
        }

        public void requestInstantAppResolutionPhaseTwo(AuxiliaryResolveInfo responseObj, Intent origIntent, String resolvedType, String callingPackage, Bundle verificationBundle, int userId) {
            PackageManagerService.this.requestInstantAppResolutionPhaseTwo(responseObj, origIntent, resolvedType, callingPackage, verificationBundle, userId);
        }

        public void grantEphemeralAccess(int userId, Intent intent, int targetAppId, int ephemeralAppId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mInstantAppRegistry.grantInstantAccessLPw(userId, intent, targetAppId, ephemeralAppId);
            }
        }

        public boolean isInstantAppInstallerComponent(ComponentName component) {
            boolean equals;
            synchronized (PackageManagerService.this.mPackages) {
                if (PackageManagerService.this.mInstantAppInstallerActivity != null) {
                    equals = PackageManagerService.this.mInstantAppInstallerActivity.getComponentName().equals(component);
                } else {
                    equals = false;
                }
            }
            return equals;
        }

        public void pruneInstantApps() {
            PackageManagerService.this.mInstantAppRegistry.pruneInstantApps();
        }

        public String getSetupWizardPackageName() {
            return PackageManagerService.this.mSetupWizardPackage;
        }

        public void setExternalSourcesPolicy(ExternalSourcesPolicy policy) {
            if (policy != null) {
                PackageManagerService.this.mExternalSourcesPolicy = policy;
            }
        }

        public boolean isPackagePersistent(String packageName) {
            boolean z = false;
            synchronized (PackageManagerService.this.mPackages) {
                Package pkg = (Package) PackageManagerService.this.mPackages.get(packageName);
                if (pkg != null && (pkg.applicationInfo.flags & 9) == 9) {
                    z = true;
                }
            }
            return z;
        }

        public List<PackageInfo> getOverlayPackages(int userId) {
            ArrayList<PackageInfo> overlayPackages = new ArrayList();
            synchronized (PackageManagerService.this.mPackages) {
                for (Package p : PackageManagerService.this.mPackages.values()) {
                    if (p.mOverlayTarget != null) {
                        PackageInfo pkg = PackageManagerService.this.generatePackageInfo((PackageSetting) p.mExtras, 0, userId);
                        if (pkg != null) {
                            overlayPackages.add(pkg);
                        }
                    }
                }
            }
            return overlayPackages;
        }

        public List<String> getTargetPackageNames(int userId) {
            List<String> targetPackages = new ArrayList();
            synchronized (PackageManagerService.this.mPackages) {
                for (Package p : PackageManagerService.this.mPackages.values()) {
                    if (p.mOverlayTarget == null) {
                        targetPackages.add(p.packageName);
                    }
                }
            }
            return targetPackages;
        }

        public boolean setEnabledOverlayPackages(int userId, String targetPackageName, List<String> overlayPackageNames) {
            synchronized (PackageManagerService.this.mPackages) {
                if (targetPackageName != null) {
                    if (PackageManagerService.this.mPackages.get(targetPackageName) != null) {
                        List overlayPaths = null;
                        if (overlayPackageNames != null) {
                            if (overlayPackageNames.size() > 0) {
                                int N = overlayPackageNames.size();
                                overlayPaths = new ArrayList(N);
                                for (int i = 0; i < N; i++) {
                                    String packageName = (String) overlayPackageNames.get(i);
                                    Package pkg = (Package) PackageManagerService.this.mPackages.get(packageName);
                                    if (pkg == null) {
                                        Slog.e(PackageManagerService.TAG, "failed to find package " + packageName);
                                        return false;
                                    }
                                    overlayPaths.add(pkg.baseCodePath);
                                }
                            }
                        }
                        ((PackageSetting) PackageManagerService.this.mSettings.mPackages.get(targetPackageName)).setOverlayPaths(overlayPaths, userId);
                        return true;
                    }
                }
                Slog.e(PackageManagerService.TAG, "failed to find package " + targetPackageName);
                return false;
            }
        }

        public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId) {
            return PackageManagerService.this.resolveIntentInternal(intent, resolvedType, flags, userId, true);
        }

        public ResolveInfo resolveService(Intent intent, String resolvedType, int flags, int userId, int callingUid) {
            return PackageManagerService.this.resolveServiceInternal(intent, resolvedType, flags, userId, callingUid);
        }

        public void addIsolatedUid(int isolatedUid, int ownerUid) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mIsolatedOwners.put(isolatedUid, ownerUid);
            }
        }

        public void removeIsolatedUid(int isolatedUid) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mIsolatedOwners.delete(isolatedUid);
            }
        }

        public int getUidTargetSdkVersion(int uid) {
            int -wrap19;
            synchronized (PackageManagerService.this.mPackages) {
                -wrap19 = PackageManagerService.this.getUidTargetSdkVersionLockedLPr(uid);
            }
            return -wrap19;
        }

        public boolean canAccessInstantApps(int callingUid, int userId) {
            return PackageManagerService.this.canViewInstantApps(callingUid, userId);
        }

        public boolean hasInstantApplicationMetadata(String packageName, int userId) {
            boolean hasInstantApplicationMetadataLPr;
            synchronized (PackageManagerService.this.mPackages) {
                hasInstantApplicationMetadataLPr = PackageManagerService.this.mInstantAppRegistry.hasInstantApplicationMetadataLPr(packageName, userId);
            }
            return hasInstantApplicationMetadataLPr;
        }

        public void notifyPackageUse(String packageName, int reason) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.notifyPackageUseLocked(packageName, reason);
            }
        }

        public boolean inCptWhiteList(int type, String verifyStr) {
            return PackageManagerService.mCompatibilityHelper.isInWhiteList(type, verifyStr);
        }

        public boolean inPmsWhiteList(int type, String verifyStr, List<String> defaultList) {
            return ColorPackageManagerHelper.inPmsWhiteList(type, verifyStr, defaultList);
        }
    }

    private class PackageManagerNative extends IPackageManagerNative.Stub {
        /* synthetic */ PackageManagerNative(PackageManagerService this$0, PackageManagerNative -this1) {
            this();
        }

        private PackageManagerNative() {
        }

        public String[] getNamesForUids(int[] uids) throws RemoteException {
            String[] results = PackageManagerService.this.getNamesForUids(uids);
            for (int i = results.length - 1; i >= 0; i--) {
                if (results[i] == null) {
                    results[i] = "";
                }
            }
            return results;
        }

        public String getInstallerForPackage(String packageName) throws RemoteException {
            String installerName = PackageManagerService.this.getInstallerPackageName(packageName);
            if (!TextUtils.isEmpty(installerName)) {
                return installerName;
            }
            ApplicationInfo appInfo = PackageManagerService.this.getApplicationInfo(packageName, 0, UserHandle.getUserId(Binder.getCallingUid()));
            if (appInfo == null || (appInfo.flags & 1) == 0) {
                return "";
            }
            return "preload";
        }

        public int getVersionCodeForPackage(String packageName) throws RemoteException {
            try {
                PackageInfo pInfo = PackageManagerService.this.getPackageInfo(packageName, 0, UserHandle.getUserId(Binder.getCallingUid()));
                if (pInfo != null) {
                    return pInfo.versionCode;
                }
            } catch (Exception e) {
            }
            return 0;
        }
    }

    static class PackageRemovedInfo {
        ArrayMap<String, PackageInstalledInfo> appearedChildPackages;
        InstallArgs args = null;
        int[] broadcastUsers = null;
        boolean dataRemoved;
        SparseArray<Integer> installReasons;
        String installerPackageName;
        boolean isRemovedPackageSystemUpdate = false;
        boolean isStaticSharedLib;
        boolean isUpdate;
        int[] origUsers;
        final PackageSender packageSender;
        int removedAppId = -1;
        ArrayMap<String, PackageRemovedInfo> removedChildPackages;
        boolean removedForAllUsers;
        String removedPackage;
        int[] removedUsers = null;
        int uid = -1;

        PackageRemovedInfo(PackageSender packageSender) {
            this.packageSender = packageSender;
        }

        void sendPackageRemovedBroadcasts(boolean killApp) {
            sendPackageRemovedBroadcastInternal(killApp);
            int childCount = this.removedChildPackages != null ? this.removedChildPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                ((PackageRemovedInfo) this.removedChildPackages.valueAt(i)).sendPackageRemovedBroadcastInternal(killApp);
            }
        }

        void sendSystemPackageUpdatedBroadcasts() {
            if (this.isRemovedPackageSystemUpdate) {
                sendSystemPackageUpdatedBroadcastsInternal();
                int childCount = this.removedChildPackages != null ? this.removedChildPackages.size() : 0;
                for (int i = 0; i < childCount; i++) {
                    PackageRemovedInfo childInfo = (PackageRemovedInfo) this.removedChildPackages.valueAt(i);
                    if (childInfo.isRemovedPackageSystemUpdate) {
                        childInfo.sendSystemPackageUpdatedBroadcastsInternal();
                    }
                }
            }
        }

        void sendSystemPackageAppearedBroadcasts() {
            int packageCount = this.appearedChildPackages != null ? this.appearedChildPackages.size() : 0;
            for (int i = 0; i < packageCount; i++) {
                PackageInstalledInfo installedInfo = (PackageInstalledInfo) this.appearedChildPackages.valueAt(i);
                this.packageSender.sendPackageAddedForNewUsers(installedInfo.name, true, false, UserHandle.getAppId(installedInfo.uid), installedInfo.newUsers);
            }
        }

        private void sendSystemPackageUpdatedBroadcastsInternal() {
            Bundle extras = new Bundle(2);
            extras.putInt("android.intent.extra.UID", this.removedAppId >= 0 ? this.removedAppId : this.uid);
            extras.putBoolean("android.intent.extra.REPLACING", true);
            this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", this.removedPackage, extras, 0, null, null, null);
            this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", this.removedPackage, extras, 0, null, null, null);
            this.packageSender.sendPackageBroadcast("android.intent.action.MY_PACKAGE_REPLACED", null, null, 0, this.removedPackage, null, null);
            if (this.installerPackageName != null) {
                this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", this.removedPackage, extras, 0, this.installerPackageName, null, null);
                this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", this.removedPackage, extras, 0, this.installerPackageName, null, null);
            }
        }

        private void sendPackageRemovedBroadcastInternal(boolean killApp) {
            if (!this.isStaticSharedLib) {
                Bundle extras = new Bundle(2);
                extras.putInt("android.intent.extra.UID", this.removedAppId >= 0 ? this.removedAppId : this.uid);
                extras.putBoolean("android.intent.extra.DATA_REMOVED", this.dataRemoved);
                extras.putBoolean("android.intent.extra.DONT_KILL_APP", killApp ^ 1);
                if (this.isUpdate || this.isRemovedPackageSystemUpdate) {
                    extras.putBoolean("android.intent.extra.REPLACING", true);
                }
                extras.putBoolean("android.intent.extra.REMOVED_FOR_ALL_USERS", this.removedForAllUsers);
                if (this.removedPackage != null) {
                    this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REMOVED", this.removedPackage, extras, 0, null, null, this.broadcastUsers);
                    if (this.installerPackageName != null) {
                        this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REMOVED", this.removedPackage, extras, 0, this.installerPackageName, null, this.broadcastUsers);
                    }
                    if (this.dataRemoved && (this.isRemovedPackageSystemUpdate ^ 1) != 0) {
                        this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_FULLY_REMOVED", this.removedPackage, extras, 16777216, null, null, this.broadcastUsers);
                    }
                }
                if (this.removedAppId >= 0) {
                    this.packageSender.sendPackageBroadcast("android.intent.action.UID_REMOVED", null, extras, 16777216, null, null, this.broadcastUsers);
                }
            }
        }

        void populateUsers(int[] userIds, PackageSetting deletedPackageSetting) {
            this.removedUsers = userIds;
            if (this.removedUsers == null) {
                this.broadcastUsers = null;
                return;
            }
            this.broadcastUsers = PackageManagerService.EMPTY_INT_ARRAY;
            for (int i = userIds.length - 1; i >= 0; i--) {
                int userId = userIds[i];
                if (!deletedPackageSetting.getInstantApp(userId)) {
                    this.broadcastUsers = ArrayUtils.appendInt(this.broadcastUsers, userId);
                }
            }
        }
    }

    static class PostInstallData {
        public InstallArgs args;
        public PackageInstalledInfo res;

        PostInstallData(InstallArgs _a, PackageInstalledInfo _r) {
            this.args = _a;
            this.res = _r;
        }
    }

    static class VerificationInfo {
        public static final int NO_UID = -1;
        final int installerUid;
        final int originatingUid;
        final Uri originatingUri;
        final Uri referrer;

        VerificationInfo(Uri originatingUri, Uri referrer, int originatingUid, int installerUid) {
            this.originatingUri = originatingUri;
            this.referrer = referrer;
            this.originatingUid = originatingUid;
            this.installerUid = installerUid;
        }
    }

    static {
        sBrowserIntent.setAction("android.intent.action.VIEW");
        sBrowserIntent.addCategory("android.intent.category.BROWSABLE");
        sBrowserIntent.setData(Uri.parse("http:"));
        PROTECTED_ACTIONS.add("android.intent.action.SEND");
        PROTECTED_ACTIONS.add("android.intent.action.SENDTO");
        PROTECTED_ACTIONS.add("android.intent.action.SEND_MULTIPLE");
        PROTECTED_ACTIONS.add("android.intent.action.VIEW");
    }

    private static boolean hasValidDomains(ActivityIntentInfo filter) {
        if (!filter.hasCategory("android.intent.category.BROWSABLE")) {
            return false;
        }
        if (filter.hasDataScheme("http")) {
            return true;
        }
        return filter.hasDataScheme("https");
    }

    private void handlePackagePostInstall(PackageInstalledInfo res, boolean grantPermissions, boolean killApp, boolean virtualPreload, String[] grantedPermissions, boolean launchedForRestore, String installerPackage, IPackageInstallObserver2 installObserver) {
        if (res.returnCode == 1) {
            String installerPackageName;
            if (res.removedInfo != null) {
                res.removedInfo.sendPackageRemovedBroadcasts(killApp);
            }
            if (grantPermissions) {
                grantRequestedRuntimePermissions(res.pkg, res.newUsers, grantedPermissions);
            }
            boolean update = res.removedInfo != null ? res.removedInfo.removedPackage != null : false;
            if (res.installerPackageName != null) {
                installerPackageName = res.installerPackageName;
            } else if (res.removedInfo != null) {
                installerPackageName = res.removedInfo.installerPackageName;
            } else {
                installerPackageName = null;
            }
            if (res.pkg.parentPackage != null) {
                synchronized (this.mPackages) {
                    grantRuntimePermissionsGrantedToDisabledPrivSysPackageParentLPw(res.pkg);
                }
            }
            synchronized (this.mPackages) {
                this.mInstantAppRegistry.onPackageInstalledLPw(res.pkg, res.newUsers);
            }
            String packageName = res.pkg.applicationInfo.packageName;
            int[] firstUsers = EMPTY_INT_ARRAY;
            int[] updateUsers = EMPTY_INT_ARRAY;
            boolean allNewUsers = res.origUsers == null || res.origUsers.length == 0;
            PackageSetting ps = res.pkg.mExtras;
            for (int newUser : res.newUsers) {
                if (!ps.getInstantApp(newUser)) {
                    if (allNewUsers) {
                        firstUsers = ArrayUtils.appendInt(firstUsers, newUser);
                    } else {
                        boolean isNew = true;
                        for (int i : res.origUsers) {
                            if (i == newUser) {
                                isNew = false;
                                break;
                            }
                        }
                        if (isNew) {
                            firstUsers = ArrayUtils.appendInt(firstUsers, newUser);
                        } else {
                            updateUsers = ArrayUtils.appendInt(updateUsers, newUser);
                        }
                    }
                }
            }
            if (res.pkg.staticSharedLibName == null) {
                this.mProcessLoggingHandler.invalidateProcessLoggingBaseApkHash(res.pkg.baseCodePath);
                sendPackageAddedForNewUsers(packageName, !res.pkg.applicationInfo.isSystemApp() ? virtualPreload : true, virtualPreload, UserHandle.getAppId(res.uid), firstUsers);
                Bundle extras = new Bundle(1);
                extras.putInt("android.intent.extra.UID", res.uid);
                if (update) {
                    extras.putBoolean("android.intent.extra.REPLACING", true);
                }
                sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName, extras, 0, null, null, updateUsers);
                if (!this.mIsCtsAppInstall && ColorPackageManagerHelper.isCtsPkgBySig(res.pkg)) {
                    Slog.i(TAG, "add full pkg : " + packageName);
                    this.mIsCtsAppInstall = true;
                }
                if (installerPackage != null) {
                    ColorPackageManagerHelper.sendDcsSilentInstallBroadcast(res.pkg.applicationInfo.packageName, extras, installerPackage, 0);
                }
                if (installerPackageName != null) {
                    sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName, extras, 0, installerPackageName, null, updateUsers);
                }
                if (update) {
                    sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", packageName, extras, 0, null, null, updateUsers);
                    if (installerPackageName != null) {
                        sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", packageName, extras, 0, installerPackageName, null, updateUsers);
                    }
                    sendPackageBroadcast("android.intent.action.MY_PACKAGE_REPLACED", null, null, 0, packageName, null, updateUsers);
                } else if (launchedForRestore && (isSystemApp(res.pkg) ^ 1) != 0) {
                    sendFirstLaunchBroadcast(packageName, installerPackage, firstUsers);
                }
                if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
                    if (DEBUG_INSTALL) {
                        Slog.i(TAG, "upgrading pkg " + res.pkg + " is ASEC-hosted -> AVAILABLE");
                    }
                    int[] uidArray = new int[]{res.pkg.applicationInfo.uid};
                    ArrayList arrayList = new ArrayList(1);
                    arrayList.add(packageName);
                    sendResourcesChangedBroadcast(true, true, arrayList, uidArray, null);
                }
            }
            if (firstUsers != null && firstUsers.length > 0) {
                synchronized (this.mPackages) {
                    for (int userId : firstUsers) {
                        if (packageIsBrowser(packageName, userId)) {
                            this.mSettings.setDefaultBrowserPackageNameLPw(null, userId);
                        }
                        this.mSettings.applyPendingPermissionGrantsLPw(packageName, userId);
                    }
                }
            }
            EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED, getUnknownSourcesSettings());
            if (res.removedInfo == null || res.removedInfo.args == null) {
                VMRuntime.getRuntime().requestConcurrentGC();
            } else {
                Runtime.getRuntime().gc();
                synchronized (this.mInstallLock) {
                    res.removedInfo.args.doPostDeleteLI(true);
                }
            }
            if (isStrictOpEnable()) {
                Intent intent = new Intent("android.intent.action.MANAGE_APP_PERMISSIONS");
                intent.putExtra("android.intent.extra.PACKAGE_NAME", packageName);
                intent.putExtra("hideInfoButton", true);
                intent.setFlags(268435456);
                this.mContext.startActivity(intent);
            }
            if (update && (isSystemApp(res.pkg) ^ 1) != 0) {
                ColorPackageManagerHelper.addPkgToNotLaunchedList(packageName);
            }
            for (int userId2 : firstUsers) {
                PackageInfo info = getPackageInfo(packageName, 0, userId2);
                if (info != null) {
                    this.mDexManager.notifyPackageInstalled(info, userId2);
                }
            }
        }
        if (installObserver != null) {
            try {
                installObserver.onPackageInstalled(res.name, res.returnCode, res.returnMsg, extrasForInstallResult(res));
            } catch (RemoteException e) {
                Slog.i(TAG, "Observer no longer exists.");
            }
        }
        OppoAdbInstallerManager.getInstance().handleForAdbSessionInstallerObserver(res.name, res.returnCode);
        if (res.returnCode != 1) {
            ColorPackageManagerHelper.sendOppoInstallFailBro(res.name, installerPackage, 0);
        }
    }

    private boolean isStrictOpEnable() {
        return SystemProperties.getBoolean("persist.vendor.strict_op_enable", false);
    }

    private void grantRuntimePermissionsGrantedToDisabledPrivSysPackageParentLPw(Package pkg) {
        if (pkg.parentPackage != null && pkg.requestedPermissions != null) {
            PackageSetting disabledSysParentPs = this.mSettings.getDisabledSystemPkgLPr(pkg.parentPackage.packageName);
            if (disabledSysParentPs != null && disabledSysParentPs.pkg != null && (disabledSysParentPs.isPrivileged() ^ 1) == 0 && (disabledSysParentPs.childPackageNames == null || (disabledSysParentPs.childPackageNames.isEmpty() ^ 1) == 0)) {
                int[] allUserIds = sUserManager.getUserIds();
                int permCount = pkg.requestedPermissions.size();
                for (int i = 0; i < permCount; i++) {
                    String permission = (String) pkg.requestedPermissions.get(i);
                    BasePermission bp = (BasePermission) this.mSettings.mPermissions.get(permission);
                    if (bp != null) {
                        if (((!bp.isRuntime() ? bp.isDevelopment() : 1) ^ 1) == 0) {
                            for (int userId : allUserIds) {
                                if (disabledSysParentPs.getPermissionsState().hasRuntimePermission(permission, userId)) {
                                    grantRuntimePermission(pkg.packageName, permission, userId);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    private void grantRequestedRuntimePermissions(Package pkg, int[] userIds, String[] grantedPermissions) {
        for (int userId : userIds) {
            grantRequestedRuntimePermissionsForUser(pkg, userId, grantedPermissions);
        }
    }

    private void grantRequestedRuntimePermissionsForUser(Package pkg, int userId, String[] grantedPermissions) {
        PackageSetting ps = pkg.mExtras;
        if (ps != null) {
            PermissionsState permissionsState = ps.getPermissionsState();
            boolean supportsRuntimePermissions = pkg.applicationInfo.targetSdkVersion >= 23;
            boolean instantApp = isInstantApp(pkg.packageName, userId);
            for (String permission : pkg.requestedPermissions) {
                BasePermission bp;
                synchronized (this.mPackages) {
                    bp = (BasePermission) this.mSettings.mPermissions.get(permission);
                }
                if (bp != null && ((bp.isRuntime() || bp.isDevelopment()) && ((!instantApp || bp.isInstant()) && ((supportsRuntimePermissions || (bp.isRuntimeOnly() ^ 1) != 0) && (grantedPermissions == null || ArrayUtils.contains(grantedPermissions, permission)))))) {
                    int flags = permissionsState.getPermissionFlags(permission, userId);
                    if (supportsRuntimePermissions) {
                        if ((flags & 20) == 0) {
                            grantRuntimePermission(pkg.packageName, permission, userId);
                        }
                    } else if (this.mPermissionReviewRequired && (flags & 64) != 0) {
                        updatePermissionFlags(permission, pkg.packageName, 64, 0, userId);
                    }
                }
            }
        }
    }

    Bundle extrasForInstallResult(PackageInstalledInfo res) {
        boolean z = false;
        Bundle extras;
        switch (res.returnCode) {
            case -112:
                extras = new Bundle();
                extras.putString("android.content.pm.extra.FAILURE_EXISTING_PERMISSION", res.origPermission);
                extras.putString("android.content.pm.extra.FAILURE_EXISTING_PACKAGE", res.origPackage);
                return extras;
            case 1:
                extras = new Bundle();
                String str = "android.intent.extra.REPLACING";
                if (!(res.removedInfo == null || res.removedInfo.removedPackage == null)) {
                    z = true;
                }
                extras.putBoolean(str, z);
                return extras;
            default:
                return null;
        }
    }

    void scheduleWriteSettingsLocked() {
        if (!this.mHandler.hasMessages(13)) {
            this.mHandler.sendEmptyMessageDelayed(13, 10000);
        }
    }

    void scheduleWritePackageListLocked(int userId) {
        if (!this.mHandler.hasMessages(19)) {
            Message msg = this.mHandler.obtainMessage(19);
            msg.arg1 = userId;
            this.mHandler.sendMessageDelayed(msg, 10000);
        }
    }

    void scheduleWritePackageRestrictionsLocked(UserHandle user) {
        scheduleWritePackageRestrictionsLocked(user == null ? -1 : user.getIdentifier());
    }

    void scheduleWritePackageRestrictionsLocked(int userId) {
        int i = 0;
        int[] userIds = userId == -1 ? sUserManager.getUserIds() : new int[]{userId};
        int length = userIds.length;
        while (i < length) {
            int nextUserId = userIds[i];
            if (sUserManager.exists(nextUserId)) {
                this.mDirtyUsers.add(Integer.valueOf(nextUserId));
                if (!this.mHandler.hasMessages(14)) {
                    this.mHandler.sendEmptyMessageDelayed(14, 10000);
                }
                i++;
            } else {
                return;
            }
        }
    }

    void immediatelyWritePackageRestrictionsLocked(int userId) {
        if (sUserManager.exists(userId)) {
            this.mDirtyUsers.add(Integer.valueOf(userId));
            if (this.mHandler.hasMessages(14)) {
                this.mHandler.removeMessages(14);
            }
            this.mHandler.sendEmptyMessage(14);
        }
    }

    public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) {
        PackageManagerServiceCompilerMapping.checkProperties();
        PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore);
        m.enableSystemUserPackages();
        ServiceManager.addService(PACKAGE_SCHEME, m);
        m.getClass();
        ServiceManager.addService("package_native", new PackageManagerNative(m, null));
        return m;
    }

    private void enableSystemUserPackages() {
        if (UserManager.isSplitSystemUser()) {
            AppsQueryHelper queryHelper = new AppsQueryHelper(this);
            Set<String> enableApps = new ArraySet();
            enableApps.addAll(queryHelper.queryApps((AppsQueryHelper.GET_NON_LAUNCHABLE_APPS | AppsQueryHelper.GET_APPS_WITH_INTERACT_ACROSS_USERS_PERM) | AppsQueryHelper.GET_IMES, true, UserHandle.SYSTEM));
            enableApps.addAll(SystemConfig.getInstance().getSystemUserWhitelistedApps());
            enableApps.addAll(queryHelper.queryApps(AppsQueryHelper.GET_REQUIRED_FOR_SYSTEM_USER, false, UserHandle.SYSTEM));
            enableApps.removeAll(SystemConfig.getInstance().getSystemUserBlacklistedApps());
            Log.i(TAG, "Applications installed for system user: " + enableApps);
            List<String> allAps = queryHelper.queryApps(0, false, UserHandle.SYSTEM);
            int allAppsSize = allAps.size();
            synchronized (this.mPackages) {
                for (int i = 0; i < allAppsSize; i++) {
                    String pName = (String) allAps.get(i);
                    PackageSetting pkgSetting = (PackageSetting) this.mSettings.mPackages.get(pName);
                    if (pkgSetting != null) {
                        boolean install = enableApps.contains(pName);
                        if (pkgSetting.getInstalled(0) != install) {
                            Log.i(TAG, (install ? "Installing " : "Uninstalling ") + pName + " for system user");
                            pkgSetting.setInstalled(install, 0);
                        } else {
                            continue;
                        }
                    }
                }
                scheduleWritePackageRestrictionsLocked(0);
            }
        }
    }

    private static void getDefaultDisplayMetrics(Context context, DisplayMetrics metrics) {
        ((DisplayManager) context.getSystemService("display")).getDisplay(0).getMetrics(metrics);
    }

    private static void requestCopyPreoptedFiles() {
        String CP_PREOPT_PROPERTY = "sys.cppreopt";
        if (SystemProperties.getInt("ro.cp_system_other_odex", 0) == 1) {
            SystemProperties.set("sys.cppreopt", "requested");
            long timeStart = SystemClock.uptimeMillis();
            long timeEnd = timeStart + 100000;
            long timeNow = timeStart;
            while (!SystemProperties.get("sys.cppreopt").equals("finished")) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                }
                timeNow = SystemClock.uptimeMillis();
                if (timeNow > timeEnd) {
                    SystemProperties.set("sys.cppreopt", "timed-out");
                    Slog.wtf(TAG, "cppreopt did not finish!");
                    break;
                }
            }
            Slog.i(TAG, "cppreopts took " + (timeNow - timeStart) + " ms");
        }
    }

    public PackageManagerService(android.content.Context r102, com.android.server.pm.Installer r103, boolean r104, boolean r105) {
        /* JADX: method processing error */
/*
Error: jadx.core.utils.exceptions.JadxRuntimeException: Unknown predecessor block by arg (r30_2 'bp' com.android.server.pm.BasePermission) in PHI: PHI: (r30_3 'bp' com.android.server.pm.BasePermission) = (r30_1 'bp' com.android.server.pm.BasePermission), (r30_2 'bp' com.android.server.pm.BasePermission) binds: {(r30_1 'bp' com.android.server.pm.BasePermission)=B:53:0x0637, (r30_2 'bp' com.android.server.pm.BasePermission)=B:54:0x0639}
	at jadx.core.dex.instructions.PhiInsn.replaceArg(PhiInsn.java:78)
	at jadx.core.dex.visitors.ModVisitor.processInvoke(ModVisitor.java:222)
	at jadx.core.dex.visitors.ModVisitor.replaceStep(ModVisitor.java:83)
	at jadx.core.dex.visitors.ModVisitor.visit(ModVisitor.java:68)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:27)
	at jadx.core.dex.visitors.DepthTraversal.lambda$visit$1(DepthTraversal.java:14)
	at java.util.ArrayList.forEach(ArrayList.java:1251)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:14)
	at jadx.core.ProcessClass.process(ProcessClass.java:32)
	at jadx.core.ProcessClass.lambda$processDependencies$0(ProcessClass.java:51)
	at java.lang.Iterable.forEach(Iterable.java:75)
	at jadx.core.ProcessClass.processDependencies(ProcessClass.java:51)
	at jadx.core.ProcessClass.process(ProcessClass.java:37)
	at jadx.api.JadxDecompiler.processClass(JadxDecompiler.java:286)
	at jadx.api.JavaClass.decompile(JavaClass.java:62)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
*/
        /*
        r101 = this;
        r101.<init>();
        r4 = android.os.Build.VERSION.SDK_INT;
        r0 = r101;
        r0.mSdkVersion = r4;
        r4 = 0;
        r0 = r101;
        r0.mDefaultContainerWhitelisted = r4;
        r4 = "oppo";
        r0 = r101;
        r0.mDeviceType = r4;
        r4 = new java.util.ArrayList;
        r4.<init>();
        r0 = r101;
        r0.mDataAppArrayList = r4;
        r4 = new java.util.ArrayList;
        r4.<init>();
        r0 = r101;
        r0.mSystemAppArrayList = r4;
        r4 = new java.util.ArrayList;
        r4.<init>();
        r0 = r101;
        r0.mAppChannelArrayList = r4;
        r4 = new java.lang.Object;
        r4.<init>();
        r0 = r101;
        r0.mInstallLock = r4;
        r4 = new android.util.ArrayMap;
        r4.<init>();
        r0 = r101;
        r0.mPackages = r4;
        r4 = new android.util.ArrayMap;
        r4.<init>();
        r0 = r101;
        r0.mKnownCodebase = r4;
        r4 = new android.util.SparseIntArray;
        r4.<init>();
        r0 = r101;
        r0.mIsolatedOwners = r4;
        r4 = new android.util.ArrayMap;
        r4.<init>();
        r0 = r101;
        r0.mExpectingBetter = r4;
        r4 = new java.util.ArrayList;
        r4.<init>();
        r0 = r101;
        r0.mProtectedFilters = r4;
        r4 = 1;
        r0 = r101;
        r0.mDeferProtectedFilters = r4;
        r4 = new android.util.ArraySet;
        r4.<init>();
        r0 = r101;
        r0.mExistingSystemPackages = r4;
        r4 = new android.util.ArraySet;
        r4.<init>();
        r0 = r101;
        r0.mFrozenPackages = r4;
        r4 = new android.util.ArraySet;
        r4.<init>();
        r0 = r101;
        r0.mLoadedVolumes = r4;
        r4 = 0;
        r0 = r101;
        r0.mOppoAvailableFeatures = r4;
        r4 = 0;
        r0 = r101;
        r0.mIsCtsAppInstall = r4;
        r4 = 0;
        r0 = r101;
        r0.mLowRamFeature = r4;
        r4 = new android.util.SparseArray;
        r4.<init>();
        r0 = r101;
        r0.mChangedPackages = r4;
        r4 = new android.util.SparseArray;
        r4.<init>();
        r0 = r101;
        r0.mChangedPackagesSequenceNumbers = r4;
        r4 = 0;
        r0 = r101;
        r0.mOppoScimProtection = r4;
        r4 = 0;
        r0 = r101;
        r0.mBlackAppInstallHelper = r4;
        r4 = new com.android.server.pm.PackageManagerService$PackageParserCallback;
        r0 = r101;
        r4.<init>();
        r0 = r101;
        r0.mPackageParserCallback = r4;
        r4 = new com.android.server.pm.PackageManagerService$ParallelPackageParserCallback;
        r0 = r101;
        r4.<init>();
        r0 = r101;
        r0.mParallelPackageParserCallback = r4;
        r4 = new android.util.ArrayMap;
        r4.<init>();
        r0 = r101;
        r0.mSharedLibraries = r4;
        r4 = new android.util.ArrayMap;
        r4.<init>();
        r0 = r101;
        r0.mStaticLibsByDeclaringPackage = r4;
        r4 = new java.util.ArrayList;
        r4.<init>();
        r0 = r101;
        r0.mOppoPackageInstallerList = r4;
        r4 = new com.android.server.pm.PackageManagerService$ActivityIntentResolver;
        r0 = r101;
        r4.<init>();
        r0 = r101;
        r0.mActivities = r4;
        r4 = new com.android.server.pm.PackageManagerService$ActivityIntentResolver;
        r0 = r101;
        r4.<init>();
        r0 = r101;
        r0.mReceivers = r4;
        r4 = new com.android.server.pm.PackageManagerService$ServiceIntentResolver;
        r6 = 0;
        r0 = r101;
        r4.<init>(r0, r6);
        r0 = r101;
        r0.mServices = r4;
        r4 = new com.android.server.pm.PackageManagerService$ProviderIntentResolver;
        r6 = 0;
        r0 = r101;
        r4.<init>(r0, r6);
        r0 = r101;
        r0.mProviders = r4;
        r4 = new android.util.ArrayMap;
        r4.<init>();
        r0 = r101;
        r0.mProvidersByAuthority = r4;
        r4 = new android.util.ArrayMap;
        r4.<init>();
        r0 = r101;
        r0.mInstrumentation = r4;
        r4 = new android.util.ArrayMap;
        r4.<init>();
        r0 = r101;
        r0.mPermissionGroups = r4;
        r4 = new android.util.ArraySet;
        r4.<init>();
        r0 = r101;
        r0.mTransferedPackages = r4;
        r4 = new android.util.ArraySet;
        r4.<init>();
        r0 = r101;
        r0.mProtectedBroadcasts = r4;
        r4 = new android.util.SparseArray;
        r4.<init>();
        r0 = r101;
        r0.mPendingVerification = r4;
        r4 = new android.util.ArrayMap;
        r4.<init>();
        r0 = r101;
        r0.mAppOpPermissionPackages = r4;
        r4 = new java.util.concurrent.atomic.AtomicInteger;
        r4.<init>();
        r0 = r101;
        r0.mNextMoveId = r4;
        r4 = new android.util.SparseBooleanArray;
        r4.<init>();
        r0 = r101;
        r0.mUserNeedsBadging = r4;
        r4 = 0;
        r0 = r101;
        r0.mPendingVerificationToken = r4;
        r4 = new android.content.pm.ActivityInfo;
        r4.<init>();
        r0 = r101;
        r0.mResolveActivity = r4;
        r4 = new android.content.pm.ResolveInfo;
        r4.<init>();
        r0 = r101;
        r0.mResolveInfo = r4;
        r4 = 0;
        r0 = r101;
        r0.mResolverReplaced = r4;
        r4 = 0;
        r0 = r101;
        r0.mIntentFilterVerificationToken = r4;
        r4 = new android.content.pm.ResolveInfo;
        r4.<init>();
        r0 = r101;
        r0.mInstantAppInstallerInfo = r4;
        r4 = new android.util.SparseArray;
        r4.<init>();
        r0 = r101;
        r0.mIntentFilterVerificationStates = r4;
        r4 = "/system/etc/oppo_customize_whitelist.xml";
        r0 = r101;
        r0.CUSTOMIZE_LIST_PATH = r4;
        r4 = new java.util.ArrayList;
        r4.<init>();
        r0 = r101;
        r0.mCustomizeList = r4;
        r4 = "/system/etc/customize_system_app_blacklist.xml";
        r0 = r101;
        r0.CUSTOMIZE_SYSTEM_APP_BLACKLIST_PATH = r4;
        r4 = new java.util.ArrayList;
        r4.<init>();
        r0 = r101;
        r0.mCustomizeSystemAppBlacklist = r4;
        r4 = 0;
        r0 = r101;
        r0.mOppoAppScaleHelper = r4;
        r4 = 0;
        r0 = r101;
        r0.mOppoDPSHelper = r4;
        r4 = new android.util.ArrayMap;
        r4.<init>();
        r0 = r101;
        r0.mRunningInstallerPkgName = r4;
        r4 = new com.android.server.pm.PackageManagerService$PendingPackageBroadcasts;
        r4.<init>();
        r0 = r101;
        r0.mPendingBroadcasts = r4;
        r4 = 0;
        r0 = r101;
        r0.mContainerService = r4;
        r4 = new android.util.ArraySet;
        r4.<init>();
        r0 = r101;
        r0.mDirtyUsers = r4;
        r4 = new com.android.server.pm.PackageManagerService$DefaultContainerConnection;
        r0 = r101;
        r4.<init>();
        r0 = r101;
        r0.mDefContainerConn = r4;
        r4 = new android.util.SparseArray;
        r4.<init>();
        r0 = r101;
        r0.mRunningInstalls = r4;
        r4 = 1;
        r0 = r101;
        r0.mNextInstallToken = r4;
        r4 = new com.android.server.pm.PackageUsage;
        r4.<init>();
        r0 = r101;
        r0.mPackageUsage = r4;
        r4 = new com.android.server.pm.CompilerStats;
        r4.<init>();
        r0 = r101;
        r0.mCompilerStats = r4;
        r4 = new com.android.server.pm.PackageManagerService$1;
        r0 = r101;
        r4.<init>();
        r0 = r101;
        r0.mStorageListener = r4;
        r4 = new com.android.server.pm.PackageManagerService$2;
        r0 = r101;
        r4.<init>();
        r0 = r101;
        r0.mClearSystemApp = r4;
        r4 = new com.android.server.pm.PackageManagerService$6;
        r0 = r101;
        r4.<init>();
        r0 = r101;
        r0.mSkinChangedReceiver = r4;
        r4 = 0;
        r0 = r101;
        r0.mThemeIconsChanged = r4;
        r4 = new com.android.server.pm.PackageManagerService$7;
        r6 = "/data/theme/icons";
        r8 = 1546; // 0x60a float:2.166E-42 double:7.64E-321;
        r0 = r101;
        r4.<init>(r6, r8);
        r0 = r101;
        r0.mThemeIconsFileObserver = r4;
        r4 = 0;
        r0 = r101;
        r0.mMediaMounted = r4;
        r4 = new com.android.server.pm.PackageManagerService$8;
        r0 = r101;
        r4.<init>();
        r0 = r101;
        r0.mReadSystemDefaultApp = r4;
        r4 = new java.util.HashMap;
        r4.<init>();
        r0 = r101;
        r0.mPackageDeleteList = r4;
        r4 = 3;
        r4 = new java.lang.String[r4];
        r6 = "com.android.vending";
        r8 = 0;
        r4[r8] = r6;
        r6 = "com.coloros.backuprestore";
        r8 = 1;
        r4[r8] = r6;
        r6 = "com.google.android.packageinstaller";
        r8 = 2;
        r4[r8] = r6;
        r0 = r101;
        r0.mPackageInstaller = r4;
        r0 = r101;
        r4 = r0.mPackages;
        r6 = 3;
        com.android.server.LockGuard.installLock(r4, r6);
        r4 = "create package manager";
        r22 = 262144; // 0x40000 float:3.67342E-40 double:1.295163E-318;
        r0 = r22;
        android.os.Trace.traceBegin(r0, r4);
        r22 = android.os.SystemClock.uptimeMillis();
        r4 = 3060; // 0xbf4 float:4.288E-42 double:1.512E-320;
        r0 = r22;
        android.util.EventLog.writeEvent(r4, r0);
        r38 = com.android.server.pm.ColorPackageManagerHelper.getAvaiDataSize();
        r4 = 16;
        r0 = r38;
        if (r0 >= r4) goto L_0x02be;
    L_0x0299:
        r4 = "PackageManager";
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r8 = "data avaible size is : ";
        r6 = r6.append(r8);
        r0 = r38;
        r6 = r6.append(r0);
        r6 = r6.toString();
        android.util.Slog.w(r4, r6);
        r4 = "oppo.service.datafree.enable";
        r6 = "1";
        android.os.SystemProperties.set(r4, r6);
    L_0x02be:
        com.android.server.pm.OppoPackageManagerHelper.parsePackageXml();
        r4 = com.android.server.pm.ColorPackageManagerHelper.readEncryptFiles();
        if (r4 == 0) goto L_0x02d3;
    L_0x02c7:
        r4 = "PackageManager";
        r6 = "fatal error:read encrypt file fail, try again";
        android.util.Slog.w(r4, r6);
        com.android.server.pm.ColorPackageManagerHelper.readEncryptFiles();
    L_0x02d3:
        r64 = "oppo.service.odexmove.enable";
        r60 = r101.isBootFromOTA();
        if (r60 == 0) goto L_0x031c;
    L_0x02dc:
        r4 = "1";
        r0 = r64;
        android.os.SystemProperties.set(r0, r4);
        r34 = 0;
    L_0x02e6:
        r4 = "0";
        r0 = r64;
        r4 = android.os.SystemProperties.get(r0, r4);
        r6 = "1";
        r4 = r4.equals(r6);
        if (r4 == 0) goto L_0x0314;
    L_0x02f8:
        r4 = 10;
        r0 = r34;
        if (r0 > r4) goto L_0x0314;
    L_0x02fe:
        r22 = 500; // 0x1f4 float:7.0E-43 double:2.47E-321;
        java.lang.Thread.sleep(r22);	 Catch:{ InterruptedException -> 0x030f }
        r4 = "PackageManager";	 Catch:{ InterruptedException -> 0x030f }
        r6 = "wait for odex move ok!";	 Catch:{ InterruptedException -> 0x030f }
        android.util.Slog.w(r4, r6);	 Catch:{ InterruptedException -> 0x030f }
        r34 = r34 + 1;
        goto L_0x02e6;
    L_0x030f:
        r51 = move-exception;
        r51.printStackTrace();
        goto L_0x02e6;
    L_0x0314:
        r4 = "0";
        r0 = r64;
        android.os.SystemProperties.set(r0, r4);
    L_0x031c:
        r0 = r101;
        r4 = r0.mSdkVersion;
        if (r4 > 0) goto L_0x032b;
    L_0x0322:
        r4 = "PackageManager";
        r6 = "**** ro.build.version.sdk not set!";
        android.util.Slog.w(r4, r6);
    L_0x032b:
        com.android.server.pm.ColorPackageManagerHelper.initRuntimeFilterInfos();
        com.android.server.pm.ColorPackageManagerHelper.initCtsToolList();
        com.android.server.pm.ColorPackageManagerHelper.initNotLaunchedList();
        r0 = r102;
        r1 = r101;
        r1.mContext = r0;
        r4 = r102.getResources();
        r6 = 17956992; // 0x1120080 float:2.6816324E-38 double:8.871933E-317;
        r4 = r4.getBoolean(r6);
        r0 = r101;
        r0.mPermissionReviewRequired = r4;
        r0 = r104;
        r1 = r101;
        r1.mFactoryTest = r0;
        r0 = r105;
        r1 = r101;
        r1.mOnlyCore = r0;
        r4 = new android.util.DisplayMetrics;
        r4.<init>();
        r0 = r101;
        r0.mMetrics = r4;
        r4 = new com.android.server.pm.Settings;
        r0 = r101;
        r6 = r0.mPackages;
        r4.<init>(r6);
        r0 = r101;
        r0.mSettings = r4;
        r0 = r101;
        r4 = r0.mSettings;
        r6 = "android.uid.system";
        r8 = 1000; // 0x3e8 float:1.401E-42 double:4.94E-321;
        r10 = 1;
        r12 = 8;
        r4.addSharedUserLPw(r6, r8, r10, r12);
        r0 = r101;
        r4 = r0.mSettings;
        r6 = "android.uid.phone";
        r8 = 1001; // 0x3e9 float:1.403E-42 double:4.946E-321;
        r10 = 1;
        r12 = 8;
        r4.addSharedUserLPw(r6, r8, r10, r12);
        r0 = r101;
        r4 = r0.mSettings;
        r6 = "android.uid.log";
        r8 = 1007; // 0x3ef float:1.411E-42 double:4.975E-321;
        r10 = 1;
        r12 = 8;
        r4.addSharedUserLPw(r6, r8, r10, r12);
        r0 = r101;
        r4 = r0.mSettings;
        r6 = "android.uid.nfc";
        r8 = 1027; // 0x403 float:1.439E-42 double:5.074E-321;
        r10 = 1;
        r12 = 8;
        r4.addSharedUserLPw(r6, r8, r10, r12);
        r0 = r101;
        r4 = r0.mSettings;
        r6 = "android.uid.bluetooth";
        r8 = 1002; // 0x3ea float:1.404E-42 double:4.95E-321;
        r10 = 1;
        r12 = 8;
        r4.addSharedUserLPw(r6, r8, r10, r12);
        r0 = r101;
        r4 = r0.mSettings;
        r6 = "android.uid.shell";
        r8 = 2000; // 0x7d0 float:2.803E-42 double:9.88E-321;
        r10 = 1;
        r12 = 8;
        r4.addSharedUserLPw(r6, r8, r10, r12);
        r4 = "debug.separate_processes";
        r82 = android.os.SystemProperties.get(r4);
        if (r82 == 0) goto L_0x069d;
    L_0x03ce:
        r4 = r82.length();
        if (r4 <= 0) goto L_0x069d;
    L_0x03d4:
        r4 = "*";
        r0 = r82;
        r4 = r4.equals(r0);
        if (r4 == 0) goto L_0x066d;
    L_0x03df:
        r4 = 8;
        r0 = r101;
        r0.mDefParseFlags = r4;
        r4 = 0;
        r0 = r101;
        r0.mSeparateProcesses = r4;
        r4 = "PackageManager";
        r6 = "Running with debug.separate_processes: * (ALL)";
        android.util.Slog.w(r4, r6);
    L_0x03f3:
        r0 = r103;
        r1 = r101;
        r1.mInstaller = r0;
        r4 = new com.android.server.pm.PackageDexOptimizer;
        r0 = r101;
        r6 = r0.mInstallLock;
        r8 = "*dexopt*";
        r0 = r103;
        r1 = r102;
        r4.<init>(r0, r6, r1, r8);
        r0 = r101;
        r0.mPackageDexOptimizer = r4;
        r4 = new com.android.server.pm.dex.DexManager;
        r0 = r101;
        r6 = r0.mPackageDexOptimizer;
        r0 = r101;
        r8 = r0.mInstallLock;
        r0 = r101;
        r1 = r103;
        r4.<init>(r0, r6, r1, r8);
        r0 = r101;
        r0.mDexManager = r4;
        r4 = new com.android.server.pm.PackageManagerService$MoveCallbacks;
        r6 = com.android.server.FgThread.get();
        r6 = r6.getLooper();
        r4.<init>(r6);
        r0 = r101;
        r0.mMoveCallbacks = r4;
        r4 = new com.android.server.pm.PackageManagerService$OnPermissionChangeListeners;
        r6 = com.android.server.FgThread.get();
        r6 = r6.getLooper();
        r4.<init>(r6);
        r0 = r101;
        r0.mOnPermissionChangeListeners = r4;
        r0 = r101;
        r4 = r0.mMetrics;
        r0 = r102;
        getDefaultDisplayMetrics(r0, r4);
        r4 = "get system config";
        r22 = 262144; // 0x40000 float:3.67342E-40 double:1.295163E-318;
        r0 = r22;
        android.os.Trace.traceBegin(r0, r4);
        r88 = com.android.server.SystemConfig.getInstance();
        r4 = r88.getGlobalGids();
        r0 = r101;
        r0.mGlobalGids = r4;
        r4 = r88.getSystemPermissions();
        r0 = r101;
        r0.mSystemPermissions = r4;
        r4 = r88.getAvailableFeatures();
        r0 = r101;
        r0.mAvailableFeatures = r4;
        r22 = 262144; // 0x40000 float:3.67342E-40 double:1.295163E-318;
        android.os.Trace.traceEnd(r22);
        r4 = "persist.sys.oppo.region";
        r79 = android.os.SystemProperties.get(r4);
        if (r79 == 0) goto L_0x04bf;
    L_0x0483:
        r4 = r79.length();
        if (r4 <= 0) goto L_0x04bf;
    L_0x0489:
        r4 = "PackageManager";
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r8 = "load region";
        r6 = r6.append(r8);
        r0 = r79;
        r6 = r6.append(r0);
        r8 = "features!";
        r6 = r6.append(r8);
        r6 = r6.toString();
        android.util.Slog.w(r4, r6);
        r0 = r101;
        r1 = r79;
        r4 = r0.loadRegionFeature(r1);
        if (r4 != 0) goto L_0x04bf;
    L_0x04b6:
        r4 = "PackageManager";
        r6 = "load region feature failed!";
        android.util.Slog.w(r4, r6);
    L_0x04bf:
        r4 = "oppo.exp.default.browser";
        r6 = 0;
        r0 = r101;
        r57 = r0.hasSystemFeature(r4, r6);
        r4 = EXP_VERSION;
        if (r4 == 0) goto L_0x04ea;
    L_0x04cd:
        if (r57 == 0) goto L_0x04ea;
    L_0x04cf:
        r4 = "ro.oppo.region.netlock";
        r6 = "";
        r78 = android.os.SystemProperties.get(r4, r6);
        r4 = "IN";
        r0 = r78;
        r4 = r4.equals(r0);
        if (r4 == 0) goto L_0x06a9;
    L_0x04e4:
        r4 = "com.android.browser";
        com.android.server.pm.ColorPackageManagerHelper.initDefaultPackageList(r4);
    L_0x04ea:
        r4 = new com.android.server.pm.ProtectedPackages;
        r0 = r101;
        r6 = r0.mContext;
        r4.<init>(r6);
        r0 = r101;
        r0.mProtectedPackages = r4;
        r4 = new com.android.server.pm.CompatibilityHelper;
        r0 = r102;
        r4.<init>(r0);
        mCompatibilityHelper = r4;
        r4 = "/system/etc/oppo_customize_whitelist.xml";
        r0 = r101;
        r4 = r0.loadCustomizeWhiteList(r4);
        r0 = r101;
        r0.mCustomizeList = r4;
        r4 = "/system/etc/customize_system_app_blacklist.xml";
        r0 = r101;
        r4 = r0.loadCustomizeWhiteList(r4);
        r0 = r101;
        r0.mCustomizeSystemAppBlacklist = r4;
        r0 = r101;
        r4 = r0.mSettings;
        r4.loadAllCustomizeList();
        r4 = new com.android.internal.app.OppoAppScaleHelper;
        r0 = r102;
        r4.<init>(r0);
        r0 = r101;
        r0.mOppoAppScaleHelper = r4;
        r4 = new com.android.server.display.OppoDPSHelper;
        r0 = r102;
        r4.<init>(r0);
        r0 = r101;
        r0.mOppoDPSHelper = r4;
        r0 = r101;
        r0 = r0.mInstallLock;
        r99 = r0;
        monitor-enter(r99);
        r0 = r101;	 Catch:{ all -> 0x07d6 }
        r0 = r0.mPackages;	 Catch:{ all -> 0x07d6 }
        r100 = r0;	 Catch:{ all -> 0x07d6 }
        monitor-enter(r100);	 Catch:{ all -> 0x07d6 }
        r4 = new com.android.server.ServiceThread;	 Catch:{ all -> 0x07d3 }
        r6 = "PackageManager";	 Catch:{ all -> 0x07d3 }
        r8 = 10;	 Catch:{ all -> 0x07d3 }
        r10 = 1;	 Catch:{ all -> 0x07d3 }
        r4.<init>(r6, r8, r10);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mHandlerThread = r4;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mHandlerThread;	 Catch:{ all -> 0x07d3 }
        r4.start();	 Catch:{ all -> 0x07d3 }
        r4 = new com.android.server.pm.PackageManagerService$PackageHandler;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r6 = r0.mHandlerThread;	 Catch:{ all -> 0x07d3 }
        r6 = r6.getLooper();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4.<init>(r6);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mHandler = r4;	 Catch:{ all -> 0x07d3 }
        r4 = new com.android.server.pm.ProcessLoggingHandler;	 Catch:{ all -> 0x07d3 }
        r4.<init>();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mProcessLoggingHandler = r4;	 Catch:{ all -> 0x07d3 }
        r4 = com.android.server.Watchdog.getInstance();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r6 = r0.mHandler;	 Catch:{ all -> 0x07d3 }
        r22 = 600000; // 0x927c0 float:8.40779E-40 double:2.964394E-318;	 Catch:{ all -> 0x07d3 }
        r0 = r22;	 Catch:{ all -> 0x07d3 }
        r4.addThread(r6, r0);	 Catch:{ all -> 0x07d3 }
        r4 = new com.android.server.pm.DefaultPermissionGrantPolicy;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4.<init>(r0);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mDefaultPermissionPolicy = r4;	 Catch:{ all -> 0x07d3 }
        r4 = new com.android.server.pm.InstantAppRegistry;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4.<init>(r0);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mInstantAppRegistry = r4;	 Catch:{ all -> 0x07d3 }
        r37 = android.os.Environment.getDataDirectory();	 Catch:{ all -> 0x07d3 }
        r4 = new java.io.File;	 Catch:{ all -> 0x07d3 }
        r6 = "app";	 Catch:{ all -> 0x07d3 }
        r0 = r37;	 Catch:{ all -> 0x07d3 }
        r4.<init>(r0, r6);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mAppInstallDir = r4;	 Catch:{ all -> 0x07d3 }
        r4 = new java.io.File;	 Catch:{ all -> 0x07d3 }
        r6 = "app-lib";	 Catch:{ all -> 0x07d3 }
        r0 = r37;	 Catch:{ all -> 0x07d3 }
        r4.<init>(r0, r6);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mAppLib32InstallDir = r4;	 Catch:{ all -> 0x07d3 }
        r4 = new java.io.File;	 Catch:{ all -> 0x07d3 }
        r6 = "app-asec";	 Catch:{ all -> 0x07d3 }
        r0 = r37;	 Catch:{ all -> 0x07d3 }
        r4.<init>(r0, r6);	 Catch:{ all -> 0x07d3 }
        r4 = r4.getPath();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mAsecInternalPath = r4;	 Catch:{ all -> 0x07d3 }
        r4 = new java.io.File;	 Catch:{ all -> 0x07d3 }
        r6 = "app-private";	 Catch:{ all -> 0x07d3 }
        r0 = r37;	 Catch:{ all -> 0x07d3 }
        r4.<init>(r0, r6);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mDrmAppPrivateInstallDir = r4;	 Catch:{ all -> 0x07d3 }
        r4 = new java.io.File;	 Catch:{ all -> 0x07d3 }
        r6 = "app-regional";	 Catch:{ all -> 0x07d3 }
        r0 = r37;	 Catch:{ all -> 0x07d3 }
        r4.<init>(r0, r6);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mRegionalizationAppInstallDir = r4;	 Catch:{ all -> 0x07d3 }
        r4 = new com.android.server.pm.UserManagerService;	 Catch:{ all -> 0x07d3 }
        r6 = new com.android.server.pm.UserDataPreparer;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r8 = r0.mInstaller;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r10 = r0.mInstallLock;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r12 = r0.mContext;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r14 = r0.mOnlyCore;	 Catch:{ all -> 0x07d3 }
        r6.<init>(r8, r10, r12, r14);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r8 = r0.mPackages;	 Catch:{ all -> 0x07d3 }
        r0 = r102;	 Catch:{ all -> 0x07d3 }
        r1 = r101;	 Catch:{ all -> 0x07d3 }
        r4.<init>(r0, r1, r6, r8);	 Catch:{ all -> 0x07d3 }
        sUserManager = r4;	 Catch:{ all -> 0x07d3 }
        r71 = r88.getPermissions();	 Catch:{ all -> 0x07d3 }
        r58 = 0;	 Catch:{ all -> 0x07d3 }
    L_0x0615:
        r4 = r71.size();	 Catch:{ all -> 0x07d3 }
        r0 = r58;	 Catch:{ all -> 0x07d3 }
        if (r0 >= r4) goto L_0x06b1;	 Catch:{ all -> 0x07d3 }
    L_0x061d:
        r0 = r71;	 Catch:{ all -> 0x07d3 }
        r1 = r58;	 Catch:{ all -> 0x07d3 }
        r70 = r0.valueAt(r1);	 Catch:{ all -> 0x07d3 }
        r70 = (com.android.server.SystemConfig.PermissionEntry) r70;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r4 = r4.mPermissions;	 Catch:{ all -> 0x07d3 }
        r0 = r70;	 Catch:{ all -> 0x07d3 }
        r6 = r0.name;	 Catch:{ all -> 0x07d3 }
        r30 = r4.get(r6);	 Catch:{ all -> 0x07d3 }
        r30 = (com.android.server.pm.BasePermission) r30;	 Catch:{ all -> 0x07d3 }
        if (r30 != 0) goto L_0x0657;	 Catch:{ all -> 0x07d3 }
    L_0x0639:
        r30 = new com.android.server.pm.BasePermission;	 Catch:{ all -> 0x07d3 }
        r0 = r70;	 Catch:{ all -> 0x07d3 }
        r4 = r0.name;	 Catch:{ all -> 0x07d3 }
        r6 = "android";	 Catch:{ all -> 0x07d3 }
        r8 = 1;	 Catch:{ all -> 0x07d3 }
        r0 = r30;	 Catch:{ all -> 0x07d3 }
        r0.<init>(r4, r6, r8);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r4 = r4.mPermissions;	 Catch:{ all -> 0x07d3 }
        r0 = r70;	 Catch:{ all -> 0x07d3 }
        r6 = r0.name;	 Catch:{ all -> 0x07d3 }
        r0 = r30;	 Catch:{ all -> 0x07d3 }
        r4.put(r6, r0);	 Catch:{ all -> 0x07d3 }
    L_0x0657:
        r0 = r70;	 Catch:{ all -> 0x07d3 }
        r4 = r0.gids;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x066a;	 Catch:{ all -> 0x07d3 }
    L_0x065d:
        r0 = r70;	 Catch:{ all -> 0x07d3 }
        r4 = r0.gids;	 Catch:{ all -> 0x07d3 }
        r0 = r70;	 Catch:{ all -> 0x07d3 }
        r6 = r0.perUser;	 Catch:{ all -> 0x07d3 }
        r0 = r30;	 Catch:{ all -> 0x07d3 }
        r0.setGids(r4, r6);	 Catch:{ all -> 0x07d3 }
    L_0x066a:
        r58 = r58 + 1;
        goto L_0x0615;
    L_0x066d:
        r4 = 0;
        r0 = r101;
        r0.mDefParseFlags = r4;
        r4 = ",";
        r0 = r82;
        r4 = r0.split(r4);
        r0 = r101;
        r0.mSeparateProcesses = r4;
        r4 = "PackageManager";
        r6 = new java.lang.StringBuilder;
        r6.<init>();
        r8 = "Running with debug.separate_processes: ";
        r6 = r6.append(r8);
        r0 = r82;
        r6 = r6.append(r0);
        r6 = r6.toString();
        android.util.Slog.w(r4, r6);
        goto L_0x03f3;
    L_0x069d:
        r4 = 0;
        r0 = r101;
        r0.mDefParseFlags = r4;
        r4 = 0;
        r0 = r101;
        r0.mSeparateProcesses = r4;
        goto L_0x03f3;
    L_0x06a9:
        r4 = "com.android.chrome";
        com.android.server.pm.ColorPackageManagerHelper.initDefaultPackageList(r4);
        goto L_0x04ea;
    L_0x06b1:
        r61 = r88.getSharedLibraries();	 Catch:{ all -> 0x07d3 }
        r31 = r61.size();	 Catch:{ all -> 0x07d3 }
        r58 = 0;	 Catch:{ all -> 0x07d3 }
    L_0x06bb:
        r0 = r58;	 Catch:{ all -> 0x07d3 }
        r1 = r31;	 Catch:{ all -> 0x07d3 }
        if (r0 >= r1) goto L_0x06e4;	 Catch:{ all -> 0x07d3 }
    L_0x06c1:
        r0 = r61;	 Catch:{ all -> 0x07d3 }
        r1 = r58;	 Catch:{ all -> 0x07d3 }
        r7 = r0.keyAt(r1);	 Catch:{ all -> 0x07d3 }
        r7 = (java.lang.String) r7;	 Catch:{ all -> 0x07d3 }
        r0 = r61;	 Catch:{ all -> 0x07d3 }
        r1 = r58;	 Catch:{ all -> 0x07d3 }
        r5 = r0.valueAt(r1);	 Catch:{ all -> 0x07d3 }
        r5 = (java.lang.String) r5;	 Catch:{ all -> 0x07d3 }
        r10 = "android";	 Catch:{ all -> 0x07d3 }
        r6 = 0;	 Catch:{ all -> 0x07d3 }
        r8 = -1;	 Catch:{ all -> 0x07d3 }
        r9 = 0;	 Catch:{ all -> 0x07d3 }
        r11 = 0;	 Catch:{ all -> 0x07d3 }
        r4 = r101;	 Catch:{ all -> 0x07d3 }
        r4.addSharedLibraryLPw(r5, r6, r7, r8, r9, r10, r11);	 Catch:{ all -> 0x07d3 }
        r58 = r58 + 1;	 Catch:{ all -> 0x07d3 }
        goto L_0x06bb;	 Catch:{ all -> 0x07d3 }
    L_0x06e4:
        r4 = com.android.server.pm.SELinuxMMAC.readInstallPolicy();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mFoundPolicyFile = r4;	 Catch:{ all -> 0x07d3 }
        r4 = "read user settings";	 Catch:{ all -> 0x07d3 }
        r22 = 262144; // 0x40000 float:3.67342E-40 double:1.295163E-318;	 Catch:{ all -> 0x07d3 }
        r0 = r22;	 Catch:{ all -> 0x07d3 }
        android.os.Trace.traceBegin(r0, r4);	 Catch:{ all -> 0x07d3 }
        r4 = "oppo.securitypay.support";	 Catch:{ all -> 0x07d3 }
        r6 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.hasSystemFeature(r4, r6);	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0719;	 Catch:{ all -> 0x07d3 }
    L_0x0703:
        r4 = "PackageManager";	 Catch:{ all -> 0x07d3 }
        r6 = "start init SandboxApp ";	 Catch:{ all -> 0x07d3 }
        android.util.Slog.i(r4, r6);	 Catch:{ all -> 0x07d3 }
        r4 = com.android.server.pm.ColorSecurePayManager.getInstance();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r6 = r0.mContext;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4.initSecurePay(r6, r0);	 Catch:{ all -> 0x07d3 }
    L_0x0719:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r6 = sUserManager;	 Catch:{ all -> 0x07d3 }
        r8 = 0;	 Catch:{ all -> 0x07d3 }
        r6 = r6.getUsers(r8);	 Catch:{ all -> 0x07d3 }
        r4 = r4.readLPw(r6);	 Catch:{ all -> 0x07d3 }
        r4 = r4 ^ 1;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mFirstBoot = r4;	 Catch:{ all -> 0x07d3 }
        r22 = 262144; // 0x40000 float:3.67342E-40 double:1.295163E-318;	 Catch:{ all -> 0x07d3 }
        android.os.Trace.traceEnd(r22);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r4 = r4.mPackages;	 Catch:{ all -> 0x07d3 }
        r68 = r4.size();	 Catch:{ all -> 0x07d3 }
        r58 = r68 + -1;	 Catch:{ all -> 0x07d3 }
    L_0x0740:
        if (r58 < 0) goto L_0x07d9;	 Catch:{ all -> 0x07d3 }
    L_0x0742:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r4 = r4.mPackages;	 Catch:{ all -> 0x07d3 }
        r0 = r58;	 Catch:{ all -> 0x07d3 }
        r76 = r4.valueAt(r0);	 Catch:{ all -> 0x07d3 }
        r76 = (com.android.server.pm.PackageSetting) r76;	 Catch:{ all -> 0x07d3 }
        r4 = isExternal(r76);	 Catch:{ all -> 0x07d3 }
        if (r4 != 0) goto L_0x07cc;	 Catch:{ all -> 0x07d3 }
    L_0x0756:
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r4 = r0.codePath;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0768;	 Catch:{ all -> 0x07d3 }
    L_0x075c:
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r4 = r0.codePath;	 Catch:{ all -> 0x07d3 }
        r4 = r4.exists();	 Catch:{ all -> 0x07d3 }
        r4 = r4 ^ 1;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x07cc;	 Catch:{ all -> 0x07d3 }
    L_0x0768:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r6 = r0.name;	 Catch:{ all -> 0x07d3 }
        r4 = r4.getDisabledSystemPkgLPr(r6);	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x07cc;	 Catch:{ all -> 0x07d3 }
    L_0x0776:
        r4 = r101.isBootFromOTA();	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x07b6;	 Catch:{ all -> 0x07d3 }
    L_0x077c:
        if (r76 == 0) goto L_0x07b6;	 Catch:{ all -> 0x07d3 }
    L_0x077e:
        r4 = "PackageManager";	 Catch:{ all -> 0x07d3 }
        r6 = new java.lang.StringBuilder;	 Catch:{ all -> 0x07d3 }
        r6.<init>();	 Catch:{ all -> 0x07d3 }
        r8 = "enableSystem scannedPkg PKG = ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r8 = r0.name;	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r8 = " UID = ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r8 = r0.appId;	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r6 = r6.toString();	 Catch:{ all -> 0x07d3 }
        android.util.Slog.d(r4, r6);	 Catch:{ all -> 0x07d3 }
        r6 = com.android.server.pm.ColorPackageManagerHelper.sOppoSystemToDataList;	 Catch:{ all -> 0x07d3 }
        monitor-enter(r6);	 Catch:{ all -> 0x07d3 }
        r4 = com.android.server.pm.ColorPackageManagerHelper.sOppoSystemToDataList;	 Catch:{ all -> 0x07d0 }
        r0 = r76;	 Catch:{ all -> 0x07d0 }
        r4.add(r0);	 Catch:{ all -> 0x07d0 }
        monitor-exit(r6);	 Catch:{ all -> 0x07d3 }
    L_0x07b6:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r4 = r4.mPackages;	 Catch:{ all -> 0x07d3 }
        r0 = r58;	 Catch:{ all -> 0x07d3 }
        r4.removeAt(r0);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r6 = r0.name;	 Catch:{ all -> 0x07d3 }
        r4.enableSystemPackageLPw(r6);	 Catch:{ all -> 0x07d3 }
    L_0x07cc:
        r58 = r58 + -1;	 Catch:{ all -> 0x07d3 }
        goto L_0x0740;	 Catch:{ all -> 0x07d3 }
    L_0x07d0:
        r4 = move-exception;	 Catch:{ all -> 0x07d3 }
        monitor-exit(r6);	 Catch:{ all -> 0x07d3 }
        throw r4;	 Catch:{ all -> 0x07d3 }
    L_0x07d3:
        r4 = move-exception;
        monitor-exit(r100);	 Catch:{ all -> 0x07d6 }
        throw r4;	 Catch:{ all -> 0x07d6 }
    L_0x07d6:
        r4 = move-exception;
        monitor-exit(r99);
        throw r4;
    L_0x07d9:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mFirstBoot;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x07e2;	 Catch:{ all -> 0x07d3 }
    L_0x07df:
        requestCopyPreoptedFiles();	 Catch:{ all -> 0x07d3 }
    L_0x07e2:
        r101.commonSoftInit();	 Catch:{ all -> 0x07d3 }
        r4 = r101.isCommonSoft();	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x07f5;	 Catch:{ all -> 0x07d3 }
    L_0x07eb:
        r4 = r101.getSystemAppPkgFileName();	 Catch:{ all -> 0x07d3 }
        r6 = 1;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.readFileToArrayList(r4, r6);	 Catch:{ all -> 0x07d3 }
    L_0x07f5:
        r101.deleteAppChannel();	 Catch:{ all -> 0x07d3 }
        r4 = r101.isFirstBoot();	 Catch:{ all -> 0x07d3 }
        com.android.server.pm.OppoPackageManagerHelper.isFirstBoot(r4);	 Catch:{ all -> 0x07d3 }
        r4 = android.content.res.Resources.getSystem();	 Catch:{ all -> 0x07d3 }
        r6 = 17039655; // 0x1040127 float:2.4245398E-38 double:8.418708E-317;	 Catch:{ all -> 0x07d3 }
        r36 = r4.getString(r6);	 Catch:{ all -> 0x07d3 }
        r4 = android.text.TextUtils.isEmpty(r36);	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x090e;	 Catch:{ all -> 0x07d3 }
    L_0x0810:
        r36 = 0;	 Catch:{ all -> 0x07d3 }
    L_0x0812:
        r86 = android.os.SystemClock.uptimeMillis();	 Catch:{ all -> 0x07d3 }
        r4 = 3070; // 0xbfe float:4.302E-42 double:1.517E-320;	 Catch:{ all -> 0x07d3 }
        r0 = r86;	 Catch:{ all -> 0x07d3 }
        android.util.EventLog.writeEvent(r4, r0);	 Catch:{ all -> 0x07d3 }
        r4 = "persist.sys.oppo.scanstage";	 Catch:{ all -> 0x07d3 }
        r6 = "true";	 Catch:{ all -> 0x07d3 }
        android.os.SystemProperties.set(r4, r6);	 Catch:{ all -> 0x07d3 }
        r4 = "BOOTCLASSPATH";	 Catch:{ all -> 0x07d3 }
        r29 = java.lang.System.getenv(r4);	 Catch:{ all -> 0x07d3 }
        r4 = "SYSTEMSERVERCLASSPATH";	 Catch:{ all -> 0x07d3 }
        r92 = java.lang.System.getenv(r4);	 Catch:{ all -> 0x07d3 }
        if (r29 != 0) goto L_0x083f;	 Catch:{ all -> 0x07d3 }
    L_0x0836:
        r4 = "PackageManager";	 Catch:{ all -> 0x07d3 }
        r6 = "No BOOTCLASSPATH found!";	 Catch:{ all -> 0x07d3 }
        android.util.Slog.w(r4, r6);	 Catch:{ all -> 0x07d3 }
    L_0x083f:
        if (r92 != 0) goto L_0x084a;	 Catch:{ all -> 0x07d3 }
    L_0x0841:
        r4 = "PackageManager";	 Catch:{ all -> 0x07d3 }
        r6 = "No SYSTEMSERVERCLASSPATH found!";	 Catch:{ all -> 0x07d3 }
        android.util.Slog.w(r4, r6);	 Catch:{ all -> 0x07d3 }
    L_0x084a:
        r56 = new java.io.File;	 Catch:{ all -> 0x07d3 }
        r4 = android.os.Environment.getRootDirectory();	 Catch:{ all -> 0x07d3 }
        r6 = "framework";	 Catch:{ all -> 0x07d3 }
        r0 = r56;	 Catch:{ all -> 0x07d3 }
        r0.<init>(r4, r6);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r98 = r4.getInternalVersion();	 Catch:{ all -> 0x07d3 }
        r4 = android.os.Build.FINGERPRINT;	 Catch:{ all -> 0x07d3 }
        r0 = r98;	 Catch:{ all -> 0x07d3 }
        r6 = r0.fingerprint;	 Catch:{ all -> 0x07d3 }
        r4 = r4.equals(r6);	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0918;	 Catch:{ all -> 0x07d3 }
    L_0x086c:
        r4 = r101.isBootFromOTA();	 Catch:{ all -> 0x07d3 }
    L_0x0870:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mIsUpgrade = r4;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mIsUpgrade;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x08a3;	 Catch:{ all -> 0x07d3 }
    L_0x087a:
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x07d3 }
        r4.<init>();	 Catch:{ all -> 0x07d3 }
        r6 = "Upgrading from ";	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r0 = r98;	 Catch:{ all -> 0x07d3 }
        r6 = r0.fingerprint;	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r6 = " to ";	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r6 = android.os.Build.FINGERPRINT;	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r4 = r4.toString();	 Catch:{ all -> 0x07d3 }
        r6 = 4;	 Catch:{ all -> 0x07d3 }
        logCriticalInfo(r6, r4);	 Catch:{ all -> 0x07d3 }
    L_0x08a3:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mIsUpgrade;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x091b;	 Catch:{ all -> 0x07d3 }
    L_0x08a9:
        r0 = r98;	 Catch:{ all -> 0x07d3 }
        r4 = r0.sdkVersion;	 Catch:{ all -> 0x07d3 }
        r6 = 22;	 Catch:{ all -> 0x07d3 }
        if (r4 > r6) goto L_0x091b;	 Catch:{ all -> 0x07d3 }
    L_0x08b1:
        r4 = 1;	 Catch:{ all -> 0x07d3 }
    L_0x08b2:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mPromoteSystemApps = r4;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mIsUpgrade;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x091d;	 Catch:{ all -> 0x07d3 }
    L_0x08bc:
        r0 = r98;	 Catch:{ all -> 0x07d3 }
        r4 = r0.sdkVersion;	 Catch:{ all -> 0x07d3 }
        r6 = 24;	 Catch:{ all -> 0x07d3 }
        if (r4 >= r6) goto L_0x091d;	 Catch:{ all -> 0x07d3 }
    L_0x08c4:
        r4 = 1;	 Catch:{ all -> 0x07d3 }
    L_0x08c5:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mIsPreNUpgrade = r4;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mIsUpgrade;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x091f;	 Catch:{ all -> 0x07d3 }
    L_0x08cf:
        r0 = r98;	 Catch:{ all -> 0x07d3 }
        r4 = r0.sdkVersion;	 Catch:{ all -> 0x07d3 }
        r6 = 25;	 Catch:{ all -> 0x07d3 }
        if (r4 >= r6) goto L_0x091f;	 Catch:{ all -> 0x07d3 }
    L_0x08d7:
        r4 = 1;	 Catch:{ all -> 0x07d3 }
    L_0x08d8:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mIsPreNMR1Upgrade = r4;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mPromoteSystemApps;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0921;	 Catch:{ all -> 0x07d3 }
    L_0x08e2:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r4 = r4.mPackages;	 Catch:{ all -> 0x07d3 }
        r4 = r4.values();	 Catch:{ all -> 0x07d3 }
        r74 = r4.iterator();	 Catch:{ all -> 0x07d3 }
    L_0x08f0:
        r4 = r74.hasNext();	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0921;	 Catch:{ all -> 0x07d3 }
    L_0x08f6:
        r76 = r74.next();	 Catch:{ all -> 0x07d3 }
        r76 = (com.android.server.pm.PackageSetting) r76;	 Catch:{ all -> 0x07d3 }
        r4 = isSystemApp(r76);	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x08f0;	 Catch:{ all -> 0x07d3 }
    L_0x0902:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mExistingSystemPackages;	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r6 = r0.name;	 Catch:{ all -> 0x07d3 }
        r4.add(r6);	 Catch:{ all -> 0x07d3 }
        goto L_0x08f0;	 Catch:{ all -> 0x07d3 }
    L_0x090e:
        r4 = android.content.ComponentName.unflattenFromString(r36);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mCustomResolverComponentName = r4;	 Catch:{ all -> 0x07d3 }
        goto L_0x0812;	 Catch:{ all -> 0x07d3 }
    L_0x0918:
        r4 = 1;	 Catch:{ all -> 0x07d3 }
        goto L_0x0870;	 Catch:{ all -> 0x07d3 }
    L_0x091b:
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        goto L_0x08b2;	 Catch:{ all -> 0x07d3 }
    L_0x091d:
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        goto L_0x08c5;	 Catch:{ all -> 0x07d3 }
    L_0x091f:
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        goto L_0x08d8;	 Catch:{ all -> 0x07d3 }
    L_0x0921:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mIsUpgrade;	 Catch:{ all -> 0x07d3 }
        r4 = preparePackageParserCache(r4);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mCacheDir = r4;	 Catch:{ all -> 0x07d3 }
        r80 = 4160; // 0x1040 float:5.83E-42 double:2.0553E-320;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mIsUpgrade;	 Catch:{ all -> 0x07d3 }
        if (r4 != 0) goto L_0x093b;	 Catch:{ all -> 0x07d3 }
    L_0x0935:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mFirstBoot;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x093e;	 Catch:{ all -> 0x07d3 }
    L_0x093b:
        r80 = 69696; // 0x11040 float:9.7665E-41 double:3.44344E-319;	 Catch:{ all -> 0x07d3 }
    L_0x093e:
        r9 = new java.io.File;	 Catch:{ all -> 0x07d3 }
        r4 = "/vendor/overlay";	 Catch:{ all -> 0x07d3 }
        r9.<init>(r4);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mDefParseFlags;	 Catch:{ all -> 0x07d3 }
        r4 = r4 | 1;	 Catch:{ all -> 0x07d3 }
        r4 = r4 | 64;	 Catch:{ all -> 0x07d3 }
        r10 = r4 | 512;	 Catch:{ all -> 0x07d3 }
        r0 = r80;	 Catch:{ all -> 0x07d3 }
        r11 = r0 | 128;	 Catch:{ all -> 0x07d3 }
        r12 = 0;	 Catch:{ all -> 0x07d3 }
        r8 = r101;	 Catch:{ all -> 0x07d3 }
        r8.scanDirTracedLI(r9, r10, r11, r12);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mParallelPackageParserCallback;	 Catch:{ all -> 0x07d3 }
        r4.findStaticOverlayPackages();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mDefParseFlags;	 Catch:{ all -> 0x07d3 }
        r4 = r4 | 1;	 Catch:{ all -> 0x07d3 }
        r4 = r4 | 64;	 Catch:{ all -> 0x07d3 }
        r10 = r4 | 128;	 Catch:{ all -> 0x07d3 }
        r11 = r80 | 2;	 Catch:{ all -> 0x07d3 }
        r12 = 0;	 Catch:{ all -> 0x07d3 }
        r8 = r101;	 Catch:{ all -> 0x07d3 }
        r9 = r56;	 Catch:{ all -> 0x07d3 }
        r8.scanDirTracedLI(r9, r10, r11, r12);	 Catch:{ all -> 0x07d3 }
        r9 = new java.io.File;	 Catch:{ all -> 0x07d3 }
        r4 = android.os.Environment.getRootDirectory();	 Catch:{ all -> 0x07d3 }
        r6 = "priv-app";	 Catch:{ all -> 0x07d3 }
        r9.<init>(r4, r6);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mDefParseFlags;	 Catch:{ all -> 0x07d3 }
        r4 = r4 | 1;	 Catch:{ all -> 0x07d3 }
        r4 = r4 | 64;	 Catch:{ all -> 0x07d3 }
        r10 = r4 | 128;	 Catch:{ all -> 0x07d3 }
        r12 = 0;	 Catch:{ all -> 0x07d3 }
        r8 = r101;	 Catch:{ all -> 0x07d3 }
        r11 = r80;	 Catch:{ all -> 0x07d3 }
        r8.scanDirTracedLI(r9, r10, r11, r12);	 Catch:{ all -> 0x07d3 }
        r11 = new java.io.File;	 Catch:{ all -> 0x07d3 }
        r4 = android.os.Environment.getRootDirectory();	 Catch:{ all -> 0x07d3 }
        r6 = "app";	 Catch:{ all -> 0x07d3 }
        r11.<init>(r4, r6);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mDefParseFlags;	 Catch:{ all -> 0x07d3 }
        r4 = r4 | 1;	 Catch:{ all -> 0x07d3 }
        r12 = r4 | 64;	 Catch:{ all -> 0x07d3 }
        r14 = 0;	 Catch:{ all -> 0x07d3 }
        r10 = r101;	 Catch:{ all -> 0x07d3 }
        r13 = r80;	 Catch:{ all -> 0x07d3 }
        r10.scanDirTracedLI(r11, r12, r13, r14);	 Catch:{ all -> 0x07d3 }
        r4 = EXP_VERSION;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0a32;	 Catch:{ all -> 0x07d3 }
    L_0x09b7:
        r4 = "persist.sys.oppo.opinstalled";	 Catch:{ all -> 0x07d3 }
        r6 = "false";	 Catch:{ all -> 0x07d3 }
        r62 = android.os.SystemProperties.get(r4, r6);	 Catch:{ all -> 0x07d3 }
        r4 = mRegion;	 Catch:{ all -> 0x07d3 }
        r6 = "SG";	 Catch:{ all -> 0x07d3 }
        r4 = r4.equals(r6);	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x09d7;	 Catch:{ all -> 0x07d3 }
    L_0x09cc:
        r4 = mOperator;	 Catch:{ all -> 0x07d3 }
        r6 = "STARHUB";	 Catch:{ all -> 0x07d3 }
        r4 = r4.equals(r6);	 Catch:{ all -> 0x07d3 }
        if (r4 != 0) goto L_0x0a03;	 Catch:{ all -> 0x07d3 }
    L_0x09d7:
        r4 = mRegion;	 Catch:{ all -> 0x07d3 }
        r6 = "TW";	 Catch:{ all -> 0x07d3 }
        r4 = r4.equals(r6);	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x09ed;	 Catch:{ all -> 0x07d3 }
    L_0x09e2:
        r4 = mOperator;	 Catch:{ all -> 0x07d3 }
        r6 = "APT";	 Catch:{ all -> 0x07d3 }
        r4 = r4.equals(r6);	 Catch:{ all -> 0x07d3 }
        if (r4 != 0) goto L_0x0a03;	 Catch:{ all -> 0x07d3 }
    L_0x09ed:
        r4 = mRegion;	 Catch:{ all -> 0x07d3 }
        r6 = "TW";	 Catch:{ all -> 0x07d3 }
        r4 = r4.equals(r6);	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0a32;	 Catch:{ all -> 0x07d3 }
    L_0x09f8:
        r4 = mOperator;	 Catch:{ all -> 0x07d3 }
        r6 = "FET";	 Catch:{ all -> 0x07d3 }
        r4 = r4.equals(r6);	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0a32;	 Catch:{ all -> 0x07d3 }
    L_0x0a03:
        r4 = "false";	 Catch:{ all -> 0x07d3 }
        r0 = r62;	 Catch:{ all -> 0x07d3 }
        r4 = r0.equals(r4);	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0a32;	 Catch:{ all -> 0x07d3 }
    L_0x0a0e:
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x07d3 }
        r4.<init>();	 Catch:{ all -> 0x07d3 }
        r6 = "reserve/data_app_";	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r6 = mOperator;	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r4 = r4.toString();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.operatorAppCopy(r4);	 Catch:{ all -> 0x07d3 }
        r4 = "persist.sys.oppo.opinstalled";	 Catch:{ all -> 0x07d3 }
        r6 = "true";	 Catch:{ all -> 0x07d3 }
        android.os.SystemProperties.set(r4, r6);	 Catch:{ all -> 0x07d3 }
    L_0x0a32:
        r13 = new java.io.File;	 Catch:{ all -> 0x07d3 }
        r4 = "/vendor/app";	 Catch:{ all -> 0x07d3 }
        r13.<init>(r4);	 Catch:{ all -> 0x07d3 }
        r13 = r13.getCanonicalFile();	 Catch:{ IOException -> 0x0ae5 }
    L_0x0a3e:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mDefParseFlags;	 Catch:{ all -> 0x07d3 }
        r4 = r4 | 1;	 Catch:{ all -> 0x07d3 }
        r14 = r4 | 64;	 Catch:{ all -> 0x07d3 }
        r16 = 0;	 Catch:{ all -> 0x07d3 }
        r12 = r101;	 Catch:{ all -> 0x07d3 }
        r15 = r80;	 Catch:{ all -> 0x07d3 }
        r12.scanDirTracedLI(r13, r14, r15, r16);	 Catch:{ all -> 0x07d3 }
        r15 = new java.io.File;	 Catch:{ all -> 0x07d3 }
        r4 = android.os.Environment.getOemDirectory();	 Catch:{ all -> 0x07d3 }
        r6 = "app";	 Catch:{ all -> 0x07d3 }
        r15.<init>(r4, r6);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mDefParseFlags;	 Catch:{ all -> 0x07d3 }
        r4 = r4 | 1;	 Catch:{ all -> 0x07d3 }
        r16 = r4 | 64;	 Catch:{ all -> 0x07d3 }
        r18 = 0;	 Catch:{ all -> 0x07d3 }
        r14 = r101;	 Catch:{ all -> 0x07d3 }
        r17 = r80;	 Catch:{ all -> 0x07d3 }
        r14.scanDirTracedLI(r15, r16, r17, r18);	 Catch:{ all -> 0x07d3 }
        r4 = com.android.internal.os.RegionalizationEnvironment.isSupported();	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0ae8;	 Catch:{ all -> 0x07d3 }
    L_0x0a72:
        r4 = "PackageManager";	 Catch:{ all -> 0x07d3 }
        r6 = "Load Regionalization vendor apks";	 Catch:{ all -> 0x07d3 }
        android.util.Log.d(r4, r6);	 Catch:{ all -> 0x07d3 }
        r27 = com.android.internal.os.RegionalizationEnvironment.getAllPackageDirectories();	 Catch:{ all -> 0x07d3 }
        r53 = r27.iterator();	 Catch:{ all -> 0x07d3 }
    L_0x0a83:
        r4 = r53.hasNext();	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0ae8;	 Catch:{ all -> 0x07d3 }
    L_0x0a89:
        r52 = r53.next();	 Catch:{ all -> 0x07d3 }
        r52 = (java.io.File) r52;	 Catch:{ all -> 0x07d3 }
        r28 = new java.io.File;	 Catch:{ all -> 0x07d3 }
        r4 = "system";	 Catch:{ all -> 0x07d3 }
        r0 = r28;	 Catch:{ all -> 0x07d3 }
        r1 = r52;	 Catch:{ all -> 0x07d3 }
        r0.<init>(r1, r4);	 Catch:{ all -> 0x07d3 }
        r17 = new java.io.File;	 Catch:{ all -> 0x07d3 }
        r4 = "priv-app";	 Catch:{ all -> 0x07d3 }
        r0 = r17;	 Catch:{ all -> 0x07d3 }
        r1 = r28;	 Catch:{ all -> 0x07d3 }
        r0.<init>(r1, r4);	 Catch:{ all -> 0x07d3 }
        r20 = 0;	 Catch:{ all -> 0x07d3 }
        r18 = 193; // 0xc1 float:2.7E-43 double:9.54E-322;	 Catch:{ all -> 0x07d3 }
        r16 = r101;	 Catch:{ all -> 0x07d3 }
        r19 = r80;	 Catch:{ all -> 0x07d3 }
        r16.scanDirLI(r17, r18, r19, r20);	 Catch:{ all -> 0x07d3 }
        r17 = new java.io.File;	 Catch:{ all -> 0x07d3 }
        r4 = "app";	 Catch:{ all -> 0x07d3 }
        r0 = r17;	 Catch:{ all -> 0x07d3 }
        r1 = r28;	 Catch:{ all -> 0x07d3 }
        r0.<init>(r1, r4);	 Catch:{ all -> 0x07d3 }
        r20 = 0;	 Catch:{ all -> 0x07d3 }
        r18 = 65;	 Catch:{ all -> 0x07d3 }
        r16 = r101;	 Catch:{ all -> 0x07d3 }
        r19 = r80;	 Catch:{ all -> 0x07d3 }
        r16.scanDirLI(r17, r18, r19, r20);	 Catch:{ all -> 0x07d3 }
        r17 = new java.io.File;	 Catch:{ all -> 0x07d3 }
        r4 = "vendor/overlay";	 Catch:{ all -> 0x07d3 }
        r0 = r17;	 Catch:{ all -> 0x07d3 }
        r1 = r28;	 Catch:{ all -> 0x07d3 }
        r0.<init>(r1, r4);	 Catch:{ all -> 0x07d3 }
        r0 = r80;	 Catch:{ all -> 0x07d3 }
        r0 = r0 | 128;	 Catch:{ all -> 0x07d3 }
        r19 = r0;	 Catch:{ all -> 0x07d3 }
        r20 = 0;	 Catch:{ all -> 0x07d3 }
        r18 = 577; // 0x241 float:8.09E-43 double:2.85E-321;	 Catch:{ all -> 0x07d3 }
        r16 = r101;	 Catch:{ all -> 0x07d3 }
        r16.scanDirLI(r17, r18, r19, r20);	 Catch:{ all -> 0x07d3 }
        goto L_0x0a83;	 Catch:{ all -> 0x07d3 }
    L_0x0ae5:
        r50 = move-exception;	 Catch:{ all -> 0x07d3 }
        goto L_0x0a3e;	 Catch:{ all -> 0x07d3 }
    L_0x0ae8:
        r75 = new java.util.ArrayList;	 Catch:{ all -> 0x07d3 }
        r75.<init>();	 Catch:{ all -> 0x07d3 }
        r85 = new java.util.ArrayList;	 Catch:{ all -> 0x07d3 }
        r85.<init>();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mOnlyCore;	 Catch:{ all -> 0x07d3 }
        if (r4 != 0) goto L_0x0c79;	 Catch:{ all -> 0x07d3 }
    L_0x0af8:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mPackages;	 Catch:{ all -> 0x07d3 }
        r4 = r4.values();	 Catch:{ all -> 0x07d3 }
        r73 = r4.iterator();	 Catch:{ all -> 0x07d3 }
    L_0x0b04:
        r4 = r73.hasNext();	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0b20;	 Catch:{ all -> 0x07d3 }
    L_0x0b0a:
        r72 = r73.next();	 Catch:{ all -> 0x07d3 }
        r72 = (android.content.pm.PackageParser.Package) r72;	 Catch:{ all -> 0x07d3 }
        r0 = r72;	 Catch:{ all -> 0x07d3 }
        r4 = r0.isStub;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0b04;	 Catch:{ all -> 0x07d3 }
    L_0x0b16:
        r0 = r72;	 Catch:{ all -> 0x07d3 }
        r4 = r0.packageName;	 Catch:{ all -> 0x07d3 }
        r0 = r85;	 Catch:{ all -> 0x07d3 }
        r0.add(r4);	 Catch:{ all -> 0x07d3 }
        goto L_0x0b04;	 Catch:{ all -> 0x07d3 }
    L_0x0b20:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r4 = r4.mPackages;	 Catch:{ all -> 0x07d3 }
        r4 = r4.values();	 Catch:{ all -> 0x07d3 }
        r77 = r4.iterator();	 Catch:{ all -> 0x07d3 }
    L_0x0b2e:
        r4 = r77.hasNext();	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0c79;	 Catch:{ all -> 0x07d3 }
    L_0x0b34:
        r76 = r77.next();	 Catch:{ all -> 0x07d3 }
        r76 = (com.android.server.pm.PackageSetting) r76;	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r4 = r0.pkgFlags;	 Catch:{ all -> 0x07d3 }
        r4 = r4 & 1;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0b2e;	 Catch:{ all -> 0x07d3 }
    L_0x0b42:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mPackages;	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r6 = r0.name;	 Catch:{ all -> 0x07d3 }
        r81 = r4.get(r6);	 Catch:{ all -> 0x07d3 }
        r81 = (android.content.pm.PackageParser.Package) r81;	 Catch:{ all -> 0x07d3 }
        if (r81 == 0) goto L_0x0bd1;	 Catch:{ all -> 0x07d3 }
    L_0x0b52:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r6 = r0.name;	 Catch:{ all -> 0x07d3 }
        r4 = r4.isDisabledSystemPackageLPr(r6);	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0b2e;	 Catch:{ all -> 0x07d3 }
    L_0x0b60:
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x07d3 }
        r4.<init>();	 Catch:{ all -> 0x07d3 }
        r6 = "Expecting better updated system app for ";	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r6 = r0.name;	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r6 = "; removing system app.  Last known codePath=";	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r6 = r0.codePathString;	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r6 = ", installStatus=";	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r6 = r0.installStatus;	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r6 = ", versionCode=";	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r6 = r0.versionCode;	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r6 = "; scanned versionCode=";	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r0 = r81;	 Catch:{ all -> 0x07d3 }
        r6 = r0.mVersionCode;	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r4 = r4.toString();	 Catch:{ all -> 0x07d3 }
        r6 = 5;	 Catch:{ all -> 0x07d3 }
        logCriticalInfo(r6, r4);	 Catch:{ all -> 0x07d3 }
        r4 = 1;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r1 = r81;	 Catch:{ all -> 0x07d3 }
        r0.removePackageLI(r1, r4);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mExpectingBetter;	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r6 = r0.name;	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r8 = r0.codePath;	 Catch:{ all -> 0x07d3 }
        r4.put(r6, r8);	 Catch:{ all -> 0x07d3 }
        goto L_0x0b2e;	 Catch:{ all -> 0x07d3 }
    L_0x0bd1:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r6 = r0.name;	 Catch:{ all -> 0x07d3 }
        r4 = r4.isDisabledSystemPackageLPr(r6);	 Catch:{ all -> 0x07d3 }
        if (r4 != 0) goto L_0x0c4a;	 Catch:{ all -> 0x07d3 }
    L_0x0bdf:
        r77.remove();	 Catch:{ all -> 0x07d3 }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x07d3 }
        r4.<init>();	 Catch:{ all -> 0x07d3 }
        r6 = "System package ";	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r6 = r0.name;	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r6 = " no longer exists; it's data will be wiped";	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r4 = r4.toString();	 Catch:{ all -> 0x07d3 }
        r6 = 5;	 Catch:{ all -> 0x07d3 }
        logCriticalInfo(r6, r4);	 Catch:{ all -> 0x07d3 }
        r4 = r101.isBootFromOTA();	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0b2e;	 Catch:{ all -> 0x07d3 }
    L_0x0c0b:
        if (r76 == 0) goto L_0x0b2e;	 Catch:{ all -> 0x07d3 }
    L_0x0c0d:
        r4 = "PackageManager";	 Catch:{ all -> 0x07d3 }
        r6 = new java.lang.StringBuilder;	 Catch:{ all -> 0x07d3 }
        r6.<init>();	 Catch:{ all -> 0x07d3 }
        r8 = "scannedPkg PKG = ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r8 = r0.name;	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r8 = " UID = ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r8 = r0.appId;	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r6 = r6.toString();	 Catch:{ all -> 0x07d3 }
        android.util.Slog.d(r4, r6);	 Catch:{ all -> 0x07d3 }
        r6 = com.android.server.pm.ColorPackageManagerHelper.sOppoSystemToDataList;	 Catch:{ all -> 0x07d3 }
        monitor-enter(r6);	 Catch:{ all -> 0x07d3 }
        r4 = com.android.server.pm.ColorPackageManagerHelper.sOppoSystemToDataList;	 Catch:{ all -> 0x0c47 }
        r0 = r76;	 Catch:{ all -> 0x0c47 }
        r4.add(r0);	 Catch:{ all -> 0x0c47 }
        monitor-exit(r6);	 Catch:{ all -> 0x07d3 }
        goto L_0x0b2e;	 Catch:{ all -> 0x07d3 }
    L_0x0c47:
        r4 = move-exception;	 Catch:{ all -> 0x07d3 }
        monitor-exit(r6);	 Catch:{ all -> 0x07d3 }
        throw r4;	 Catch:{ all -> 0x07d3 }
    L_0x0c4a:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r6 = r0.name;	 Catch:{ all -> 0x07d3 }
        r48 = r4.getDisabledSystemPkgLPr(r6);	 Catch:{ all -> 0x07d3 }
        r0 = r48;	 Catch:{ all -> 0x07d3 }
        r4 = r0.codePath;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0c6e;	 Catch:{ all -> 0x07d3 }
    L_0x0c5c:
        r0 = r48;	 Catch:{ all -> 0x07d3 }
        r4 = r0.codePath;	 Catch:{ all -> 0x07d3 }
        r4 = r4.exists();	 Catch:{ all -> 0x07d3 }
        r4 = r4 ^ 1;	 Catch:{ all -> 0x07d3 }
        if (r4 != 0) goto L_0x0c6e;	 Catch:{ all -> 0x07d3 }
    L_0x0c68:
        r0 = r48;	 Catch:{ all -> 0x07d3 }
        r4 = r0.pkg;	 Catch:{ all -> 0x07d3 }
        if (r4 != 0) goto L_0x0b2e;	 Catch:{ all -> 0x07d3 }
    L_0x0c6e:
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r4 = r0.name;	 Catch:{ all -> 0x07d3 }
        r0 = r75;	 Catch:{ all -> 0x07d3 }
        r0.add(r4);	 Catch:{ all -> 0x07d3 }
        goto L_0x0b2e;	 Catch:{ all -> 0x07d3 }
    L_0x0c79:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r6 = r0.mAppInstallDir;	 Catch:{ all -> 0x07d3 }
        com.android.server.pm.OppoPackageManagerHelper.restorePresetApk(r4, r6);	 Catch:{ all -> 0x07d3 }
        r4 = r101.isCommonSoft();	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0c99;	 Catch:{ all -> 0x07d3 }
    L_0x0c8a:
        r4 = r101.isFirstBoot();	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0c99;	 Catch:{ all -> 0x07d3 }
    L_0x0c90:
        r4 = r101.isPackageXmlExists();	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0ce5;	 Catch:{ all -> 0x07d3 }
    L_0x0c96:
        r101.resetDataAppForMasterClear();	 Catch:{ all -> 0x07d3 }
    L_0x0c99:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r43 = r4.getListOfIncompleteInstallPackagesLPr();	 Catch:{ all -> 0x07d3 }
        r58 = 0;	 Catch:{ all -> 0x07d3 }
    L_0x0ca3:
        r4 = r43.size();	 Catch:{ all -> 0x07d3 }
        r0 = r58;	 Catch:{ all -> 0x07d3 }
        if (r0 >= r4) goto L_0x0cec;	 Catch:{ all -> 0x07d3 }
    L_0x0cab:
        r0 = r43;	 Catch:{ all -> 0x07d3 }
        r1 = r58;	 Catch:{ all -> 0x07d3 }
        r4 = r0.get(r1);	 Catch:{ all -> 0x07d3 }
        r4 = (com.android.server.pm.PackageSetting) r4;	 Catch:{ all -> 0x07d3 }
        r0 = r4.name;	 Catch:{ all -> 0x07d3 }
        r67 = r0;	 Catch:{ all -> 0x07d3 }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x07d3 }
        r4.<init>();	 Catch:{ all -> 0x07d3 }
        r6 = "Cleaning up incompletely installed app: ";	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r0 = r67;	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r0);	 Catch:{ all -> 0x07d3 }
        r4 = r4.toString();	 Catch:{ all -> 0x07d3 }
        r6 = 5;	 Catch:{ all -> 0x07d3 }
        logCriticalInfo(r6, r4);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r6 = r0.mPackages;	 Catch:{ all -> 0x07d3 }
        monitor-enter(r6);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x0ce9 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x0ce9 }
        r0 = r67;	 Catch:{ all -> 0x0ce9 }
        r4.removePackageLPw(r0);	 Catch:{ all -> 0x0ce9 }
        monitor-exit(r6);	 Catch:{ all -> 0x07d3 }
        r58 = r58 + 1;	 Catch:{ all -> 0x07d3 }
        goto L_0x0ca3;	 Catch:{ all -> 0x07d3 }
    L_0x0ce5:
        r101.resetDataAppForFirstBoot();	 Catch:{ all -> 0x07d3 }
        goto L_0x0c99;	 Catch:{ all -> 0x07d3 }
    L_0x0ce9:
        r4 = move-exception;	 Catch:{ all -> 0x07d3 }
        monitor-exit(r6);	 Catch:{ all -> 0x07d3 }
        throw r4;	 Catch:{ all -> 0x07d3 }
    L_0x0cec:
        r101.deleteTempPackageFiles();	 Catch:{ all -> 0x07d3 }
        r4 = android.content.pm.PackageParser.sCachedPackageReadCount;	 Catch:{ all -> 0x07d3 }
        r33 = r4.get();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r4.pruneSharedUsersLPw();	 Catch:{ all -> 0x07d3 }
        r22 = android.os.SystemClock.uptimeMillis();	 Catch:{ all -> 0x07d3 }
        r90 = r22 - r86;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mPackages;	 Catch:{ all -> 0x07d3 }
        r89 = r4.size();	 Catch:{ all -> 0x07d3 }
        r4 = "PackageManager";	 Catch:{ all -> 0x07d3 }
        r6 = new java.lang.StringBuilder;	 Catch:{ all -> 0x07d3 }
        r6.<init>();	 Catch:{ all -> 0x07d3 }
        r8 = "Finished scanning system apps. Time: ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r0 = r90;	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r0);	 Catch:{ all -> 0x07d3 }
        r8 = " ms, packageCount: ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r0 = r89;	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r0);	 Catch:{ all -> 0x07d3 }
        r8 = " , timePerPackage: ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        if (r89 != 0) goto L_0x0e0b;	 Catch:{ all -> 0x07d3 }
    L_0x0d35:
        r22 = 0;	 Catch:{ all -> 0x07d3 }
    L_0x0d37:
        r0 = r22;	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r0);	 Catch:{ all -> 0x07d3 }
        r8 = " , cached: ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r0 = r33;	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r0);	 Catch:{ all -> 0x07d3 }
        r6 = r6.toString();	 Catch:{ all -> 0x07d3 }
        android.util.Slog.i(r4, r6);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mIsUpgrade;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0d65;	 Catch:{ all -> 0x07d3 }
    L_0x0d57:
        if (r89 <= 0) goto L_0x0d65;	 Catch:{ all -> 0x07d3 }
    L_0x0d59:
        r4 = "ota_package_manager_system_app_avg_scan_time";	 Catch:{ all -> 0x07d3 }
        r0 = r90;	 Catch:{ all -> 0x07d3 }
        r6 = (int) r0;	 Catch:{ all -> 0x07d3 }
        r6 = r6 / r89;	 Catch:{ all -> 0x07d3 }
        r8 = 0;	 Catch:{ all -> 0x07d3 }
        com.android.internal.logging.MetricsLogger.histogram(r8, r4, r6);	 Catch:{ all -> 0x07d3 }
    L_0x0d65:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mOnlyCore;	 Catch:{ all -> 0x07d3 }
        if (r4 != 0) goto L_0x0ff5;	 Catch:{ all -> 0x07d3 }
    L_0x0d6b:
        r22 = android.os.SystemClock.uptimeMillis();	 Catch:{ all -> 0x07d3 }
        r4 = 3080; // 0xc08 float:4.316E-42 double:1.5217E-320;	 Catch:{ all -> 0x07d3 }
        r0 = r22;	 Catch:{ all -> 0x07d3 }
        android.util.EventLog.writeEvent(r4, r0);	 Catch:{ all -> 0x07d3 }
        r4 = "persist.sys.oppo.scanstage";	 Catch:{ all -> 0x07d3 }
        r6 = "1";	 Catch:{ all -> 0x07d3 }
        android.os.SystemProperties.set(r4, r6);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0 = r0.mAppInstallDir;	 Catch:{ all -> 0x07d3 }
        r17 = r0;	 Catch:{ all -> 0x07d3 }
        r0 = r80;	 Catch:{ all -> 0x07d3 }
        r0 = r0 | 1024;	 Catch:{ all -> 0x07d3 }
        r19 = r0;	 Catch:{ all -> 0x07d3 }
        r20 = 0;	 Catch:{ all -> 0x07d3 }
        r18 = 0;	 Catch:{ all -> 0x07d3 }
        r16 = r101;	 Catch:{ all -> 0x07d3 }
        r16.scanDirTracedLI(r17, r18, r19, r20);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0 = r0.mDrmAppPrivateInstallDir;	 Catch:{ all -> 0x07d3 }
        r17 = r0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mDefParseFlags;	 Catch:{ all -> 0x07d3 }
        r18 = r4 | 16;	 Catch:{ all -> 0x07d3 }
        r0 = r80;	 Catch:{ all -> 0x07d3 }
        r0 = r0 | 1024;	 Catch:{ all -> 0x07d3 }
        r19 = r0;	 Catch:{ all -> 0x07d3 }
        r20 = 0;	 Catch:{ all -> 0x07d3 }
        r16 = r101;	 Catch:{ all -> 0x07d3 }
        r16.scanDirTracedLI(r17, r18, r19, r20);	 Catch:{ all -> 0x07d3 }
        r4 = com.android.internal.os.RegionalizationEnvironment.isSupported();	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0e14;	 Catch:{ all -> 0x07d3 }
    L_0x0db3:
        r4 = "PackageManager";	 Catch:{ all -> 0x07d3 }
        r6 = "Load Regionalization 3rd apks from res packages.";	 Catch:{ all -> 0x07d3 }
        android.util.Log.d(r4, r6);	 Catch:{ all -> 0x07d3 }
        r69 = com.android.internal.os.RegionalizationEnvironment.getAllPackageNames();	 Catch:{ all -> 0x07d3 }
        r66 = r69.iterator();	 Catch:{ all -> 0x07d3 }
    L_0x0dc4:
        r4 = r66.hasNext();	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0e14;	 Catch:{ all -> 0x07d3 }
    L_0x0dca:
        r65 = r66.next();	 Catch:{ all -> 0x07d3 }
        r65 = (java.lang.String) r65;	 Catch:{ all -> 0x07d3 }
        r17 = new java.io.File;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mRegionalizationAppInstallDir;	 Catch:{ all -> 0x07d3 }
        r0 = r17;	 Catch:{ all -> 0x07d3 }
        r1 = r65;	 Catch:{ all -> 0x07d3 }
        r0.<init>(r4, r1);	 Catch:{ all -> 0x07d3 }
        r4 = "PackageManager";	 Catch:{ all -> 0x07d3 }
        r6 = new java.lang.StringBuilder;	 Catch:{ all -> 0x07d3 }
        r6.<init>();	 Catch:{ all -> 0x07d3 }
        r8 = "Load Regionalization 3rd apks of path ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r8 = r17.getPath();	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r6 = r6.toString();	 Catch:{ all -> 0x07d3 }
        android.util.Log.d(r4, r6);	 Catch:{ all -> 0x07d3 }
        r0 = r80;	 Catch:{ all -> 0x07d3 }
        r0 = r0 | 1024;	 Catch:{ all -> 0x07d3 }
        r19 = r0;	 Catch:{ all -> 0x07d3 }
        r20 = 0;	 Catch:{ all -> 0x07d3 }
        r18 = 0;	 Catch:{ all -> 0x07d3 }
        r16 = r101;	 Catch:{ all -> 0x07d3 }
        r16.scanDirLI(r17, r18, r19, r20);	 Catch:{ all -> 0x07d3 }
        goto L_0x0dc4;	 Catch:{ all -> 0x07d3 }
    L_0x0e0b:
        r0 = r89;	 Catch:{ all -> 0x07d3 }
        r0 = (long) r0;	 Catch:{ all -> 0x07d3 }
        r22 = r0;	 Catch:{ all -> 0x07d3 }
        r22 = r90 / r22;	 Catch:{ all -> 0x07d3 }
        goto L_0x0d37;	 Catch:{ all -> 0x07d3 }
    L_0x0e14:
        r45 = r75.iterator();	 Catch:{ all -> 0x07d3 }
    L_0x0e18:
        r4 = r45.hasNext();	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0e9f;	 Catch:{ all -> 0x07d3 }
    L_0x0e1e:
        r44 = r45.next();	 Catch:{ all -> 0x07d3 }
        r44 = (java.lang.String) r44;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mPackages;	 Catch:{ all -> 0x07d3 }
        r0 = r44;	 Catch:{ all -> 0x07d3 }
        r46 = r4.get(r0);	 Catch:{ all -> 0x07d3 }
        r46 = (android.content.pm.PackageParser.Package) r46;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r0 = r44;	 Catch:{ all -> 0x07d3 }
        r4.removeDisabledSystemPackageLPw(r0);	 Catch:{ all -> 0x07d3 }
        if (r46 != 0) goto L_0x0e5f;	 Catch:{ all -> 0x07d3 }
    L_0x0e3b:
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x07d3 }
        r4.<init>();	 Catch:{ all -> 0x07d3 }
        r6 = "Updated system package ";	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r0 = r44;	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r0);	 Catch:{ all -> 0x07d3 }
        r6 = " no longer exists; removing its data";	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r63 = r4.toString();	 Catch:{ all -> 0x07d3 }
    L_0x0e58:
        r4 = 5;	 Catch:{ all -> 0x07d3 }
        r0 = r63;	 Catch:{ all -> 0x07d3 }
        logCriticalInfo(r4, r0);	 Catch:{ all -> 0x07d3 }
        goto L_0x0e18;	 Catch:{ all -> 0x07d3 }
    L_0x0e5f:
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x07d3 }
        r4.<init>();	 Catch:{ all -> 0x07d3 }
        r6 = "Updated system package + ";	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r0 = r44;	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r0);	 Catch:{ all -> 0x07d3 }
        r6 = " no longer exists; revoking system privileges";	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r63 = r4.toString();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r4 = r4.mPackages;	 Catch:{ all -> 0x07d3 }
        r0 = r44;	 Catch:{ all -> 0x07d3 }
        r47 = r4.get(r0);	 Catch:{ all -> 0x07d3 }
        r47 = (com.android.server.pm.PackageSetting) r47;	 Catch:{ all -> 0x07d3 }
        r0 = r46;	 Catch:{ all -> 0x07d3 }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x07d3 }
        r6 = r4.flags;	 Catch:{ all -> 0x07d3 }
        r6 = r6 & -2;	 Catch:{ all -> 0x07d3 }
        r4.flags = r6;	 Catch:{ all -> 0x07d3 }
        r0 = r47;	 Catch:{ all -> 0x07d3 }
        r4 = r0.pkgFlags;	 Catch:{ all -> 0x07d3 }
        r4 = r4 & -2;	 Catch:{ all -> 0x07d3 }
        r0 = r47;	 Catch:{ all -> 0x07d3 }
        r0.pkgFlags = r4;	 Catch:{ all -> 0x07d3 }
        goto L_0x0e58;	 Catch:{ all -> 0x07d3 }
    L_0x0e9f:
        r58 = 0;	 Catch:{ all -> 0x07d3 }
    L_0x0ea1:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mExpectingBetter;	 Catch:{ all -> 0x07d3 }
        r4 = r4.size();	 Catch:{ all -> 0x07d3 }
        r0 = r58;	 Catch:{ all -> 0x07d3 }
        if (r0 >= r4) goto L_0x0f77;	 Catch:{ all -> 0x07d3 }
    L_0x0ead:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mExpectingBetter;	 Catch:{ all -> 0x07d3 }
        r0 = r58;	 Catch:{ all -> 0x07d3 }
        r67 = r4.keyAt(r0);	 Catch:{ all -> 0x07d3 }
        r67 = (java.lang.String) r67;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mPackages;	 Catch:{ all -> 0x07d3 }
        r0 = r67;	 Catch:{ all -> 0x07d3 }
        r4 = r4.containsKey(r0);	 Catch:{ all -> 0x07d3 }
        if (r4 != 0) goto L_0x0f16;	 Catch:{ all -> 0x07d3 }
    L_0x0ec5:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mExpectingBetter;	 Catch:{ all -> 0x07d3 }
        r0 = r58;	 Catch:{ all -> 0x07d3 }
        r19 = r4.valueAt(r0);	 Catch:{ all -> 0x07d3 }
        r19 = (java.io.File) r19;	 Catch:{ all -> 0x07d3 }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x07d3 }
        r4.<init>();	 Catch:{ all -> 0x07d3 }
        r6 = "Expected better ";	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r0 = r67;	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r0);	 Catch:{ all -> 0x07d3 }
        r6 = " but never showed up; reverting to system";	 Catch:{ all -> 0x07d3 }
        r4 = r4.append(r6);	 Catch:{ all -> 0x07d3 }
        r4 = r4.toString();	 Catch:{ all -> 0x07d3 }
        r6 = 5;	 Catch:{ all -> 0x07d3 }
        logCriticalInfo(r6, r4);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0 = r0.mDefParseFlags;	 Catch:{ all -> 0x07d3 }
        r20 = r0;	 Catch:{ all -> 0x07d3 }
        r0 = r19;	 Catch:{ all -> 0x07d3 }
        r4 = android.os.FileUtils.contains(r9, r0);	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0f19;	 Catch:{ all -> 0x07d3 }
    L_0x0f00:
        r20 = 193; // 0xc1 float:2.7E-43 double:9.54E-322;	 Catch:{ all -> 0x07d3 }
    L_0x0f02:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r0 = r67;	 Catch:{ all -> 0x07d3 }
        r4.enableSystemPackageLPw(r0);	 Catch:{ all -> 0x07d3 }
        r22 = 0;
        r24 = 0;
        r18 = r101;
        r21 = r80;
        r18.scanPackageTracedLI(r19, r20, r21, r22, r24);	 Catch:{ PackageManagerException -> 0x0f57 }
    L_0x0f16:
        r58 = r58 + 1;
        goto L_0x0ea1;
    L_0x0f19:
        r0 = r19;	 Catch:{ all -> 0x07d3 }
        r4 = android.os.FileUtils.contains(r11, r0);	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0f24;	 Catch:{ all -> 0x07d3 }
    L_0x0f21:
        r20 = 65;	 Catch:{ all -> 0x07d3 }
        goto L_0x0f02;	 Catch:{ all -> 0x07d3 }
    L_0x0f24:
        r0 = r19;	 Catch:{ all -> 0x07d3 }
        r4 = android.os.FileUtils.contains(r13, r0);	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0f2f;	 Catch:{ all -> 0x07d3 }
    L_0x0f2c:
        r20 = 65;	 Catch:{ all -> 0x07d3 }
        goto L_0x0f02;	 Catch:{ all -> 0x07d3 }
    L_0x0f2f:
        r0 = r19;	 Catch:{ all -> 0x07d3 }
        r4 = android.os.FileUtils.contains(r15, r0);	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0f3a;	 Catch:{ all -> 0x07d3 }
    L_0x0f37:
        r20 = 65;	 Catch:{ all -> 0x07d3 }
        goto L_0x0f02;	 Catch:{ all -> 0x07d3 }
    L_0x0f3a:
        r4 = "PackageManager";	 Catch:{ all -> 0x07d3 }
        r6 = new java.lang.StringBuilder;	 Catch:{ all -> 0x07d3 }
        r6.<init>();	 Catch:{ all -> 0x07d3 }
        r8 = "Ignoring unexpected fallback path ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r0 = r19;	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r0);	 Catch:{ all -> 0x07d3 }
        r6 = r6.toString();	 Catch:{ all -> 0x07d3 }
        android.util.Slog.e(r4, r6);	 Catch:{ all -> 0x07d3 }
        goto L_0x0f16;	 Catch:{ all -> 0x07d3 }
    L_0x0f57:
        r49 = move-exception;	 Catch:{ all -> 0x07d3 }
        r4 = "PackageManager";	 Catch:{ all -> 0x07d3 }
        r6 = new java.lang.StringBuilder;	 Catch:{ all -> 0x07d3 }
        r6.<init>();	 Catch:{ all -> 0x07d3 }
        r8 = "Failed to parse original system package: ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r8 = r49.getMessage();	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r6 = r6.toString();	 Catch:{ all -> 0x07d3 }
        android.util.Slog.e(r4, r6);	 Catch:{ all -> 0x07d3 }
        goto L_0x0f16;	 Catch:{ all -> 0x07d3 }
    L_0x0f77:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r1 = r85;	 Catch:{ all -> 0x07d3 }
        r2 = r80;	 Catch:{ all -> 0x07d3 }
        r0.decompressSystemApplications(r1, r2);	 Catch:{ all -> 0x07d3 }
        r4 = android.content.pm.PackageParser.sCachedPackageReadCount;	 Catch:{ all -> 0x07d3 }
        r4 = r4.get();	 Catch:{ all -> 0x07d3 }
        r32 = r4 - r33;	 Catch:{ all -> 0x07d3 }
        r22 = android.os.SystemClock.uptimeMillis();	 Catch:{ all -> 0x07d3 }
        r22 = r22 - r90;	 Catch:{ all -> 0x07d3 }
        r40 = r22 - r86;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mPackages;	 Catch:{ all -> 0x07d3 }
        r4 = r4.size();	 Catch:{ all -> 0x07d3 }
        r39 = r4 - r89;	 Catch:{ all -> 0x07d3 }
        r4 = "PackageManager";	 Catch:{ all -> 0x07d3 }
        r6 = new java.lang.StringBuilder;	 Catch:{ all -> 0x07d3 }
        r6.<init>();	 Catch:{ all -> 0x07d3 }
        r8 = "Finished scanning non-system apps. Time: ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r0 = r40;	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r0);	 Catch:{ all -> 0x07d3 }
        r8 = " ms, packageCount: ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r0 = r39;	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r0);	 Catch:{ all -> 0x07d3 }
        r8 = " , timePerPackage: ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        if (r39 != 0) goto L_0x1043;	 Catch:{ all -> 0x07d3 }
    L_0x0fc5:
        r22 = 0;	 Catch:{ all -> 0x07d3 }
    L_0x0fc7:
        r0 = r22;	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r0);	 Catch:{ all -> 0x07d3 }
        r8 = " , cached: ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r0 = r32;	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r0);	 Catch:{ all -> 0x07d3 }
        r6 = r6.toString();	 Catch:{ all -> 0x07d3 }
        android.util.Slog.i(r4, r6);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mIsUpgrade;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x0ff5;	 Catch:{ all -> 0x07d3 }
    L_0x0fe7:
        if (r39 <= 0) goto L_0x0ff5;	 Catch:{ all -> 0x07d3 }
    L_0x0fe9:
        r4 = "ota_package_manager_data_app_avg_scan_time";	 Catch:{ all -> 0x07d3 }
        r0 = r40;	 Catch:{ all -> 0x07d3 }
        r6 = (int) r0;	 Catch:{ all -> 0x07d3 }
        r6 = r6 / r39;	 Catch:{ all -> 0x07d3 }
        r8 = 0;	 Catch:{ all -> 0x07d3 }
        com.android.internal.logging.MetricsLogger.histogram(r8, r4, r6);	 Catch:{ all -> 0x07d3 }
    L_0x0ff5:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mExpectingBetter;	 Catch:{ all -> 0x07d3 }
        r4.clear();	 Catch:{ all -> 0x07d3 }
        r4 = r101.getStorageManagerPackageName();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mStorageManagerPackage = r4;	 Catch:{ all -> 0x07d3 }
        r4 = r101.getSetupWizardPackageName();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mSetupWizardPackage = r4;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mProtectedFilters;	 Catch:{ all -> 0x07d3 }
        r4 = r4.size();	 Catch:{ all -> 0x07d3 }
        if (r4 <= 0) goto L_0x104c;	 Catch:{ all -> 0x07d3 }
    L_0x1016:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mProtectedFilters;	 Catch:{ all -> 0x07d3 }
        r55 = r4.iterator();	 Catch:{ all -> 0x07d3 }
    L_0x101e:
        r4 = r55.hasNext();	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x104c;	 Catch:{ all -> 0x07d3 }
    L_0x1024:
        r54 = r55.next();	 Catch:{ all -> 0x07d3 }
        r54 = (android.content.pm.PackageParser.ActivityIntentInfo) r54;	 Catch:{ all -> 0x07d3 }
        r0 = r54;	 Catch:{ all -> 0x07d3 }
        r4 = r0.activity;	 Catch:{ all -> 0x07d3 }
        r4 = r4.info;	 Catch:{ all -> 0x07d3 }
        r4 = r4.packageName;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r6 = r0.mSetupWizardPackage;	 Catch:{ all -> 0x07d3 }
        r4 = r4.equals(r6);	 Catch:{ all -> 0x07d3 }
        if (r4 != 0) goto L_0x101e;	 Catch:{ all -> 0x07d3 }
    L_0x103c:
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r54;	 Catch:{ all -> 0x07d3 }
        r0.setPriority(r4);	 Catch:{ all -> 0x07d3 }
        goto L_0x101e;	 Catch:{ all -> 0x07d3 }
    L_0x1043:
        r0 = r39;	 Catch:{ all -> 0x07d3 }
        r0 = (long) r0;	 Catch:{ all -> 0x07d3 }
        r22 = r0;	 Catch:{ all -> 0x07d3 }
        r22 = r40 / r22;	 Catch:{ all -> 0x07d3 }
        goto L_0x0fc7;	 Catch:{ all -> 0x07d3 }
    L_0x104c:
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mDeferProtectedFilters = r4;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mProtectedFilters;	 Catch:{ all -> 0x07d3 }
        r4.clear();	 Catch:{ all -> 0x07d3 }
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.updateAllSharedLibrariesLPw(r4);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r4 = r4.getAllSharedUsersLPw();	 Catch:{ all -> 0x07d3 }
        r84 = r4.iterator();	 Catch:{ all -> 0x07d3 }
    L_0x106a:
        r4 = r84.hasNext();	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x1081;	 Catch:{ all -> 0x07d3 }
    L_0x1070:
        r83 = r84.next();	 Catch:{ all -> 0x07d3 }
        r83 = (com.android.server.pm.SharedUserSetting) r83;	 Catch:{ all -> 0x07d3 }
        r0 = r83;	 Catch:{ all -> 0x07d3 }
        r4 = r0.packages;	 Catch:{ all -> 0x07d3 }
        r6 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.adjustCpuAbisForSharedUserLPw(r4, r6);	 Catch:{ all -> 0x07d3 }
        goto L_0x106a;	 Catch:{ all -> 0x07d3 }
    L_0x1081:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mPackageUsage;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r6 = r0.mPackages;	 Catch:{ all -> 0x07d3 }
        r4.read(r6);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mCompilerStats;	 Catch:{ all -> 0x07d3 }
        r4.read();	 Catch:{ all -> 0x07d3 }
        r22 = android.os.SystemClock.uptimeMillis();	 Catch:{ all -> 0x07d3 }
        r4 = 3090; // 0xc12 float:4.33E-42 double:1.5267E-320;	 Catch:{ all -> 0x07d3 }
        r0 = r22;	 Catch:{ all -> 0x07d3 }
        android.util.EventLog.writeEvent(r4, r0);	 Catch:{ all -> 0x07d3 }
        r4 = "persist.sys.oppo.scanstage";	 Catch:{ all -> 0x07d3 }
        r6 = "2";	 Catch:{ all -> 0x07d3 }
        android.os.SystemProperties.set(r4, r6);	 Catch:{ all -> 0x07d3 }
        r4 = "PackageManager";	 Catch:{ all -> 0x07d3 }
        r6 = new java.lang.StringBuilder;	 Catch:{ all -> 0x07d3 }
        r6.<init>();	 Catch:{ all -> 0x07d3 }
        r8 = "Time to scan packages: ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r22 = android.os.SystemClock.uptimeMillis();	 Catch:{ all -> 0x07d3 }
        r22 = r22 - r86;	 Catch:{ all -> 0x07d3 }
        r0 = r22;	 Catch:{ all -> 0x07d3 }
        r8 = (float) r0;	 Catch:{ all -> 0x07d3 }
        r10 = 1148846080; // 0x447a0000 float:1000.0 double:5.676053805E-315;	 Catch:{ all -> 0x07d3 }
        r8 = r8 / r10;	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r8 = " seconds";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r6 = r6.toString();	 Catch:{ all -> 0x07d3 }
        android.util.Slog.i(r4, r6);	 Catch:{ all -> 0x07d3 }
        r93 = 1;	 Catch:{ all -> 0x07d3 }
        r0 = r98;	 Catch:{ all -> 0x07d3 }
        r4 = r0.sdkVersion;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r6 = r0.mSdkVersion;	 Catch:{ all -> 0x07d3 }
        if (r4 == r6) goto L_0x1116;	 Catch:{ all -> 0x07d3 }
    L_0x10e0:
        r4 = "PackageManager";	 Catch:{ all -> 0x07d3 }
        r6 = new java.lang.StringBuilder;	 Catch:{ all -> 0x07d3 }
        r6.<init>();	 Catch:{ all -> 0x07d3 }
        r8 = "Platform changed from ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r0 = r98;	 Catch:{ all -> 0x07d3 }
        r8 = r0.sdkVersion;	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r8 = " to ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r8 = r0.mSdkVersion;	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r8 = "; regranting permissions for internal storage";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r6 = r6.toString();	 Catch:{ all -> 0x07d3 }
        android.util.Slog.i(r4, r6);	 Catch:{ all -> 0x07d3 }
        r93 = 7;	 Catch:{ all -> 0x07d3 }
    L_0x1116:
        r4 = android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL;	 Catch:{ all -> 0x07d3 }
        r6 = 0;	 Catch:{ all -> 0x07d3 }
        r8 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r1 = r93;	 Catch:{ all -> 0x07d3 }
        r0.updatePermissionsLPw(r6, r8, r4, r1);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSdkVersion;	 Catch:{ all -> 0x07d3 }
        r0 = r98;	 Catch:{ all -> 0x07d3 }
        r0.sdkVersion = r4;	 Catch:{ all -> 0x07d3 }
        if (r105 != 0) goto L_0x116e;	 Catch:{ all -> 0x07d3 }
    L_0x112b:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mPromoteSystemApps;	 Catch:{ all -> 0x07d3 }
        if (r4 != 0) goto L_0x1137;	 Catch:{ all -> 0x07d3 }
    L_0x1131:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mFirstBoot;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x116e;	 Catch:{ all -> 0x07d3 }
    L_0x1137:
        r4 = sUserManager;	 Catch:{ all -> 0x07d3 }
        r6 = 1;	 Catch:{ all -> 0x07d3 }
        r4 = r4.getUsers(r6);	 Catch:{ all -> 0x07d3 }
        r95 = r4.iterator();	 Catch:{ all -> 0x07d3 }
    L_0x1142:
        r4 = r95.hasNext();	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x116e;	 Catch:{ all -> 0x07d3 }
    L_0x1148:
        r94 = r95.next();	 Catch:{ all -> 0x07d3 }
        r94 = (android.content.pm.UserInfo) r94;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r0 = r94;	 Catch:{ all -> 0x07d3 }
        r6 = r0.id;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4.applyDefaultPreferredAppsLPw(r0, r6);	 Catch:{ all -> 0x07d3 }
        r0 = r94;	 Catch:{ all -> 0x07d3 }
        r4 = r0.id;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.applyFactoryDefaultBrowserLPw(r4);	 Catch:{ all -> 0x07d3 }
        r0 = r94;	 Catch:{ all -> 0x07d3 }
        r4 = r0.id;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.primeDomainVerificationsLPw(r4);	 Catch:{ all -> 0x07d3 }
        goto L_0x1142;	 Catch:{ all -> 0x07d3 }
    L_0x116e:
        r4 = android.os.storage.StorageManager.isFileEncryptedNativeOrEmulated();	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x1212;	 Catch:{ all -> 0x07d3 }
    L_0x1174:
        r24 = 1;	 Catch:{ all -> 0x07d3 }
    L_0x1176:
        r4 = r101.isFirstBoot();	 Catch:{ all -> 0x07d3 }
        if (r4 != 0) goto L_0x1194;	 Catch:{ all -> 0x07d3 }
    L_0x117c:
        r4 = r101.isUpgrade();	 Catch:{ all -> 0x07d3 }
        if (r4 != 0) goto L_0x1194;	 Catch:{ all -> 0x07d3 }
    L_0x1182:
        r4 = r101.isBootFromOTA();	 Catch:{ all -> 0x07d3 }
        if (r4 != 0) goto L_0x1194;	 Catch:{ all -> 0x07d3 }
    L_0x1188:
        r4 = "persist.sys.reconcile.finish";	 Catch:{ all -> 0x07d3 }
        r6 = 0;	 Catch:{ all -> 0x07d3 }
        r4 = android.os.SystemProperties.getBoolean(r4, r6);	 Catch:{ all -> 0x07d3 }
        r4 = r4 ^ 1;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x11c6;	 Catch:{ all -> 0x07d3 }
    L_0x1194:
        r4 = "persist.sys.reconcile.finish";	 Catch:{ all -> 0x07d3 }
        r6 = "false";	 Catch:{ all -> 0x07d3 }
        android.os.SystemProperties.set(r4, r6);	 Catch:{ all -> 0x07d3 }
        r22 = android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL;	 Catch:{ all -> 0x07d3 }
        r23 = 0;	 Catch:{ all -> 0x07d3 }
        r25 = 1;	 Catch:{ all -> 0x07d3 }
        r26 = 1;	 Catch:{ all -> 0x07d3 }
        r21 = r101;	 Catch:{ all -> 0x07d3 }
        r42 = r21.reconcileAppsDataLI(r22, r23, r24, r25, r26);	 Catch:{ all -> 0x07d3 }
        r4 = com.android.server.SystemServerInitThreadPool.get();	 Catch:{ all -> 0x07d3 }
        r6 = new com.android.server.pm.-$Lambda$i1ZZeLvwPPAZVBl_nnQ0C2t5oMs;	 Catch:{ all -> 0x07d3 }
        r8 = 1;	 Catch:{ all -> 0x07d3 }
        r0 = r24;	 Catch:{ all -> 0x07d3 }
        r1 = r101;	 Catch:{ all -> 0x07d3 }
        r2 = r42;	 Catch:{ all -> 0x07d3 }
        r6.<init>(r8, r0, r1, r2);	 Catch:{ all -> 0x07d3 }
        r8 = "prepareAppData";	 Catch:{ all -> 0x07d3 }
        r4 = r4.submit(r6, r8);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mPrepareAppDataFuture = r4;	 Catch:{ all -> 0x07d3 }
    L_0x11c6:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mIsUpgrade;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x121c;	 Catch:{ all -> 0x07d3 }
    L_0x11cc:
        r4 = r105 ^ 1;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x121c;	 Catch:{ all -> 0x07d3 }
    L_0x11d0:
        r4 = "PackageManager";	 Catch:{ all -> 0x07d3 }
        r6 = "Build fingerprint changed; clearing code caches";	 Catch:{ all -> 0x07d3 }
        android.util.Slog.i(r4, r6);	 Catch:{ all -> 0x07d3 }
        r58 = 0;	 Catch:{ all -> 0x07d3 }
    L_0x11db:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r4 = r4.mPackages;	 Catch:{ all -> 0x07d3 }
        r4 = r4.size();	 Catch:{ all -> 0x07d3 }
        r0 = r58;	 Catch:{ all -> 0x07d3 }
        if (r0 >= r4) goto L_0x1216;	 Catch:{ all -> 0x07d3 }
    L_0x11e9:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r4 = r4.mPackages;	 Catch:{ all -> 0x07d3 }
        r0 = r58;	 Catch:{ all -> 0x07d3 }
        r76 = r4.valueAt(r0);	 Catch:{ all -> 0x07d3 }
        r76 = (com.android.server.pm.PackageSetting) r76;	 Catch:{ all -> 0x07d3 }
        r4 = android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL;	 Catch:{ all -> 0x07d3 }
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r6 = r0.volumeUuid;	 Catch:{ all -> 0x07d3 }
        r4 = java.util.Objects.equals(r4, r6);	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x120f;	 Catch:{ all -> 0x07d3 }
    L_0x1203:
        r0 = r76;	 Catch:{ all -> 0x07d3 }
        r4 = r0.pkg;	 Catch:{ all -> 0x07d3 }
        r6 = -1;	 Catch:{ all -> 0x07d3 }
        r8 = 515; // 0x203 float:7.22E-43 double:2.544E-321;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.clearAppDataLIF(r4, r6, r8);	 Catch:{ all -> 0x07d3 }
    L_0x120f:
        r58 = r58 + 1;	 Catch:{ all -> 0x07d3 }
        goto L_0x11db;	 Catch:{ all -> 0x07d3 }
    L_0x1212:
        r24 = 3;	 Catch:{ all -> 0x07d3 }
        goto L_0x1176;	 Catch:{ all -> 0x07d3 }
    L_0x1216:
        r4 = android.os.Build.FINGERPRINT;	 Catch:{ all -> 0x07d3 }
        r0 = r98;	 Catch:{ all -> 0x07d3 }
        r0.fingerprint = r4;	 Catch:{ all -> 0x07d3 }
    L_0x121c:
        r101.checkDefaultBrowser();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mExistingSystemPackages;	 Catch:{ all -> 0x07d3 }
        r4.clear();	 Catch:{ all -> 0x07d3 }
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mPromoteSystemApps = r4;	 Catch:{ all -> 0x07d3 }
        r4 = 3;	 Catch:{ all -> 0x07d3 }
        r0 = r98;	 Catch:{ all -> 0x07d3 }
        r0.databaseVersion = r4;	 Catch:{ all -> 0x07d3 }
        r4 = "write settings";	 Catch:{ all -> 0x07d3 }
        r22 = 262144; // 0x40000 float:3.67342E-40 double:1.295163E-318;	 Catch:{ all -> 0x07d3 }
        r0 = r22;	 Catch:{ all -> 0x07d3 }
        android.os.Trace.traceBegin(r0, r4);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x07d3 }
        r4.writeLPr();	 Catch:{ all -> 0x07d3 }
        r22 = 262144; // 0x40000 float:3.67342E-40 double:1.295163E-318;	 Catch:{ all -> 0x07d3 }
        android.os.Trace.traceEnd(r22);	 Catch:{ all -> 0x07d3 }
        r22 = android.os.SystemClock.uptimeMillis();	 Catch:{ all -> 0x07d3 }
        r4 = 3100; // 0xc1c float:4.344E-42 double:1.5316E-320;	 Catch:{ all -> 0x07d3 }
        r0 = r22;	 Catch:{ all -> 0x07d3 }
        android.util.EventLog.writeEvent(r4, r0);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mOnlyCore;	 Catch:{ all -> 0x07d3 }
        if (r4 != 0) goto L_0x134d;	 Catch:{ all -> 0x07d3 }
    L_0x1259:
        r4 = r101.getRequiredButNotReallyRequiredVerifierLPr();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mRequiredVerifierPackage = r4;	 Catch:{ all -> 0x07d3 }
        r4 = r101.getOptionalVerifierLPr();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mOptionalVerifierPackage = r4;	 Catch:{ all -> 0x07d3 }
        r4 = r101.getRequiredInstallerLPr();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mRequiredInstallerPackage = r4;	 Catch:{ all -> 0x07d3 }
        r4 = r101.getRequiredUninstallerLPr();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mRequiredUninstallerPackage = r4;	 Catch:{ all -> 0x07d3 }
        r4 = r101.getIntentFilterVerifierComponentNameLPr();	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mIntentFilterVerifierComponent = r4;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mIntentFilterVerifierComponent;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x1346;	 Catch:{ all -> 0x07d3 }
    L_0x1287:
        r4 = new com.android.server.pm.PackageManagerService$IntentVerifierProxy;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r6 = r0.mContext;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r8 = r0.mIntentFilterVerifierComponent;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4.<init>(r6, r8);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mIntentFilterVerifier = r4;	 Catch:{ all -> 0x07d3 }
    L_0x129a:
        r4 = "android.ext.services";	 Catch:{ all -> 0x07d3 }
        r6 = -1;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.getRequiredSharedLibraryLPr(r4, r6);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mServicesSystemSharedLibraryPackageName = r4;	 Catch:{ all -> 0x07d3 }
        r4 = "android.ext.shared";	 Catch:{ all -> 0x07d3 }
        r6 = -1;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.getRequiredSharedLibraryLPr(r4, r6);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mSharedSystemSharedLibraryPackageName = r4;	 Catch:{ all -> 0x07d3 }
    L_0x12b6:
        r4 = new com.android.server.pm.PackageInstallerService;	 Catch:{ all -> 0x07d3 }
        r0 = r102;	 Catch:{ all -> 0x07d3 }
        r1 = r101;	 Catch:{ all -> 0x07d3 }
        r4.<init>(r0, r1);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mInstallerService = r4;	 Catch:{ all -> 0x07d3 }
        r59 = r101.getInstantAppResolverLPr();	 Catch:{ all -> 0x07d3 }
        if (r59 == 0) goto L_0x1377;	 Catch:{ all -> 0x07d3 }
    L_0x12c9:
        r4 = DEBUG_EPHEMERAL;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x12e9;	 Catch:{ all -> 0x07d3 }
    L_0x12cd:
        r4 = "PackageManager";	 Catch:{ all -> 0x07d3 }
        r6 = new java.lang.StringBuilder;	 Catch:{ all -> 0x07d3 }
        r6.<init>();	 Catch:{ all -> 0x07d3 }
        r8 = "Set ephemeral resolver: ";	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r8);	 Catch:{ all -> 0x07d3 }
        r0 = r59;	 Catch:{ all -> 0x07d3 }
        r6 = r6.append(r0);	 Catch:{ all -> 0x07d3 }
        r6 = r6.toString();	 Catch:{ all -> 0x07d3 }
        android.util.Slog.d(r4, r6);	 Catch:{ all -> 0x07d3 }
    L_0x12e9:
        r8 = new com.android.server.pm.EphemeralResolverConnection;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r10 = r0.mContext;	 Catch:{ all -> 0x07d3 }
        r0 = r59;	 Catch:{ all -> 0x07d3 }
        r4 = r0.first;	 Catch:{ all -> 0x07d3 }
        r4 = (android.content.ComponentName) r4;	 Catch:{ all -> 0x07d3 }
        r0 = r59;	 Catch:{ all -> 0x07d3 }
        r6 = r0.second;	 Catch:{ all -> 0x07d3 }
        r6 = (java.lang.String) r6;	 Catch:{ all -> 0x07d3 }
        r8.<init>(r10, r4, r6);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mInstantAppResolverConnection = r8;	 Catch:{ all -> 0x07d3 }
        r0 = r59;	 Catch:{ all -> 0x07d3 }
        r4 = r0.first;	 Catch:{ all -> 0x07d3 }
        r4 = (android.content.ComponentName) r4;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.getInstantAppResolverSettingsLPr(r4);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mInstantAppResolverSettingsComponent = r4;	 Catch:{ all -> 0x07d3 }
    L_0x1312:
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.updateInstantAppInstallerLocked(r4);	 Catch:{ all -> 0x07d3 }
        r97 = new java.util.HashMap;	 Catch:{ all -> 0x07d3 }
        r97.<init>();	 Catch:{ all -> 0x07d3 }
        r4 = com.android.server.pm.UserManagerService.getInstance();	 Catch:{ all -> 0x07d3 }
        r35 = r4.getUserIds();	 Catch:{ all -> 0x07d3 }
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r35;	 Catch:{ all -> 0x07d3 }
        r6 = r0.length;	 Catch:{ all -> 0x07d3 }
    L_0x1329:
        if (r4 >= r6) goto L_0x1382;	 Catch:{ all -> 0x07d3 }
    L_0x132b:
        r96 = r35[r4];	 Catch:{ all -> 0x07d3 }
        r8 = java.lang.Integer.valueOf(r96);	 Catch:{ all -> 0x07d3 }
        r10 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r1 = r96;	 Catch:{ all -> 0x07d3 }
        r10 = r0.getInstalledPackages(r10, r1);	 Catch:{ all -> 0x07d3 }
        r10 = r10.getList();	 Catch:{ all -> 0x07d3 }
        r0 = r97;	 Catch:{ all -> 0x07d3 }
        r0.put(r8, r10);	 Catch:{ all -> 0x07d3 }
        r4 = r4 + 1;	 Catch:{ all -> 0x07d3 }
        goto L_0x1329;	 Catch:{ all -> 0x07d3 }
    L_0x1346:
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mIntentFilterVerifier = r4;	 Catch:{ all -> 0x07d3 }
        goto L_0x129a;	 Catch:{ all -> 0x07d3 }
    L_0x134d:
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mRequiredVerifierPackage = r4;	 Catch:{ all -> 0x07d3 }
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mOptionalVerifierPackage = r4;	 Catch:{ all -> 0x07d3 }
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mRequiredInstallerPackage = r4;	 Catch:{ all -> 0x07d3 }
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mRequiredUninstallerPackage = r4;	 Catch:{ all -> 0x07d3 }
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mIntentFilterVerifierComponent = r4;	 Catch:{ all -> 0x07d3 }
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mIntentFilterVerifier = r4;	 Catch:{ all -> 0x07d3 }
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mServicesSystemSharedLibraryPackageName = r4;	 Catch:{ all -> 0x07d3 }
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mSharedSystemSharedLibraryPackageName = r4;	 Catch:{ all -> 0x07d3 }
        goto L_0x12b6;	 Catch:{ all -> 0x07d3 }
    L_0x1377:
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mInstantAppResolverConnection = r4;	 Catch:{ all -> 0x07d3 }
        r4 = 0;	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r0.mInstantAppResolverSettingsComponent = r4;	 Catch:{ all -> 0x07d3 }
        goto L_0x1312;	 Catch:{ all -> 0x07d3 }
    L_0x1382:
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mDexManager;	 Catch:{ all -> 0x07d3 }
        r0 = r97;	 Catch:{ all -> 0x07d3 }
        r4.load(r0);	 Catch:{ all -> 0x07d3 }
        r0 = r101;	 Catch:{ all -> 0x07d3 }
        r4 = r0.mIsUpgrade;	 Catch:{ all -> 0x07d3 }
        if (r4 == 0) goto L_0x13a1;	 Catch:{ all -> 0x07d3 }
    L_0x1391:
        r4 = "ota_package_manager_init_time";	 Catch:{ all -> 0x07d3 }
        r22 = android.os.SystemClock.uptimeMillis();	 Catch:{ all -> 0x07d3 }
        r22 = r22 - r86;	 Catch:{ all -> 0x07d3 }
        r0 = r22;	 Catch:{ all -> 0x07d3 }
        r6 = (int) r0;	 Catch:{ all -> 0x07d3 }
        r8 = 0;	 Catch:{ all -> 0x07d3 }
        com.android.internal.logging.MetricsLogger.histogram(r8, r4, r6);	 Catch:{ all -> 0x07d3 }
    L_0x13a1:
        monitor-exit(r100);	 Catch:{ all -> 0x07d6 }
        monitor-exit(r99);
        r4 = com.android.server.pm.OppoAdbInstallerManager.getInstance();
        r0 = r101;
        r4.init(r0);
        r0 = r101;
        r4 = r0.mOppoScimProtection;
        if (r4 != 0) goto L_0x13be;
    L_0x13b2:
        r0 = r101;
        r4 = r0.mContext;
        r4 = com.android.server.pm.OppoDcimProtectionService.getInstall(r4);
        r0 = r101;
        r0.mOppoScimProtection = r4;
    L_0x13be:
        r4 = "GC";
        r22 = 262144; // 0x40000 float:3.67342E-40 double:1.295163E-318;
        r0 = r22;
        android.os.Trace.traceBegin(r0, r4);
        r4 = java.lang.Runtime.getRuntime();
        r4.gc();
        r22 = 262144; // 0x40000 float:3.67342E-40 double:1.295163E-318;
        android.os.Trace.traceEnd(r22);
        r4 = "loadFallbacks";
        r22 = 262144; // 0x40000 float:3.67342E-40 double:1.295163E-318;
        r0 = r22;
        android.os.Trace.traceBegin(r0, r4);
        android.content.pm.FallbackCategoryProvider.loadFallbacks();
        r22 = 262144; // 0x40000 float:3.67342E-40 double:1.295163E-318;
        android.os.Trace.traceEnd(r22);
        r0 = r101;
        r4 = r0.mInstaller;
        r0 = r101;
        r6 = r0.mPackages;
        r4.setWarnIfHeld(r6);
        r4 = android.content.pm.PackageManagerInternal.class;
        r6 = new com.android.server.pm.PackageManagerService$PackageManagerInternalImpl;
        r8 = 0;
        r0 = r101;
        r6.<init>(r0, r8);
        com.android.server.LocalServices.addService(r4, r6);
        r22 = 262144; // 0x40000 float:3.67342E-40 double:1.295163E-318;
        android.os.Trace.traceEnd(r22);
        return;
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.pm.PackageManagerService.<init>(android.content.Context, com.android.server.pm.Installer, boolean, boolean):void");
    }

    /* synthetic */ void lambda$-com_android_server_pm_PackageManagerService_172800(List deferPackages, int storageFlags) {
        TimingsTraceLog traceLog = new TimingsTraceLog("SystemServerTimingAsync", 262144);
        traceLog.traceBegin("AppDataFixup");
        try {
            this.mInstaller.fixupAppData(StorageManager.UUID_PRIVATE_INTERNAL, 3);
        } catch (InstallerException e) {
            Slog.w(TAG, "Trouble fixing GIDs", e);
        }
        traceLog.traceEnd();
        traceLog.traceBegin("AppDataPrepare");
        if (deferPackages == null || deferPackages.isEmpty()) {
            SystemProperties.set("persist.sys.reconcile.finish", "true");
            return;
        }
        int count = 0;
        for (String pkgName : deferPackages) {
            Package pkg = null;
            synchronized (this.mPackages) {
                PackageSetting ps = this.mSettings.getPackageLPr(pkgName);
                if (ps != null && ps.getInstalled(0)) {
                    pkg = ps.pkg;
                }
            }
            if (pkg != null) {
                synchronized (this.mInstallLock) {
                    prepareAppDataAndMigrateLIF(pkg, 0, storageFlags, true);
                }
                count++;
            }
        }
        SystemProperties.set("persist.sys.reconcile.finish", "true");
        traceLog.traceEnd();
        Slog.i(TAG, "Deferred reconcileAppsData finished " + count + " packages");
    }

    private void decompressSystemApplications(List<String> stubSystemApps, int scanFlags) {
        int i;
        String pkgName;
        for (i = stubSystemApps.size() - 1; i >= 0; i--) {
            pkgName = (String) stubSystemApps.get(i);
            if (this.mSettings.isDisabledSystemPackageLPr(pkgName)) {
                stubSystemApps.remove(i);
            } else {
                Package pkg = (Package) this.mPackages.get(pkgName);
                if (pkg == null) {
                    stubSystemApps.remove(i);
                } else {
                    PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(pkgName);
                    if (ps == null || ps.getEnabled(0) != 3) {
                        if (DEBUG_COMPRESSION) {
                            Slog.i(TAG, "Uncompressing system stub; pkg: " + pkgName);
                        }
                        File scanFile = decompressPackage(pkg);
                        if (scanFile != null) {
                            try {
                                this.mSettings.disableSystemPackageLPw(pkgName, true);
                                removePackageLI(pkg, true);
                                scanPackageTracedLI(scanFile, 0, scanFlags, 0, null);
                                ps.setEnabled(0, 0, PLATFORM_PACKAGE_NAME);
                                stubSystemApps.remove(i);
                            } catch (PackageManagerException e) {
                                Slog.e(TAG, "Failed to parse uncompressed system package: " + e.getMessage());
                            }
                        }
                    } else {
                        stubSystemApps.remove(i);
                    }
                }
            }
        }
        for (i = stubSystemApps.size() - 1; i >= 0; i--) {
            pkgName = (String) stubSystemApps.get(i);
            ((PackageSetting) this.mSettings.mPackages.get(pkgName)).setEnabled(2, 0, PLATFORM_PACKAGE_NAME);
            logCriticalInfo(6, "Stub disabled; pkg: " + pkgName);
        }
    }

    private int decompressFile(File srcFile, File dstFile) throws ErrnoException {
        Throwable th;
        Throwable th2;
        Throwable th3 = null;
        if (DEBUG_COMPRESSION) {
            Slog.i(TAG, "Decompress file; src: " + srcFile.getAbsolutePath() + ", dst: " + dstFile.getAbsolutePath());
        }
        InputStream fileIn = null;
        OutputStream fileOut = null;
        try {
            OutputStream fileOut2;
            InputStream fileIn2 = new GZIPInputStream(new FileInputStream(srcFile));
            try {
                fileOut2 = new FileOutputStream(dstFile, false);
            } catch (Throwable th4) {
                th = th4;
                fileIn = fileIn2;
                if (fileOut != null) {
                    try {
                        fileOut.close();
                    } catch (Throwable th5) {
                        th2 = th5;
                        if (th3 != null) {
                            if (th3 != th2) {
                                th3.addSuppressed(th2);
                                th2 = th3;
                            }
                        }
                    }
                }
                th2 = th3;
                if (fileIn != null) {
                    try {
                        fileIn.close();
                    } catch (Throwable th6) {
                        th3 = th6;
                        if (th2 != null) {
                            if (th2 != th3) {
                                th2.addSuppressed(th3);
                                th3 = th2;
                            }
                        }
                    }
                }
                th3 = th2;
                if (th3 != null) {
                    throw th;
                }
                try {
                    throw th3;
                } catch (IOException e) {
                    logCriticalInfo(6, "Failed to decompress file; src: " + srcFile.getAbsolutePath() + ", dst: " + dstFile.getAbsolutePath());
                    return -110;
                }
            }
            try {
                Streams.copy(fileIn2, fileOut2);
                Os.chmod(dstFile.getAbsolutePath(), 420);
                if (fileOut2 != null) {
                    try {
                        fileOut2.close();
                    } catch (Throwable th7) {
                        th3 = th7;
                    }
                }
                if (fileIn2 != null) {
                    try {
                        fileIn2.close();
                    } catch (Throwable th8) {
                        th = th8;
                        if (th3 != null) {
                            if (th3 != th) {
                                th3.addSuppressed(th);
                                th = th3;
                            }
                        }
                    }
                }
                th = th3;
                if (th == null) {
                    return 1;
                }
                try {
                    throw th;
                } catch (IOException e2) {
                    fileIn = fileIn2;
                }
            } catch (Throwable th9) {
                th = th9;
                fileOut = fileOut2;
                fileIn = fileIn2;
                if (fileOut != null) {
                    try {
                        fileOut.close();
                    } catch (Throwable th52) {
                        th2 = th52;
                        if (th3 != null) {
                            if (th3 != th2) {
                                th3.addSuppressed(th2);
                                th2 = th3;
                            }
                        }
                    }
                }
                th2 = th3;
                if (fileIn != null) {
                    try {
                        fileIn.close();
                    } catch (Throwable th62) {
                        th3 = th62;
                        if (th2 != null) {
                            if (th2 != th3) {
                                th2.addSuppressed(th3);
                                th3 = th2;
                            }
                        }
                    }
                }
                th3 = th2;
                if (th3 != null) {
                    try {
                        throw th3;
                    } catch (IOException e3) {
                        logCriticalInfo(6, "Failed to decompress file; src: " + srcFile.getAbsolutePath() + ", dst: " + dstFile.getAbsolutePath());
                        return -110;
                    }
                }
                throw th;
            }
        } catch (Throwable th10) {
            th = th10;
            if (fileOut != null) {
                try {
                    fileOut.close();
                } catch (Throwable th522) {
                    th2 = th522;
                    if (th3 != null) {
                        if (th3 != th2) {
                            th3.addSuppressed(th2);
                            th2 = th3;
                        }
                    }
                }
            }
            th2 = th3;
            if (fileIn != null) {
                try {
                    fileIn.close();
                } catch (Throwable th622) {
                    th3 = th622;
                    if (th2 != null) {
                        if (th2 != th3) {
                            th2.addSuppressed(th3);
                            th3 = th2;
                        }
                    }
                }
            }
            th3 = th2;
            if (th3 != null) {
                try {
                    throw th3;
                } catch (IOException e32) {
                    logCriticalInfo(6, "Failed to decompress file; src: " + srcFile.getAbsolutePath() + ", dst: " + dstFile.getAbsolutePath());
                    return -110;
                }
            }
            throw th;
        }
    }

    private File[] getCompressedFiles(String codePath) {
        File stubCodePath = new File(codePath);
        String stubName = stubCodePath.getName();
        int idx = stubName.lastIndexOf(STUB_SUFFIX);
        if (idx < 0 || stubName.length() != STUB_SUFFIX.length() + idx) {
            return null;
        }
        File stubParentDir = stubCodePath.getParentFile();
        if (stubParentDir == null) {
            Slog.e(TAG, "Unable to determine stub parent dir for codePath: " + codePath);
            return null;
        }
        File[] files = new File(stubParentDir, stubName.substring(0, idx)).listFiles(new FilenameFilter() {
            public boolean accept(File dir, String name) {
                return name.toLowerCase().endsWith(PackageManagerService.COMPRESSED_EXTENSION);
            }
        });
        if (DEBUG_COMPRESSION && files != null && files.length > 0) {
            Slog.i(TAG, "getCompressedFiles[" + codePath + "]: " + Arrays.toString(files));
        }
        return files;
    }

    private boolean compressedFileExists(String codePath) {
        File[] compressedFiles = getCompressedFiles(codePath);
        if (compressedFiles == null || compressedFiles.length <= 0) {
            return false;
        }
        return true;
    }

    private File decompressPackage(Package pkg) {
        File[] compressedFiles = getCompressedFiles(pkg.codePath);
        if (compressedFiles == null || compressedFiles.length == 0) {
            if (DEBUG_COMPRESSION) {
                Slog.i(TAG, "No files to decompress: " + pkg.baseCodePath);
            }
            return null;
        }
        File dstCodePath = getNextCodePath(Environment.getDataAppDirectory(null), pkg.packageName);
        int ret = 1;
        try {
            Os.mkdir(dstCodePath.getAbsolutePath(), 493);
            Os.chmod(dstCodePath.getAbsolutePath(), 493);
            for (File srcFile : compressedFiles) {
                String srcFileName = srcFile.getName();
                String dstFileName = srcFileName.substring(0, srcFileName.length() - COMPRESSED_EXTENSION.length());
                ret = decompressFile(srcFile, new File(dstCodePath, dstFileName));
                if (ret != 1) {
                    logCriticalInfo(6, "Failed to decompress; pkg: " + pkg.packageName + ", file: " + dstFileName);
                    break;
                }
            }
        } catch (ErrnoException e) {
            logCriticalInfo(6, "Failed to decompress; pkg: " + pkg.packageName + ", err: " + e.errno);
        }
        if (ret == 1) {
            File libraryRoot = new File(dstCodePath, "lib");
            AutoCloseable autoCloseable = null;
            try {
                autoCloseable = Handle.create(dstCodePath);
                ret = NativeLibraryHelper.copyNativeBinariesWithOverride(autoCloseable, libraryRoot, null);
                IoUtils.closeQuietly(autoCloseable);
            } catch (IOException e2) {
                logCriticalInfo(6, "Failed to extract native libraries; pkg: " + pkg.packageName);
                ret = -110;
                IoUtils.closeQuietly(autoCloseable);
            } catch (Throwable th) {
                IoUtils.closeQuietly(autoCloseable);
                throw th;
            }
        }
        if (ret == 1) {
            return dstCodePath;
        }
        if (dstCodePath == null || (dstCodePath.exists() ^ 1) != 0) {
            return null;
        }
        removeCodePathLI(dstCodePath);
        return null;
    }

    private void updateInstantAppInstallerLocked(String modifiedPackage) {
        if (this.mInstantAppInstallerActivity == null || (this.mInstantAppInstallerActivity.getComponentName().getPackageName().equals(modifiedPackage) ^ 1) == 0) {
            setUpInstantAppInstallerActivityLP(getInstantAppInstallerLPr());
        }
    }

    private static File preparePackageParserCache(boolean isUpgrade) {
        if (Build.IS_ENG) {
            return null;
        }
        if (SystemProperties.getBoolean("pm.boot.disable_package_cache", false)) {
            Slog.i(TAG, "Disabling package parser cache due to system property.");
            return null;
        }
        File cacheBaseDir = FileUtils.createDir(Environment.getDataSystemDirectory(), "package_cache");
        if (cacheBaseDir == null) {
            return null;
        }
        if (isUpgrade) {
            FileUtils.deleteContents(cacheBaseDir);
        }
        File cacheDir = FileUtils.createDir(cacheBaseDir, "1");
        if (Build.IS_USERDEBUG && VERSION.INCREMENTAL.startsWith("eng.")) {
            Slog.w(TAG, "Wiping cache directory because the system partition changed.");
            if (cacheDir.lastModified() < new File(Environment.getRootDirectory(), "framework").lastModified()) {
                FileUtils.deleteContents(cacheBaseDir);
                cacheDir = FileUtils.createDir(cacheBaseDir, "1");
            }
        }
        return cacheDir;
    }

    private void resetDataAppForFirstBoot() {
        int i = 0;
        if (EXP_VERSION) {
            if (getNetLockExpAppPathFileName().exists()) {
                readFileToArrayList(getNetLockExpAppPathFileName(), false);
            }
            if (getOperatorExpAppPathFileName().exists()) {
                readFileToArrayList(getOperatorExpAppPathFileName(), false);
            }
        }
        if (getDataAppPathFileName().exists()) {
            readFileToArrayList(getDataAppPathFileName(), false);
        }
        if (this.mDataAppDir.exists() && this.mDataAppArrayList.size() > 0) {
            File[] files = this.mDataAppDir.listFiles();
            if (ArrayUtils.isEmpty(files)) {
                Log.d(TAG, "No files in app dir " + this.mDataAppDir);
                return;
            }
            int length = files.length;
            while (i < length) {
                File apkFile = files[i];
                if (!this.mDataAppArrayList.contains("data/app/" + apkFile.getName())) {
                    deleteFiles(apkFile);
                }
                i++;
            }
        }
    }

    private void resetDataAppForMasterClear() {
        int i = 0;
        if (EXP_VERSION) {
            if (getNetLockExpAppPkgFileName().exists()) {
                readFileToArrayList(getNetLockExpAppPkgFileName(), false);
            }
            if (getOperatorExpAppPkgFileName().exists()) {
                readFileToArrayList(getOperatorExpAppPkgFileName(), false);
            }
        }
        if (getDataAppPkgFileName().exists()) {
            readFileToArrayList(getDataAppPkgFileName(), false);
        }
        if (this.mDataAppDir.exists() && this.mDataAppArrayList.size() > 0) {
            File[] files = this.mDataAppDir.listFiles();
            if (ArrayUtils.isEmpty(files)) {
                Log.d(TAG, "No files in app dir " + this.mDataAppDir);
                return;
            }
            int length = files.length;
            while (i < length) {
                File apkFile = files[i];
                String pkgName = getPkgName(apkFile);
                Log.d(TAG, "pkgName : " + pkgName + "  apkFile.getName() = " + apkFile.getName());
                if (pkgName != null) {
                    if (!this.mDataAppArrayList.contains(pkgName)) {
                        Log.d(TAG, "deleteFiles 1 ");
                        deleteFiles(apkFile);
                    }
                } else if (!(apkFile.getName().startsWith("packages.xml") || this.mDataAppArrayList.contains(apkFile.getName()))) {
                    Log.d(TAG, "deleteFiles 2 ");
                    deleteFiles(apkFile);
                }
                i++;
            }
        }
    }

    private String getPkgName(File file) {
        if (file.isDirectory()) {
            for (File apkFile : file.listFiles()) {
                if (apkFile.getName().endsWith(".apk")) {
                    return parsePkg(file);
                }
            }
        } else if (file.getName().endsWith(".apk")) {
            return parsePkg(file);
        }
        return null;
    }

    private String parsePkg(File file) {
        try {
            PackageLite pkg = PackageParser.parsePackageLite(file, 2);
            if (pkg != null) {
                return pkg.packageName;
            }
        } catch (PackageParserException ex) {
            Log.e(TAG, "parser pkg fail !!!" + ex);
        }
        return null;
    }

    private void readFileToArrayList(File apkfile, boolean isSystem) {
        IOException e;
        Throwable th;
        AutoCloseable autoCloseable = null;
        try {
            BufferedReader in = new BufferedReader(new FileReader(apkfile));
            while (true) {
                try {
                    String line = in.readLine();
                    if (line == null) {
                        IoUtils.closeQuietly(in);
                        return;
                    } else if (isSystem) {
                        this.mSystemAppArrayList.add(line);
                    } else {
                        this.mDataAppArrayList.add(line);
                    }
                } catch (IOException e2) {
                    e = e2;
                    autoCloseable = in;
                } catch (Throwable th2) {
                    th = th2;
                    autoCloseable = in;
                }
            }
        } catch (IOException e3) {
            e = e3;
            try {
                Log.e(TAG, "readApkWhiteList IOException " + e);
                IoUtils.closeQuietly(autoCloseable);
            } catch (Throwable th3) {
                th = th3;
                IoUtils.closeQuietly(autoCloseable);
                throw th;
            }
        }
    }

    private void deleteFiles(File file) {
        if (file.getName().startsWith("com.cootek.smartinputv5.language") && mNetLock.equals("") && mRegionMark.equals("")) {
            Slog.d(TAG, "ignore file" + file);
            return;
        }
        if (file.exists()) {
            if (file.isFile()) {
                Log.d(TAG, "delete file : " + file);
                file.delete();
            } else if (file.isDirectory()) {
                File[] files = file.listFiles();
                for (File deleteFiles : files) {
                    deleteFiles(deleteFiles);
                }
                Log.d(TAG, "delete dir : " + file);
                file.delete();
            }
        }
    }

    private boolean isCommonSoft() {
        if ((getDataAppPkgFileName() == null || !getDataAppPkgFileName().exists()) && (getSystemAppPkgFileName() == null || !getSystemAppPkgFileName().exists())) {
            return false;
        }
        return true;
    }

    private boolean isPackageXmlExists() {
        if (this.mPackagexmlFile == null || !this.mPackagexmlFile.exists()) {
            return false;
        }
        return true;
    }

    private File getDataAppPkgFileName() {
        return this.mDataAppPkgNameFile;
    }

    private File getDataAppPathFileName() {
        return this.mDataAppPathNameFile;
    }

    private File getSystemAppPkgFileName() {
        return this.mSystemAppPkgFileName;
    }

    private File getNetLockExpAppPkgFileName() {
        return this.mNetLockExpAppPkgNameFile;
    }

    private File getNetLockExpAppPathFileName() {
        return this.mNetLockExpAppPathNameFile;
    }

    private File getOperatorExpAppPkgFileName() {
        return this.mOperatorExpAppPkgNameFile;
    }

    private File getOperatorExpAppPathFileName() {
        return this.mOperatorExpAppPathNameFile;
    }

    private void commonSoftInit() {
        File mSysemRootDir = Environment.getRootDirectory();
        File dataDir = Environment.getDataDirectory();
        this.mDeviceType = SystemProperties.get("ro.commonsoft.product", "oppo");
        this.mSystemEtcDir = new File(mSysemRootDir, "etc");
        this.mDataEngineermodeDir = new File(dataDir, "engineermode");
        this.mDataAppPkgNameFile = new File(this.mDataEngineermodeDir, "persistname_" + this.mDeviceType + ".txt");
        this.mDataAppPathNameFile = new File(this.mDataEngineermodeDir, "persistpath_" + this.mDeviceType + ".txt");
        this.mSystemAppPkgFileName = new File(this.mSystemEtcDir, "systemapp_" + this.mDeviceType + ".txt");
        this.mAppChanelFile = new File(this.mDataEngineermodeDir, "appchannel_" + this.mDeviceType + ".txt");
        this.mNetLockExpAppPkgNameFile = new File(this.mDataEngineermodeDir, "persistname_" + this.mDeviceType + "_" + mNetLock + ".txt");
        this.mNetLockExpAppPathNameFile = new File(this.mDataEngineermodeDir, "persistpath_" + this.mDeviceType + "_" + mNetLock + ".txt");
        this.mOperatorExpAppPkgNameFile = new File(this.mDataEngineermodeDir, "persistname_" + this.mDeviceType + "_" + mOperator + ".txt");
        this.mOperatorExpAppPathNameFile = new File(this.mDataEngineermodeDir, "persistpath_" + this.mDeviceType + "_" + mOperator + ".txt");
        this.mDataAppDir = new File(dataDir, "app");
        this.mPackagexmlFile = new File(this.mDataAppDir, "packages.xml");
    }

    private void deleteAppChannel() {
        IOException e;
        File appChannelDir;
        File[] files;
        Throwable th;
        if (this.mAppChanelFile.exists()) {
            AutoCloseable in = null;
            try {
                BufferedReader in2 = new BufferedReader(new FileReader(this.mAppChanelFile));
                while (true) {
                    try {
                        String line = in2.readLine();
                        if (line == null) {
                            break;
                        }
                        this.mAppChannelArrayList.add(line);
                    } catch (IOException e2) {
                        e = e2;
                        in = in2;
                        try {
                            Slog.e(TAG, "read app channel file IOException " + e);
                            IoUtils.closeQuietly(in);
                            appChannelDir = new File("/data/etc", "appchannel");
                            files = appChannelDir.listFiles();
                            if (ArrayUtils.isEmpty(files)) {
                                Slog.d(TAG, "No files in app channel dir " + appChannelDir);
                                return;
                            }
                            for (File channelFile : files) {
                                if (!this.mAppChannelArrayList.contains("/data/etc/appchannel/" + channelFile.getName())) {
                                    Slog.d(TAG, "deleteFiles channelFile=" + channelFile.getName());
                                    deleteFiles(channelFile);
                                }
                            }
                        } catch (Throwable th2) {
                            th = th2;
                            IoUtils.closeQuietly(in);
                            throw th;
                        }
                    } catch (Throwable th3) {
                        th = th3;
                        Object in3 = in2;
                        IoUtils.closeQuietly(in);
                        throw th;
                    }
                }
                IoUtils.closeQuietly(in2);
            } catch (IOException e3) {
                e = e3;
                Slog.e(TAG, "read app channel file IOException " + e);
                IoUtils.closeQuietly(in);
                appChannelDir = new File("/data/etc", "appchannel");
                files = appChannelDir.listFiles();
                if (ArrayUtils.isEmpty(files)) {
                    for (File channelFile2 : files) {
                        if (!this.mAppChannelArrayList.contains("/data/etc/appchannel/" + channelFile2.getName())) {
                            Slog.d(TAG, "deleteFiles channelFile=" + channelFile2.getName());
                            deleteFiles(channelFile2);
                        }
                    }
                } else {
                    Slog.d(TAG, "No files in app channel dir " + appChannelDir);
                    return;
                }
            }
        }
        appChannelDir = new File("/data/etc", "appchannel");
        if (appChannelDir.exists() && this.mAppChannelArrayList.size() > 0) {
            files = appChannelDir.listFiles();
            if (ArrayUtils.isEmpty(files)) {
                Slog.d(TAG, "No files in app channel dir " + appChannelDir);
                return;
            }
            for (File channelFile22 : files) {
                if (!this.mAppChannelArrayList.contains("/data/etc/appchannel/" + channelFile22.getName())) {
                    Slog.d(TAG, "deleteFiles channelFile=" + channelFile22.getName());
                    deleteFiles(channelFile22);
                }
            }
        }
    }

    public boolean isFirstBoot() {
        return this.mFirstBoot;
    }

    public boolean isOnlyCoreApps() {
        return this.mOnlyCore;
    }

    public boolean isUpgrade() {
        return this.mIsUpgrade;
    }

    private String getRequiredButNotReallyRequiredVerifierLPr() {
        List<ResolveInfo> matches = queryIntentReceiversInternal(new Intent("android.intent.action.PACKAGE_NEEDS_VERIFICATION"), PACKAGE_MIME_TYPE, 1835008, 0, false);
        if (matches.size() == 1) {
            return ((ResolveInfo) matches.get(0)).getComponentInfo().packageName;
        }
        if (matches.size() > 1) {
            String optionalVerifierName = this.mContext.getResources().getString(17039706);
            if (TextUtils.isEmpty(optionalVerifierName)) {
                return ((ResolveInfo) matches.get(0)).getComponentInfo().packageName;
            }
            for (int i = 0; i < matches.size(); i++) {
                if (!((ResolveInfo) matches.get(i)).getComponentInfo().packageName.contains(optionalVerifierName)) {
                    return ((ResolveInfo) matches.get(i)).getComponentInfo().packageName;
                }
            }
        } else if (matches.size() == 0) {
            Log.e(TAG, "There should probably be a verifier, but, none were found");
            return null;
        }
        throw new RuntimeException("There must be exactly one verifier; found " + matches);
    }

    private String getOptionalVerifierLPr() {
        List<ResolveInfo> matches = queryIntentReceiversInternal(new Intent("com.qualcomm.qti.intent.action.PACKAGE_NEEDS_OPTIONAL_VERIFICATION"), PACKAGE_MIME_TYPE, 1835008, 0, false);
        if (matches.size() >= 1) {
            String optionalVerifierName = this.mContext.getResources().getString(17039706);
            if (TextUtils.isEmpty(optionalVerifierName)) {
                return null;
            }
            for (int i = 0; i < matches.size(); i++) {
                if (((ResolveInfo) matches.get(i)).getComponentInfo().packageName.contains(optionalVerifierName)) {
                    return ((ResolveInfo) matches.get(i)).getComponentInfo().packageName;
                }
            }
        }
        return null;
    }

    private String getRequiredSharedLibraryLPr(String name, int version) {
        String str;
        synchronized (this.mPackages) {
            SharedLibraryEntry libraryEntry = getSharedLibraryEntryLPr(name, version);
            if (libraryEntry == null) {
                throw new IllegalStateException("Missing required shared library:" + name);
            }
            str = libraryEntry.apk;
        }
        return str;
    }

    private String getRequiredInstallerLPr() {
        Intent intent = new Intent("android.intent.action.INSTALL_PACKAGE");
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setDataAndType(Uri.fromFile(new File("foo.apk")), PACKAGE_MIME_TYPE);
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, PACKAGE_MIME_TYPE, 1835008, 0);
        if (matches.size() != 1) {
            throw new RuntimeException("There must be exactly one installer; found " + matches);
        } else if (((ResolveInfo) matches.get(0)).activityInfo.applicationInfo.isPrivilegedApp()) {
            return ((ResolveInfo) matches.get(0)).getComponentInfo().packageName;
        } else {
            throw new RuntimeException("The installer must be a privileged app");
        }
    }

    private String getRequiredUninstallerLPr() {
        Intent intent = new Intent("android.intent.action.UNINSTALL_PACKAGE");
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setData(Uri.fromParts(PACKAGE_SCHEME, "foo.bar", null));
        ResolveInfo resolveInfo = resolveIntent(intent, null, 1835008, 0);
        if (resolveInfo != null && !this.mResolveActivity.name.equals(resolveInfo.getComponentInfo().name)) {
            return resolveInfo.getComponentInfo().packageName;
        }
        throw new RuntimeException("There must be exactly one uninstaller; found " + resolveInfo);
    }

    private ComponentName getIntentFilterVerifierComponentNameLPr() {
        List<ResolveInfo> matches = queryIntentReceiversInternal(new Intent("android.intent.action.INTENT_FILTER_NEEDS_VERIFICATION"), PACKAGE_MIME_TYPE, 1835008, 0, false);
        ResolveInfo best = null;
        int N = matches.size();
        for (int i = 0; i < N; i++) {
            ResolveInfo cur = (ResolveInfo) matches.get(i);
            if (checkPermission("android.permission.INTENT_FILTER_VERIFICATION_AGENT", cur.getComponentInfo().packageName, 0) == 0 && (best == null || cur.priority > best.priority)) {
                best = cur;
            }
        }
        if (best != null) {
            return best.getComponentInfo().getComponentName();
        }
        Slog.w(TAG, "Intent filter verifier not found");
        return null;
    }

    public ComponentName getInstantAppResolverComponent() {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            Pair<ComponentName, String> instantAppResolver = getInstantAppResolverLPr();
            if (instantAppResolver == null) {
                return null;
            }
            ComponentName componentName = (ComponentName) instantAppResolver.first;
            return componentName;
        }
    }

    private Pair<ComponentName, String> getInstantAppResolverLPr() {
        String[] packageArray = this.mContext.getResources().getStringArray(17236011);
        if (packageArray.length != 0 || (Build.IS_DEBUGGABLE ^ 1) == 0) {
            int i;
            int callingUid = Binder.getCallingUid();
            if (Build.IS_DEBUGGABLE) {
                i = 0;
            } else {
                i = DumpState.DUMP_DEXOPT;
            }
            int resolveFlags = 786432 | i;
            String actionName = "android.intent.action.RESOLVE_INSTANT_APP_PACKAGE";
            Intent resolverIntent = new Intent(actionName);
            List<ResolveInfo> resolvers = queryIntentServicesInternal(resolverIntent, null, resolveFlags, 0, callingUid, false);
            if (resolvers.size() == 0) {
                if (DEBUG_EPHEMERAL) {
                    Slog.d(TAG, "Ephemeral resolver not found with new action; try old one");
                }
                actionName = "android.intent.action.RESOLVE_EPHEMERAL_PACKAGE";
                resolverIntent.setAction(actionName);
                resolvers = queryIntentServicesInternal(resolverIntent, null, resolveFlags, 0, callingUid, false);
            }
            int N = resolvers.size();
            if (N == 0) {
                if (DEBUG_EPHEMERAL) {
                    Slog.d(TAG, "Ephemeral resolver NOT found; no matching intent filters");
                }
                return null;
            }
            Set<String> possiblePackages = new ArraySet(Arrays.asList(packageArray));
            for (int i2 = 0; i2 < N; i2++) {
                ResolveInfo info = (ResolveInfo) resolvers.get(i2);
                if (info.serviceInfo != null) {
                    String packageName = info.serviceInfo.packageName;
                    if (possiblePackages.contains(packageName) || (Build.IS_DEBUGGABLE ^ 1) == 0) {
                        if (DEBUG_EPHEMERAL) {
                            Slog.v(TAG, "Ephemeral resolver found; pkg: " + packageName + ", info:" + info);
                        }
                        return new Pair(new ComponentName(packageName, info.serviceInfo.name), actionName);
                    } else if (DEBUG_EPHEMERAL) {
                        Slog.d(TAG, "Ephemeral resolver not in allowed package list; pkg: " + packageName + ", info:" + info);
                    }
                }
            }
            if (DEBUG_EPHEMERAL) {
                Slog.v(TAG, "Ephemeral resolver NOT found");
            }
            return null;
        }
        if (DEBUG_EPHEMERAL) {
            Slog.d(TAG, "Ephemeral resolver NOT found; empty package list");
        }
        return null;
    }

    private ActivityInfo getInstantAppInstallerLPr() {
        int i;
        Intent intent = new Intent("android.intent.action.INSTALL_INSTANT_APP_PACKAGE");
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setDataAndType(Uri.fromFile(new File("foo.apk")), PACKAGE_MIME_TYPE);
        if (Build.IS_DEBUGGABLE) {
            i = 0;
        } else {
            i = DumpState.DUMP_DEXOPT;
        }
        int resolveFlags = 786432 | i;
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, PACKAGE_MIME_TYPE, resolveFlags, 0);
        if (matches.isEmpty()) {
            if (DEBUG_EPHEMERAL) {
                Slog.d(TAG, "Ephemeral installer not found with new action; try old one");
            }
            intent.setAction("android.intent.action.INSTALL_EPHEMERAL_PACKAGE");
            matches = queryIntentActivitiesInternal(intent, PACKAGE_MIME_TYPE, resolveFlags, 0);
        }
        Iterator<ResolveInfo> iter = matches.iterator();
        while (iter.hasNext()) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(((ResolveInfo) iter.next()).activityInfo.packageName);
            if (ps == null || !ps.getPermissionsState().hasPermission("android.permission.INSTALL_PACKAGES", 0)) {
                iter.remove();
            }
        }
        if (matches.size() == 0) {
            return null;
        }
        if (matches.size() == 1) {
            return (ActivityInfo) ((ResolveInfo) matches.get(0)).getComponentInfo();
        }
        throw new RuntimeException("There must be at most one ephemeral installer; found " + matches);
    }

    private ComponentName getInstantAppResolverSettingsLPr(ComponentName resolver) {
        Intent intent = new Intent("android.intent.action.INSTANT_APP_RESOLVER_SETTINGS").addCategory("android.intent.category.DEFAULT").setPackage(resolver.getPackageName());
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, null, 786432, 0);
        if (matches.isEmpty()) {
            if (DEBUG_EPHEMERAL) {
                Slog.d(TAG, "Ephemeral resolver settings not found with new action; try old one");
            }
            intent.setAction("android.intent.action.EPHEMERAL_RESOLVER_SETTINGS");
            matches = queryIntentActivitiesInternal(intent, null, 786432, 0);
        }
        if (matches.isEmpty()) {
            return null;
        }
        return ((ResolveInfo) matches.get(0)).getComponentInfo().getComponentName();
    }

    private void primeDomainVerificationsLPw(int userId) {
        for (String packageName : SystemConfig.getInstance().getLinkedApps()) {
            Package pkg = (Package) this.mPackages.get(packageName);
            if (pkg == null) {
                Slog.w(TAG, "Unknown package " + packageName + " in sysconfig <app-link>");
            } else if (pkg.isSystemApp()) {
                ArraySet domains = null;
                for (Activity a : pkg.activities) {
                    for (ActivityIntentInfo filter : a.intents) {
                        if (hasValidDomains(filter)) {
                            if (domains == null) {
                                domains = new ArraySet();
                            }
                            domains.addAll(filter.getHostsList());
                        }
                    }
                }
                if (domains == null || domains.size() <= 0) {
                    Slog.w(TAG, "Sysconfig <app-link> package '" + packageName + "' does not handle web links");
                } else {
                    this.mSettings.createIntentFilterVerificationIfNeededLPw(packageName, domains).setStatus(0);
                    this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, 2, userId);
                }
            } else {
                Slog.w(TAG, "Non-system app '" + packageName + "' in sysconfig <app-link>");
            }
        }
        scheduleWritePackageRestrictionsLocked(userId);
        scheduleWriteSettingsLocked();
    }

    private void applyFactoryDefaultBrowserLPw(int userId) {
        String browserPkg = this.mContext.getResources().getString(17039777);
        if (!TextUtils.isEmpty(browserPkg)) {
            if (((PackageSetting) this.mSettings.mPackages.get(browserPkg)) == null) {
                Slog.e(TAG, "Product default browser app does not exist: " + browserPkg);
                browserPkg = null;
            } else {
                this.mSettings.setDefaultBrowserPackageNameLPw(browserPkg, userId);
            }
        }
        if (browserPkg == null) {
            calculateDefaultBrowserLPw(userId);
        }
    }

    private void calculateDefaultBrowserLPw(int userId) {
        List<String> allBrowsers = resolveAllBrowserApps(userId);
        this.mSettings.setDefaultBrowserPackageNameLPw(allBrowsers.size() == 1 ? (String) allBrowsers.get(0) : null, userId);
    }

    private List<String> resolveAllBrowserApps(int userId) {
        List<ResolveInfo> list = queryIntentActivitiesInternal(sBrowserIntent, null, 131072, userId);
        int count = list.size();
        List<String> result = new ArrayList(count);
        for (int i = 0; i < count; i++) {
            ResolveInfo info = (ResolveInfo) list.get(i);
            if (!(info.activityInfo == null || (info.handleAllWebDataURI ^ 1) != 0 || (info.activityInfo.applicationInfo.flags & 1) == 0 || result.contains(info.activityInfo.packageName))) {
                result.add(info.activityInfo.packageName);
            }
        }
        return result;
    }

    private boolean packageIsBrowser(String packageName, int userId) {
        List<ResolveInfo> list = queryIntentActivitiesInternal(sBrowserIntent, null, 131072, userId);
        int N = list.size();
        for (int i = 0; i < N; i++) {
            if (packageName.equals(((ResolveInfo) list.get(i)).activityInfo.packageName)) {
                return true;
            }
        }
        return false;
    }

    private void checkDefaultBrowser() {
        int myUserId = UserHandle.myUserId();
        String packageName = getDefaultBrowserPackageName(myUserId);
        if (packageName != null && getPackageInfo(packageName, 0, myUserId) == null) {
            Slog.w(TAG, "Default browser no longer installed: " + packageName);
            synchronized (this.mPackages) {
                applyFactoryDefaultBrowserLPw(myUserId);
            }
        }
    }

    public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
        try {
            return super.onTransact(code, data, reply, flags);
        } catch (RuntimeException e) {
            if (!((e instanceof SecurityException) || ((e instanceof IllegalArgumentException) ^ 1) == 0)) {
                Slog.wtf(TAG, "Package Manager Crash", e);
            }
            throw e;
        }
    }

    static int[] appendInts(int[] cur, int[] add) {
        if (add == null) {
            return cur;
        }
        if (cur == null) {
            return add;
        }
        for (int appendInt : add) {
            cur = ArrayUtils.appendInt(cur, appendInt);
        }
        return cur;
    }

    private boolean canViewInstantApps(int callingUid, int userId) {
        if (callingUid < 10000 || this.mContext.checkCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS") == 0) {
            return true;
        }
        if (this.mContext.checkCallingOrSelfPermission("android.permission.VIEW_INSTANT_APPS") == 0) {
            ComponentName homeComponent = getDefaultHomeActivity(userId);
            return homeComponent != null && isCallerSameApp(homeComponent.getPackageName(), callingUid);
        }
    }

    private PackageInfo generatePackageInfo(PackageSetting ps, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        if (ps == null) {
            return null;
        }
        Package p = ps.pkg;
        if (p == null) {
            return null;
        }
        if (filterAppAccessLPr(ps, Binder.getCallingUid(), userId)) {
            return null;
        }
        PermissionsState permissionsState = ps.getPermissionsState();
        int[] gids = (flags & 256) == 0 ? EMPTY_INT_ARRAY : permissionsState.computeGids(userId);
        Set<String> permissions = ArrayUtils.isEmpty(p.requestedPermissions) ? Collections.emptySet() : permissionsState.getPermissions(userId);
        PackageUserState state = ps.readUserState(userId);
        if ((flags & 8192) != 0 && ps.isSystem()) {
            flags |= DumpState.DUMP_CHANGES;
        }
        PackageInfo packageInfo = PackageParser.generatePackageInfo(p, gids, flags, ps.firstInstallTime, ps.lastUpdateTime, permissions, state, userId);
        if (packageInfo == null) {
            return null;
        }
        String resolveExternalPackageNameLPr = resolveExternalPackageNameLPr(p);
        packageInfo.applicationInfo.packageName = resolveExternalPackageNameLPr;
        packageInfo.packageName = resolveExternalPackageNameLPr;
        return packageInfo;
    }

    public void checkPackageStartable(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            throw new SecurityException("Instant applications don't have access to this method");
        }
        boolean userKeyUnlocked = StorageManager.isUserKeyUnlocked(userId);
        synchronized (this.mPackages) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                throw new SecurityException("Package " + packageName + " was not found!");
            } else if (!ps.getInstalled(userId)) {
                throw new SecurityException("Package " + packageName + " was not installed for user " + userId + "!");
            } else if (this.mSafeMode && (ps.isSystem() ^ 1) != 0) {
                throw new SecurityException("Package " + packageName + " not a system app!");
            } else if (this.mFrozenPackages.contains(packageName)) {
                throw new SecurityException("Package " + packageName + " is currently frozen!");
            } else if (userKeyUnlocked || (ps.pkg.applicationInfo.isEncryptionAware() ^ 1) == 0) {
            } else {
                throw new SecurityException("Package " + packageName + " is not encryption aware!");
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean isPackageAvailable(String packageName, int userId) {
        if (!sUserManager.exists(userId)) {
            return false;
        }
        int callingUid = Binder.getCallingUid();
        enforceCrossUserPermission(callingUid, userId, false, false, "is package available");
        synchronized (this.mPackages) {
            Package p = (Package) this.mPackages.get(packageName);
            if (p != null) {
                PackageSetting ps = p.mExtras;
                if (filterAppAccessLPr(ps, callingUid, userId)) {
                    return false;
                } else if (ps != null) {
                    PackageUserState state = ps.readUserState(userId);
                    if (state != null) {
                        boolean isAvailable = PackageParser.isAvailable(state);
                        return isAvailable;
                    }
                }
            }
        }
    }

    public PackageInfo getPackageInfo(String packageName, int flags, int userId) {
        return getPackageInfoInternal(packageName, -1, flags, Binder.getCallingUid(), userId);
    }

    public PackageInfo getPackageInfoVersioned(VersionedPackage versionedPackage, int flags, int userId) {
        return getPackageInfoInternal(versionedPackage.getPackageName(), versionedPackage.getVersionCode(), flags, Binder.getCallingUid(), userId);
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private PackageInfo getPackageInfoInternal(String packageName, int versionCode, int flags, int filterCallingUid, int userId) {
        if ((134217728 & flags) == 0 && userId == 999 && packageName != null && (OppoMultiAppManagerUtil.getInstance().isMultiApp(packageName) ^ 1) != 0) {
            userId = 0;
        } else if (!((134217728 & flags) == 0 || userId != 999 || (OppoMultiAppManagerUtil.getInstance().isMultiApp(packageName) ^ 1) == 0)) {
            return null;
        }
        if (!sUserManager.exists(userId)) {
            return null;
        }
        flags = updateFlagsForPackage(flags, userId, packageName);
        enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get package info");
        synchronized (this.mPackages) {
            PackageSetting ps;
            PackageInfo generatePackageInfo;
            packageName = resolveInternalPackageNameLPr(packageName, versionCode);
            boolean matchFactoryOnly = (DumpState.DUMP_COMPILER_STATS & flags) != 0;
            if (matchFactoryOnly) {
                ps = this.mSettings.getDisabledSystemPkgLPr(packageName);
                if (ps != null) {
                    if (filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags)) {
                        return null;
                    } else if (filterAppAccessLPr(ps, filterCallingUid, userId)) {
                        return null;
                    } else {
                        generatePackageInfo = generatePackageInfo(ps, flags, userId);
                        return generatePackageInfo;
                    }
                }
            }
            Package p = (Package) this.mPackages.get(packageName);
            if (!matchFactoryOnly || p == null || (isSystemApp(p) ^ 1) == 0) {
                if (DEBUG_PACKAGE_INFO) {
                    Log.v(TAG, "getPackageInfo " + packageName + ": " + p);
                }
                if (p != null) {
                    ps = (PackageSetting) p.mExtras;
                    if (filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags)) {
                        return null;
                    }
                    if (ps != null) {
                        if (filterAppAccessLPr(ps, filterCallingUid, userId)) {
                            return null;
                        }
                    }
                    generatePackageInfo = generatePackageInfo((PackageSetting) p.mExtras, flags, userId);
                    return generatePackageInfo;
                } else if (matchFactoryOnly || (4202496 & flags) == 0) {
                } else {
                    ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                    if (ps == null) {
                        return null;
                    } else if (filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags)) {
                        return null;
                    } else if (filterAppAccessLPr(ps, filterCallingUid, userId)) {
                        return null;
                    } else {
                        generatePackageInfo = generatePackageInfo(ps, flags, userId);
                        return generatePackageInfo;
                    }
                }
            }
            return null;
        }
    }

    private boolean isComponentVisibleToInstantApp(ComponentName component) {
        if (isComponentVisibleToInstantApp(component, 1) || isComponentVisibleToInstantApp(component, 3) || isComponentVisibleToInstantApp(component, 4)) {
            return true;
        }
        return false;
    }

    private boolean isComponentVisibleToInstantApp(ComponentName component, int type) {
        boolean z = true;
        boolean z2 = false;
        Activity activity;
        if (type == 1) {
            activity = (Activity) this.mActivities.mActivities.get(component);
            if (activity == null) {
                z = false;
            } else if ((activity.info.flags & DumpState.DUMP_DEXOPT) == 0) {
                z = false;
            }
            return z;
        } else if (type == 2) {
            activity = (Activity) this.mReceivers.mActivities.get(component);
            if (!(activity == null || (activity.info.flags & DumpState.DUMP_DEXOPT) == 0)) {
                z2 = true;
            }
            return z2;
        } else if (type == 3) {
            Service service = (Service) this.mServices.mServices.get(component);
            if (!(service == null || (service.info.flags & DumpState.DUMP_DEXOPT) == 0)) {
                z2 = true;
            }
            return z2;
        } else if (type == 4) {
            Provider provider = (Provider) this.mProviders.mProviders.get(component);
            if (!(provider == null || (provider.info.flags & DumpState.DUMP_DEXOPT) == 0)) {
                z2 = true;
            }
            return z2;
        } else if (type == 0) {
            return isComponentVisibleToInstantApp(component);
        } else {
            return false;
        }
    }

    private boolean filterAppAccessLPr(PackageSetting ps, int callingUid, ComponentName component, int componentType, int userId) {
        boolean z = true;
        if (Process.isIsolated(callingUid)) {
            callingUid = this.mIsolatedOwners.get(callingUid);
        }
        boolean callerIsInstantApp = getInstantAppPackageName(callingUid) != null;
        if (ps == null) {
            return callerIsInstantApp;
        } else {
            if (isCallerSameApp(ps.name, callingUid)) {
                return false;
            }
            if (callerIsInstantApp) {
                if (component != null) {
                    return isComponentVisibleToInstantApp(component, componentType) ^ 1;
                }
                if (!ps.getInstantApp(userId)) {
                    z = ps.pkg.visibleToInstantApps ^ 1;
                }
                return z;
            } else if (!ps.getInstantApp(userId) || canViewInstantApps(callingUid, userId)) {
                return false;
            } else {
                if (component != null) {
                    return true;
                }
                return this.mInstantAppRegistry.isInstantAccessGranted(userId, UserHandle.getAppId(callingUid), ps.appId) ^ 1;
            }
        }
    }

    private boolean filterAppAccessLPr(PackageSetting ps, int callingUid, int userId) {
        return filterAppAccessLPr(ps, callingUid, null, 0, userId);
    }

    private boolean filterSharedLibPackageLPr(PackageSetting ps, int uid, int userId, int flags) {
        if ((67108864 & flags) != 0) {
            int appId = UserHandle.getAppId(uid);
            if (appId == 1000 || appId == 2000 || appId == 0) {
                return false;
            }
        }
        if (ps == null || ps.pkg == null || (ps.pkg.applicationInfo.isStaticSharedLibrary() ^ 1) != 0) {
            return false;
        }
        SharedLibraryEntry libEntry = getSharedLibraryEntryLPr(ps.pkg.staticSharedLibName, ps.pkg.staticSharedLibVersion);
        if (libEntry == null) {
            return false;
        }
        String[] uidPackageNames = getPackagesForUid(UserHandle.getUid(userId, UserHandle.getAppId(uid)));
        if (uidPackageNames == null) {
            return true;
        }
        for (String uidPackageName : uidPackageNames) {
            if (ps.name.equals(uidPackageName)) {
                return false;
            }
            PackageSetting uidPs = this.mSettings.getPackageLPr(uidPackageName);
            if (uidPs != null) {
                int index = ArrayUtils.indexOf(uidPs.usesStaticLibraries, libEntry.info.getName());
                if (index >= 0 && uidPs.pkg.usesStaticLibrariesVersions[index] == libEntry.info.getVersion()) {
                    return false;
                }
            }
        }
        return true;
    }

    public String[] currentToCanonicalPackageNames(String[] names) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return names;
        }
        String[] out = new String[names.length];
        synchronized (this.mPackages) {
            int callingUserId = UserHandle.getUserId(callingUid);
            boolean canViewInstantApps = canViewInstantApps(callingUid, callingUserId);
            for (int i = names.length - 1; i >= 0; i--) {
                String str;
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(names[i]);
                boolean translateName = false;
                if (!(ps == null || ps.realName == null)) {
                    translateName = (!ps.getInstantApp(callingUserId) || canViewInstantApps) ? true : this.mInstantAppRegistry.isInstantAccessGranted(callingUserId, UserHandle.getAppId(callingUid), ps.appId);
                }
                if (translateName) {
                    str = ps.realName;
                } else {
                    str = names[i];
                }
                out[i] = str;
            }
        }
        return out;
    }

    public String[] canonicalToCurrentPackageNames(String[] names) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return names;
        }
        String[] out = new String[names.length];
        synchronized (this.mPackages) {
            int callingUserId = UserHandle.getUserId(callingUid);
            boolean canViewInstantApps = canViewInstantApps(callingUid, callingUserId);
            for (int i = names.length - 1; i >= 0; i--) {
                String cur = this.mSettings.getRenamedPackageLPr(names[i]);
                boolean translateName = false;
                if (cur != null) {
                    PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(names[i]);
                    if (!(ps != null ? ps.getInstantApp(callingUserId) : false) || canViewInstantApps) {
                        translateName = true;
                    } else {
                        translateName = this.mInstantAppRegistry.isInstantAccessGranted(callingUserId, UserHandle.getAppId(callingUid), ps.appId);
                    }
                }
                if (!translateName) {
                    cur = names[i];
                }
                out[i] = cur;
            }
        }
        return out;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public int getPackageUid(String packageName, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return -1;
        }
        int callingUid = Binder.getCallingUid();
        flags = updateFlagsForPackage(flags, userId, packageName);
        enforceCrossUserPermission(callingUid, userId, false, false, "getPackageUid");
        synchronized (this.mPackages) {
            Package p = (Package) this.mPackages.get(packageName);
            int uid;
            if (p == null || !p.isMatch(flags)) {
                if ((4202496 & flags) != 0) {
                    PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                    if (!(ps == null || !ps.isMatch(flags) || (filterAppAccessLPr(ps, callingUid, userId) ^ 1) == 0)) {
                        uid = UserHandle.getUid(userId, ps.appId);
                        return uid;
                    }
                }
            } else if (filterAppAccessLPr(p.mExtras, callingUid, userId)) {
                return -1;
            } else {
                uid = UserHandle.getUid(userId, p.applicationInfo.uid);
                return uid;
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public int[] getPackageGids(String packageName, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        flags = updateFlagsForPackage(flags, userId, packageName);
        enforceCrossUserPermission(callingUid, userId, false, false, "getPackageGids");
        synchronized (this.mPackages) {
            Package p = (Package) this.mPackages.get(packageName);
            PackageSetting ps;
            int[] computeGids;
            if (p != null && p.isMatch(flags)) {
                ps = p.mExtras;
                if (filterAppAccessLPr(ps, callingUid, userId)) {
                    return null;
                }
                computeGids = ps.getPermissionsState().computeGids(userId);
                return computeGids;
            } else if ((4202496 & flags) != 0) {
                ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (!(ps == null || !ps.isMatch(flags) || (filterAppAccessLPr(ps, callingUid, userId) ^ 1) == 0)) {
                    computeGids = ps.getPermissionsState().computeGids(userId);
                    return computeGids;
                }
            }
        }
    }

    static PermissionInfo generatePermissionInfo(BasePermission bp, int flags) {
        if (bp.perm != null) {
            return PackageParser.generatePermissionInfo(bp.perm, flags);
        }
        PermissionInfo pi = new PermissionInfo();
        pi.name = bp.name;
        pi.packageName = bp.sourcePackage;
        pi.nonLocalizedLabel = bp.name;
        pi.protectionLevel = bp.protectionLevel;
        return pi;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public PermissionInfo getPermissionInfo(String name, String packageName, int flags) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            BasePermission p = (BasePermission) this.mSettings.mPermissions.get(name);
            if (p == null) {
                return null;
            }
            PermissionInfo permissionInfo = generatePermissionInfo(p, flags);
            if (permissionInfo != null) {
                int protectionLevel = adjustPermissionProtectionFlagsLPr(permissionInfo.protectionLevel, packageName, callingUid);
                if (permissionInfo.protectionLevel != protectionLevel) {
                    if (p.perm != null && p.perm.info == permissionInfo) {
                        permissionInfo = new PermissionInfo(permissionInfo);
                    }
                    permissionInfo.protectionLevel = protectionLevel;
                }
            }
        }
    }

    private int adjustPermissionProtectionFlagsLPr(int protectionLevel, String packageName, int uid) {
        int protectionLevelMasked = protectionLevel & 3;
        if (protectionLevelMasked == 2) {
            return protectionLevel;
        }
        int appId = UserHandle.getAppId(uid);
        if (appId == 1000 || appId == 0 || appId == 2000) {
            return protectionLevel;
        }
        packageName = resolveInternalPackageNameLPr(packageName, -1);
        PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
        if (ps == null || ps.appId != appId) {
            return protectionLevel;
        }
        Package pkg = (Package) this.mPackages.get(packageName);
        if (pkg != null && pkg.applicationInfo.targetSdkVersion < 26) {
            return protectionLevelMasked;
        }
        return protectionLevel;
    }

    public ParceledListSlice<PermissionInfo> queryPermissionsByGroup(String group, int flags) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            if (group != null) {
                if ((this.mPermissionGroups.containsKey(group) ^ 1) != 0) {
                    return null;
                }
            }
            ArrayList<PermissionInfo> out = new ArrayList(10);
            for (BasePermission p : this.mSettings.mPermissions.values()) {
                if (group == null) {
                    if (p.perm == null || p.perm.info.group == null) {
                        out.add(generatePermissionInfo(p, flags));
                    }
                } else if (p.perm != null && group.equals(p.perm.info.group)) {
                    out.add(PackageParser.generatePermissionInfo(p.perm, flags));
                }
            }
            ParceledListSlice<PermissionInfo> parceledListSlice = new ParceledListSlice(out);
            return parceledListSlice;
        }
    }

    public PermissionGroupInfo getPermissionGroupInfo(String name, int flags) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        PermissionGroupInfo generatePermissionGroupInfo;
        synchronized (this.mPackages) {
            generatePermissionGroupInfo = PackageParser.generatePermissionGroupInfo((PermissionGroup) this.mPermissionGroups.get(name), flags);
        }
        return generatePermissionGroupInfo;
    }

    public ParceledListSlice<PermissionGroupInfo> getAllPermissionGroups(int flags) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return ParceledListSlice.emptyList();
        }
        ParceledListSlice<PermissionGroupInfo> parceledListSlice;
        synchronized (this.mPackages) {
            ArrayList<PermissionGroupInfo> out = new ArrayList(this.mPermissionGroups.size());
            for (PermissionGroup pg : this.mPermissionGroups.values()) {
                out.add(PackageParser.generatePermissionGroupInfo(pg, flags));
            }
            parceledListSlice = new ParceledListSlice(out);
        }
        return parceledListSlice;
    }

    private ApplicationInfo generateApplicationInfoFromSettingsLPw(String packageName, int flags, int filterCallingUid, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
        if (ps == null || filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags) || filterAppAccessLPr(ps, filterCallingUid, userId)) {
            return null;
        }
        if (ps.pkg == null) {
            PackageInfo pInfo = generatePackageInfo(ps, flags, userId);
            if (pInfo != null) {
                return pInfo.applicationInfo;
            }
            return null;
        }
        ApplicationInfo ai = PackageParser.generateApplicationInfo(ps.pkg, flags, ps.readUserState(userId), userId);
        if (ai != null) {
            ai.packageName = resolveExternalPackageNameLPr(ps.pkg);
        }
        return ai;
    }

    public ApplicationInfo getApplicationInfo(String packageName, int flags, int userId) {
        ApplicationInfo ai = getApplicationInfoInternal(packageName, flags, Binder.getCallingUid(), userId);
        if (ai != null || Binder.getCallingUserHandle().getIdentifier() != OppoMultiAppManager.USER_ID || (OppoMultiAppManagerUtil.getInstance().isMultiApp(packageName) ^ 1) == 0) {
            return ai;
        }
        try {
            String[] packages = getPackagesForUid(Binder.getCallingUid());
            if (packages == null) {
                return ai;
            }
            for (String pkgName : packages) {
                if (OppoMultiAppManagerUtil.getInstance().isMultiApp(pkgName)) {
                    return getApplicationInfoInternal(packageName, flags, Binder.getCallingUid(), 0);
                }
            }
            return ai;
        } catch (Exception e) {
            return ai;
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private ApplicationInfo getApplicationInfoInternal(String packageName, int flags, int filterCallingUid, int userId) {
        if (((134217728 & flags) != 0 && userId == OppoMultiAppManager.USER_ID && (OppoMultiAppManagerUtil.getInstance().isMultiApp(packageName) ^ 1) != 0) || !sUserManager.exists(userId)) {
            return null;
        }
        flags = updateFlagsForApplication(flags, userId, packageName);
        enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get application info");
        synchronized (this.mPackages) {
            packageName = resolveInternalPackageNameLPr(packageName, -1);
            Package p = (Package) this.mPackages.get(packageName);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getApplicationInfo " + packageName + ": " + p);
            }
            ApplicationInfo applicationInfo;
            if (p != null) {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (ps == null) {
                    return null;
                } else if (filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags)) {
                    return null;
                } else if (filterAppAccessLPr(ps, filterCallingUid, userId)) {
                    return null;
                } else {
                    ApplicationInfo ai = PackageParser.generateApplicationInfo(p, flags, ps.readUserState(userId), userId);
                    if (ai != null) {
                        ai.packageName = resolveExternalPackageNameLPr(p);
                    }
                }
            } else if (PLATFORM_PACKAGE_NAME.equals(packageName) || "system".equals(packageName)) {
                applicationInfo = this.mAndroidApplication;
                return applicationInfo;
            } else if ((4202496 & flags) != 0) {
                applicationInfo = generateApplicationInfoFromSettingsLPw(packageName, flags, filterCallingUid, userId);
                return applicationInfo;
            } else {
                return null;
            }
        }
    }

    private String normalizePackageNameLPr(String packageName) {
        String normalizedPackageName = this.mSettings.getRenamedPackageLPr(packageName);
        return normalizedPackageName != null ? normalizedPackageName : packageName;
    }

    public void deletePreloadsFileCache() {
        if (UserHandle.isSameApp(Binder.getCallingUid(), 1000)) {
            File dir = Environment.getDataPreloadsFileCacheDirectory();
            Slog.i(TAG, "Deleting preloaded file cache " + dir);
            FileUtils.deleteContents(dir);
            return;
        }
        throw new SecurityException("Only system or settings may call deletePreloadsFileCache");
    }

    public void freeStorageAndNotify(String volumeUuid, long freeStorageSize, int storageFlags, IPackageDataObserver observer) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_CACHE", null);
        this.mHandler.post(new com.android.server.pm.-$Lambda$kozCdtU4hxwnpbopzC6ZLMsBV5E.AnonymousClass2((byte) 1, storageFlags, freeStorageSize, this, volumeUuid, observer));
    }

    /* synthetic */ void lambda$-com_android_server_pm_PackageManagerService_258120(String volumeUuid, long freeStorageSize, int storageFlags, IPackageDataObserver observer) {
        boolean success = false;
        try {
            freeStorage(volumeUuid, freeStorageSize, storageFlags);
            success = true;
        } catch (IOException e) {
            Slog.w(TAG, e);
        }
        if (observer != null) {
            try {
                observer.onRemoveCompleted(null, success);
            } catch (RemoteException e2) {
                Slog.w(TAG, e2);
            }
        }
    }

    public void freeStorage(String volumeUuid, long freeStorageSize, int storageFlags, IntentSender pi) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_CACHE", TAG);
        this.mHandler.post(new com.android.server.pm.-$Lambda$kozCdtU4hxwnpbopzC6ZLMsBV5E.AnonymousClass2((byte) 0, storageFlags, freeStorageSize, this, volumeUuid, pi));
    }

    /* synthetic */ void lambda$-com_android_server_pm_PackageManagerService_258919(String volumeUuid, long freeStorageSize, int storageFlags, IntentSender pi) {
        boolean success = false;
        try {
            freeStorage(volumeUuid, freeStorageSize, storageFlags);
            success = true;
        } catch (IOException e) {
            Slog.w(TAG, e);
        }
        if (pi != null) {
            int i;
            if (success) {
                i = 1;
            } else {
                i = 0;
            }
            try {
                pi.sendIntent(null, i, null, null, null);
            } catch (SendIntentException e2) {
                Slog.w(TAG, e2);
            }
        }
    }

    public void freeStorage(String volumeUuid, long bytes, int storageFlags) throws IOException {
        StorageManager storage = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        File file = storage.findPathForUuid(volumeUuid);
        if (file.getUsableSpace() < bytes) {
            if (ENABLE_FREE_CACHE_V2) {
                boolean internalVolume = Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, volumeUuid);
                boolean aggressive = (storageFlags & 1) != 0;
                long reservedBytes = storage.getStorageCacheBytes(file, storageFlags);
                if (internalVolume && (aggressive || SystemProperties.getBoolean("persist.sys.preloads.file_cache_expired", false))) {
                    deletePreloadsFileCache();
                    if (file.getUsableSpace() >= bytes) {
                        return;
                    }
                }
                if (internalVolume && aggressive) {
                    FileUtils.deleteContents(this.mCacheDir);
                    if (file.getUsableSpace() >= bytes) {
                        return;
                    }
                }
                try {
                    this.mInstaller.freeCache(volumeUuid, bytes, reservedBytes, 8192);
                } catch (InstallerException e) {
                }
                if (file.getUsableSpace() < bytes) {
                    if (internalVolume) {
                        if (pruneUnusedStaticSharedLibraries(bytes, Global.getLong(this.mContext.getContentResolver(), "unused_static_shared_lib_min_cache_period", DEFAULT_UNUSED_STATIC_SHARED_LIB_MIN_CACHE_PERIOD))) {
                            return;
                        }
                    }
                    if (internalVolume) {
                        if (this.mInstantAppRegistry.pruneInstalledInstantApps(bytes, Global.getLong(this.mContext.getContentResolver(), "installed_instant_app_min_cache_period", UnixCalendar.WEEK_IN_MILLIS))) {
                            return;
                        }
                    }
                    try {
                        this.mInstaller.freeCache(volumeUuid, bytes, reservedBytes, 24576);
                    } catch (InstallerException e2) {
                    }
                    if (file.getUsableSpace() < bytes) {
                        if (internalVolume) {
                            if (this.mInstantAppRegistry.pruneUninstalledInstantApps(bytes, Global.getLong(this.mContext.getContentResolver(), "uninstalled_instant_app_min_cache_period", UnixCalendar.WEEK_IN_MILLIS))) {
                                return;
                            }
                        }
                    }
                    return;
                }
                return;
            }
            try {
                this.mInstaller.freeCache(volumeUuid, bytes, 0, 0);
            } catch (InstallerException e3) {
            }
            if (file.getUsableSpace() >= bytes) {
                return;
            }
            throw new IOException("Failed to free " + bytes + " on storage device at " + file);
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private boolean pruneUnusedStaticSharedLibraries(long neededSpace, long maxCachePeriod) throws IOException {
        Throwable th;
        File volume = ((StorageManager) this.mContext.getSystemService(StorageManager.class)).findPathForUuid(StorageManager.UUID_PRIVATE_INTERNAL);
        List<VersionedPackage> packagesToDelete = null;
        long now = System.currentTimeMillis();
        synchronized (this.mPackages) {
            try {
                int[] allUsers = sUserManager.getUserIds();
                int libCount = this.mSharedLibraries.size();
                for (int i = 0; i < libCount; i++) {
                    SparseArray<SharedLibraryEntry> versionedLib = (SparseArray) this.mSharedLibraries.valueAt(i);
                    if (versionedLib != null) {
                        int versionCount = versionedLib.size();
                        int j = 0;
                        while (true) {
                            List<VersionedPackage> packagesToDelete2 = packagesToDelete;
                            if (j >= versionCount) {
                                packagesToDelete = packagesToDelete2;
                                break;
                            }
                            try {
                                SharedLibraryInfo libInfo = ((SharedLibraryEntry) versionedLib.valueAt(j)).info;
                                if (!libInfo.isStatic()) {
                                    packagesToDelete = packagesToDelete2;
                                    break;
                                }
                                VersionedPackage declaringPackage = libInfo.getDeclaringPackage();
                                String internalPackageName = resolveInternalPackageNameLPr(declaringPackage.getPackageName(), declaringPackage.getVersionCode());
                                PackageSetting ps = this.mSettings.getPackageLPr(internalPackageName);
                                if (ps == null || now - ps.lastUpdateTime < maxCachePeriod) {
                                    packagesToDelete = packagesToDelete2;
                                } else {
                                    if (packagesToDelete2 == null) {
                                        packagesToDelete = new ArrayList();
                                    } else {
                                        packagesToDelete = packagesToDelete2;
                                    }
                                    packagesToDelete.add(new VersionedPackage(internalPackageName, declaringPackage.getVersionCode()));
                                }
                                j++;
                            } catch (Throwable th2) {
                                th = th2;
                                packagesToDelete = packagesToDelete2;
                                throw th;
                            }
                        }
                    }
                }
            } catch (Throwable th3) {
                th = th3;
            }
        }
    }

    private int updateFlags(int flags, int userId) {
        if ((flags & 786432) != 0) {
            return flags;
        }
        if (getUserManagerInternal().isUserUnlockingOrUnlocked(userId)) {
            return flags | 786432;
        }
        return flags | 524288;
    }

    private UserManagerInternal getUserManagerInternal() {
        if (this.mUserManagerInternal == null) {
            this.mUserManagerInternal = (UserManagerInternal) LocalServices.getService(UserManagerInternal.class);
        }
        return this.mUserManagerInternal;
    }

    private LocalService getDeviceIdleController() {
        if (this.mDeviceIdleController == null) {
            this.mDeviceIdleController = (LocalService) LocalServices.getService(LocalService.class);
        }
        return this.mDeviceIdleController;
    }

    private int updateFlagsForPackage(int flags, int userId, Object cookie) {
        boolean isCallerSystemUser = UserHandle.getCallingUserId() == 0;
        if ((flags & 15) != 0 && (269221888 & flags) == 0) {
        }
        if ((269492224 & flags) == 0) {
        }
        if ((flags & DumpState.DUMP_CHANGES) != 0) {
            enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "MATCH_ANY_USER flag requires INTERACT_ACROSS_USERS permission at " + Debug.getCallers(5));
        } else if ((flags & 8192) != 0 && isCallerSystemUser && sUserManager.hasManagedProfile(0)) {
            flags |= DumpState.DUMP_CHANGES;
        }
        return updateFlags(flags, userId);
    }

    private int updateFlagsForApplication(int flags, int userId, Object cookie) {
        return updateFlagsForPackage(flags, userId, cookie);
    }

    private int updateFlagsForComponent(int flags, int userId, Object cookie) {
        if ((cookie instanceof Intent) && (((Intent) cookie).getFlags() & 256) != 0) {
            flags |= 268435456;
        }
        if ((269221888 & flags) == 0) {
        }
        return updateFlags(flags, userId);
    }

    private Intent updateIntentForResolve(Intent intent) {
        if (intent.getSelector() != null) {
            intent = intent.getSelector();
        }
        if (DEBUG_PREFERRED) {
            intent.addFlags(8);
        }
        return intent;
    }

    int updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid) {
        return updateFlagsForResolve(flags, userId, intent, callingUid, false, false);
    }

    int updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid, boolean wantInstantApps) {
        return updateFlagsForResolve(flags, userId, intent, callingUid, wantInstantApps, false);
    }

    int updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid, boolean wantInstantApps, boolean onlyExposedExplicitly) {
        if (this.mSafeMode) {
            flags |= DumpState.DUMP_DEXOPT;
        }
        if (getInstantAppPackageName(callingUid) != null) {
            if (onlyExposedExplicitly) {
                flags |= PhoneWindowManager.SYSTEM_UI_FLAG_APP_CUSTOM_NAVIGATION_BAR;
            }
            flags = (flags | 16777216) | DumpState.DUMP_VOLUMES;
        } else {
            boolean allowMatchInstant = (wantInstantApps && "android.intent.action.VIEW".equals(intent.getAction()) && hasWebURI(intent)) ? true : (flags & DumpState.DUMP_VOLUMES) != 0 ? canViewInstantApps(callingUid, userId) : false;
            flags &= -50331649;
            if (!allowMatchInstant) {
                flags &= -8388609;
            }
        }
        return updateFlagsForComponent(flags, userId, intent);
    }

    public ActivityInfo getActivityInfo(ComponentName component, int flags, int userId) {
        return getActivityInfoInternal(component, flags, Binder.getCallingUid(), userId);
    }

    private ActivityInfo getActivityInfoInternal(ComponentName component, int flags, int filterCallingUid, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        flags = updateFlagsForComponent(flags, userId, component);
        enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get activity info");
        synchronized (this.mPackages) {
            Activity a = (Activity) this.mActivities.mActivities.get(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getActivityInfo " + component + ": " + a);
            }
            ActivityInfo generateActivityInfo;
            if (a != null && this.mSettings.isEnabledAndMatchLPr(a.info, flags, userId)) {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                } else if (filterAppAccessLPr(ps, filterCallingUid, component, 1, userId)) {
                    return null;
                } else {
                    generateActivityInfo = PackageParser.generateActivityInfo(a, flags, ps.readUserState(userId), userId);
                    return generateActivityInfo;
                }
            } else if (this.mResolveComponentName.equals(component)) {
                generateActivityInfo = PackageParser.generateActivityInfo(this.mResolveActivity, flags, new PackageUserState(), userId);
                return generateActivityInfo;
            } else {
                return null;
            }
        }
    }

    public boolean activitySupportsIntent(ComponentName component, Intent intent, String resolvedType) {
        synchronized (this.mPackages) {
            if (component.equals(this.mResolveComponentName)) {
                return true;
            }
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            Activity a = (Activity) this.mActivities.mActivities.get(component);
            if (a == null) {
                return false;
            }
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return false;
            } else if (filterAppAccessLPr(ps, callingUid, component, 1, callingUserId)) {
                return false;
            } else {
                for (int i = 0; i < a.intents.size(); i++) {
                    if (((ActivityIntentInfo) a.intents.get(i)).match(intent.getAction(), resolvedType, intent.getScheme(), intent.getData(), intent.getCategories(), TAG) >= 0) {
                        return true;
                    }
                }
                return false;
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public ActivityInfo getReceiverInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        flags = updateFlagsForComponent(flags, userId, component);
        enforceCrossUserPermission(callingUid, userId, false, false, "get receiver info");
        synchronized (this.mPackages) {
            Activity a = (Activity) this.mReceivers.mActivities.get(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getReceiverInfo " + component + ": " + a);
            }
            if (a == null || !this.mSettings.isEnabledAndMatchLPr(a.info, flags, userId)) {
            } else {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                } else if (filterAppAccessLPr(ps, callingUid, component, 2, userId)) {
                    return null;
                } else {
                    ActivityInfo generateActivityInfo = PackageParser.generateActivityInfo(a, flags, ps.readUserState(userId), userId);
                    return generateActivityInfo;
                }
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public ParceledListSlice<SharedLibraryInfo> getSharedLibraries(String packageName, int flags, int userId) {
        Throwable th;
        if (!sUserManager.exists(userId)) {
            return null;
        }
        Preconditions.checkArgumentNonnegative(userId, "userId must be >= 0");
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        flags = updateFlagsForPackage(flags, userId, null);
        boolean canSeeStaticLibraries = (this.mContext.checkCallingOrSelfPermission("android.permission.INSTALL_PACKAGES") == 0 || this.mContext.checkCallingOrSelfPermission("android.permission.DELETE_PACKAGES") == 0 || canRequestPackageInstallsInternal(packageName, 67108864, userId, false)) ? true : this.mContext.checkCallingOrSelfPermission("android.permission.REQUEST_DELETE_PACKAGES") == 0;
        synchronized (this.mPackages) {
            List<SharedLibraryInfo> result = null;
            try {
                int libCount = this.mSharedLibraries.size();
                for (int i = 0; i < libCount; i++) {
                    SparseArray<SharedLibraryEntry> versionedLib = (SparseArray) this.mSharedLibraries.valueAt(i);
                    if (versionedLib != null) {
                        int versionCount = versionedLib.size();
                        int j = 0;
                        while (true) {
                            List<SharedLibraryInfo> result2 = result;
                            if (j >= versionCount) {
                                result = result2;
                                break;
                            }
                            long identity;
                            try {
                                SharedLibraryInfo libInfo = ((SharedLibraryEntry) versionedLib.valueAt(j)).info;
                                if (!canSeeStaticLibraries && libInfo.isStatic()) {
                                    result = result2;
                                    break;
                                }
                                identity = Binder.clearCallingIdentity();
                                if (getPackageInfoVersioned(libInfo.getDeclaringPackage(), 67108864 | flags, userId) == null) {
                                    Binder.restoreCallingIdentity(identity);
                                    result = result2;
                                } else {
                                    Binder.restoreCallingIdentity(identity);
                                    SharedLibraryInfo resLibInfo = new SharedLibraryInfo(libInfo.getName(), libInfo.getVersion(), libInfo.getType(), libInfo.getDeclaringPackage(), getPackagesUsingSharedLibraryLPr(libInfo, flags, userId));
                                    if (result2 == null) {
                                        result = new ArrayList();
                                    } else {
                                        result = result2;
                                    }
                                    result.add(resLibInfo);
                                }
                                j++;
                            } catch (Throwable th2) {
                                th = th2;
                                result = result2;
                                throw th;
                            }
                        }
                    }
                }
                ParceledListSlice<SharedLibraryInfo> parceledListSlice = result != null ? new ParceledListSlice(result) : null;
            } catch (Throwable th3) {
                th = th3;
            }
        }
    }

    private List<VersionedPackage> getPackagesUsingSharedLibraryLPr(SharedLibraryInfo libInfo, int flags, int userId) {
        List<VersionedPackage> versionedPackages = null;
        int packageCount = this.mSettings.mPackages.size();
        for (int i = 0; i < packageCount; i++) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.valueAt(i);
            if (ps != null && ((PackageUserState) ps.getUserState().get(userId)).isAvailable(flags)) {
                String libName = libInfo.getName();
                if (libInfo.isStatic()) {
                    int libIdx = ArrayUtils.indexOf(ps.usesStaticLibraries, libName);
                    if (libIdx >= 0 && ps.usesStaticLibrariesVersions[libIdx] == libInfo.getVersion()) {
                        if (versionedPackages == null) {
                            versionedPackages = new ArrayList();
                        }
                        String dependentPackageName = ps.name;
                        if (ps.pkg != null && ps.pkg.applicationInfo.isStaticSharedLibrary()) {
                            dependentPackageName = ps.pkg.manifestPackageName;
                        }
                        versionedPackages.add(new VersionedPackage(dependentPackageName, ps.versionCode));
                    }
                } else if (ps.pkg != null && (ArrayUtils.contains(ps.pkg.usesLibraries, libName) || ArrayUtils.contains(ps.pkg.usesOptionalLibraries, libName))) {
                    if (versionedPackages == null) {
                        versionedPackages = new ArrayList();
                    }
                    versionedPackages.add(new VersionedPackage(ps.name, ps.versionCode));
                }
            }
        }
        return versionedPackages;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public ServiceInfo getServiceInfo(ComponentName component, int flags, int userId) {
        ServiceInfo info;
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        flags = updateFlagsForComponent(flags, userId, component);
        enforceCrossUserPermission(callingUid, userId, false, false, "get service info");
        synchronized (this.mPackages) {
            Service s = (Service) this.mServices.mServices.get(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getServiceInfo " + component + ": " + s);
            }
            if (s == null || !this.mSettings.isEnabledAndMatchLPr(s.info, flags, userId)) {
            } else {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                } else if (filterAppAccessLPr(ps, callingUid, component, 3, userId)) {
                    return null;
                } else {
                    info = PackageParser.generateServiceInfo(s, flags, ps.readUserState(userId), userId);
                    if (info == null && userId == 999) {
                        try {
                            String[] packages = getPackagesForUid(callingUid);
                            if (packages != null) {
                                for (String pkgName : packages) {
                                    if (OppoMultiAppManagerUtil.getInstance().isMultiApp(pkgName)) {
                                        info = PackageParser.generateServiceInfo(s, flags, ps.readUserState(0), 0);
                                        break;
                                    }
                                }
                            }
                        } catch (Exception e) {
                        }
                    }
                }
            }
        }
        return info;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public ProviderInfo getProviderInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        flags = updateFlagsForComponent(flags, userId, component);
        enforceCrossUserPermission(callingUid, userId, false, false, "get provider info");
        synchronized (this.mPackages) {
            Provider p = (Provider) this.mProviders.mProviders.get(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getProviderInfo " + component + ": " + p);
            }
            if (p == null || !this.mSettings.isEnabledAndMatchLPr(p.info, flags, userId)) {
            } else {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                } else if (filterAppAccessLPr(ps, callingUid, component, 4, userId)) {
                    return null;
                } else {
                    ProviderInfo generateProviderInfo = PackageParser.generateProviderInfo(p, flags, ps.readUserState(userId), userId);
                    return generateProviderInfo;
                }
            }
        }
    }

    public String[] getSystemSharedLibraryNames() {
        Throwable th;
        synchronized (this.mPackages) {
            int libCount = this.mSharedLibraries.size();
            int i = 0;
            Set<String> libs = null;
            while (i < libCount) {
                Set<String> libs2;
                try {
                    SparseArray<SharedLibraryEntry> versionedLib = (SparseArray) this.mSharedLibraries.valueAt(i);
                    if (versionedLib == null) {
                        libs2 = libs;
                    } else {
                        int versionCount = versionedLib.size();
                        int j = 0;
                        while (j < versionCount) {
                            SharedLibraryEntry libEntry = (SharedLibraryEntry) versionedLib.valueAt(j);
                            if (libEntry.info.isStatic()) {
                                PackageSetting ps = this.mSettings.getPackageLPr(libEntry.apk);
                                if (ps == null || (filterSharedLibPackageLPr(ps, Binder.getCallingUid(), UserHandle.getUserId(Binder.getCallingUid()), 67108864) ^ 1) == 0) {
                                    j++;
                                } else {
                                    if (libs == null) {
                                        libs2 = new ArraySet();
                                    } else {
                                        libs2 = libs;
                                    }
                                    libs2.add(libEntry.info.getName());
                                }
                            } else {
                                if (libs == null) {
                                    libs2 = new ArraySet();
                                } else {
                                    libs2 = libs;
                                }
                                try {
                                    libs2.add(libEntry.info.getName());
                                } catch (Throwable th2) {
                                    th = th2;
                                }
                            }
                        }
                        libs2 = libs;
                    }
                    i++;
                    libs = libs2;
                } catch (Throwable th3) {
                    th = th3;
                    libs2 = libs;
                    throw th;
                }
            }
            if (libs != null) {
                String[] libsArray = new String[libs.size()];
                libs.toArray(libsArray);
                return libsArray;
            }
            return null;
        }
    }

    public String getServicesSystemSharedLibraryPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mServicesSystemSharedLibraryPackageName;
        }
        return str;
    }

    public String getSharedSystemSharedLibraryPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mSharedSystemSharedLibraryPackageName;
        }
        return str;
    }

    private void updateSequenceNumberLP(PackageSetting pkgSetting, int[] userList) {
        for (int i = userList.length - 1; i >= 0; i--) {
            int userId = userList[i];
            if (!pkgSetting.getInstantApp(userId)) {
                SparseArray<String> changedPackages = (SparseArray) this.mChangedPackages.get(userId);
                if (changedPackages == null) {
                    changedPackages = new SparseArray();
                    this.mChangedPackages.put(userId, changedPackages);
                }
                Map<String, Integer> sequenceNumbers = (Map) this.mChangedPackagesSequenceNumbers.get(userId);
                if (sequenceNumbers == null) {
                    sequenceNumbers = new HashMap();
                    this.mChangedPackagesSequenceNumbers.put(userId, sequenceNumbers);
                }
                Integer sequenceNumber = (Integer) sequenceNumbers.get(pkgSetting.name);
                if (sequenceNumber != null) {
                    changedPackages.remove(sequenceNumber.intValue());
                }
                changedPackages.put(this.mChangedPackagesSequenceNumber, pkgSetting.name);
                sequenceNumbers.put(pkgSetting.name, Integer.valueOf(this.mChangedPackagesSequenceNumber));
            }
        }
        this.mChangedPackagesSequenceNumber++;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public ChangedPackages getChangedPackages(int sequenceNumber, int userId) {
        ChangedPackages changedPackages = null;
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            if (sequenceNumber >= this.mChangedPackagesSequenceNumber) {
                return null;
            }
            SparseArray<String> changedPackages2 = (SparseArray) this.mChangedPackages.get(userId);
            if (changedPackages2 == null) {
                return null;
            }
            List<String> packageNames = new ArrayList(this.mChangedPackagesSequenceNumber - sequenceNumber);
            for (int i = sequenceNumber; i < this.mChangedPackagesSequenceNumber; i++) {
                String packageName = (String) changedPackages2.get(i);
                if (packageName != null) {
                    packageNames.add(packageName);
                }
            }
            if (!packageNames.isEmpty()) {
                changedPackages = new ChangedPackages(this.mChangedPackagesSequenceNumber, packageNames);
            }
        }
    }

    public ParceledListSlice<FeatureInfo> getSystemAvailableFeatures() {
        ArrayList<FeatureInfo> res;
        synchronized (this.mAvailableFeatures) {
            res = new ArrayList(this.mAvailableFeatures.size() + 1);
            res.addAll(this.mAvailableFeatures.values());
        }
        FeatureInfo fi = new FeatureInfo();
        fi.reqGlEsVersion = SystemProperties.getInt("ro.opengles.version", 0);
        res.add(fi);
        return new ParceledListSlice(res);
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean loadRegionFeature(String name) {
        String callerName = getNameForUid(Binder.getCallingUid());
        Slog.d(TAG, "loadRegionFeature callerName = " + callerName);
        if (!(callerName == null || (callerName.contains("android.uid.system") ^ 1) == 0)) {
            synchronized (this.mPackages) {
                Package pkg = (Package) this.mPackages.get(callerName);
                if (pkg == null || (pkg.applicationInfo.isSystemApp() ^ 1) == 0) {
                } else {
                    Slog.d(TAG, "this is not system app : " + callerName);
                    return false;
                }
            }
        }
        SystemConfig systemConfig = SystemConfig.getInstance();
        synchronized (this.mPackages) {
            ArrayMap<String, FeatureInfo> tmp = systemConfig.loadOppoAvailableFeatures(name);
            if (tmp == null || tmp.size() <= 0) {
            } else {
                clearOppoFeatureMap();
                this.mOppoAvailableFeatures = tmp;
                SystemProperties.set("persist.sys.oppo.region", name);
                if (this.mSystemReady) {
                    this.mHandler.postDelayed(this.mClearSystemApp, 1000);
                }
                return true;
            }
        }
    }

    private void clearOppoFeatureMap() {
        if (this.mOppoAvailableFeatures != null) {
            this.mOppoAvailableFeatures = null;
        }
    }

    public FeatureInfo[] getOppoSystemAvailableFeatures() {
        synchronized (this.mPackages) {
            if (this.mOppoAvailableFeatures == null) {
                return null;
            }
            Collection<FeatureInfo> featSet = this.mOppoAvailableFeatures.values();
            int size = featSet.size();
            if (size > 0) {
                FeatureInfo[] features = new FeatureInfo[(size + 1)];
                featSet.toArray(features);
                FeatureInfo fi = new FeatureInfo();
                fi.reqGlEsVersion = SystemProperties.getInt("ro.opengles.version", 0);
                features[size] = fi;
                return features;
            }
            return null;
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean hasSystemFeature(String name, int version) {
        boolean z = true;
        synchronized (this.mAvailableFeatures) {
            if (this.mOppoAvailableFeatures == null || !this.mOppoAvailableFeatures.containsKey(name)) {
                FeatureInfo feat = (FeatureInfo) this.mAvailableFeatures.get(name);
                if (feat == null) {
                    return false;
                } else if (feat.version < version) {
                    z = false;
                }
            } else {
                return true;
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public int checkPermission(String permName, String pkgName, int userId) {
        if (!sUserManager.exists(userId)) {
            return -1;
        }
        int callingUid = Binder.getCallingUid();
        synchronized (this.mPackages) {
            Package p = (Package) this.mPackages.get(pkgName);
            if (!(p == null || p.mExtras == null)) {
                PackageSetting ps = p.mExtras;
                if (filterAppAccessLPr(ps, callingUid, userId)) {
                    return -1;
                }
                boolean instantApp = ps.getInstantApp(userId);
                PermissionsState permissionsState = ps.getPermissionsState();
                if (permissionsState.hasPermission(permName, userId)) {
                    if (instantApp) {
                        BasePermission bp = (BasePermission) this.mSettings.mPermissions.get(permName);
                        if (bp != null && bp.isInstant()) {
                            return 0;
                        }
                    }
                    return 0;
                }
                if ("android.permission.ACCESS_COARSE_LOCATION".equals(permName) && permissionsState.hasPermission(OppoPermissionConstants.PERMISSION_ACCESS, userId)) {
                    return 0;
                }
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public int checkUidPermission(String permName, int uid) {
        Object obj;
        if (OppoManager.isInnerVersion.booleanValue() && this.mContext != null) {
            PackageManager packageManager = this.mContext.getPackageManager();
            if (packageManager != null) {
                String[] packages = packageManager.getPackagesForUid(uid);
                if (packages != null) {
                    for (String packageName : packages) {
                        if (OppoManager.grList.contains(packageName) || packageName.equals("com.android.vending")) {
                            obj = this.mSettings.getUserIdLPr(uid);
                            Signature[] s = null;
                            if (obj != null) {
                                if (obj instanceof SharedUserSetting) {
                                    s = ((SharedUserSetting) obj).signatures.mSignatures;
                                } else if (obj instanceof PackageSetting) {
                                    s = ((PackageSetting) obj).signatures.mSignatures;
                                }
                            }
                            if (compareSignatures(s, OppoManager.grSig) == 0) {
                                return 0;
                            }
                        }
                    }
                }
            }
        }
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
        boolean isUidInstantApp = getInstantAppPackageName(uid) != null;
        int userId = UserHandle.getUserId(uid);
        if (!sUserManager.exists(userId)) {
            return -1;
        }
        synchronized (this.mPackages) {
            obj = this.mSettings.getUserIdLPr(UserHandle.getAppId(uid));
            if (OppoPackageManagerHelper.revokeShellPermission(this.mContext, permName, uid)) {
                return -1;
            } else if (obj != null) {
                if (obj instanceof SharedUserSetting) {
                    if (isCallerInstantApp) {
                        return -1;
                    }
                } else if (obj instanceof PackageSetting) {
                    if (filterAppAccessLPr((PackageSetting) obj, callingUid, callingUserId)) {
                        return -1;
                    }
                }
                PermissionsState permissionsState = ((SettingBase) obj).getPermissionsState();
                if (permissionsState.hasPermission(permName, userId)) {
                    if (isUidInstantApp) {
                        BasePermission bp = (BasePermission) this.mSettings.mPermissions.get(permName);
                        if (bp != null && bp.isInstant()) {
                            return 0;
                        }
                    }
                    return 0;
                }
                if ("android.permission.ACCESS_COARSE_LOCATION".equals(permName) && permissionsState.hasPermission(OppoPermissionConstants.PERMISSION_ACCESS, userId)) {
                    return 0;
                }
            } else {
                ArraySet<String> perms = (ArraySet) this.mSystemPermissions.get(uid);
                if (perms != null) {
                    if (perms.contains(permName)) {
                        return 0;
                    } else if ("android.permission.ACCESS_COARSE_LOCATION".equals(permName) && perms.contains(OppoPermissionConstants.PERMISSION_ACCESS)) {
                        return 0;
                    }
                }
            }
        }
    }

    public boolean isPermissionRevokedByPolicy(String permission, String packageName, int userId) {
        boolean z = false;
        if (UserHandle.getCallingUserId() != userId) {
            this.mContext.enforceCallingPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "isPermissionRevokedByPolicy for user " + userId);
        }
        if (checkPermission(permission, packageName, userId) == 0) {
            return false;
        }
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            if (!isCallerSameApp(packageName, callingUid)) {
                return false;
            }
        } else if (isInstantApp(packageName, userId)) {
            return false;
        }
        long identity = Binder.clearCallingIdentity();
        try {
            if ((getPermissionFlags(permission, packageName, userId) & 4) != 0) {
                z = true;
            }
            Binder.restoreCallingIdentity(identity);
            return z;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(identity);
        }
    }

    public String getPermissionControllerPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mRequiredInstallerPackage;
        }
        return str;
    }

    public boolean inCptWhiteList(int type, String verifyStr) {
        return mCompatibilityHelper.isInWhiteList(type, verifyStr);
    }

    public boolean inPmsWhiteList(int type, String verifyStr, List<String> defaultList) {
        return ColorPackageManagerHelper.inPmsWhiteList(type, verifyStr, defaultList);
    }

    void enforceCrossUserPermission(int callingUid, int userId, boolean requireFullPermission, boolean checkShell, String message) {
        if (userId < 0) {
            throw new IllegalArgumentException("Invalid userId " + userId);
        }
        if (checkShell) {
            enforceShellRestriction("no_debugging_features", callingUid, userId);
        }
        if (!(userId == UserHandle.getUserId(callingUid) || OppoMultiAppManager.getInstance().enforceCrossUserPermission(callingUid, userId) || callingUid == 1000 || callingUid == 0)) {
            if (requireFullPermission) {
                this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", message);
            } else {
                try {
                    this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", message);
                } catch (SecurityException e) {
                    this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS", message);
                }
            }
        }
    }

    void enforceShellRestriction(String restriction, int callingUid, int userHandle) {
        if (callingUid != 2000) {
            return;
        }
        if (userHandle >= 0 && sUserManager.hasUserRestriction(restriction, userHandle)) {
            throw new SecurityException("Shell does not have permission to access user " + userHandle);
        } else if (userHandle < 0) {
            Slog.e(TAG, "Unable to check shell permission for user " + userHandle + "\n\t" + Debug.getCallers(3));
        }
    }

    private BasePermission findPermissionTreeLP(String permName) {
        for (BasePermission bp : this.mSettings.mPermissionTrees.values()) {
            if (permName.startsWith(bp.name) && permName.length() > bp.name.length() && permName.charAt(bp.name.length()) == '.') {
                return bp;
            }
        }
        return null;
    }

    private BasePermission checkPermissionTreeLP(String permName) {
        if (permName != null) {
            BasePermission bp = findPermissionTreeLP(permName);
            if (bp != null) {
                if (bp.uid == UserHandle.getAppId(Binder.getCallingUid())) {
                    return bp;
                }
                throw new SecurityException("Calling uid " + Binder.getCallingUid() + " is not allowed to add to permission tree " + bp.name + " owned by uid " + bp.uid);
            }
        }
        throw new SecurityException("No permission tree found for " + permName);
    }

    static boolean compareStrings(CharSequence s1, CharSequence s2) {
        boolean z = false;
        if (s1 == null) {
            if (s2 == null) {
                z = true;
            }
            return z;
        } else if (s2 != null && s1.getClass() == s2.getClass()) {
            return s1.equals(s2);
        } else {
            return false;
        }
    }

    static boolean comparePermissionInfos(PermissionInfo pi1, PermissionInfo pi2) {
        if (pi1.icon == pi2.icon && pi1.logo == pi2.logo && pi1.protectionLevel == pi2.protectionLevel && compareStrings(pi1.name, pi2.name) && compareStrings(pi1.nonLocalizedLabel, pi2.nonLocalizedLabel) && compareStrings(pi1.packageName, pi2.packageName)) {
            return true;
        }
        return false;
    }

    int permissionInfoFootprint(PermissionInfo info) {
        int size = info.name.length();
        if (info.nonLocalizedLabel != null) {
            size += info.nonLocalizedLabel.length();
        }
        if (info.nonLocalizedDescription != null) {
            return size + info.nonLocalizedDescription.length();
        }
        return size;
    }

    int calculateCurrentPermissionFootprintLocked(BasePermission tree) {
        int size = 0;
        for (BasePermission perm : this.mSettings.mPermissions.values()) {
            if (perm.uid == tree.uid) {
                size += perm.name.length() + permissionInfoFootprint(perm.perm.info);
            }
        }
        return size;
    }

    void enforcePermissionCapLocked(PermissionInfo info, BasePermission tree) {
        if (tree.uid != 1000) {
            if (permissionInfoFootprint(info) + calculateCurrentPermissionFootprintLocked(tree) > 32768) {
                throw new SecurityException("Permission tree size cap exceeded");
            }
        }
    }

    boolean addPermissionLocked(PermissionInfo info, boolean async) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            throw new SecurityException("Instant apps can't add permissions");
        } else if (info.labelRes == 0 && info.nonLocalizedLabel == null) {
            throw new SecurityException("Label must be specified in permission");
        } else {
            BasePermission tree = checkPermissionTreeLP(info.name);
            BasePermission bp = (BasePermission) this.mSettings.mPermissions.get(info.name);
            boolean added = bp == null;
            boolean changed = true;
            int fixedLevel = PermissionInfo.fixProtectionLevel(info.protectionLevel);
            if (added) {
                enforcePermissionCapLocked(info, tree);
                bp = new BasePermission(info.name, tree.sourcePackage, 2);
            } else if (bp.type != 2) {
                throw new SecurityException("Not allowed to modify non-dynamic permission " + info.name);
            } else if (bp.protectionLevel == fixedLevel && bp.perm.owner.equals(tree.perm.owner) && bp.uid == tree.uid && comparePermissionInfos(bp.perm.info, info)) {
                changed = false;
            }
            bp.protectionLevel = fixedLevel;
            PermissionInfo info2 = new PermissionInfo(info);
            info2.protectionLevel = fixedLevel;
            bp.perm = new Permission(tree.perm.owner, info2);
            bp.perm.info.packageName = tree.perm.info.packageName;
            bp.uid = tree.uid;
            if (added) {
                this.mSettings.mPermissions.put(info2.name, bp);
            }
            if (changed) {
                if (async) {
                    scheduleWriteSettingsLocked();
                } else {
                    this.mSettings.writeLPr();
                }
            }
            return added;
        }
    }

    public boolean addPermission(PermissionInfo info) {
        boolean addPermissionLocked;
        synchronized (this.mPackages) {
            addPermissionLocked = addPermissionLocked(info, false);
        }
        return addPermissionLocked;
    }

    public boolean addPermissionAsync(PermissionInfo info) {
        boolean addPermissionLocked;
        synchronized (this.mPackages) {
            addPermissionLocked = addPermissionLocked(info, true);
        }
        return addPermissionLocked;
    }

    public void removePermission(String name) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            throw new SecurityException("Instant applications don't have access to this method");
        }
        synchronized (this.mPackages) {
            checkPermissionTreeLP(name);
            BasePermission bp = (BasePermission) this.mSettings.mPermissions.get(name);
            if (bp != null) {
                if (bp.type != 2) {
                    throw new SecurityException("Not allowed to modify non-dynamic permission " + name);
                }
                this.mSettings.mPermissions.remove(name);
                this.mSettings.writeLPr();
            }
        }
    }

    private static void enforceDeclaredAsUsedAndRuntimeOrDevelopmentPermission(Package pkg, BasePermission bp) {
        if (pkg.requestedPermissions.indexOf(bp.name) == -1) {
            throw new SecurityException("Package " + pkg.packageName + " has not requested permission " + bp.name);
        } else if (!bp.isRuntime() && (bp.isDevelopment() ^ 1) != 0) {
            throw new SecurityException("Permission " + bp.name + " is not a changeable permission type");
        }
    }

    public void grantRuntimePermission(String packageName, String name, int userId) {
        grantRuntimePermission(packageName, name, userId, false);
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void grantRuntimePermission(String packageName, String name, int userId, boolean overridePolicy) {
        int uid;
        if (sUserManager.exists(userId)) {
            int callingUid = Binder.getCallingUid();
            try {
                this.mContext.enforceCallingOrSelfPermission("oppo.permission.OPPO_COMPONENT_SAFE", "grantRuntimePermission");
            } catch (SecurityException e) {
                this.mContext.enforceCallingOrSelfPermission("android.permission.GRANT_RUNTIME_PERMISSIONS", "grantRuntimePermission");
            }
            enforceCrossUserPermission(callingUid, userId, true, true, "grantRuntimePermission");
            boolean supportRuntimeAlert = hasSystemFeature("oppo.runtime.permission.alert.support", 0);
            synchronized (this.mPackages) {
                Package pkg = (Package) this.mPackages.get(packageName);
                if (pkg == null) {
                    throw new IllegalArgumentException("Unknown package: " + packageName);
                }
                if (pkg.applicationInfo != null) {
                    boolean isSystem = pkg.applicationInfo.isSystemApp();
                }
                BasePermission bp = (BasePermission) this.mSettings.mPermissions.get(name);
                if (bp == null) {
                    throw new IllegalArgumentException("Unknown permission: " + name);
                }
                PackageSetting ps = pkg.mExtras;
                if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                    throw new IllegalArgumentException("Unknown package: " + packageName);
                }
                enforceDeclaredAsUsedAndRuntimeOrDevelopmentPermission(pkg, bp);
                if (this.mPermissionReviewRequired && pkg.applicationInfo.targetSdkVersion < 23 && bp.isRuntime()) {
                    return;
                }
                uid = UserHandle.getUid(userId, pkg.applicationInfo.uid);
                PermissionsState permissionsState = ps.getPermissionsState();
                int flags = permissionsState.getPermissionFlags(name, userId);
                if ((flags & 16) != 0) {
                    throw new SecurityException("Cannot grant system fixed permission " + name + " for package " + packageName);
                } else if (!overridePolicy && (flags & 4) != 0) {
                    throw new SecurityException("Cannot grant policy fixed permission " + name + " for package " + packageName);
                } else if (bp.isDevelopment()) {
                    if (permissionsState.grantInstallPermission(bp) != -1) {
                        scheduleWriteSettingsLocked();
                    }
                } else if (ps.getInstantApp(userId) && (bp.isInstant() ^ 1) != 0) {
                    throw new SecurityException("Cannot grant non-ephemeral permission" + name + " for package " + packageName);
                } else if (pkg.applicationInfo.targetSdkVersion < 23) {
                    Slog.w(TAG, "Cannot grant runtime permission to a legacy app");
                    return;
                } else {
                    switch (permissionsState.grantRuntimePermission(bp, userId)) {
                        case -1:
                            return;
                        case 1:
                            final int appId = UserHandle.getAppId(pkg.applicationInfo.uid);
                            final int i = userId;
                            this.mHandler.post(new Runnable() {
                                public void run() {
                                    PackageManagerService.this.killUid(appId, i, PackageManagerService.KILL_APP_REASON_GIDS_CHANGED);
                                }
                            });
                            break;
                    }
                    if (bp.isRuntime()) {
                        logPermissionGranted(this.mContext, name, packageName);
                    }
                    this.mOnPermissionChangeListeners.onPermissionsChanged(uid);
                    this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
                }
            }
        } else {
            Log.e(TAG, "No such user:" + userId);
            return;
        }
        if ("android.permission.READ_EXTERNAL_STORAGE".equals(name) || "android.permission.WRITE_EXTERNAL_STORAGE".equals(name)) {
            long token = Binder.clearCallingIdentity();
            try {
                if (sUserManager.isInitialized(userId)) {
                    StorageManagerInternal storageManagerInternal = (StorageManagerInternal) LocalServices.getService(StorageManagerInternal.class);
                    storageManagerInternal.onExternalStoragePolicyChanged(uid, packageName);
                    if (packageName != null && sUserManager.exists(OppoMultiAppManager.USER_ID) && OppoMultiAppManagerUtil.getInstance().isMultiApp(packageName)) {
                        PackageSetting pkgSetting = (PackageSetting) this.mSettings.mPackages.get(packageName);
                        if (pkgSetting != null && pkgSetting.getInstalled(OppoMultiAppManager.USER_ID)) {
                            storageManagerInternal.onExternalStoragePolicyChanged(UserHandle.getUid(OppoMultiAppManager.USER_ID, uid), packageName);
                        }
                    }
                }
                Binder.restoreCallingIdentity(token);
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(token);
            }
        }
    }

    public void revokeRuntimePermission(String packageName, String name, int userId) {
        revokeRuntimePermission(packageName, name, userId, false);
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void revokeRuntimePermission(String packageName, String name, int userId, boolean overridePolicy) {
        boolean isSystem;
        int appId;
        if (sUserManager.exists(userId)) {
            try {
                this.mContext.enforceCallingOrSelfPermission("oppo.permission.OPPO_COMPONENT_SAFE", "revokeRuntimePermission");
            } catch (SecurityException e) {
                this.mContext.enforceCallingOrSelfPermission("android.permission.REVOKE_RUNTIME_PERMISSIONS", "revokeRuntimePermission");
            }
            enforceCrossUserPermission(Binder.getCallingUid(), userId, true, true, "revokeRuntimePermission");
            isSystem = false;
            boolean supportRuntimeAlert = hasSystemFeature("oppo.runtime.permission.alert.support", 0);
            synchronized (this.mPackages) {
                Package pkg = (Package) this.mPackages.get(packageName);
                if (pkg == null) {
                    throw new IllegalArgumentException("Unknown package: " + packageName);
                }
                if (pkg.applicationInfo != null) {
                    isSystem = pkg.applicationInfo.isSystemApp();
                }
                PackageSetting ps = pkg.mExtras;
                if (ps != null) {
                    if (!filterAppAccessLPr(ps, Binder.getCallingUid(), userId)) {
                        BasePermission bp = (BasePermission) this.mSettings.mPermissions.get(name);
                        if (bp == null) {
                            throw new IllegalArgumentException("Unknown permission: " + name);
                        }
                        enforceDeclaredAsUsedAndRuntimeOrDevelopmentPermission(pkg, bp);
                        if (this.mPermissionReviewRequired && pkg.applicationInfo.targetSdkVersion < 23 && bp.isRuntime()) {
                            return;
                        }
                        PermissionsState permissionsState = ps.getPermissionsState();
                        int flags = permissionsState.getPermissionFlags(name, userId);
                        if ((flags & 16) != 0) {
                            throw new SecurityException("Cannot revoke system fixed permission " + name + " for package " + packageName);
                        } else if (!overridePolicy && (flags & 4) != 0) {
                            throw new SecurityException("Cannot revoke policy fixed permission " + name + " for package " + packageName);
                        } else if (bp.isDevelopment()) {
                            if (permissionsState.revokeInstallPermission(bp) != -1) {
                                scheduleWriteSettingsLocked();
                            }
                        } else if (permissionsState.revokeRuntimePermission(bp, userId) == -1) {
                            return;
                        } else {
                            if (bp.isRuntime()) {
                                logPermissionRevoked(this.mContext, name, packageName);
                            }
                            this.mOnPermissionChangeListeners.onPermissionsChanged(pkg.applicationInfo.uid);
                            this.mSettings.writeRuntimePermissionsForUserLPr(userId, true);
                            appId = UserHandle.getAppId(pkg.applicationInfo.uid);
                        }
                    }
                }
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        Log.e(TAG, "No such user:" + userId);
        return;
        long identity;
        Binder.restoreCallingIdentity(identity);
        if (isSystem) {
            Slog.i(TAG, "Force stop " + packageName + ": " + KILL_APP_REASON_PERMISSIONS_REVOKED);
            identity = Binder.clearCallingIdentity();
            try {
                IActivityManager am = ActivityManagerNative.getDefault();
                if (am != null) {
                    try {
                        am.forceStopPackage(packageName, userId);
                    } catch (RemoteException e2) {
                    }
                }
                Binder.restoreCallingIdentity(identity);
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(identity);
            }
        } else {
            killUid(appId, userId, KILL_APP_REASON_PERMISSIONS_REVOKED);
        }
    }

    private static int getBaseEventId(String name) {
        int eventIdIndex = ALL_DANGEROUS_PERMISSIONS.indexOf(name);
        if (eventIdIndex != -1) {
            return (eventIdIndex * 4) + 634;
        }
        if (AppOpsManager.permissionToOpCode(name) == -1 || Build.IS_USER) {
            Log.i(TAG, "Unknown permission " + name);
            return 630;
        }
        throw new IllegalStateException("Unknown permission " + name);
    }

    private static void logPermissionRevoked(Context context, String name, String packageName) {
        MetricsLogger.action(context, getBaseEventId(name) + 3, packageName);
    }

    private static void logPermissionGranted(Context context, String name, String packageName) {
        MetricsLogger.action(context, getBaseEventId(name) + 1, packageName);
    }

    public void resetRuntimePermissions() {
        this.mContext.enforceCallingOrSelfPermission("android.permission.REVOKE_RUNTIME_PERMISSIONS", "revokeRuntimePermission");
        int callingUid = Binder.getCallingUid();
        if (!(callingUid == 1000 || callingUid == 0)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "resetRuntimePermissions");
        }
        synchronized (this.mPackages) {
            updatePermissionsLPw(null, null, 1);
            for (int userId : UserManagerService.getInstance().getUserIds()) {
                int packageCount = this.mPackages.size();
                for (int i = 0; i < packageCount; i++) {
                    Package pkg = (Package) this.mPackages.valueAt(i);
                    if (pkg.mExtras instanceof PackageSetting) {
                        resetUserChangesToRuntimePermissionsAndFlagsLPw(pkg.mExtras, userId);
                    }
                }
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public int getPermissionFlags(String name, String packageName, int userId) {
        if (!sUserManager.exists(userId)) {
            return 0;
        }
        enforceGrantRevokeRuntimePermissionPermissions("getPermissionFlags");
        int callingUid = Binder.getCallingUid();
        enforceCrossUserPermission(callingUid, userId, true, false, "getPermissionFlags");
        synchronized (this.mPackages) {
            Package pkg = (Package) this.mPackages.get(packageName);
            if (pkg == null) {
                return 0;
            } else if (((BasePermission) this.mSettings.mPermissions.get(name)) == null) {
                return 0;
            } else {
                PackageSetting ps = pkg.mExtras;
                if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                } else {
                    int permissionFlags = ps.getPermissionsState().getPermissionFlags(name, userId);
                    return permissionFlags;
                }
            }
        }
    }

    public void updatePermissionFlags(String name, String packageName, int flagMask, int flagValues, int userId) {
        if (sUserManager.exists(userId)) {
            enforceGrantRevokeRuntimePermissionPermissions("updatePermissionFlags");
            int callingUid = Binder.getCallingUid();
            enforceCrossUserPermission(callingUid, userId, true, true, "updatePermissionFlags");
            if (getCallingUid() != 1000) {
                flagMask = (flagMask & -17) & -33;
                flagValues = ((flagValues & -17) & -33) & -65;
            }
            synchronized (this.mPackages) {
                Package pkg = (Package) this.mPackages.get(packageName);
                if (pkg == null) {
                    throw new IllegalArgumentException("Unknown package: " + packageName);
                }
                PackageSetting ps = pkg.mExtras;
                if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                    throw new IllegalArgumentException("Unknown package: " + packageName);
                }
                BasePermission bp = (BasePermission) this.mSettings.mPermissions.get(name);
                if (bp == null) {
                    throw new IllegalArgumentException("Unknown permission: " + name);
                }
                PermissionsState permissionsState = ps.getPermissionsState();
                boolean hadState = permissionsState.getRuntimePermissionState(name, userId) != null;
                if (permissionsState.updatePermissionFlags(bp, userId, flagMask, flagValues)) {
                    if (permissionsState.getInstallPermissionState(name) != null) {
                        scheduleWriteSettingsLocked();
                    } else if (permissionsState.getRuntimePermissionState(name, userId) != null || hadState) {
                        this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
                    }
                }
            }
        }
    }

    public void updatePermissionFlagsForAllApps(int flagMask, int flagValues, int userId) {
        if (sUserManager.exists(userId)) {
            enforceGrantRevokeRuntimePermissionPermissions("updatePermissionFlagsForAllApps");
            enforceCrossUserPermission(Binder.getCallingUid(), userId, true, true, "updatePermissionFlagsForAllApps");
            if (getCallingUid() != 1000) {
                flagMask &= -17;
                flagValues &= -17;
            }
            synchronized (this.mPackages) {
                boolean changed = false;
                int packageCount = this.mPackages.size();
                for (int pkgIndex = 0; pkgIndex < packageCount; pkgIndex++) {
                    PackageSetting ps = ((Package) this.mPackages.valueAt(pkgIndex)).mExtras;
                    if (ps != null) {
                        changed |= ps.getPermissionsState().updatePermissionFlagsForAllPermissions(userId, flagMask, flagValues);
                    }
                }
                if (changed) {
                    this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
                }
            }
        }
    }

    private void enforceGrantRevokeRuntimePermissionPermissions(String message) {
        if (this.mContext.checkCallingOrSelfPermission("android.permission.GRANT_RUNTIME_PERMISSIONS") != 0 && this.mContext.checkCallingOrSelfPermission("android.permission.REVOKE_RUNTIME_PERMISSIONS") != 0) {
            throw new SecurityException(message + " requires " + "android.permission.GRANT_RUNTIME_PERMISSIONS" + " or " + "android.permission.REVOKE_RUNTIME_PERMISSIONS");
        }
    }

    public boolean shouldShowRequestPermissionRationale(String permissionName, String packageName, int userId) {
        boolean z = false;
        if (UserHandle.getCallingUserId() != userId) {
            this.mContext.enforceCallingPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "canShowRequestPermissionRationale for user " + userId);
        }
        if (UserHandle.getAppId(getCallingUid()) != UserHandle.getAppId(getPackageUid(packageName, 268435456, userId)) || checkPermission(permissionName, packageName, userId) == 0) {
            return false;
        }
        long identity = Binder.clearCallingIdentity();
        try {
            int flags = getPermissionFlags(permissionName, packageName, userId);
            if ((flags & 22) != 0) {
                return false;
            }
            if ((flags & 1) != 0) {
                z = true;
            }
            return z;
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    public void addOnPermissionsChangeListener(IOnPermissionsChangeListener listener) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.OBSERVE_GRANT_REVOKE_PERMISSIONS", "addOnPermissionsChangeListener");
        synchronized (this.mPackages) {
            this.mOnPermissionChangeListeners.addListenerLocked(listener);
        }
    }

    public void removeOnPermissionsChangeListener(IOnPermissionsChangeListener listener) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            throw new SecurityException("Instant applications don't have access to this method");
        }
        synchronized (this.mPackages) {
            this.mOnPermissionChangeListeners.removeListenerLocked(listener);
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean isProtectedBroadcast(String actionName) {
        synchronized (this.mProtectedBroadcasts) {
            if (this.mProtectedBroadcasts.contains(actionName)) {
                return true;
            } else if (actionName != null) {
                if (actionName.startsWith("android.net.netmon.lingerExpired") || actionName.startsWith("com.android.server.sip.SipWakeupTimer") || actionName.startsWith("com.android.internal.telephony.data-reconnect") || actionName.startsWith("android.net.netmon.launchCaptivePortalApp")) {
                }
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public int checkSignatures(String pkg1, String pkg2) {
        synchronized (this.mPackages) {
            Package p1 = (Package) this.mPackages.get(pkg1);
            Package p2 = (Package) this.mPackages.get(pkg2);
            if (!(p1 == null || p1.mExtras == null || p2 == null)) {
                if (p2.mExtras != null) {
                    int callingUid = Binder.getCallingUid();
                    int callingUserId = UserHandle.getUserId(callingUid);
                    PackageSetting ps2 = p2.mExtras;
                    if (filterAppAccessLPr(p1.mExtras, callingUid, callingUserId) || filterAppAccessLPr(ps2, callingUid, callingUserId)) {
                    } else {
                        int compareSignatures = compareSignatures(p1.mSignatures, p2.mSignatures);
                        return compareSignatures;
                    }
                }
            }
        }
    }

    public int checkUidSignatures(int uid1, int uid2) {
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
        uid1 = UserHandle.getAppId(uid1);
        uid2 = UserHandle.getAppId(uid2);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getUserIdLPr(uid1);
            if (obj != null) {
                Signature[] s1;
                PackageSetting ps;
                if (obj instanceof SharedUserSetting) {
                    if (isCallerInstantApp) {
                        return -4;
                    }
                    s1 = ((SharedUserSetting) obj).signatures.mSignatures;
                } else if (obj instanceof PackageSetting) {
                    ps = (PackageSetting) obj;
                    if (filterAppAccessLPr(ps, callingUid, callingUserId)) {
                        return -4;
                    }
                    s1 = ps.signatures.mSignatures;
                } else {
                    return -4;
                }
                obj = this.mSettings.getUserIdLPr(uid2);
                if (obj != null) {
                    Signature[] s2;
                    if (obj instanceof SharedUserSetting) {
                        if (isCallerInstantApp) {
                            return -4;
                        }
                        s2 = ((SharedUserSetting) obj).signatures.mSignatures;
                    } else if (obj instanceof PackageSetting) {
                        ps = (PackageSetting) obj;
                        if (filterAppAccessLPr(ps, callingUid, callingUserId)) {
                            return -4;
                        }
                        s2 = ps.signatures.mSignatures;
                    } else {
                        return -4;
                    }
                    int compareSignatures = compareSignatures(s1, s2);
                    return compareSignatures;
                }
                return -4;
            }
            return -4;
        }
    }

    private void killUid(int appId, int userId, String reason) {
        long identity = Binder.clearCallingIdentity();
        try {
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                try {
                    am.killUid(appId, userId, reason);
                } catch (RemoteException e) {
                }
            }
            Binder.restoreCallingIdentity(identity);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(identity);
        }
    }

    static int compareSignatures(Signature[] s1, Signature[] s2) {
        int i = 1;
        if (s1 == null) {
            if (s2 != null) {
                i = -1;
            }
            return i;
        } else if (s2 == null) {
            return -2;
        } else {
            if (s1.length != s2.length) {
                return -3;
            }
            if (s1.length == 1) {
                return s1[0].equals(s2[0]) ? 0 : -3;
            }
            ArraySet<Signature> set1 = new ArraySet();
            for (Signature sig : s1) {
                set1.add(sig);
            }
            ArraySet<Signature> set2 = new ArraySet();
            for (Signature sig2 : s2) {
                set2.add(sig2);
            }
            return set1.equals(set2) ? 0 : -3;
        }
    }

    private boolean isCompatSignatureUpdateNeeded(Package scannedPkg) {
        return getSettingsVersionForPackage(scannedPkg).databaseVersion < 2;
    }

    private int compareSignaturesCompat(PackageSignatures existingSigs, Package scannedPkg) {
        if (!isCompatSignatureUpdateNeeded(scannedPkg)) {
            return -3;
        }
        ArraySet<Signature> existingSet = new ArraySet();
        for (Signature sig : existingSigs.mSignatures) {
            existingSet.add(sig);
        }
        ArraySet<Signature> scannedCompatSet = new ArraySet();
        for (Signature sig2 : scannedPkg.mSignatures) {
            try {
                for (Signature chainSig : sig2.getChainSignatures()) {
                    scannedCompatSet.add(chainSig);
                }
            } catch (CertificateEncodingException e) {
                scannedCompatSet.add(sig2);
            }
        }
        if (!scannedCompatSet.equals(existingSet)) {
            return -3;
        }
        existingSigs.assignSignatures(scannedPkg.mSignatures);
        synchronized (this.mPackages) {
            this.mSettings.mKeySetManagerService.removeAppKeySetDataLPw(scannedPkg.packageName);
        }
        return 0;
    }

    private boolean isRecoverSignatureUpdateNeeded(Package scannedPkg) {
        return getSettingsVersionForPackage(scannedPkg).databaseVersion < 3;
    }

    private int compareSignaturesRecover(PackageSignatures existingSigs, Package scannedPkg) {
        if (!isRecoverSignatureUpdateNeeded(scannedPkg)) {
            return -3;
        }
        String msg = null;
        try {
            if (Signature.areEffectiveMatch(existingSigs.mSignatures, scannedPkg.mSignatures)) {
                logCriticalInfo(4, "Recovered effectively matching certificates for " + scannedPkg.packageName);
                return 0;
            }
        } catch (CertificateException e) {
            msg = e.getMessage();
        }
        logCriticalInfo(4, "Failed to recover certificates for " + scannedPkg.packageName + ": " + msg);
        return -3;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public List<String> getAllPackages() {
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        synchronized (this.mPackages) {
            if (canViewInstantApps(callingUid, callingUserId)) {
                List arrayList = new ArrayList(this.mPackages.keySet());
                return arrayList;
            }
            String instantAppPkgName = getInstantAppPackageName(callingUid);
            List<String> result = new ArrayList();
            if (instantAppPkgName != null) {
                for (Package pkg : this.mPackages.values()) {
                    if (pkg.visibleToInstantApps) {
                        result.add(pkg.packageName);
                    }
                }
            } else {
                for (Package pkg2 : this.mPackages.values()) {
                    PackageSetting ps = pkg2.mExtras != null ? (PackageSetting) pkg2.mExtras : null;
                    if (ps == null || !ps.getInstantApp(callingUserId) || (this.mInstantAppRegistry.isInstantAccessGranted(callingUserId, UserHandle.getAppId(callingUid), ps.appId) ^ 1) == 0) {
                        result.add(pkg2.packageName);
                    }
                }
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public String[] getPackagesForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
        int userId = UserHandle.getUserId(uid);
        uid = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getUserIdLPr(uid);
            PackageSetting ps;
            if (obj instanceof SharedUserSetting) {
                if (isCallerInstantApp) {
                    return null;
                }
                SharedUserSetting sus = (SharedUserSetting) obj;
                String[] res = new String[sus.packages.size()];
                Iterator<PackageSetting> it = sus.packages.iterator();
                int i = 0;
                while (true) {
                    int i2 = i;
                    if (it.hasNext()) {
                        ps = (PackageSetting) it.next();
                        if (ps.getInstalled(userId)) {
                            i = i2 + 1;
                            res[i2] = ps.name;
                        } else {
                            res = (String[]) ArrayUtils.removeElement(String.class, res, res[i2]);
                            i = i2;
                        }
                    } else {
                        return res;
                    }
                }
            } else if (obj instanceof PackageSetting) {
                ps = (PackageSetting) obj;
                if (ps.getInstalled(userId) && (filterAppAccessLPr(ps, callingUid, userId) ^ 1) != 0) {
                    String[] strArr = new String[]{ps.name};
                    return strArr;
                }
            }
        }
    }

    public String getNameForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getUserIdLPr(UserHandle.getAppId(uid));
            String str;
            if (obj instanceof SharedUserSetting) {
                SharedUserSetting sus = (SharedUserSetting) obj;
                str = sus.name + ":" + sus.userId;
                return str;
            } else if (obj instanceof PackageSetting) {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return null;
                }
                str = ps.name;
                return str;
            } else {
                return null;
            }
        }
    }

    public String[] getNamesForUids(int[] uids) {
        if (uids == null || uids.length == 0) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return null;
        }
        String[] names = new String[uids.length];
        synchronized (this.mPackages) {
            for (int i = uids.length - 1; i >= 0; i--) {
                Object obj = this.mSettings.getUserIdLPr(UserHandle.getAppId(uids[i]));
                if (obj instanceof SharedUserSetting) {
                    names[i] = "shared:" + ((SharedUserSetting) obj).name;
                } else if (obj instanceof PackageSetting) {
                    PackageSetting ps = (PackageSetting) obj;
                    if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                        names[i] = null;
                    } else {
                        names[i] = ps.name;
                    }
                } else {
                    names[i] = null;
                }
            }
        }
        return names;
    }

    public int getUidForSharedUser(String sharedUserName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null || sharedUserName == null) {
            return -1;
        }
        synchronized (this.mPackages) {
            try {
                SharedUserSetting suid = this.mSettings.getSharedUserLPw(sharedUserName, 0, 0, false);
                if (suid != null) {
                    int i = suid.userId;
                    return i;
                }
            } catch (PackageManagerException e) {
            }
        }
        return -1;
    }

    public int getFlagsForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return 0;
        }
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getUserIdLPr(UserHandle.getAppId(uid));
            int i;
            if (obj instanceof SharedUserSetting) {
                i = ((SharedUserSetting) obj).pkgFlags;
                return i;
            } else if (obj instanceof PackageSetting) {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return 0;
                }
                i = ps.pkgFlags;
                return i;
            } else {
                return 0;
            }
        }
    }

    public int getPrivateFlagsForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return 0;
        }
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getUserIdLPr(UserHandle.getAppId(uid));
            int i;
            if (obj instanceof SharedUserSetting) {
                i = ((SharedUserSetting) obj).pkgPrivateFlags;
                return i;
            } else if (obj instanceof PackageSetting) {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return 0;
                }
                i = ps.pkgPrivateFlags;
                return i;
            } else {
                return 0;
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean isUidPrivileged(int uid) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return false;
        }
        uid = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getUserIdLPr(uid);
            if (obj instanceof SharedUserSetting) {
                Iterator<PackageSetting> it = ((SharedUserSetting) obj).packages.iterator();
                while (it.hasNext()) {
                    if (((PackageSetting) it.next()).isPrivileged()) {
                        return true;
                    }
                }
            } else if (obj instanceof PackageSetting) {
                boolean isPrivileged = ((PackageSetting) obj).isPrivileged();
                return isPrivileged;
            }
        }
    }

    public String[] getAppOpPermissionPackages(String permissionName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            ArraySet<String> pkgs = (ArraySet) this.mAppOpPermissionPackages.get(permissionName);
            if (pkgs == null) {
                return null;
            }
            for (String ignoreApp : ColorPackageManagerHelper.getIgnoreAppList()) {
                pkgs.remove(ignoreApp);
            }
            String[] strArr = (String[]) pkgs.toArray(new String[pkgs.size()]);
            return strArr;
        }
    }

    public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId) {
        int i = 0;
        ResolveInfo info = resolveIntentInternal(intent, resolvedType, flags, userId, false);
        if (info != null || userId != OppoMultiAppManager.USER_ID) {
            return info;
        }
        try {
            String[] packages = getPackagesForUid(Binder.getCallingUid());
            if (packages == null) {
                return info;
            }
            int length = packages.length;
            while (i < length) {
                if (OppoMultiAppManagerUtil.getInstance().isMultiApp(packages[i])) {
                    return resolveIntentInternal(intent, resolvedType, flags, 0, false);
                }
                i++;
            }
            return info;
        } catch (Exception e) {
            return info;
        }
    }

    private ResolveInfo resolveIntentInternal(Intent intent, String resolvedType, int flags, int userId, boolean resolveForStart) {
        try {
            Trace.traceBegin(262144, "resolveIntent");
            if (!sUserManager.exists(userId)) {
                return null;
            }
            int callingUid = Binder.getCallingUid();
            flags = updateFlagsForResolve(flags, userId, intent, callingUid, resolveForStart);
            enforceCrossUserPermission(callingUid, userId, false, false, "resolve intent");
            Trace.traceBegin(262144, "queryIntentActivities");
            List<ResolveInfo> query = queryIntentActivitiesInternal(intent, resolvedType, flags, callingUid, userId, resolveForStart, true);
            Trace.traceEnd(262144);
            ResolveInfo bestChoice = chooseBestActivity(intent, resolvedType, flags, query, userId);
            Trace.traceEnd(262144);
            return bestChoice;
        } finally {
            Trace.traceEnd(262144);
        }
    }

    public ResolveInfo findPersistentPreferredActivity(Intent intent, int userId) {
        if (!UserHandle.isSameApp(Binder.getCallingUid(), 1000)) {
            throw new SecurityException("findPersistentPreferredActivity can only be run by the system");
        } else if (!sUserManager.exists(userId)) {
            return null;
        } else {
            ResolveInfo findPersistentPreferredActivityLP;
            int callingUid = Binder.getCallingUid();
            intent = updateIntentForResolve(intent);
            String resolvedType = intent.resolveTypeIfNeeded(this.mContext.getContentResolver());
            int flags = updateFlagsForResolve(0, userId, intent, callingUid, false);
            List<ResolveInfo> query = queryIntentActivitiesInternal(intent, resolvedType, flags, userId);
            synchronized (this.mPackages) {
                findPersistentPreferredActivityLP = findPersistentPreferredActivityLP(intent, resolvedType, flags, query, false, userId);
            }
            return findPersistentPreferredActivityLP;
        }
    }

    public void setLastChosenActivity(Intent intent, String resolvedType, int flags, IntentFilter filter, int match, ComponentName activity) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            int userId = UserHandle.getCallingUserId();
            if (DEBUG_PREFERRED) {
                Log.v(TAG, "setLastChosenActivity intent=" + intent + " resolvedType=" + resolvedType + " flags=" + flags + " filter=" + filter + " match=" + match + " activity=" + activity);
                filter.dump(new PrintStreamPrinter(System.out), "    ");
            }
            intent.setComponent(null);
            findPreferredActivity(intent, resolvedType, flags, queryIntentActivitiesInternal(intent, resolvedType, flags, userId), 0, false, true, false, userId);
            addPreferredActivityInternal(filter, match, null, activity, false, userId, "Setting last chosen");
        }
    }

    public ResolveInfo getLastChosenActivity(Intent intent, String resolvedType, int flags) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        int userId = UserHandle.getCallingUserId();
        if (DEBUG_PREFERRED) {
            Log.v(TAG, "Querying last chosen activity for " + intent);
        }
        return findPreferredActivity(intent, resolvedType, flags, queryIntentActivitiesInternal(intent, resolvedType, flags, userId), 0, false, false, false, userId);
    }

    private boolean isEphemeralDisabled() {
        return this.mEphemeralAppsDisabled;
    }

    private boolean isInstantAppAllowed(Intent intent, List<ResolveInfo> resolvedActivities, int userId, boolean skipPackageCheck) {
        if (this.mInstantAppResolverConnection == null) {
            return false;
        }
        if (this.mInstantAppInstallerActivity == null) {
            return false;
        }
        if (intent.getComponent() != null) {
            return false;
        }
        if ((intent.getFlags() & 512) != 0) {
            return false;
        }
        if (!skipPackageCheck && intent.getPackage() != null) {
            return false;
        }
        if (!hasWebURI(intent) || intent.getData().getHost() == null) {
            return false;
        }
        synchronized (this.mPackages) {
            int count = resolvedActivities == null ? 0 : resolvedActivities.size();
            for (int n = 0; n < count; n++) {
                ResolveInfo info = (ResolveInfo) resolvedActivities.get(n);
                String packageName = info.activityInfo.packageName;
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (ps != null) {
                    if (!info.handleAllWebDataURI) {
                        int status = (int) (getDomainVerificationStatusLPr(ps, userId) >> 32);
                        if (status == 2 || status == 4) {
                            if (DEBUG_EPHEMERAL) {
                                Slog.v(TAG, "DENY instant app; pkg: " + packageName + ", status: " + status);
                            }
                            return false;
                        }
                    }
                    if (ps.getInstantApp(userId)) {
                        if (DEBUG_EPHEMERAL) {
                            Slog.v(TAG, "DENY instant app installed; pkg: " + packageName);
                        }
                        return false;
                    }
                }
            }
            return true;
        }
    }

    private void requestInstantAppResolutionPhaseTwo(AuxiliaryResolveInfo responseObj, Intent origIntent, String resolvedType, String callingPackage, Bundle verificationBundle, int userId) {
        this.mHandler.sendMessage(this.mHandler.obtainMessage(20, new InstantAppRequest(responseObj, origIntent, resolvedType, callingPackage, userId, verificationBundle, false)));
    }

    private ResolveInfo chooseBestActivity(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, int userId) {
        if (query != null) {
            int N = query.size();
            if (N == 1) {
                return (ResolveInfo) query.get(0);
            }
            if (N > 1) {
                boolean debug = (intent.getFlags() & 8) != 0;
                ResolveInfo r0 = (ResolveInfo) query.get(0);
                ResolveInfo r1 = (ResolveInfo) query.get(1);
                if (DEBUG_INTENT_MATCHING || debug) {
                    Slog.v(TAG, r0.activityInfo.name + "=" + r0.priority + " vs " + r1.activityInfo.name + "=" + r1.priority);
                }
                if (r0.priority != r1.priority || r0.preferredOrder != r1.preferredOrder || r0.isDefault != r1.isDefault) {
                    return (ResolveInfo) query.get(0);
                }
                int p;
                ResolveInfo r;
                ActivityInfo ait;
                String callerName = getNameForUid(Binder.getCallingUid());
                Log.d(TAG, "callerName== " + callerName);
                boolean hasArmyFeatury = hasSystemFeature("oppo.business.custom", 0);
                boolean bChildrenMode = false;
                ResolveInfo resolveInfo = null;
                String PKG_OPPO_LAUNCHER = ActivityManagerService.OPPO_LAUNCHER;
                String PKG_SETTINGS = "com.android.settings";
                String PKG_BOOTREG = "com.coloros.bootreg";
                if (hasSystemFeature("oppo.childspace.support", 0)) {
                    bChildrenMode = Global.getInt(this.mContext.getContentResolver(), "children_mode_on", 0) == 1;
                }
                if (ColorPackageManagerHelper.isDefaultAppEnabled(callerName, this.mIsCtsAppInstall)) {
                    List<String> mFoundPackageList = new ArrayList();
                    ResolveInfo matchResolve = null;
                    int matchOppoTypeNum = 0;
                    for (p = 0; p < query.size(); p++) {
                        r = (ResolveInfo) query.get(p);
                        ait = r.activityInfo;
                        if (hasArmyFeatury && "com.android.packageinstaller".equals(ait.packageName)) {
                            Log.d(TAG, "Army feature filter app ai.packageName = " + ait.packageName);
                        } else {
                            if (ActivityManagerService.OPPO_LAUNCHER.equals(ait.packageName)) {
                                resolveInfo = r;
                            }
                            if (ColorPackageManagerHelper.isOppoForceApp(ait.packageName)) {
                                matchResolve = r;
                            }
                            if (ColorPackageManagerHelper.isOppoDefaultApp(ait.packageName)) {
                                if (!mFoundPackageList.contains(ait.packageName)) {
                                    mFoundPackageList.add(ait.packageName);
                                    matchOppoTypeNum++;
                                }
                            }
                        }
                    }
                    if (matchResolve != null && matchOppoTypeNum == 1) {
                        Log.d(TAG, "Force app ai.packageName = " + matchResolve.activityInfo.packageName + " ai.name = " + matchResolve.activityInfo.name);
                        return matchResolve;
                    }
                }
                ResolveInfo ri = findPreferredActivity(intent, resolvedType, flags, query, r0.priority, true, false, debug, userId);
                boolean openFlag = ColorPackageManagerHelper.hasFileManagerOpenFlag(intent, getNameForUid(Binder.getCallingUid()));
                if (ri != null) {
                    ait = ri.activityInfo;
                    if (bChildrenMode && resolveInfo != null && ait != null && (ActivityManagerService.OPPO_LAUNCHER.equals(ait.packageName) ^ 1) != 0 && ("com.coloros.bootreg".equals(ait.packageName) ^ 1) != 0 && ("com.android.settings".equals(ait.packageName) ^ 1) != 0) {
                        return resolveInfo;
                    }
                    if (!openFlag) {
                        return ri;
                    }
                }
                if (ColorPackageManagerHelper.isDefaultAppEnabled(callerName, this.mIsCtsAppInstall)) {
                    int match = 0;
                    int pos = 0;
                    HashMap<String, Integer> mFoundPackageMap = new HashMap();
                    for (p = 0; p < query.size(); p++) {
                        r = (ResolveInfo) query.get(p);
                        ait = r.activityInfo;
                        if (hasArmyFeatury && "com.android.packageinstaller".equals(ait.packageName)) {
                            Log.d(TAG, "Army feature filter app ai.packageName = " + ait.packageName);
                        } else if (ColorPackageManagerHelper.isOppoDefaultApp(ait.packageName)) {
                            if (mFoundPackageMap.containsKey(ait.packageName)) {
                                if (((Integer) mFoundPackageMap.get(ait.packageName)).intValue() < r.priority) {
                                    pos = p;
                                }
                            } else {
                                mFoundPackageMap.put(ait.packageName, Integer.valueOf(r.priority));
                                match++;
                                pos = p;
                            }
                        }
                    }
                    if (1 == match) {
                        Log.d(TAG, "oppo select Default app ai.packageName = " + ((ResolveInfo) query.get(pos)).activityInfo.packageName + " ai.name = " + ((ResolveInfo) query.get(pos)).activityInfo.name);
                        if (!openFlag) {
                            return (ResolveInfo) query.get(pos);
                        }
                    }
                }
                ColorPackageManagerHelper.filterBlackList(this.mContext, intent, query);
                int size = query.size();
                if (size == 0) {
                    return null;
                }
                if (size == 1) {
                    return (ResolveInfo) query.get(0);
                }
                for (int i = 0; i < size; i++) {
                    ri = (ResolveInfo) query.get(i);
                    if (ri.activityInfo.applicationInfo.isInstantApp()) {
                        if (((int) (getDomainVerificationStatusLPr((PackageSetting) this.mSettings.mPackages.get(ri.activityInfo.packageName), userId) >> 32)) != 4) {
                            return ri;
                        }
                    }
                }
                ResolveInfo resolveInfo2 = new ResolveInfo(this.mResolveInfo);
                resolveInfo2.activityInfo = new ActivityInfo(resolveInfo2.activityInfo);
                resolveInfo2.activityInfo.labelRes = ResolverActivity.getLabelRes(intent.getAction());
                String intentPackage = intent.getPackage();
                if (!TextUtils.isEmpty(intentPackage) && allHavePackage(query, intentPackage)) {
                    ApplicationInfo appi = ((ResolveInfo) query.get(0)).activityInfo.applicationInfo;
                    resolveInfo2.resolvePackageName = intentPackage;
                    if (userNeedsBadging(userId)) {
                        resolveInfo2.noResourceId = true;
                    } else {
                        resolveInfo2.icon = appi.icon;
                    }
                    resolveInfo2.iconResourceId = appi.icon;
                    resolveInfo2.labelRes = appi.labelRes;
                }
                resolveInfo2.activityInfo.applicationInfo = new ApplicationInfo(resolveInfo2.activityInfo.applicationInfo);
                if (userId != 0) {
                    resolveInfo2.activityInfo.applicationInfo.uid = UserHandle.getUid(userId, UserHandle.getAppId(resolveInfo2.activityInfo.applicationInfo.uid));
                }
                if (resolveInfo2.activityInfo.metaData == null) {
                    resolveInfo2.activityInfo.metaData = new Bundle();
                }
                resolveInfo2.activityInfo.metaData.putBoolean("android.dock_home", true);
                return resolveInfo2;
            }
        }
        return null;
    }

    private boolean allHavePackage(List<ResolveInfo> list, String packageName) {
        if (ArrayUtils.isEmpty(list)) {
            return false;
        }
        int N = list.size();
        for (int i = 0; i < N; i++) {
            ResolveInfo ri = (ResolveInfo) list.get(i);
            ActivityInfo ai = ri != null ? ri.activityInfo : null;
            if (ai == null || (packageName.equals(ai.packageName) ^ 1) != 0) {
                return false;
            }
        }
        return true;
    }

    private ResolveInfo findPersistentPreferredActivityLP(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, boolean debug, int userId) {
        List pprefs;
        int N = query.size();
        PersistentPreferredIntentResolver ppir = (PersistentPreferredIntentResolver) this.mSettings.mPersistentPreferredActivities.get(userId);
        if (DEBUG_PREFERRED || debug) {
            Slog.v(TAG, "Looking for presistent preferred activities...");
        }
        if (ppir != null) {
            pprefs = ppir.queryIntent(intent, resolvedType, (65536 & flags) != 0, userId);
        } else {
            pprefs = null;
        }
        if (pprefs != null && pprefs.size() > 0) {
            int M = pprefs.size();
            for (int i = 0; i < M; i++) {
                PersistentPreferredActivity ppa = (PersistentPreferredActivity) pprefs.get(i);
                if (DEBUG_PREFERRED || debug) {
                    Slog.v(TAG, "Checking PersistentPreferredActivity ds=" + (ppa.countDataSchemes() > 0 ? ppa.getDataScheme(0) : "<none>") + "\n  component=" + ppa.mComponent);
                    ppa.dump(new LogPrinter(2, TAG, 3), "  ");
                }
                ActivityInfo ai = getActivityInfo(ppa.mComponent, flags | 512, userId);
                if (DEBUG_PREFERRED || debug) {
                    Slog.v(TAG, "Found persistent preferred activity:");
                    if (ai != null) {
                        ai.dump(new LogPrinter(2, TAG, 3), "  ");
                    } else {
                        Slog.v(TAG, "  null");
                    }
                }
                if (ai != null) {
                    for (int j = 0; j < N; j++) {
                        ResolveInfo ri = (ResolveInfo) query.get(j);
                        if (ri.activityInfo.applicationInfo.packageName.equals(ai.applicationInfo.packageName) && ri.activityInfo.name.equals(ai.name)) {
                            if (DEBUG_PREFERRED || debug) {
                                Slog.v(TAG, "Returning persistent preferred activity: " + ri.activityInfo.packageName + "/" + ri.activityInfo.name);
                            }
                            return ri;
                        }
                    }
                    continue;
                }
            }
        }
        return null;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    ResolveInfo findPreferredActivity(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, int priority, boolean always, boolean removeMatches, boolean debug, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        flags = updateFlagsForResolve(flags, userId, intent, Binder.getCallingUid(), false);
        intent = updateIntentForResolve(intent);
        synchronized (this.mPackages) {
            ResolveInfo pri = findPersistentPreferredActivityLP(intent, resolvedType, flags, query, debug, userId);
            if (pri != null) {
                return pri;
            }
            List prefs;
            PreferredIntentResolver pir = (PreferredIntentResolver) this.mSettings.mPreferredActivities.get(userId);
            if (DEBUG_PREFERRED || debug) {
                Slog.v(TAG, "Looking for preferred activities...");
            }
            if (pir != null) {
                prefs = pir.queryIntent(intent, resolvedType, (65536 & flags) != 0, userId);
            } else {
                prefs = null;
            }
            if (prefs != null && prefs.size() > 0) {
                boolean changed = false;
                int match = 0;
                try {
                    int j;
                    ResolveInfo ri;
                    if (DEBUG_PREFERRED || debug) {
                        Slog.v(TAG, "Figuring out best match...");
                    }
                    int N = query.size();
                    for (j = 0; j < N; j++) {
                        ri = (ResolveInfo) query.get(j);
                        if (DEBUG_PREFERRED || debug) {
                            Slog.v(TAG, "Match for " + ri.activityInfo + ": 0x" + Integer.toHexString(match));
                        }
                        if (ri.match > match) {
                            match = ri.match;
                        }
                    }
                    if (DEBUG_PREFERRED || debug) {
                        Slog.v(TAG, "Best match: 0x" + Integer.toHexString(match));
                    }
                    match &= 268369920;
                    boolean containsOppoDefaultPkg = ColorPackageManagerHelper.isQueryListContainsOppoDefaultPkg(query);
                    int M = prefs.size();
                    for (int i = 0; i < M; i++) {
                        IntentFilter pa = (PreferredActivity) prefs.get(i);
                        if (DEBUG_PREFERRED || debug) {
                            Slog.v(TAG, "Checking PreferredActivity ds=" + (pa.countDataSchemes() > 0 ? pa.getDataScheme(0) : "<none>") + "\n  component=" + pa.mPref.mComponent);
                            pa.dump(new LogPrinter(2, TAG, 3), "  ");
                        }
                        if (containsOppoDefaultPkg || pa.mPref.mMatch == match) {
                            if (!always || (pa.mPref.mAlways ^ 1) == 0) {
                                ActivityInfo ai = getActivityInfo(pa.mPref.mComponent, ((flags | 512) | 524288) | 262144, userId);
                                if (DEBUG_PREFERRED || debug) {
                                    Slog.v(TAG, "Found preferred activity:");
                                    if (ai != null) {
                                        ai.dump(new LogPrinter(2, TAG, 3), "  ");
                                    } else {
                                        Slog.v(TAG, "  null");
                                    }
                                }
                                if (ai == null) {
                                    Slog.w(TAG, "Removing dangling preferred activity: " + pa.mPref.mComponent);
                                    pir.removeFilter(pa);
                                    changed = true;
                                } else {
                                    j = 0;
                                    while (j < N) {
                                        ri = (ResolveInfo) query.get(j);
                                        if (!ri.activityInfo.applicationInfo.packageName.equals(ai.applicationInfo.packageName) || !ri.activityInfo.name.equals(ai.name)) {
                                            j++;
                                        } else if (removeMatches) {
                                            pir.removeFilter(pa);
                                            changed = true;
                                            if (DEBUG_PREFERRED) {
                                                Slog.v(TAG, "Removing match " + pa.mPref.mComponent);
                                            }
                                        } else {
                                            if (always && (pa.mPref.sameSet((List) query) ^ 1) != 0) {
                                                if (pa.mPref.isSuperset(query)) {
                                                    if (DEBUG_PREFERRED) {
                                                        Slog.i(TAG, "Result set changed, but PreferredActivity is still valid as only non-preferred components were removed for " + intent + " type " + resolvedType);
                                                    }
                                                    PreferredActivity freshPa = new PreferredActivity(pa, pa.mPref.mMatch, pa.mPref.discardObsoleteComponents(query), pa.mPref.mComponent, pa.mPref.mAlways);
                                                    pir.removeFilter(pa);
                                                    pir.addFilter(freshPa);
                                                    changed = true;
                                                } else {
                                                    Slog.i(TAG, "Result set changed, dropping preferred activity for " + intent + " type " + resolvedType);
                                                    if (DEBUG_PREFERRED) {
                                                        Slog.v(TAG, "Removing preferred activity since set changed " + pa.mPref.mComponent);
                                                    }
                                                    pir.removeFilter(pa);
                                                    pir.addFilter(new PreferredActivity(pa, pa.mPref.mMatch, null, pa.mPref.mComponent, false));
                                                    if (true) {
                                                        if (DEBUG_PREFERRED) {
                                                            Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                                                        }
                                                        scheduleWritePackageRestrictionsLocked(userId);
                                                    }
                                                    return null;
                                                }
                                            }
                                            if (DEBUG_PREFERRED || debug) {
                                                Slog.v(TAG, "Returning preferred activity: " + ri.activityInfo.packageName + "/" + ri.activityInfo.name);
                                            }
                                            if (changed) {
                                                if (DEBUG_PREFERRED) {
                                                    Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                                                }
                                                scheduleWritePackageRestrictionsLocked(userId);
                                            }
                                        }
                                    }
                                    continue;
                                }
                            } else if (DEBUG_PREFERRED || debug) {
                                Slog.v(TAG, "Skipping mAlways=false entry");
                            }
                        } else if (DEBUG_PREFERRED || debug) {
                            Slog.v(TAG, "Skipping bad match " + Integer.toHexString(pa.mPref.mMatch));
                        }
                    }
                    if (changed) {
                        if (DEBUG_PREFERRED) {
                            Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                        }
                        scheduleWritePackageRestrictionsLocked(userId);
                    }
                } catch (Throwable th) {
                    if (changed) {
                        if (DEBUG_PREFERRED) {
                            Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                        }
                        scheduleWritePackageRestrictionsLocked(userId);
                    }
                }
            }
        }
    }

    public boolean canForwardTo(Intent intent, String resolvedType, int sourceUserId, int targetUserId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        List<CrossProfileIntentFilter> matches = getMatchingCrossProfileIntentFilters(intent, resolvedType, sourceUserId);
        if (matches != null) {
            int size = matches.size();
            for (int i = 0; i < size; i++) {
                if (((CrossProfileIntentFilter) matches.get(i)).getTargetUserId() == targetUserId) {
                    return true;
                }
            }
        }
        if (!hasWebURI(intent)) {
            return false;
        }
        boolean z;
        int callingUid = Binder.getCallingUid();
        UserInfo parent = getProfileParent(sourceUserId);
        synchronized (this.mPackages) {
            z = getCrossProfileDomainPreferredLpr(intent, resolvedType, updateFlagsForResolve(0, parent.id, intent, callingUid, false), sourceUserId, parent.id) != null;
        }
        return z;
    }

    private UserInfo getProfileParent(int userId) {
        long identity = Binder.clearCallingIdentity();
        try {
            UserInfo profileParent = sUserManager.getProfileParent(userId);
            return profileParent;
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    private List<CrossProfileIntentFilter> getMatchingCrossProfileIntentFilters(Intent intent, String resolvedType, int userId) {
        CrossProfileIntentResolver resolver = (CrossProfileIntentResolver) this.mSettings.mCrossProfileIntentResolvers.get(userId);
        if (resolver != null) {
            return resolver.queryIntent(intent, resolvedType, false, userId);
        }
        return null;
    }

    public ParceledListSlice<ResolveInfo> queryIntentActivities(Intent intent, String resolvedType, int flags, int userId) {
        ParceledListSlice<ResolveInfo> parceledListSlice;
        try {
            Trace.traceBegin(262144, "queryIntentActivities");
            List<ResolveInfo> query = queryIntentActivitiesInternal(intent, resolvedType, flags, userId);
            boolean openFlag = ColorPackageManagerHelper.hasFileManagerOpenFlag(intent, getNameForUid(Binder.getCallingUid()));
            if (DEBUG_PREFERRED) {
                Slog.d(TAG, "queryIntentActivities, openFlag=" + openFlag);
            }
            if (openFlag) {
                ColorPackageManagerHelper.filterBlackList(this.mContext, intent, query);
            }
            parceledListSlice = new ParceledListSlice(query);
            return parceledListSlice;
        } catch (Exception e) {
            e.printStackTrace();
            parceledListSlice = new ParceledListSlice(Collections.emptyList());
            return parceledListSlice;
        } finally {
            Trace.traceEnd(262144);
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private String getInstantAppPackageName(int callingUid) {
        String str = null;
        synchronized (this.mPackages) {
            if (Process.isIsolated(callingUid)) {
                callingUid = this.mIsolatedOwners.get(callingUid);
            }
            Object obj = this.mSettings.getUserIdLPr(UserHandle.getAppId(callingUid));
            if (obj instanceof PackageSetting) {
                PackageSetting ps = (PackageSetting) obj;
                if (ps.getInstantApp(UserHandle.getUserId(callingUid))) {
                    str = ps.pkg.packageName;
                }
            } else {
                return null;
            }
        }
    }

    private List<ResolveInfo> queryIntentActivitiesInternal(Intent intent, String resolvedType, int flags, int userId) {
        return queryIntentActivitiesInternal(intent, resolvedType, flags, Binder.getCallingUid(), userId, false, true);
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private List<ResolveInfo> queryIntentActivitiesInternal(Intent intent, String resolvedType, int flags, int filterCallingUid, int userId, boolean resolveForStart, boolean allowDynamicSplits) {
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        String instantAppPkgName = getInstantAppPackageName(filterCallingUid);
        enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "query intent activities");
        String pkgName = intent.getPackage();
        ComponentName comp = intent.getComponent();
        if (comp == null && intent.getSelector() != null) {
            intent = intent.getSelector();
            comp = intent.getComponent();
        }
        boolean z = (comp == null && pkgName == null) ? false : true;
        flags = updateFlagsForResolve(flags, userId, intent, filterCallingUid, resolveForStart, z);
        if (comp != null) {
            List<ResolveInfo> list = new ArrayList(1);
            ActivityInfo ai = getActivityInfo(comp, flags, userId);
            if (ai != null) {
                boolean blockResolution;
                boolean matchInstantApp = (DumpState.DUMP_VOLUMES & flags) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags) != 0;
                boolean matchExplicitlyVisibleOnly = (PhoneWindowManager.SYSTEM_UI_FLAG_APP_CUSTOM_NAVIGATION_BAR & flags) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                boolean isTargetSameInstantApp = comp.getPackageName().equals(instantAppPkgName);
                boolean isTargetInstantApp = (ai.applicationInfo.privateFlags & 128) != 0;
                boolean isTargetVisibleToInstantApp = (ai.flags & DumpState.DUMP_DEXOPT) != 0;
                boolean isTargetExplicitlyVisibleToInstantApp = isTargetVisibleToInstantApp ? (ai.flags & DumpState.DUMP_COMPILER_STATS) == 0 : false;
                boolean isTargetHiddenFromInstantApp = isTargetVisibleToInstantApp ? matchExplicitlyVisibleOnly ? isTargetExplicitlyVisibleToInstantApp ^ 1 : false : true;
                if (isTargetSameInstantApp) {
                    blockResolution = false;
                } else if (!matchInstantApp && (isCallerInstantApp ^ 1) != 0 && isTargetInstantApp) {
                    blockResolution = true;
                } else if (matchVisibleToInstantAppOnly && isCallerInstantApp) {
                    blockResolution = isTargetHiddenFromInstantApp;
                } else {
                    blockResolution = false;
                }
                if (!blockResolution) {
                    ResolveInfo ri = new ResolveInfo();
                    ri.activityInfo = ai;
                    list.add(ri);
                }
            }
            return applyPostResolutionFilter(list, instantAppPkgName, allowDynamicSplits, filterCallingUid, userId);
        }
        boolean sortResult = false;
        int addEphemeral = 0;
        boolean ephemeralDisabled = isEphemeralDisabled();
        synchronized (this.mPackages) {
            List result;
            if (pkgName == null) {
                List<CrossProfileIntentFilter> matchingFilters = getMatchingCrossProfileIntentFilters(intent, resolvedType, userId);
                ResolveInfo xpResolveInfo = querySkipCurrentProfileIntents(matchingFilters, intent, resolvedType, flags, userId);
                List<ResolveInfo> applyPostResolutionFilter;
                if (xpResolveInfo != null) {
                    List<ResolveInfo> arrayList = new ArrayList(1);
                    arrayList.add(xpResolveInfo);
                    applyPostResolutionFilter = applyPostResolutionFilter(filterIfNotSystemUser(arrayList, userId), instantAppPkgName, allowDynamicSplits, filterCallingUid, userId);
                    return applyPostResolutionFilter;
                }
                result = filterIfNotSystemUser(this.mActivities.queryIntent(intent, resolvedType, flags, userId), userId);
                if (ephemeralDisabled) {
                    addEphemeral = 0;
                } else {
                    addEphemeral = isInstantAppAllowed(intent, result, userId, false);
                }
                xpResolveInfo = queryCrossProfileIntents(matchingFilters, intent, resolvedType, flags, userId, hasNonNegativePriority(result));
                if (xpResolveInfo != null) {
                    if (isUserEnabled(xpResolveInfo.targetUserId)) {
                        if (filterIfNotSystemUser(Collections.singletonList(xpResolveInfo), userId).size() > 0) {
                            result.add(xpResolveInfo);
                            sortResult = true;
                        }
                    }
                }
                if (hasWebURI(intent)) {
                    CrossProfileDomainInfo crossProfileDomainInfo = null;
                    UserInfo parent = getProfileParent(userId);
                    if (parent != null) {
                        crossProfileDomainInfo = getCrossProfileDomainPreferredLpr(intent, resolvedType, flags, userId, parent.id);
                    }
                    if (crossProfileDomainInfo != null) {
                        if (xpResolveInfo != null) {
                            result.remove(xpResolveInfo);
                        }
                        if (result.size() == 0 && (addEphemeral ^ 1) != 0) {
                            result.add(crossProfileDomainInfo.resolveInfo);
                            applyPostResolutionFilter = applyPostResolutionFilter(result, instantAppPkgName, allowDynamicSplits, filterCallingUid, userId);
                            return applyPostResolutionFilter;
                        }
                    } else if (result.size() <= 1 && (addEphemeral ^ 1) != 0) {
                        applyPostResolutionFilter = applyPostResolutionFilter(result, instantAppPkgName, allowDynamicSplits, filterCallingUid, userId);
                        return applyPostResolutionFilter;
                    }
                    result = filterCandidatesWithDomainPreferredActivitiesLPr(intent, flags, result, crossProfileDomainInfo, userId);
                    sortResult = true;
                }
            } else {
                Package pkg = (Package) this.mPackages.get(pkgName);
                result = null;
                if (pkg != null) {
                    result = filterIfNotSystemUser(this.mActivities.queryIntentForPackage(intent, resolvedType, flags, pkg.activities, userId), userId);
                }
                if (result == null || result.size() == 0) {
                    if (ephemeralDisabled) {
                        addEphemeral = 0;
                    } else {
                        addEphemeral = isInstantAppAllowed(intent, null, userId, true);
                    }
                    if (result == null) {
                        result = new ArrayList();
                    }
                }
            }
        }
    }

    private List<ResolveInfo> maybeAddInstantAppInstaller(List<ResolveInfo> result, Intent intent, String resolvedType, int flags, int userId, boolean resolveForStart) {
        PackageSetting ps;
        ResolveInfo localInstantApp = null;
        boolean blockResolution = false;
        if (!((DumpState.DUMP_VOLUMES & flags) != 0)) {
            List<ResolveInfo> instantApps = this.mActivities.queryIntent(intent, resolvedType, ((flags | 64) | DumpState.DUMP_VOLUMES) | 16777216, userId);
            int i = instantApps.size() - 1;
            while (i >= 0) {
                ResolveInfo info = (ResolveInfo) instantApps.get(i);
                String packageName = info.activityInfo.packageName;
                ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (ps.getInstantApp(userId)) {
                    long packedStatus = getDomainVerificationStatusLPr(ps, userId);
                    int linkGeneration = (int) (-1 & packedStatus);
                    if (((int) (packedStatus >> 32)) == 3) {
                        if (DEBUG_EPHEMERAL) {
                            Slog.v(TAG, "Instant app marked to never run; pkg: " + packageName);
                        }
                        blockResolution = true;
                    } else {
                        if (DEBUG_EPHEMERAL) {
                            Slog.v(TAG, "Found installed instant app; pkg: " + packageName);
                        }
                        localInstantApp = info;
                    }
                } else {
                    i--;
                }
            }
        }
        AuxiliaryResolveInfo auxiliaryResponse = null;
        if (!blockResolution) {
            if (localInstantApp == null) {
                Trace.traceBegin(262144, "resolveEphemeral");
                auxiliaryResponse = InstantAppResolver.doInstantAppResolutionPhaseOne(this.mContext, this.mInstantAppResolverConnection, new InstantAppRequest(null, intent, resolvedType, null, userId, null, resolveForStart));
                Trace.traceEnd(262144);
            } else {
                ApplicationInfo ai = localInstantApp.activityInfo.applicationInfo;
                auxiliaryResponse = new AuxiliaryResolveInfo(ai.packageName, null, null, ai.versionCode, null);
            }
        }
        if (auxiliaryResponse != null) {
            if (DEBUG_EPHEMERAL) {
                Slog.v(TAG, "Adding ephemeral installer to the ResolveInfo list");
            }
            ResolveInfo ephemeralInstaller = new ResolveInfo(this.mInstantAppInstallerInfo);
            ps = (PackageSetting) this.mSettings.mPackages.get(this.mInstantAppInstallerActivity.packageName);
            if (ps != null) {
                ephemeralInstaller.activityInfo = PackageParser.generateActivityInfo(this.mInstantAppInstallerActivity, 0, ps.readUserState(userId), userId);
                ephemeralInstaller.activityInfo.launchToken = auxiliaryResponse.token;
                ephemeralInstaller.auxiliaryInfo = auxiliaryResponse;
                ephemeralInstaller.isDefault = true;
                ephemeralInstaller.match = 5799936;
                ephemeralInstaller.filter = new IntentFilter(intent.getAction());
                ephemeralInstaller.filter.addDataPath(intent.getData().getPath(), 0);
                ephemeralInstaller.isInstantAppAvailable = true;
                result.add(ephemeralInstaller);
            }
        }
        if (result.size() > 1) {
            Collections.sort(result, mSystemAppPrioritySorter);
        }
        return result;
    }

    private CrossProfileDomainInfo getCrossProfileDomainPreferredLpr(Intent intent, String resolvedType, int flags, int sourceUserId, int parentUserId) {
        if (!sUserManager.hasUserRestriction("allow_parent_profile_app_linking", sourceUserId)) {
            return null;
        }
        List<ResolveInfo> resultTargetUser = this.mActivities.queryIntent(intent, resolvedType, flags, parentUserId);
        if (resultTargetUser == null || resultTargetUser.isEmpty()) {
            return null;
        }
        CrossProfileDomainInfo result = null;
        int size = resultTargetUser.size();
        for (int i = 0; i < size; i++) {
            ResolveInfo riTargetUser = (ResolveInfo) resultTargetUser.get(i);
            if (!riTargetUser.handleAllWebDataURI) {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(riTargetUser.activityInfo.packageName);
                if (ps != null) {
                    int status = (int) (getDomainVerificationStatusLPr(ps, parentUserId) >> 32);
                    if (result == null) {
                        result = new CrossProfileDomainInfo();
                        result.resolveInfo = createForwardingResolveInfoUnchecked(new IntentFilter(), sourceUserId, parentUserId);
                        result.bestDomainVerificationStatus = status;
                    } else {
                        result.bestDomainVerificationStatus = bestDomainVerificationStatus(status, result.bestDomainVerificationStatus);
                    }
                }
            }
        }
        if (result == null || result.bestDomainVerificationStatus != 3) {
            return result;
        }
        return null;
    }

    private int bestDomainVerificationStatus(int status1, int status2) {
        if (status1 == 3) {
            return status2;
        }
        if (status2 == 3) {
            return status1;
        }
        return (int) MathUtils.max(status1, status2);
    }

    private boolean isUserEnabled(int userId) {
        long callingId = Binder.clearCallingIdentity();
        try {
            UserInfo userInfo = sUserManager.getUserInfo(userId);
            boolean isEnabled = userInfo != null ? userInfo.isEnabled() : false;
            Binder.restoreCallingIdentity(callingId);
            return isEnabled;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private List<ResolveInfo> filterIfNotSystemUser(List<ResolveInfo> resolveInfos, int userId) {
        if (userId == 0) {
            return resolveInfos;
        }
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            if ((((ResolveInfo) resolveInfos.get(i)).activityInfo.flags & 536870912) != 0) {
                resolveInfos.remove(i);
            }
        }
        return resolveInfos;
    }

    private List<ResolveInfo> applyPostResolutionFilter(List<ResolveInfo> resolveInfos, String ephemeralPkgName, boolean allowDynamicSplits, int filterCallingUid, int userId) {
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            ResolveInfo info = (ResolveInfo) resolveInfos.get(i);
            if (!allowDynamicSplits || info.activityInfo.splitName == null || (ArrayUtils.contains(info.activityInfo.applicationInfo.splitNames, info.activityInfo.splitName) ^ 1) == 0) {
                if (!(ephemeralPkgName == null || ephemeralPkgName.equals(info.activityInfo.packageName) || (!info.activityInfo.applicationInfo.isInstantApp() && (info.activityInfo.flags & DumpState.DUMP_DEXOPT) != 0))) {
                    resolveInfos.remove(i);
                }
            } else if (this.mInstantAppInstallerInfo == null) {
                if (DEBUG_INSTALL) {
                    Slog.v(TAG, "No installer - not adding it to the ResolveInfo list");
                }
                resolveInfos.remove(i);
            } else {
                if (DEBUG_INSTALL) {
                    Slog.v(TAG, "Adding installer to the ResolveInfo list");
                }
                ResolveInfo installerInfo = new ResolveInfo(this.mInstantAppInstallerInfo);
                installerInfo.auxiliaryInfo = new AuxiliaryResolveInfo(info.activityInfo.packageName, info.activityInfo.splitName, findInstallFailureActivity(info.activityInfo.packageName, filterCallingUid, userId), info.activityInfo.applicationInfo.versionCode, null);
                installerInfo.match = 5799936;
                installerInfo.filter = new IntentFilter();
                installerInfo.resolvePackageName = info.getComponentInfo().packageName;
                installerInfo.labelRes = info.resolveLabelResId();
                installerInfo.icon = info.resolveIconResId();
                installerInfo.priority = info.priority;
                installerInfo.preferredOrder = info.preferredOrder;
                installerInfo.isDefault = info.isDefault;
                resolveInfos.set(i, installerInfo);
            }
        }
        return resolveInfos;
    }

    private ComponentName findInstallFailureActivity(String packageName, int filterCallingUid, int userId) {
        Intent failureActivityIntent = new Intent("android.intent.action.INSTALL_FAILURE");
        failureActivityIntent.setPackage(packageName);
        List<ResolveInfo> result = queryIntentActivitiesInternal(failureActivityIntent, null, 0, filterCallingUid, userId, false, false);
        int NR = result.size();
        if (NR > 0) {
            for (int i = 0; i < NR; i++) {
                ResolveInfo info = (ResolveInfo) result.get(i);
                if (info.activityInfo.splitName == null) {
                    return new ComponentName(packageName, info.activityInfo.name);
                }
            }
        }
        return null;
    }

    private boolean hasNonNegativePriority(List<ResolveInfo> resolveInfos) {
        return resolveInfos.size() > 0 && ((ResolveInfo) resolveInfos.get(0)).priority >= 0;
    }

    private static boolean hasWebURI(Intent intent) {
        if (intent.getData() == null) {
            return false;
        }
        String scheme = intent.getScheme();
        if (TextUtils.isEmpty(scheme)) {
            return false;
        }
        return !scheme.equals("http") ? scheme.equals("https") : true;
    }

    private List<ResolveInfo> filterCandidatesWithDomainPreferredActivitiesLPr(Intent intent, int matchFlags, List<ResolveInfo> candidates, CrossProfileDomainInfo xpDomainInfo, int userId) {
        ResolveInfo info;
        boolean debug = (intent.getFlags() & 8) != 0;
        if (DEBUG_PREFERRED) {
            Slog.v(TAG, "Filtering results with preferred activities. Candidates count: " + candidates.size());
        }
        ArrayList<ResolveInfo> result = new ArrayList();
        ArrayList<ResolveInfo> alwaysList = new ArrayList();
        ArrayList<ResolveInfo> undefinedList = new ArrayList();
        ArrayList<ResolveInfo> alwaysAskList = new ArrayList();
        ArrayList<ResolveInfo> neverList = new ArrayList();
        ArrayList<ResolveInfo> matchAllList = new ArrayList();
        synchronized (this.mPackages) {
            int n;
            int count = candidates.size();
            for (n = 0; n < count; n++) {
                info = (ResolveInfo) candidates.get(n);
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(info.activityInfo.packageName);
                if (ps != null) {
                    if (info.handleAllWebDataURI) {
                        matchAllList.add(info);
                    } else {
                        long packedStatus = getDomainVerificationStatusLPr(ps, userId);
                        int status = (int) (packedStatus >> 32);
                        int linkGeneration = (int) (-1 & packedStatus);
                        if (status == 2) {
                            if (debug) {
                                Slog.i(TAG, "  + always: " + info.activityInfo.packageName + " : linkgen=" + linkGeneration);
                            }
                            info.preferredOrder = linkGeneration;
                            alwaysList.add(info);
                        } else if (status == 3) {
                            if (debug) {
                                Slog.i(TAG, "  + never: " + info.activityInfo.packageName);
                            }
                            neverList.add(info);
                        } else if (status == 4) {
                            if (debug) {
                                Slog.i(TAG, "  + always-ask: " + info.activityInfo.packageName);
                            }
                            alwaysAskList.add(info);
                        } else if (status == 0 || status == 1) {
                            if (debug) {
                                Slog.i(TAG, "  + ask: " + info.activityInfo.packageName);
                            }
                            undefinedList.add(info);
                        }
                    }
                }
            }
            boolean includeBrowser = false;
            if (alwaysList.size() > 0) {
                result.addAll(alwaysList);
            } else {
                result.addAll(undefinedList);
                if (!(xpDomainInfo == null || xpDomainInfo.bestDomainVerificationStatus == 3)) {
                    result.add(xpDomainInfo.resolveInfo);
                }
                includeBrowser = true;
            }
            if (alwaysAskList.size() > 0) {
                for (ResolveInfo i : result) {
                    i.preferredOrder = 0;
                }
                result.addAll(alwaysAskList);
                includeBrowser = true;
            }
            if (includeBrowser) {
                if ((131072 & matchFlags) != 0) {
                    result.addAll(matchAllList);
                } else {
                    String defaultBrowserPackageName = getDefaultBrowserPackageName(userId);
                    int maxMatchPrio = 0;
                    ResolveInfo defaultBrowserMatch = null;
                    int numCandidates = matchAllList.size();
                    for (n = 0; n < numCandidates; n++) {
                        info = (ResolveInfo) matchAllList.get(n);
                        if (info.priority > maxMatchPrio) {
                            maxMatchPrio = info.priority;
                        }
                        if (info.activityInfo.packageName.equals(defaultBrowserPackageName) && (defaultBrowserMatch == null || defaultBrowserMatch.priority < info.priority)) {
                            if (debug) {
                                Slog.v(TAG, "Considering default browser match " + info);
                            }
                            defaultBrowserMatch = info;
                        }
                    }
                    if (defaultBrowserMatch == null || defaultBrowserMatch.priority < maxMatchPrio || (TextUtils.isEmpty(defaultBrowserPackageName) ^ 1) == 0) {
                        result.addAll(matchAllList);
                    } else {
                        if (debug) {
                            Slog.v(TAG, "Default browser match " + defaultBrowserMatch);
                        }
                        result.add(defaultBrowserMatch);
                    }
                }
                if (result.size() == 0) {
                    result.addAll(candidates);
                    result.removeAll(neverList);
                }
            }
        }
        if (DEBUG_PREFERRED) {
            Slog.v(TAG, "Filtered results with preferred activities. New candidates count: " + result.size());
            for (ResolveInfo info2 : result) {
                Slog.v(TAG, "  + " + info2.activityInfo);
            }
        }
        return result;
    }

    private long getDomainVerificationStatusLPr(PackageSetting ps, int userId) {
        long result = ps.getDomainVerificationStatusForUser(userId);
        if ((result >> 32) != 0 || ps.getIntentFilterVerificationInfo() == null) {
            return result;
        }
        return ((long) ps.getIntentFilterVerificationInfo().getStatus()) << 32;
    }

    private ResolveInfo querySkipCurrentProfileIntents(List<CrossProfileIntentFilter> matchingFilters, Intent intent, String resolvedType, int flags, int sourceUserId) {
        if (matchingFilters != null) {
            int size = matchingFilters.size();
            for (int i = 0; i < size; i++) {
                CrossProfileIntentFilter filter = (CrossProfileIntentFilter) matchingFilters.get(i);
                if ((filter.getFlags() & 2) != 0) {
                    ResolveInfo resolveInfo = createForwardingResolveInfo(filter, intent, resolvedType, flags, sourceUserId);
                    if (resolveInfo != null) {
                        return resolveInfo;
                    }
                }
            }
        }
        return null;
    }

    private ResolveInfo queryCrossProfileIntents(List<CrossProfileIntentFilter> matchingFilters, Intent intent, String resolvedType, int flags, int sourceUserId, boolean matchInCurrentProfile) {
        if (matchingFilters != null) {
            SparseBooleanArray alreadyTriedUserIds = new SparseBooleanArray();
            int size = matchingFilters.size();
            for (int i = 0; i < size; i++) {
                CrossProfileIntentFilter filter = (CrossProfileIntentFilter) matchingFilters.get(i);
                int targetUserId = filter.getTargetUserId();
                boolean skipCurrentProfile = (filter.getFlags() & 2) != 0;
                boolean skipCurrentProfileIfNoMatchFound = (filter.getFlags() & 4) != 0;
                if (!(skipCurrentProfile || (alreadyTriedUserIds.get(targetUserId) ^ 1) == 0 || (skipCurrentProfileIfNoMatchFound && (matchInCurrentProfile ^ 1) == 0))) {
                    ResolveInfo resolveInfo = createForwardingResolveInfo(filter, intent, resolvedType, flags, sourceUserId);
                    if (resolveInfo != null) {
                        return resolveInfo;
                    }
                    alreadyTriedUserIds.put(targetUserId, true);
                }
            }
        }
        return null;
    }

    private ResolveInfo createForwardingResolveInfo(CrossProfileIntentFilter filter, Intent intent, String resolvedType, int flags, int sourceUserId) {
        int targetUserId = filter.getTargetUserId();
        List<ResolveInfo> resultTargetUser = this.mActivities.queryIntent(intent, resolvedType, flags, targetUserId);
        if (resultTargetUser != null && isUserEnabled(targetUserId)) {
            for (int i = resultTargetUser.size() - 1; i >= 0; i--) {
                if ((((ResolveInfo) resultTargetUser.get(i)).activityInfo.applicationInfo.flags & 1073741824) == 0) {
                    return createForwardingResolveInfoUnchecked(filter, sourceUserId, targetUserId);
                }
            }
        }
        return null;
    }

    private ResolveInfo createForwardingResolveInfoUnchecked(IntentFilter filter, int sourceUserId, int targetUserId) {
        ResolveInfo forwardingResolveInfo = new ResolveInfo();
        long ident = Binder.clearCallingIdentity();
        try {
            String className;
            boolean targetIsProfile = sUserManager.getUserInfo(targetUserId).isManagedProfile();
            if (targetIsProfile) {
                className = IntentForwarderActivity.FORWARD_INTENT_TO_MANAGED_PROFILE;
            } else {
                className = IntentForwarderActivity.FORWARD_INTENT_TO_PARENT;
            }
            ActivityInfo forwardingActivityInfo = getActivityInfo(new ComponentName(this.mAndroidApplication.packageName, className), 0, sourceUserId);
            if (!targetIsProfile) {
                forwardingActivityInfo.showUserIcon = targetUserId;
                forwardingResolveInfo.noResourceId = true;
            }
            forwardingResolveInfo.activityInfo = forwardingActivityInfo;
            forwardingResolveInfo.priority = 0;
            forwardingResolveInfo.preferredOrder = 0;
            forwardingResolveInfo.match = 0;
            forwardingResolveInfo.isDefault = true;
            forwardingResolveInfo.filter = filter;
            forwardingResolveInfo.targetUserId = targetUserId;
            return forwardingResolveInfo;
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public ParceledListSlice<ResolveInfo> queryIntentActivityOptions(ComponentName caller, Intent[] specifics, String[] specificTypes, Intent intent, String resolvedType, int flags, int userId) {
        return new ParceledListSlice(queryIntentActivityOptionsInternal(caller, specifics, specificTypes, intent, resolvedType, flags, userId));
    }

    private java.util.List<android.content.pm.ResolveInfo> queryIntentActivityOptionsInternal(android.content.ComponentName r30, android.content.Intent[] r31, java.lang.String[] r32, android.content.Intent r33, java.lang.String r34, int r35, int r36) {
        /* JADX: method processing error */
/*
Error: jadx.core.utils.exceptions.JadxRuntimeException: Unknown predecessor block by arg (r17_1 'comp' android.content.ComponentName) in PHI: PHI: (r17_2 'comp' android.content.ComponentName) = (r17_1 'comp' android.content.ComponentName), (r17_0 'comp' android.content.ComponentName) binds: {(r17_1 'comp' android.content.ComponentName)=B:29:0x00d6, (r17_0 'comp' android.content.ComponentName)=B:52:0x01a6}
	at jadx.core.dex.instructions.PhiInsn.replaceArg(PhiInsn.java:78)
	at jadx.core.dex.visitors.ModVisitor.processInvoke(ModVisitor.java:222)
	at jadx.core.dex.visitors.ModVisitor.replaceStep(ModVisitor.java:83)
	at jadx.core.dex.visitors.ModVisitor.visit(ModVisitor.java:68)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:27)
	at jadx.core.dex.visitors.DepthTraversal.lambda$visit$1(DepthTraversal.java:14)
	at java.util.ArrayList.forEach(ArrayList.java:1251)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:14)
	at jadx.core.ProcessClass.process(ProcessClass.java:32)
	at jadx.core.ProcessClass.lambda$processDependencies$0(ProcessClass.java:51)
	at java.lang.Iterable.forEach(Iterable.java:75)
	at jadx.core.ProcessClass.processDependencies(ProcessClass.java:51)
	at jadx.core.ProcessClass.process(ProcessClass.java:37)
	at jadx.api.JadxDecompiler.processClass(JadxDecompiler.java:286)
	at jadx.api.JavaClass.decompile(JavaClass.java:62)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
*/
        /*
        r29 = this;
        r4 = sUserManager;
        r0 = r36;
        r4 = r4.exists(r0);
        if (r4 != 0) goto L_0x000f;
    L_0x000a:
        r4 = java.util.Collections.emptyList();
        return r4;
    L_0x000f:
        r8 = android.os.Binder.getCallingUid();
        r9 = 0;
        r4 = r29;
        r5 = r35;
        r6 = r36;
        r7 = r33;
        r35 = r4.updateFlagsForResolve(r5, r6, r7, r8, r9);
        r12 = "query intent activity options";
        r10 = 0;
        r11 = 0;
        r7 = r29;
        r9 = r36;
        r7.enforceCrossUserPermission(r8, r9, r10, r11, r12);
        r22 = r33.getAction();
        r4 = r35 | 64;
        r0 = r29;
        r1 = r33;
        r2 = r34;
        r3 = r36;
        r21 = r0.queryIntentActivitiesInternal(r1, r2, r4, r3);
        r4 = DEBUG_INTENT_MATCHING;
        if (r4 == 0) goto L_0x006b;
    L_0x0042:
        r4 = "PackageManager";
        r5 = new java.lang.StringBuilder;
        r5.<init>();
        r6 = "Query ";
        r5 = r5.append(r6);
        r0 = r33;
        r5 = r5.append(r0);
        r6 = ": ";
        r5 = r5.append(r6);
        r0 = r21;
        r5 = r5.append(r0);
        r5 = r5.toString();
        android.util.Log.v(r4, r5);
    L_0x006b:
        r27 = 0;
        if (r31 == 0) goto L_0x01c8;
    L_0x006f:
        r18 = 0;
    L_0x0071:
        r0 = r31;
        r4 = r0.length;
        r0 = r18;
        if (r0 >= r4) goto L_0x01c8;
    L_0x0078:
        r26 = r31[r18];
        if (r26 != 0) goto L_0x007f;
    L_0x007c:
        r18 = r18 + 1;
        goto L_0x0071;
    L_0x007f:
        r4 = DEBUG_INTENT_MATCHING;
        if (r4 == 0) goto L_0x00ac;
    L_0x0083:
        r4 = "PackageManager";
        r5 = new java.lang.StringBuilder;
        r5.<init>();
        r6 = "Specific #";
        r5 = r5.append(r6);
        r0 = r18;
        r5 = r5.append(r0);
        r6 = ": ";
        r5 = r5.append(r6);
        r0 = r26;
        r5 = r5.append(r0);
        r5 = r5.toString();
        android.util.Log.v(r4, r5);
    L_0x00ac:
        r14 = r26.getAction();
        if (r22 == 0) goto L_0x00bb;
    L_0x00b2:
        r0 = r22;
        r4 = r0.equals(r14);
        if (r4 == 0) goto L_0x00bb;
    L_0x00ba:
        r14 = 0;
    L_0x00bb:
        r23 = 0;
        r15 = 0;
        r17 = r26.getComponent();
        if (r17 != 0) goto L_0x019a;
    L_0x00c4:
        if (r32 == 0) goto L_0x0197;
    L_0x00c6:
        r4 = r32[r18];
    L_0x00c8:
        r0 = r29;
        r1 = r26;
        r2 = r35;
        r3 = r36;
        r23 = r0.resolveIntent(r1, r4, r2, r3);
        if (r23 == 0) goto L_0x007c;
    L_0x00d6:
        r0 = r29;
        r4 = r0.mResolveInfo;
        r0 = r23;
        r15 = r0.activityInfo;
        r17 = new android.content.ComponentName;
        r4 = r15.applicationInfo;
        r4 = r4.packageName;
        r5 = r15.name;
        r0 = r17;
        r0.<init>(r4, r5);
    L_0x00eb:
        r4 = DEBUG_INTENT_MATCHING;
        if (r4 == 0) goto L_0x0116;
    L_0x00ef:
        r4 = "PackageManager";
        r5 = new java.lang.StringBuilder;
        r5.<init>();
        r6 = "Specific #";
        r5 = r5.append(r6);
        r0 = r18;
        r5 = r5.append(r0);
        r6 = ": ";
        r5 = r5.append(r6);
        r5 = r5.append(r15);
        r5 = r5.toString();
        android.util.Log.v(r4, r5);
    L_0x0116:
        r13 = r21.size();
        r20 = r27;
    L_0x011c:
        r0 = r20;
        if (r0 >= r13) goto L_0x01aa;
    L_0x0120:
        r0 = r21;
        r1 = r20;
        r28 = r0.get(r1);
        r28 = (android.content.pm.ResolveInfo) r28;
        r0 = r28;
        r4 = r0.activityInfo;
        r4 = r4.name;
        r5 = r17.getClassName();
        r4 = r4.equals(r5);
        if (r4 == 0) goto L_0x014c;
    L_0x013a:
        r0 = r28;
        r4 = r0.activityInfo;
        r4 = r4.applicationInfo;
        r4 = r4.packageName;
        r5 = r17.getPackageName();
        r4 = r4.equals(r5);
        if (r4 != 0) goto L_0x0158;
    L_0x014c:
        if (r14 == 0) goto L_0x0194;
    L_0x014e:
        r0 = r28;
        r4 = r0.filter;
        r4 = r4.matchAction(r14);
        if (r4 == 0) goto L_0x0194;
    L_0x0158:
        r0 = r21;
        r1 = r20;
        r0.remove(r1);
        r4 = DEBUG_INTENT_MATCHING;
        if (r4 == 0) goto L_0x018c;
    L_0x0163:
        r4 = "PackageManager";
        r5 = new java.lang.StringBuilder;
        r5.<init>();
        r6 = "Removing duplicate item from ";
        r5 = r5.append(r6);
        r0 = r20;
        r5 = r5.append(r0);
        r6 = " due to specific ";
        r5 = r5.append(r6);
        r0 = r27;
        r5 = r5.append(r0);
        r5 = r5.toString();
        android.util.Log.v(r4, r5);
    L_0x018c:
        if (r23 != 0) goto L_0x0190;
    L_0x018e:
        r23 = r28;
    L_0x0190:
        r20 = r20 + -1;
        r13 = r13 + -1;
    L_0x0194:
        r20 = r20 + 1;
        goto L_0x011c;
    L_0x0197:
        r4 = 0;
        goto L_0x00c8;
    L_0x019a:
        r0 = r29;
        r1 = r17;
        r2 = r35;
        r3 = r36;
        r15 = r0.getActivityInfo(r1, r2, r3);
        if (r15 != 0) goto L_0x00eb;
    L_0x01a8:
        goto L_0x007c;
    L_0x01aa:
        if (r23 != 0) goto L_0x01b5;
    L_0x01ac:
        r23 = new android.content.pm.ResolveInfo;
        r23.<init>();
        r0 = r23;
        r0.activityInfo = r15;
    L_0x01b5:
        r0 = r21;
        r1 = r27;
        r2 = r23;
        r0.add(r1, r2);
        r0 = r18;
        r1 = r23;
        r1.specificIndex = r0;
        r27 = r27 + 1;
        goto L_0x007c;
    L_0x01c8:
        r13 = r21.size();
        r18 = r27;
    L_0x01ce:
        r4 = r13 + -1;
        r0 = r18;
        if (r0 >= r4) goto L_0x0278;
    L_0x01d4:
        r0 = r21;
        r1 = r18;
        r24 = r0.get(r1);
        r24 = (android.content.pm.ResolveInfo) r24;
        r0 = r24;
        r4 = r0.filter;
        if (r4 != 0) goto L_0x01e7;
    L_0x01e4:
        r18 = r18 + 1;
        goto L_0x01ce;
    L_0x01e7:
        r0 = r24;
        r4 = r0.filter;
        r19 = r4.actionsIterator();
        if (r19 == 0) goto L_0x01e4;
    L_0x01f1:
        r4 = r19.hasNext();
        if (r4 == 0) goto L_0x026d;
    L_0x01f7:
        r14 = r19.next();
        r14 = (java.lang.String) r14;
        if (r22 == 0) goto L_0x0207;
    L_0x01ff:
        r0 = r22;
        r4 = r0.equals(r14);
        if (r4 != 0) goto L_0x01f1;
    L_0x0207:
        r20 = r18 + 1;
    L_0x0209:
        r0 = r20;
        if (r0 >= r13) goto L_0x01f1;
    L_0x020d:
        r0 = r21;
        r1 = r20;
        r25 = r0.get(r1);
        r25 = (android.content.pm.ResolveInfo) r25;
        r0 = r25;
        r4 = r0.filter;
        if (r4 == 0) goto L_0x026a;
    L_0x021d:
        r0 = r25;
        r4 = r0.filter;
        r4 = r4.hasAction(r14);
        if (r4 == 0) goto L_0x026a;
    L_0x0227:
        r0 = r21;
        r1 = r20;
        r0.remove(r1);
        r4 = DEBUG_INTENT_MATCHING;
        if (r4 == 0) goto L_0x0266;
    L_0x0232:
        r4 = "PackageManager";
        r5 = new java.lang.StringBuilder;
        r5.<init>();
        r6 = "Removing duplicate item from ";
        r5 = r5.append(r6);
        r0 = r20;
        r5 = r5.append(r0);
        r6 = " due to action ";
        r5 = r5.append(r6);
        r5 = r5.append(r14);
        r6 = " at ";
        r5 = r5.append(r6);
        r0 = r18;
        r5 = r5.append(r0);
        r5 = r5.toString();
        android.util.Log.v(r4, r5);
    L_0x0266:
        r20 = r20 + -1;
        r13 = r13 + -1;
    L_0x026a:
        r20 = r20 + 1;
        goto L_0x0209;
    L_0x026d:
        r4 = r35 & 64;
        if (r4 != 0) goto L_0x01e4;
    L_0x0271:
        r4 = 0;
        r0 = r24;
        r0.filter = r4;
        goto L_0x01e4;
    L_0x0278:
        if (r30 == 0) goto L_0x02b7;
    L_0x027a:
        r13 = r21.size();
        r18 = 0;
    L_0x0280:
        r0 = r18;
        if (r0 >= r13) goto L_0x02b7;
    L_0x0284:
        r0 = r21;
        r1 = r18;
        r4 = r0.get(r1);
        r4 = (android.content.pm.ResolveInfo) r4;
        r0 = r4.activityInfo;
        r16 = r0;
        r4 = r30.getPackageName();
        r0 = r16;
        r5 = r0.applicationInfo;
        r5 = r5.packageName;
        r4 = r4.equals(r5);
        if (r4 == 0) goto L_0x02d5;
    L_0x02a2:
        r4 = r30.getClassName();
        r0 = r16;
        r5 = r0.name;
        r4 = r4.equals(r5);
        if (r4 == 0) goto L_0x02d5;
    L_0x02b0:
        r0 = r21;
        r1 = r18;
        r0.remove(r1);
    L_0x02b7:
        r4 = r35 & 64;
        if (r4 != 0) goto L_0x02d8;
    L_0x02bb:
        r13 = r21.size();
        r18 = 0;
    L_0x02c1:
        r0 = r18;
        if (r0 >= r13) goto L_0x02d8;
    L_0x02c5:
        r0 = r21;
        r1 = r18;
        r4 = r0.get(r1);
        r4 = (android.content.pm.ResolveInfo) r4;
        r5 = 0;
        r4.filter = r5;
        r18 = r18 + 1;
        goto L_0x02c1;
    L_0x02d5:
        r18 = r18 + 1;
        goto L_0x0280;
    L_0x02d8:
        r4 = DEBUG_INTENT_MATCHING;
        if (r4 == 0) goto L_0x02f8;
    L_0x02dc:
        r4 = "PackageManager";
        r5 = new java.lang.StringBuilder;
        r5.<init>();
        r6 = "Result: ";
        r5 = r5.append(r6);
        r0 = r21;
        r5 = r5.append(r0);
        r5 = r5.toString();
        android.util.Log.v(r4, r5);
    L_0x02f8:
        return r21;
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.pm.PackageManagerService.queryIntentActivityOptionsInternal(android.content.ComponentName, android.content.Intent[], java.lang.String[], android.content.Intent, java.lang.String, int, int):java.util.List<android.content.pm.ResolveInfo>");
    }

    public ParceledListSlice<ResolveInfo> queryIntentReceivers(Intent intent, String resolvedType, int flags, int userId) {
        int i = 0;
        ParceledListSlice<ResolveInfo> parceledList = new ParceledListSlice(queryIntentReceiversInternal(intent, resolvedType, flags, userId, false));
        if (userId != OppoMultiAppManager.USER_ID) {
            return parceledList;
        }
        if (parceledList != null && (parceledList == null || !parceledList.getList().isEmpty())) {
            return parceledList;
        }
        try {
            String[] packages = getPackagesForUid(Binder.getCallingUid());
            if (packages == null) {
                return parceledList;
            }
            int length = packages.length;
            while (i < length) {
                if (OppoMultiAppManagerUtil.getInstance().isMultiApp(packages[i])) {
                    return new ParceledListSlice(queryIntentReceiversInternal(intent, resolvedType, flags, 0, false));
                }
                i++;
            }
            return parceledList;
        } catch (Exception e) {
            return parceledList;
        }
    }

    protected List<ResolveInfo> queryIntentReceiversInternal(Intent intent, String resolvedType, int flags, int userId, boolean allowDynamicSplits) {
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        enforceCrossUserPermission(callingUid, userId, false, false, "query intent receivers");
        String instantAppPkgName = getInstantAppPackageName(callingUid);
        flags = updateFlagsForResolve(flags, userId, intent, callingUid, false);
        ComponentName comp = intent.getComponent();
        if (comp == null && intent.getSelector() != null) {
            intent = intent.getSelector();
            comp = intent.getComponent();
        }
        if (comp != null) {
            List<ResolveInfo> list = new ArrayList(1);
            ActivityInfo ai = getReceiverInfo(comp, flags, userId);
            if (ai != null) {
                boolean blockResolution;
                boolean matchInstantApp = (DumpState.DUMP_VOLUMES & flags) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags) != 0;
                boolean matchExplicitlyVisibleOnly = (PhoneWindowManager.SYSTEM_UI_FLAG_APP_CUSTOM_NAVIGATION_BAR & flags) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                boolean isTargetSameInstantApp = comp.getPackageName().equals(instantAppPkgName);
                boolean isTargetInstantApp = (ai.applicationInfo.privateFlags & 128) != 0;
                boolean isTargetVisibleToInstantApp = (ai.flags & DumpState.DUMP_DEXOPT) != 0;
                boolean isTargetExplicitlyVisibleToInstantApp = isTargetVisibleToInstantApp ? (ai.flags & DumpState.DUMP_COMPILER_STATS) == 0 : false;
                boolean isTargetHiddenFromInstantApp = isTargetVisibleToInstantApp ? matchExplicitlyVisibleOnly ? isTargetExplicitlyVisibleToInstantApp ^ 1 : false : true;
                if (isTargetSameInstantApp) {
                    blockResolution = false;
                } else if (!matchInstantApp && (isCallerInstantApp ^ 1) != 0 && isTargetInstantApp) {
                    blockResolution = true;
                } else if (matchVisibleToInstantAppOnly && isCallerInstantApp) {
                    blockResolution = isTargetHiddenFromInstantApp;
                } else {
                    blockResolution = false;
                }
                if (!blockResolution) {
                    ResolveInfo ri = new ResolveInfo();
                    ri.activityInfo = ai;
                    list.add(ri);
                }
            }
            return applyPostResolutionFilter(list, instantAppPkgName, allowDynamicSplits, callingUid, userId);
        }
        synchronized (this.mPackages) {
            String pkgName = intent.getPackage();
            List<ResolveInfo> applyPostResolutionFilter;
            if (pkgName == null) {
                applyPostResolutionFilter = applyPostResolutionFilter(this.mReceivers.queryIntent(intent, resolvedType, flags, userId), instantAppPkgName, allowDynamicSplits, callingUid, userId);
                return applyPostResolutionFilter;
            }
            Package pkg = (Package) this.mPackages.get(pkgName);
            if (pkg != null) {
                applyPostResolutionFilter = applyPostResolutionFilter(this.mReceivers.queryIntentForPackage(intent, resolvedType, flags, pkg.receivers, userId), instantAppPkgName, allowDynamicSplits, callingUid, userId);
                return applyPostResolutionFilter;
            }
            applyPostResolutionFilter = Collections.emptyList();
            return applyPostResolutionFilter;
        }
    }

    public ResolveInfo resolveService(Intent intent, String resolvedType, int flags, int userId) {
        return resolveServiceInternal(intent, resolvedType, flags, userId, Binder.getCallingUid());
    }

    private ResolveInfo resolveServiceInternal(Intent intent, String resolvedType, int flags, int userId, int callingUid) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        List<ResolveInfo> query = queryIntentServicesInternal(intent, resolvedType, updateFlagsForResolve(flags, userId, intent, callingUid, false), userId, callingUid, false);
        if (query == null || query.size() < 1) {
            return null;
        }
        return (ResolveInfo) query.get(0);
    }

    public ParceledListSlice<ResolveInfo> queryIntentServices(Intent intent, String resolvedType, int flags, int userId) {
        int callingUid = Binder.getCallingUid();
        ParceledListSlice<ResolveInfo> parceledList = new ParceledListSlice(queryIntentServicesInternal(intent, resolvedType, flags, userId, callingUid, false));
        if (userId != 999) {
            return parceledList;
        }
        if (parceledList != null && (parceledList == null || !parceledList.getList().isEmpty())) {
            return parceledList;
        }
        try {
            String[] packages = getPackagesForUid(callingUid);
            if (packages == null) {
                return parceledList;
            }
            for (String pkgName : packages) {
                if (OppoMultiAppManagerUtil.getInstance().isMultiApp(pkgName)) {
                    return new ParceledListSlice(queryIntentServicesInternal(intent, resolvedType, flags, 0, callingUid, false));
                }
            }
            return parceledList;
        } catch (Exception e) {
            return parceledList;
        }
    }

    private List<ResolveInfo> queryIntentServicesInternal(Intent intent, String resolvedType, int flags, int userId, int callingUid, boolean includeInstantApps) {
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        enforceCrossUserPermission(callingUid, userId, false, false, "query intent receivers");
        String instantAppPkgName = getInstantAppPackageName(callingUid);
        flags = updateFlagsForResolve(flags, userId, intent, callingUid, includeInstantApps);
        ComponentName comp = intent.getComponent();
        if (comp == null && intent.getSelector() != null) {
            intent = intent.getSelector();
            comp = intent.getComponent();
        }
        if (comp != null) {
            List<ResolveInfo> arrayList = new ArrayList(1);
            ServiceInfo si = getServiceInfo(comp, flags, userId);
            if (si != null) {
                boolean blockResolution;
                boolean matchInstantApp = (DumpState.DUMP_VOLUMES & flags) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                boolean isTargetSameInstantApp = comp.getPackageName().equals(instantAppPkgName);
                boolean isTargetInstantApp = (si.applicationInfo.privateFlags & 128) != 0;
                boolean isTargetHiddenFromInstantApp = (si.flags & DumpState.DUMP_DEXOPT) == 0;
                if (isTargetSameInstantApp) {
                    blockResolution = false;
                } else if (!matchInstantApp && (isCallerInstantApp ^ 1) != 0 && isTargetInstantApp) {
                    blockResolution = true;
                } else if (matchVisibleToInstantAppOnly && isCallerInstantApp) {
                    blockResolution = isTargetHiddenFromInstantApp;
                } else {
                    blockResolution = false;
                }
                if (!blockResolution) {
                    ResolveInfo ri = new ResolveInfo();
                    ri.serviceInfo = si;
                    arrayList.add(ri);
                }
            }
            return arrayList;
        }
        synchronized (this.mPackages) {
            String pkgName = intent.getPackage();
            List<ResolveInfo> applyPostServiceResolutionFilter;
            if (pkgName == null) {
                applyPostServiceResolutionFilter = applyPostServiceResolutionFilter(this.mServices.queryIntent(intent, resolvedType, flags, userId), instantAppPkgName);
                return applyPostServiceResolutionFilter;
            }
            Package pkg = (Package) this.mPackages.get(pkgName);
            if (pkg != null) {
                applyPostServiceResolutionFilter = applyPostServiceResolutionFilter(this.mServices.queryIntentForPackage(intent, resolvedType, flags, pkg.services, userId), instantAppPkgName);
                return applyPostServiceResolutionFilter;
            }
            applyPostServiceResolutionFilter = Collections.emptyList();
            return applyPostServiceResolutionFilter;
        }
    }

    private List<ResolveInfo> applyPostServiceResolutionFilter(List<ResolveInfo> resolveInfos, String instantAppPkgName) {
        if (instantAppPkgName == null) {
            return resolveInfos;
        }
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            ResolveInfo info = (ResolveInfo) resolveInfos.get(i);
            boolean isEphemeralApp = info.serviceInfo.applicationInfo.isInstantApp();
            if (isEphemeralApp && instantAppPkgName.equals(info.serviceInfo.packageName)) {
                if (!(info.serviceInfo.splitName == null || (ArrayUtils.contains(info.serviceInfo.applicationInfo.splitNames, info.serviceInfo.splitName) ^ 1) == 0)) {
                    if (DEBUG_EPHEMERAL) {
                        Slog.v(TAG, "Adding ephemeral installer to the ResolveInfo list");
                    }
                    ResolveInfo installerInfo = new ResolveInfo(this.mInstantAppInstallerInfo);
                    installerInfo.auxiliaryInfo = new AuxiliaryResolveInfo(info.serviceInfo.packageName, info.serviceInfo.splitName, null, info.serviceInfo.applicationInfo.versionCode, null);
                    installerInfo.isDefault = true;
                    installerInfo.match = 5799936;
                    installerInfo.filter = new IntentFilter();
                    installerInfo.resolvePackageName = info.getComponentInfo().packageName;
                    resolveInfos.set(i, installerInfo);
                }
            } else if (isEphemeralApp || (info.serviceInfo.flags & DumpState.DUMP_DEXOPT) == 0) {
                resolveInfos.remove(i);
            }
        }
        return resolveInfos;
    }

    public ParceledListSlice<ResolveInfo> queryIntentContentProviders(Intent intent, String resolvedType, int flags, int userId) {
        ParceledListSlice<ResolveInfo> parceledList = new ParceledListSlice(queryIntentContentProvidersInternal(intent, resolvedType, flags, userId));
        if (userId != OppoMultiAppManager.USER_ID) {
            return parceledList;
        }
        if (parceledList != null && (parceledList == null || !parceledList.getList().isEmpty())) {
            return parceledList;
        }
        try {
            String[] packages = getPackagesForUid(Binder.getCallingUid());
            if (packages == null) {
                return parceledList;
            }
            for (String pkgName : packages) {
                if (OppoMultiAppManagerUtil.getInstance().isMultiApp(pkgName)) {
                    return new ParceledListSlice(queryIntentContentProvidersInternal(intent, resolvedType, flags, 0));
                }
            }
            return parceledList;
        } catch (Exception e) {
            return parceledList;
        }
    }

    private List<ResolveInfo> queryIntentContentProvidersInternal(Intent intent, String resolvedType, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        String instantAppPkgName = getInstantAppPackageName(callingUid);
        flags = updateFlagsForResolve(flags, userId, intent, callingUid, false);
        ComponentName comp = intent.getComponent();
        if (comp == null && intent.getSelector() != null) {
            intent = intent.getSelector();
            comp = intent.getComponent();
        }
        if (comp != null) {
            List<ResolveInfo> arrayList = new ArrayList(1);
            ProviderInfo pi = getProviderInfo(comp, flags, userId);
            if (pi != null) {
                boolean blockResolution;
                boolean matchInstantApp = (DumpState.DUMP_VOLUMES & flags) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                boolean isTargetSameInstantApp = comp.getPackageName().equals(instantAppPkgName);
                boolean isTargetInstantApp = (pi.applicationInfo.privateFlags & 128) != 0;
                boolean isTargetHiddenFromInstantApp = (pi.flags & DumpState.DUMP_DEXOPT) == 0;
                if (isTargetSameInstantApp) {
                    blockResolution = false;
                } else if (!matchInstantApp && (isCallerInstantApp ^ 1) != 0 && isTargetInstantApp) {
                    blockResolution = true;
                } else if (matchVisibleToInstantAppOnly && isCallerInstantApp) {
                    blockResolution = isTargetHiddenFromInstantApp;
                } else {
                    blockResolution = false;
                }
                if (!blockResolution) {
                    ResolveInfo ri = new ResolveInfo();
                    ri.providerInfo = pi;
                    arrayList.add(ri);
                }
            }
            return arrayList;
        }
        synchronized (this.mPackages) {
            String pkgName = intent.getPackage();
            List<ResolveInfo> applyPostContentProviderResolutionFilter;
            if (pkgName == null) {
                applyPostContentProviderResolutionFilter = applyPostContentProviderResolutionFilter(this.mProviders.queryIntent(intent, resolvedType, flags, userId), instantAppPkgName);
                return applyPostContentProviderResolutionFilter;
            }
            Package pkg = (Package) this.mPackages.get(pkgName);
            if (pkg != null) {
                applyPostContentProviderResolutionFilter = applyPostContentProviderResolutionFilter(this.mProviders.queryIntentForPackage(intent, resolvedType, flags, pkg.providers, userId), instantAppPkgName);
                return applyPostContentProviderResolutionFilter;
            }
            applyPostContentProviderResolutionFilter = Collections.emptyList();
            return applyPostContentProviderResolutionFilter;
        }
    }

    private List<ResolveInfo> applyPostContentProviderResolutionFilter(List<ResolveInfo> resolveInfos, String instantAppPkgName) {
        if (instantAppPkgName == null) {
            return resolveInfos;
        }
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            ResolveInfo info = (ResolveInfo) resolveInfos.get(i);
            boolean isEphemeralApp = info.providerInfo.applicationInfo.isInstantApp();
            if (isEphemeralApp && instantAppPkgName.equals(info.providerInfo.packageName)) {
                if (!(info.providerInfo.splitName == null || (ArrayUtils.contains(info.providerInfo.applicationInfo.splitNames, info.providerInfo.splitName) ^ 1) == 0)) {
                    if (DEBUG_EPHEMERAL) {
                        Slog.v(TAG, "Adding ephemeral installer to the ResolveInfo list");
                    }
                    ResolveInfo installerInfo = new ResolveInfo(this.mInstantAppInstallerInfo);
                    installerInfo.auxiliaryInfo = new AuxiliaryResolveInfo(info.providerInfo.packageName, info.providerInfo.splitName, null, info.providerInfo.applicationInfo.versionCode, null);
                    installerInfo.isDefault = true;
                    installerInfo.match = 5799936;
                    installerInfo.filter = new IntentFilter();
                    installerInfo.resolvePackageName = info.getComponentInfo().packageName;
                    resolveInfos.set(i, installerInfo);
                }
            } else if (isEphemeralApp || (info.providerInfo.flags & DumpState.DUMP_DEXOPT) == 0) {
                resolveInfos.remove(i);
            }
        }
        return resolveInfos;
    }

    public ParceledListSlice<PackageInfo> getInstalledPackages(int flags, int userId) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return ParceledListSlice.emptyList();
        }
        if (!sUserManager.exists(userId)) {
            return ParceledListSlice.emptyList();
        }
        ParceledListSlice<PackageInfo> parceledListSlice;
        flags = updateFlagsForPackage(flags, userId, null);
        boolean listUninstalled = (4202496 & flags) != 0;
        enforceCrossUserPermission(callingUid, userId, true, false, "get installed packages");
        boolean isSystemCaller = isSystemAppCall();
        synchronized (this.mPackages) {
            ArrayList<PackageInfo> list;
            PackageSetting ps;
            PackageInfo pi;
            if (listUninstalled) {
                list = new ArrayList(this.mSettings.mPackages.size());
                for (PackageSetting ps2 : this.mSettings.mPackages.values()) {
                    if (!(filterSharedLibPackageLPr(ps2, callingUid, userId, flags) || filterAppAccessLPr(ps2, callingUid, userId))) {
                        pi = generatePackageInfo(ps2, flags, userId);
                        if (pi == null) {
                            continue;
                        } else if (isSystemCaller || !isSecurePayApp(pi.packageName) || (ColorPackageManagerHelper.isSpecialSecureApp(pi.packageName) ^ 1) == 0) {
                            if (!ColorPackageManagerHelper.isPrivilegedHideApp(pi.packageName) && (isSystemCaller || !ColorPackageManagerHelper.isSafeCenterApp(pi.packageName))) {
                                list.add(pi);
                            }
                        } else if (DEBUG_INSTALL) {
                            Slog.d(TAG, "oppo filter SecurepayApp for get install package33 : " + pi.packageName);
                        }
                    }
                }
            } else {
                list = new ArrayList(this.mPackages.size());
                for (Package p : this.mPackages.values()) {
                    ps2 = (PackageSetting) p.mExtras;
                    if (!(filterSharedLibPackageLPr(ps2, callingUid, userId, flags) || filterAppAccessLPr(ps2, callingUid, userId))) {
                        pi = generatePackageInfo((PackageSetting) p.mExtras, flags, userId);
                        if (pi != null) {
                            if (isSystemCaller || !isSecurePayApp(pi.packageName) || (ColorPackageManagerHelper.isSpecialSecureApp(pi.packageName) ^ 1) == 0) {
                                if (!ColorPackageManagerHelper.isPrivilegedHideApp(pi.packageName) && (isSystemCaller || !ColorPackageManagerHelper.isSafeCenterApp(pi.packageName))) {
                                    list.add(pi);
                                }
                            } else if (DEBUG_INSTALL) {
                                Slog.d(TAG, "oppo filter SecurepayApp for get install package33 : " + pi.packageName);
                            }
                        }
                    }
                }
            }
            OppoPackageManagerHelper.filterThirdMarket(this.mContext, this, flags, list, this.mHandler);
            parceledListSlice = new ParceledListSlice(list);
        }
        return parceledListSlice;
    }

    private void addPackageHoldingPermissions(ArrayList<PackageInfo> list, PackageSetting ps, String[] permissions, boolean[] tmp, int flags, int userId) {
        int i;
        int numMatch = 0;
        PermissionsState permissionsState = ps.getPermissionsState();
        for (i = 0; i < permissions.length; i++) {
            if (permissionsState.hasPermission(permissions[i], userId)) {
                tmp[i] = true;
                numMatch++;
            } else {
                tmp[i] = false;
            }
        }
        if (numMatch != 0) {
            PackageInfo pi = generatePackageInfo(ps, flags, userId);
            if (pi != null) {
                if ((flags & 4096) == 0) {
                    if (numMatch == permissions.length) {
                        pi.requestedPermissions = permissions;
                    } else {
                        pi.requestedPermissions = new String[numMatch];
                        numMatch = 0;
                        for (i = 0; i < permissions.length; i++) {
                            if (tmp[i]) {
                                pi.requestedPermissions[numMatch] = permissions[i];
                                numMatch++;
                            }
                        }
                    }
                }
                list.add(pi);
            }
        }
    }

    public ParceledListSlice<PackageInfo> getPackagesHoldingPermissions(String[] permissions, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return ParceledListSlice.emptyList();
        }
        ParceledListSlice<PackageInfo> parceledListSlice;
        flags = updateFlagsForPackage(flags, userId, permissions);
        enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "get packages holding permissions");
        boolean listUninstalled = (4202496 & flags) != 0;
        synchronized (this.mPackages) {
            ArrayList<PackageInfo> list = new ArrayList();
            boolean[] tmpBools = new boolean[permissions.length];
            PackageSetting ps;
            if (listUninstalled) {
                for (PackageSetting ps2 : this.mSettings.mPackages.values()) {
                    addPackageHoldingPermissions(list, ps2, permissions, tmpBools, flags, userId);
                }
            } else {
                for (Package pkg : this.mPackages.values()) {
                    ps2 = (PackageSetting) pkg.mExtras;
                    if (ps2 != null) {
                        addPackageHoldingPermissions(list, ps2, permissions, tmpBools, flags, userId);
                    }
                }
            }
            parceledListSlice = new ParceledListSlice(list);
        }
        return parceledListSlice;
    }

    public ParceledListSlice<ApplicationInfo> getInstalledApplications(int flags, int userId) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return ParceledListSlice.emptyList();
        }
        if (!sUserManager.exists(userId)) {
            return ParceledListSlice.emptyList();
        }
        ParceledListSlice<ApplicationInfo> parceledListSlice;
        flags = updateFlagsForApplication(flags, userId, null);
        boolean listUninstalled = (4202496 & flags) != 0;
        boolean isSystemCaller = isSystemAppCall();
        synchronized (this.mPackages) {
            ArrayList<ApplicationInfo> list;
            PackageSetting ps;
            ApplicationInfo ai;
            if (listUninstalled) {
                list = new ArrayList(this.mSettings.mPackages.size());
                for (PackageSetting ps2 : this.mSettings.mPackages.values()) {
                    int effectiveFlags = flags;
                    if (ps2.isSystem()) {
                        effectiveFlags = flags | DumpState.DUMP_CHANGES;
                    }
                    if (ps2.pkg == null) {
                        ai = generateApplicationInfoFromSettingsLPw(ps2.name, callingUid, effectiveFlags, userId);
                    } else if (!(filterSharedLibPackageLPr(ps2, callingUid, userId, flags) || filterAppAccessLPr(ps2, callingUid, userId))) {
                        ai = PackageParser.generateApplicationInfo(ps2.pkg, effectiveFlags, ps2.readUserState(userId), userId);
                        if (ai != null) {
                            ai.packageName = resolveExternalPackageNameLPr(ps2.pkg);
                        }
                    }
                    if (ai != null) {
                        if (isSystemCaller || !isSecurePayApp(ai.packageName) || (ColorPackageManagerHelper.isSpecialSecureApp(ai.packageName) ^ 1) == 0) {
                            if (!ColorPackageManagerHelper.isPrivilegedHideApp(ai.packageName) && (isSystemCaller || !ColorPackageManagerHelper.isSafeCenterApp(ai.packageName))) {
                                list.add(ai);
                            }
                        } else if (DEBUG_INSTALL) {
                            Slog.d(TAG, "oppo filter SecurepayApp for get install package22 : " + ai.packageName);
                        }
                    }
                }
            } else {
                list = new ArrayList(this.mPackages.size());
                for (Package p : this.mPackages.values()) {
                    if (p.mExtras != null) {
                        ps2 = (PackageSetting) p.mExtras;
                        if (!(filterSharedLibPackageLPr(ps2, Binder.getCallingUid(), userId, flags) || filterAppAccessLPr(ps2, callingUid, userId))) {
                            ai = PackageParser.generateApplicationInfo(p, flags, ps2.readUserState(userId), userId);
                            if (ai != null) {
                                ai.packageName = resolveExternalPackageNameLPr(p);
                                if (isSystemCaller || !isSecurePayApp(ai.packageName) || (ColorPackageManagerHelper.isSpecialSecureApp(ai.packageName) ^ 1) == 0) {
                                    if (!ColorPackageManagerHelper.isPrivilegedHideApp(ai.packageName) && (isSystemCaller || !ColorPackageManagerHelper.isSafeCenterApp(ai.packageName))) {
                                        list.add(ai);
                                    }
                                } else if (DEBUG_INSTALL) {
                                    Slog.d(TAG, "oppo filter SecurepayApp for get install package22 : " + ai.packageName);
                                }
                            }
                        }
                    }
                }
            }
            parceledListSlice = new ParceledListSlice(list);
        }
        return parceledListSlice;
    }

    public ParceledListSlice<InstantAppInfo> getInstantApps(int userId) {
        if (isEphemeralDisabled()) {
            return null;
        }
        if (!canViewInstantApps(Binder.getCallingUid(), userId)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS", "getEphemeralApplications");
        }
        enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getEphemeralApplications");
        synchronized (this.mPackages) {
            List<InstantAppInfo> instantApps = this.mInstantAppRegistry.getInstantAppsLPr(userId);
            if (instantApps != null) {
                ParceledListSlice<InstantAppInfo> parceledListSlice = new ParceledListSlice(instantApps);
                return parceledListSlice;
            }
            return null;
        }
    }

    public boolean isInstantApp(String packageName, int userId) {
        enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "isInstantApp");
        if (isEphemeralDisabled()) {
            return false;
        }
        synchronized (this.mPackages) {
            boolean returnAllowed;
            int callingUid = Binder.getCallingUid();
            if (Process.isIsolated(callingUid)) {
                callingUid = this.mIsolatedOwners.get(callingUid);
            }
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            Package pkg = (Package) this.mPackages.get(packageName);
            if (ps == null) {
                returnAllowed = false;
            } else if (isCallerSameApp(packageName, callingUid) || canViewInstantApps(callingUid, userId)) {
                returnAllowed = true;
            } else {
                returnAllowed = this.mInstantAppRegistry.isInstantAccessGranted(userId, UserHandle.getAppId(callingUid), ps.appId);
            }
            if (returnAllowed) {
                boolean instantApp = ps.getInstantApp(userId);
                return instantApp;
            }
            return false;
        }
    }

    public byte[] getInstantAppCookie(String packageName, int userId) {
        if (isEphemeralDisabled()) {
            return null;
        }
        enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getInstantAppCookie");
        if (!isCallerSameApp(packageName, Binder.getCallingUid())) {
            return null;
        }
        byte[] instantAppCookieLPw;
        synchronized (this.mPackages) {
            instantAppCookieLPw = this.mInstantAppRegistry.getInstantAppCookieLPw(packageName, userId);
        }
        return instantAppCookieLPw;
    }

    public boolean setInstantAppCookie(String packageName, byte[] cookie, int userId) {
        if (isEphemeralDisabled()) {
            return true;
        }
        enforceCrossUserPermission(Binder.getCallingUid(), userId, true, true, "setInstantAppCookie");
        if (!isCallerSameApp(packageName, Binder.getCallingUid())) {
            return false;
        }
        boolean instantAppCookieLPw;
        synchronized (this.mPackages) {
            instantAppCookieLPw = this.mInstantAppRegistry.setInstantAppCookieLPw(packageName, cookie, userId);
        }
        return instantAppCookieLPw;
    }

    public Bitmap getInstantAppIcon(String packageName, int userId) {
        if (isEphemeralDisabled()) {
            return null;
        }
        Bitmap instantAppIconLPw;
        if (!canViewInstantApps(Binder.getCallingUid(), userId)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS", "getInstantAppIcon");
        }
        enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getInstantAppIcon");
        synchronized (this.mPackages) {
            instantAppIconLPw = this.mInstantAppRegistry.getInstantAppIconLPw(packageName, userId);
        }
        return instantAppIconLPw;
    }

    private boolean isCallerSameApp(String packageName, int uid) {
        Package pkg = (Package) this.mPackages.get(packageName);
        if (pkg == null || UserHandle.getAppId(uid) != pkg.applicationInfo.uid) {
            return false;
        }
        return true;
    }

    public ParceledListSlice<ApplicationInfo> getPersistentApplications(int flags) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return ParceledListSlice.emptyList();
        }
        return new ParceledListSlice(getPersistentApplicationsInternal(flags));
    }

    private List<ApplicationInfo> getPersistentApplicationsInternal(int flags) {
        ArrayList<ApplicationInfo> finalList = new ArrayList();
        synchronized (this.mPackages) {
            int userId = UserHandle.getCallingUserId();
            for (Package p : this.mPackages.values()) {
                if (p.applicationInfo != null) {
                    int matchesUnaware;
                    if ((262144 & flags) != 0) {
                        matchesUnaware = p.applicationInfo.isDirectBootAware() ^ 1;
                    } else {
                        matchesUnaware = 0;
                    }
                    boolean matchesAware;
                    if ((524288 & flags) != 0) {
                        matchesAware = p.applicationInfo.isDirectBootAware();
                    } else {
                        matchesAware = false;
                    }
                    if ((p.applicationInfo.flags & 8) != 0 && ((!this.mSafeMode || isSystemApp(p)) && (matchesUnaware != 0 || matchesAware))) {
                        PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(p.packageName);
                        if (ps != null) {
                            ApplicationInfo ai = PackageParser.generateApplicationInfo(p, flags, ps.readUserState(userId), userId);
                            if (ai != null) {
                                finalList.add(ai);
                            }
                        }
                    }
                }
            }
        }
        return finalList;
    }

    public ProviderInfo resolveContentProvider(String name, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        flags = updateFlagsForComponent(flags, userId, name);
        String instantAppPkgName = getInstantAppPackageName(Binder.getCallingUid());
        synchronized (this.mPackages) {
            PackageSetting ps;
            Provider provider = (Provider) this.mProvidersByAuthority.get(name);
            if (provider != null) {
                ps = (PackageSetting) this.mSettings.mPackages.get(provider.owner.packageName);
            } else {
                ps = null;
            }
            if (ps != null) {
                boolean isInstantApp = ps.getInstantApp(userId);
                if (instantAppPkgName == null && isInstantApp) {
                    return null;
                }
                if (instantAppPkgName != null && isInstantApp) {
                    if ((provider.owner.packageName.equals(instantAppPkgName) ^ 1) != 0) {
                        return null;
                    }
                }
                if (!(instantAppPkgName == null || (isInstantApp ^ 1) == 0)) {
                    if ((provider.info.flags & DumpState.DUMP_DEXOPT) == 0) {
                        return null;
                    }
                }
                if (this.mSettings.isEnabledAndMatchLPr(provider.info, flags, userId)) {
                    ProviderInfo generateProviderInfo = PackageParser.generateProviderInfo(provider, flags, ps.readUserState(userId), userId);
                    return generateProviderInfo;
                }
                return null;
            }
            return null;
        }
    }

    @Deprecated
    public void querySyncProviders(List<String> outNames, List<ProviderInfo> outInfo) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            synchronized (this.mPackages) {
                int userId = UserHandle.getCallingUserId();
                for (Entry<String, Provider> entry : this.mProvidersByAuthority.entrySet()) {
                    Provider p = (Provider) entry.getValue();
                    PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(p.owner.packageName);
                    if (ps != null && p.syncable) {
                        if (!this.mSafeMode || (p.info.applicationInfo.flags & 1) != 0) {
                            ProviderInfo info = PackageParser.generateProviderInfo(p, 0, ps.readUserState(userId), userId);
                            if (info != null) {
                                outNames.add((String) entry.getKey());
                                outInfo.add(info);
                            }
                        }
                    }
                }
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public ParceledListSlice<ProviderInfo> queryContentProviders(String processName, int uid, int flags, String metaDataKey) {
        int userId;
        Throwable th;
        int callingUid = Binder.getCallingUid();
        if (processName != null) {
            userId = UserHandle.getUserId(uid);
        } else {
            userId = UserHandle.getCallingUserId();
        }
        if (!sUserManager.exists(userId)) {
            return ParceledListSlice.emptyList();
        }
        flags = updateFlagsForComponent(flags, userId, processName);
        synchronized (this.mPackages) {
            try {
                ArrayList<ProviderInfo> finalList = null;
                for (Provider p : this.mProviders.mProviders.values()) {
                    ArrayList<ProviderInfo> finalList2;
                    try {
                        PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(p.owner.packageName);
                        if (ps == null || p.info.authority == null || !(processName == null || (p.info.processName.equals(processName) && UserHandle.isSameApp(p.info.applicationInfo.uid, uid)))) {
                            finalList2 = finalList;
                        } else if (!this.mSettings.isEnabledAndMatchLPr(p.info, flags, userId)) {
                            finalList2 = finalList;
                        } else if (metaDataKey == null || (p.metaData != null && (p.metaData.containsKey(metaDataKey) ^ 1) == 0)) {
                            if (!filterAppAccessLPr(ps, callingUid, new ComponentName(p.info.packageName, p.info.name), 4, userId)) {
                                if (finalList == null) {
                                    finalList2 = new ArrayList(3);
                                } else {
                                    finalList2 = finalList;
                                }
                                ProviderInfo info = PackageParser.generateProviderInfo(p, flags, ps.readUserState(userId), userId);
                                if (info != null) {
                                    finalList2.add(info);
                                }
                            }
                        }
                        finalList = finalList2;
                    } catch (Throwable th2) {
                        th = th2;
                        finalList2 = finalList;
                        throw th;
                    }
                }
            } catch (Throwable th3) {
                th = th3;
                throw th;
            }
        }
    }

    public InstrumentationInfo getInstrumentationInfo(ComponentName component, int flags) {
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return null;
            } else if (filterAppAccessLPr(ps, callingUid, component, 0, callingUserId)) {
                return null;
            } else {
                InstrumentationInfo generateInstrumentationInfo = PackageParser.generateInstrumentationInfo((Instrumentation) this.mInstrumentation.get(component), flags);
                return generateInstrumentationInfo;
            }
        }
    }

    public ParceledListSlice<InstrumentationInfo> queryInstrumentation(String targetPackage, int flags) {
        int callingUid = Binder.getCallingUid();
        if (filterAppAccessLPr((PackageSetting) this.mSettings.mPackages.get(targetPackage), callingUid, UserHandle.getUserId(callingUid))) {
            return ParceledListSlice.emptyList();
        }
        return new ParceledListSlice(queryInstrumentationInternal(targetPackage, flags));
    }

    private List<InstrumentationInfo> queryInstrumentationInternal(String targetPackage, int flags) {
        ArrayList<InstrumentationInfo> finalList = new ArrayList();
        synchronized (this.mPackages) {
            for (Instrumentation p : this.mInstrumentation.values()) {
                if (targetPackage == null || targetPackage.equals(p.info.targetPackage)) {
                    InstrumentationInfo ii = PackageParser.generateInstrumentationInfo(p, flags);
                    if (ii != null) {
                        finalList.add(ii);
                    }
                }
            }
        }
        return finalList;
    }

    private void scanDirTracedLI(File dir, int parseFlags, int scanFlags, long currentTime) {
        Trace.traceBegin(262144, "scanDir [" + dir.getAbsolutePath() + "]");
        try {
            scanDirLI(dir, parseFlags, scanFlags, currentTime);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    private void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) {
        File[] files = dir.listFiles();
        if (ArrayUtils.isEmpty(files)) {
            Log.d(TAG, "No files in app dir " + dir);
            return;
        }
        if (DEBUG_PACKAGE_SCANNING) {
            Log.d(TAG, "Scanning app dir " + dir + " scanFlags=" + scanFlags + " flags=0x" + Integer.toHexString(parseFlags));
        }
        ParallelPackageParser parallelPackageParser = new ParallelPackageParser(this.mSeparateProcesses, this.mOnlyCore, this.mMetrics, this.mCacheDir, this.mParallelPackageParserCallback);
        int fileCount = 0;
        for (File file : files) {
            boolean isPackage;
            if (PackageParser.isApkFile(file) || file.isDirectory()) {
                isPackage = PackageInstallerService.isStageName(file.getName()) ^ 1;
            } else {
                isPackage = false;
            }
            if (isPackage) {
                if (RegionalizationEnvironment.isSupported() && RegionalizationEnvironment.isExcludedApp(file.getName())) {
                    Log.d(TAG, "Regionalization Excluded:" + file.getName());
                } else if (!((EXP_VERSION && ((mOperator.equals("VODAFONE") || mOperator.equals("TELSTRA")) && file.getName().equals("OperaBrowser"))) || (EXP_VERSION && file.getName().startsWith("EXPOP_") && (mOperator == null || mOperator.equals("oppo") || !file.getName().startsWith("EXPOP_" + mOperator + "_"))))) {
                    parallelPackageParser.submit(file, parseFlags);
                    fileCount++;
                }
            }
        }
        while (fileCount > 0) {
            ParseResult parseResult = parallelPackageParser.take();
            Throwable throwable = parseResult.throwable;
            int errorCode = 1;
            if (throwable == null) {
                if (parseResult.pkg.applicationInfo.isStaticSharedLibrary()) {
                    renameStaticSharedLibraryPackage(parseResult.pkg);
                }
                try {
                    scanPackageLI(parseResult.pkg, parseResult.scanFile, parseFlags, scanFlags, currentTime, null);
                } catch (PackageManagerException e) {
                    errorCode = e.error;
                    Slog.w(TAG, "Failed to scan " + parseResult.scanFile + ": " + e.getMessage());
                }
            } else if (throwable instanceof PackageParserException) {
                PackageParserException e2 = (PackageParserException) throwable;
                errorCode = e2.error;
                Slog.w(TAG, "Failed to parse " + parseResult.scanFile + ": " + e2.getMessage());
            } else {
                throw new IllegalStateException("Unexpected exception occurred while parsing " + parseResult.scanFile, throwable);
            }
            if ((parseFlags & 1) == 0 && errorCode == -2) {
                logCriticalInfo(5, "Deleting invalid package at " + parseResult.scanFile);
                removeCodePathLI(parseResult.scanFile);
            }
            fileCount--;
        }
        parallelPackageParser.close();
    }

    private static File getSettingsProblemFile() {
        return new File(new File(Environment.getDataDirectory(), "system"), "uiderrors.txt");
    }

    static void reportSettingsProblem(int priority, String msg) {
        logCriticalInfo(priority, msg);
    }

    public static void logCriticalInfo(int priority, String msg) {
        Slog.println(priority, TAG, msg);
        EventLogTags.writePmCriticalInfo(msg);
        try {
            File fname = getSettingsProblemFile();
            PrintWriter pw = new FastPrintWriter(new FileOutputStream(fname, true));
            pw.println(new SimpleDateFormat().format(new Date(System.currentTimeMillis())) + ": " + msg);
            pw.close();
            FileUtils.setPermissions(fname.toString(), 508, -1, -1);
        } catch (IOException e) {
        }
    }

    private long getLastModifiedTime(Package pkg, File srcFile) {
        if (!srcFile.isDirectory()) {
            return srcFile.lastModified();
        }
        long maxModifiedTime = new File(pkg.baseCodePath).lastModified();
        if (pkg.splitCodePaths != null) {
            for (int i = pkg.splitCodePaths.length - 1; i >= 0; i--) {
                maxModifiedTime = Math.max(maxModifiedTime, new File(pkg.splitCodePaths[i]).lastModified());
            }
        }
        return maxModifiedTime;
    }

    private void collectCertificatesLI(PackageSetting ps, Package pkg, File srcFile, int policyFlags) throws PackageManagerException {
        long lastModifiedTime = this.mIsPreNMR1Upgrade ? new File(pkg.codePath).lastModified() : getLastModifiedTime(pkg, srcFile);
        if (ps != null && ("com.oppo.camera".equals(pkg.packageName) ^ 1) != 0 && ps.codePath.equals(srcFile) && ps.timeStamp == lastModifiedTime && (isCompatSignatureUpdateNeeded(pkg) ^ 1) != 0 && (isRecoverSignatureUpdateNeeded(pkg) ^ 1) != 0) {
            ArraySet<PublicKey> signingKs;
            long mSigningKeySetId = ps.keySetData.getProperSigningKeySet();
            KeySetManagerService ksms = this.mSettings.mKeySetManagerService;
            synchronized (this.mPackages) {
                signingKs = ksms.getPublicKeysFromKeySetLPr(mSigningKeySetId);
            }
            if (ps.signatures.mSignatures == null || ps.signatures.mSignatures.length == 0 || signingKs == null) {
                Slog.w(TAG, "PackageSetting for " + ps.name + " is missing signatures.  Collecting certs again to recover them.");
            } else {
                pkg.mSignatures = ps.signatures.mSignatures;
                pkg.mSigningKeys = signingKs;
                return;
            }
        } else if (DEBUG_PACKAGE_SCANNING) {
            Slog.i(TAG, srcFile.toString() + " changed; collecting certs");
        }
        try {
            Trace.traceBegin(262144, "collectCertificates");
            PackageParser.collectCertificates(pkg, policyFlags);
            Trace.traceEnd(262144);
        } catch (PackageParserException e) {
            throw PackageManagerException.from(e);
        } catch (Throwable th) {
            Trace.traceEnd(262144);
        }
    }

    private Package scanPackageTracedLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        Trace.traceBegin(262144, "scanPackage [" + scanFile.toString() + "]");
        try {
            Package scanPackageLI = scanPackageLI(scanFile, parseFlags, scanFlags, currentTime, user);
            return scanPackageLI;
        } finally {
            Trace.traceEnd(262144);
        }
    }

    private Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "Parsing: " + scanFile);
        }
        PackageParser pp = new PackageParser();
        pp.setSeparateProcesses(this.mSeparateProcesses);
        pp.setOnlyCoreApps(this.mOnlyCore);
        pp.setDisplayMetrics(this.mMetrics);
        pp.setCallback(this.mPackageParserCallback);
        if ((scanFlags & 128) != 0) {
            parseFlags |= 512;
        }
        Trace.traceBegin(262144, "parsePackage");
        try {
            Package pkg = pp.parsePackage(scanFile, parseFlags);
            Trace.traceEnd(262144);
            if (isBootFromOTA() && scanFile.toString().contains("/data/app/") && pkg.packageName.startsWith("com.facebook.", 0)) {
                ExpPackageManagerHelper.appNeedDelDeps(pkg.packageName, pkg.mVersionName);
            }
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                renameStaticSharedLibraryPackage(pkg);
            }
            return scanPackageLI(pkg, scanFile, parseFlags, scanFlags, currentTime, user);
        } catch (PackageParserException e) {
            throw PackageManagerException.from(e);
        } catch (Throwable th) {
            Trace.traceEnd(262144);
        }
    }

    private Package scanPackageLI(Package pkg, File scanFile, int policyFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        boolean isSystemApp;
        if ((scanFlags & 8192) != 0) {
            scanFlags &= -8193;
        } else if (pkg.childPackages != null && pkg.childPackages.size() > 0) {
            scanFlags |= 8192;
        }
        mCompatibilityHelper.customizePackageIfNeeded(pkg);
        boolean isOppoApp = ColorPackageManagerHelper.isOppoApkList(pkg.packageName);
        if (scanFile.toString().contains("/system/app") || scanFile.toString().contains("/system/priv-app") || scanFile.toString().contains("/vendor/app")) {
            isSystemApp = true;
        } else {
            isSystemApp = scanFile.toString().contains(VENDOR_OVERLAY_DIR);
        }
        Slog.d(TAG, "isOppoApp = " + isOppoApp + " isSystemApp = " + isSystemApp + " isDebugMode = " + SystemProperties.getBoolean("persist.sys.oppo.debug", false));
        if (!isOppoApp && isSystemApp) {
            Slog.d(TAG, "This is not oppo app, so skip it :" + scanFile.toString());
            throw new PackageManagerException(-2, "this is not oppo app");
        } else if (isSystemApp && this.mCustomizeSystemAppBlacklist.contains(pkg.packageName)) {
            Slog.d(TAG, "This app is excluded, so skip it :" + scanFile.toString());
            throw new PackageManagerException(-2, "this app is excluded for customize!");
        } else if (isSystemApp && this.mSystemAppArrayList.contains(pkg.packageName)) {
            Slog.d(TAG, "This is common soft, so skip it :" + scanFile.toString());
            throw new PackageManagerException(-2, "this is not current devices app");
        } else if (isSystemApp && scanFile.getName().startsWith("SystemHelper") && (scanFile.getName().endsWith(this.mDeviceType) ^ 1) != 0) {
            Slog.d(TAG, "This is SystemHelper, so skip it :" + scanFile.toString());
            throw new PackageManagerException(-2, "this is not current devices app");
        } else {
            Package scannedPkg = scanPackageInternalLI(pkg, scanFile, policyFlags, scanFlags, currentTime, user);
            int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                scanPackageInternalLI((Package) pkg.childPackages.get(i), scanFile, policyFlags, scanFlags, currentTime, user);
            }
            if ((scanFlags & 8192) != 0) {
                return scanPackageLI(pkg, scanFile, policyFlags, scanFlags, currentTime, user);
            }
            return scannedPkg;
        }
    }

    private Package scanPackageInternalLI(Package pkg, File scanFile, int policyFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        PackageSetting updatedPkg;
        int i;
        InstallArgs args;
        PackageFreezer packageFreezer;
        Throwable th;
        Throwable th2;
        if (isBootFromOTA() && scanFile.toString().contains("/data/app/") && pkg.packageName.startsWith("com.facebook.", 0)) {
            ExpPackageManagerHelper.appNeedDelDeps(pkg.packageName, pkg.mVersionName);
        }
        PackageSetting ps = null;
        synchronized (this.mPackages) {
            String str;
            String oldName = this.mSettings.getRenamedPackageLPr(pkg.packageName);
            if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName)) {
                ps = this.mSettings.getPackageLPr(oldName);
            }
            if (ps == null) {
                ps = this.mSettings.getPackageLPr(pkg.packageName);
            }
            Settings settings = this.mSettings;
            if (ps != null) {
                str = ps.name;
            } else {
                str = pkg.packageName;
            }
            updatedPkg = settings.getDisabledSystemPkgLPr(str);
            if (DEBUG_INSTALL && updatedPkg != null) {
                Slog.d(TAG, "updatedPkg = " + updatedPkg);
            }
            if ((policyFlags & 1) != 0) {
                PackageSetting disabledPs = this.mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                if (disabledPs != null) {
                    int scannedChildCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
                    int disabledChildCount = disabledPs.childPackageNames != null ? disabledPs.childPackageNames.size() : 0;
                    for (i = 0; i < disabledChildCount; i++) {
                        String disabledChildPackageName = (String) disabledPs.childPackageNames.get(i);
                        boolean disabledPackageAvailable = false;
                        for (int j = 0; j < scannedChildCount; j++) {
                            if (((Package) pkg.childPackages.get(j)).packageName.equals(disabledChildPackageName)) {
                                disabledPackageAvailable = true;
                                break;
                            }
                        }
                        if (!disabledPackageAvailable) {
                            this.mSettings.removeDisabledSystemPackageLPw(disabledChildPackageName);
                        }
                    }
                }
            }
        }
        boolean isUpdatedPkg = updatedPkg != null;
        boolean isUpdatedSystemPkg = isUpdatedPkg ? (policyFlags & 1) != 0 : false;
        boolean isUpdatedPkgBetter = false;
        if (isUpdatedSystemPkg) {
            if (locationIsPrivileged(scanFile)) {
                updatedPkg.pkgPrivateFlags |= 8;
            } else {
                updatedPkg.pkgPrivateFlags &= -9;
            }
            if (!(ps == null || (ps.codePath.equals(scanFile) ^ 1) == 0)) {
                if (DEBUG_INSTALL) {
                    Slog.d(TAG, "Path changing from " + ps.codePath);
                }
                if (pkg.mVersionCode <= ps.versionCode) {
                    if (DEBUG_INSTALL) {
                        Slog.i(TAG, "Package " + ps.name + " at " + scanFile + " ignored: updated version " + ps.versionCode + " better than this " + pkg.mVersionCode);
                    }
                    if (!updatedPkg.codePath.equals(scanFile)) {
                        Slog.w(TAG, "Code path for hidden system pkg " + ps.name + " changing from " + updatedPkg.codePathString + " to " + scanFile);
                        updatedPkg.codePath = scanFile;
                        updatedPkg.codePathString = scanFile.toString();
                        updatedPkg.resourcePath = scanFile;
                        updatedPkg.resourcePathString = scanFile.toString();
                    }
                    updatedPkg.pkg = pkg;
                    updatedPkg.versionCode = pkg.mVersionCode;
                    int childCount = updatedPkg.childPackageNames != null ? updatedPkg.childPackageNames.size() : 0;
                    for (i = 0; i < childCount; i++) {
                        PackageSetting updatedChildPkg = this.mSettings.getDisabledSystemPkgLPr((String) updatedPkg.childPackageNames.get(i));
                        if (updatedChildPkg != null) {
                            updatedChildPkg.pkg = pkg;
                            updatedChildPkg.versionCode = pkg.mVersionCode;
                        }
                    }
                } else {
                    synchronized (this.mPackages) {
                        this.mPackages.remove(ps.name);
                    }
                    logCriticalInfo(5, "Package " + ps.name + " at " + scanFile + " reverting from " + ps.codePathString + ": new version " + pkg.mVersionCode + " better than installed " + ps.versionCode);
                    args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, InstructionSets.getAppDexInstructionSets(ps));
                    synchronized (this.mInstallLock) {
                        args.cleanUpResourcesLI();
                    }
                    synchronized (this.mPackages) {
                        this.mSettings.enableSystemPackageLPw(ps.name);
                    }
                    isUpdatedPkgBetter = true;
                }
            }
        }
        String resourcePath = null;
        String baseResourcePath = null;
        if ((policyFlags & 16) == 0 || (isUpdatedPkgBetter ^ 1) == 0) {
            resourcePath = pkg.codePath;
            baseResourcePath = pkg.baseCodePath;
        } else if (ps == null || ps.resourcePathString == null) {
            Slog.e(TAG, "Resource path not set for package " + pkg.packageName);
        } else {
            resourcePath = ps.resourcePathString;
            baseResourcePath = ps.resourcePathString;
        }
        pkg.setApplicationVolumeUuid(pkg.volumeUuid);
        pkg.setApplicationInfoCodePath(pkg.codePath);
        pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
        pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
        pkg.setApplicationInfoResourcePath(resourcePath);
        pkg.setApplicationInfoBaseResourcePath(baseResourcePath);
        pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
        if (!isUpdatedSystemPkg || (isUpdatedPkgBetter ^ 1) == 0) {
            if (isUpdatedPkg) {
                policyFlags |= 1;
                if ((updatedPkg.pkgPrivateFlags & 8) != 0) {
                    policyFlags |= 128;
                }
            }
            collectCertificatesLI(ps, pkg, scanFile, policyFlags);
            boolean shouldHideSystemApp = false;
            if (!(isUpdatedPkg || ps == null || (policyFlags & 64) == 0 || (isSystemApp(ps) ^ 1) == 0)) {
                if (compareSignatures(ps.signatures.mSignatures, pkg.mSignatures) != 0) {
                    logCriticalInfo(5, "Package " + ps.name + " appeared on system, but" + " signatures don't match existing userdata copy; removing");
                    Throwable th3 = null;
                    packageFreezer = null;
                    try {
                        packageFreezer = freezePackage(pkg.packageName, "scanPackageInternalLI");
                        deletePackageLIF(pkg.packageName, null, true, null, 0, null, false, null);
                        if (packageFreezer != null) {
                            try {
                                packageFreezer.close();
                            } catch (Throwable th4) {
                                th3 = th4;
                            }
                        }
                        if (th3 != null) {
                            throw th3;
                        }
                        ps = null;
                    } catch (Throwable th22) {
                        Throwable th5 = th22;
                        th22 = th;
                        th = th5;
                    }
                } else if (pkg.mVersionCode <= ps.versionCode) {
                    shouldHideSystemApp = true;
                    logCriticalInfo(4, "Package " + ps.name + " appeared at " + scanFile + " but new version " + pkg.mVersionCode + " better than installed " + ps.versionCode + "; hiding system");
                } else {
                    logCriticalInfo(5, "Package " + ps.name + " at " + scanFile + " reverting from " + ps.codePathString + ": new version " + pkg.mVersionCode + " better than installed " + ps.versionCode);
                    args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, InstructionSets.getAppDexInstructionSets(ps));
                    synchronized (this.mInstallLock) {
                        args.cleanUpResourcesLI();
                    }
                }
            }
            if (!((policyFlags & 64) != 0 || ps == null || (ps.codePath.equals(ps.resourcePath) ^ 1) == 0)) {
                policyFlags |= 16;
            }
            int userId = user == null ? 0 : user.getIdentifier();
            if (ps != null && ps.getInstantApp(userId)) {
                scanFlags |= 131072;
            }
            if (ps != null && ps.getVirtulalPreload(userId)) {
                scanFlags |= 524288;
            }
            Package scannedPkg = scanPackageLI(pkg, policyFlags, scanFlags | 8, currentTime, user);
            if (shouldHideSystemApp) {
                synchronized (this.mPackages) {
                    this.mSettings.disableSystemPackageLPw(pkg.packageName, true);
                }
            }
            return scannedPkg;
        }
        if ((65536 & scanFlags) != 0) {
            derivePackageAbi(pkg, scanFile, deriveAbiOverride(pkg.cpuAbiOverride, updatedPkg), false, this.mAppLib32InstallDir);
        } else {
            pkg.applicationInfo.primaryCpuAbi = updatedPkg.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = updatedPkg.secondaryCpuAbiString;
        }
        throw new PackageManagerException(5, "Package " + ps.name + " at " + scanFile + " ignored: updated version " + ps.versionCode + " better than this " + pkg.mVersionCode);
        if (packageFreezer != null) {
            try {
                packageFreezer.close();
            } catch (Throwable th6) {
                if (th22 == null) {
                    th22 = th6;
                } else if (th22 != th6) {
                    th22.addSuppressed(th6);
                }
            }
        }
        if (th22 != null) {
            throw th22;
        }
        throw th;
    }

    private void renameStaticSharedLibraryPackage(Package pkg) {
        pkg.setPackageName(pkg.packageName + "_" + pkg.staticSharedLibVersion);
    }

    private static String fixProcessName(String defProcessName, String processName) {
        if (processName == null) {
            return defProcessName;
        }
        return processName;
    }

    private void verifySignaturesLP(PackageSetting pkgSetting, Package pkg) throws PackageManagerException {
        boolean match;
        if (pkgSetting.signatures.mSignatures != null) {
            match = compareSignatures(pkgSetting.signatures.mSignatures, pkg.mSignatures) == 0;
            if (!match) {
                match = compareSignaturesCompat(pkgSetting.signatures, pkg) == 0;
            }
            if (!match) {
                match = compareSignaturesRecover(pkgSetting.signatures, pkg) == 0;
            }
            if (!match) {
                throw new PackageManagerException(-7, "Package " + pkg.packageName + " signatures do not match the " + "previously installed version; ignoring!");
            }
        }
        if (pkgSetting.sharedUser != null && pkgSetting.sharedUser.signatures.mSignatures != null) {
            match = compareSignatures(pkgSetting.sharedUser.signatures.mSignatures, pkg.mSignatures) == 0;
            if (!match) {
                match = compareSignaturesCompat(pkgSetting.sharedUser.signatures, pkg) == 0;
            }
            if (!match) {
                match = compareSignaturesRecover(pkgSetting.sharedUser.signatures, pkg) == 0;
            }
            if (!match) {
                throw new PackageManagerException(-8, "Package " + pkg.packageName + " has no signatures that match those in shared user " + pkgSetting.sharedUser.name + "; ignoring!");
            }
        }
    }

    private static final void enforceSystemOrRoot(String message) {
        int uid = Binder.getCallingUid();
        if (uid != 1000 && uid != 0) {
            throw new SecurityException(message);
        }
    }

    public void performFstrimIfNeeded() {
        enforceSystemOrRoot("Only the system can request fstrim");
        try {
            IStorageManager sm = PackageHelper.getStorageManager();
            if (sm != null) {
                boolean doTrim = false;
                long interval = Global.getLong(this.mContext.getContentResolver(), "fstrim_mandatory_interval", DEFAULT_MANDATORY_FSTRIM_INTERVAL);
                if (interval > 0) {
                    long timeSinceLast = System.currentTimeMillis() - sm.lastMaintenance();
                    if (timeSinceLast > interval) {
                        doTrim = true;
                        Slog.w(TAG, "No disk maintenance in " + timeSinceLast + "; running immediately");
                    }
                }
                if (doTrim) {
                    synchronized (this.mPackages) {
                        boolean dexOptDialogShown = this.mDexOptDialogShown;
                    }
                    if (!isFirstBoot() && dexOptDialogShown) {
                        try {
                            ActivityManager.getService().showBootMessage(this.mContext.getResources().getString(17039486), true);
                        } catch (RemoteException e) {
                        }
                    }
                    sm.runMaintenance();
                    return;
                }
                return;
            }
            Slog.e(TAG, "storageManager service unavailable!");
        } catch (RemoteException e2) {
        }
    }

    public void updatePackagesIfNeeded() {
        enforceSystemOrRoot("Only the system can request package update");
        boolean causeUpgrade = isUpgrade();
        int causeFirstBoot = !isFirstBoot() ? this.mIsPreNUpgrade : 1;
        boolean causePrunedCache = VMRuntime.didPruneDalvikCache();
        if (causeUpgrade || (causeFirstBoot ^ 1) == 0 || (causePrunedCache ^ 1) == 0) {
            List<Package> pkgs;
            int i;
            if (isBootFromOTA()) {
                List<Package> persistkgs;
                synchronized (this.mPackages) {
                    persistkgs = PackageManagerServiceUtils.getPersistPackagesForDexopt(this.mPackages.values(), this);
                }
                performDexOptUpgrade(persistkgs, this.mIsPreNUpgrade, PackageManagerServiceCompilerMapping.getCompilerFilterForReason(0), false);
            }
            synchronized (this.mPackages) {
                pkgs = PackageManagerServiceUtils.getPackagesForDexopt(this.mPackages.values(), this);
            }
            long startTime = System.nanoTime();
            boolean z = this.mIsPreNUpgrade;
            if (causeFirstBoot != 0) {
                i = 0;
            } else {
                i = 1;
            }
            int[] stats = performDexOptUpgrade(pkgs, z, PackageManagerServiceCompilerMapping.getCompilerFilterForReason(i), false);
            int elapsedTimeSeconds = (int) TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - startTime);
            MetricsLogger.histogram(this.mContext, "opt_dialog_num_dexopted", stats[0]);
            MetricsLogger.histogram(this.mContext, "opt_dialog_num_skipped", stats[1]);
            MetricsLogger.histogram(this.mContext, "opt_dialog_num_failed", stats[2]);
            MetricsLogger.histogram(this.mContext, "opt_dialog_num_total", getOptimizablePackages().size());
            MetricsLogger.histogram(this.mContext, "opt_dialog_time_s", elapsedTimeSeconds);
        }
    }

    private static String getPrebuildProfilePath(Package pkg) {
        return pkg.baseCodePath + ".prof";
    }

    private int[] performDexOptUpgrade(List<Package> pkgs, boolean showDialog, String compilerFilter, boolean bootComplete) {
        int numberOfPackagesVisited = 0;
        int numberOfPackagesOptimized = 0;
        int numberOfPackagesSkipped = 0;
        int numberOfPackagesFailed = 0;
        int numberOfPackagesToDexopt = pkgs.size();
        for (Package pkg : pkgs) {
            numberOfPackagesVisited++;
            boolean useProfileForDexopt = false;
            if ((isFirstBoot() || isUpgrade()) && isSystemApp(pkg)) {
                File file = new File(getPrebuildProfilePath(pkg));
                if (file.exists()) {
                    try {
                        if (!this.mInstaller.copySystemProfile(file.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName)) {
                            Log.e(TAG, "Installer failed to copy system profile!");
                        }
                    } catch (Exception e) {
                        Log.e(TAG, "Failed to copy profile " + file.getAbsolutePath() + " ", e);
                    }
                } else {
                    PackageSetting disabledPs = this.mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                    if (disabledPs != null && disabledPs.pkg.isStub) {
                        File profileFile = new File(getPrebuildProfilePath(disabledPs.pkg).replace(STUB_SUFFIX, ""));
                        if (profileFile.exists()) {
                            try {
                                if (this.mInstaller.copySystemProfile(profileFile.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName)) {
                                    useProfileForDexopt = true;
                                } else {
                                    Log.e(TAG, "Failed to copy system profile for stub package!");
                                }
                            } catch (Exception e2) {
                                Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + " ", e2);
                            }
                        }
                    }
                }
            }
            if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                if (DEBUG_DEXOPT) {
                    Log.i(TAG, "Updating app " + numberOfPackagesVisited + " of " + numberOfPackagesToDexopt + ": " + pkg.packageName);
                }
                if (showDialog) {
                    try {
                        ActivityManager.getService().showBootMessage(this.mContext.getResources().getString(17039484, new Object[]{Integer.valueOf(numberOfPackagesVisited), Integer.valueOf(numberOfPackagesToDexopt)}), true);
                    } catch (RemoteException e3) {
                    }
                    synchronized (this.mPackages) {
                        this.mDexOptDialogShown = true;
                    }
                }
                String pkgCompilerFilter = compilerFilter;
                if (useProfileForDexopt) {
                    pkgCompilerFilter = PackageManagerServiceCompilerMapping.getCompilerFilterForReason(3);
                }
                int primaryDexOptStaus = performDexOptTraced(new DexoptOptions(pkg.packageName, pkgCompilerFilter, bootComplete ? 4 : 0));
                switch (primaryDexOptStaus) {
                    case -1:
                        numberOfPackagesFailed++;
                        break;
                    case 0:
                        numberOfPackagesSkipped++;
                        break;
                    case 1:
                        numberOfPackagesOptimized++;
                        break;
                    default:
                        Log.e(TAG, "Unexpected dexopt return code " + primaryDexOptStaus);
                        break;
                }
            }
            if (DEBUG_DEXOPT) {
                Log.i(TAG, "Skipping update of of non-optimizable app " + pkg.packageName);
            }
            numberOfPackagesSkipped++;
        }
        return new int[]{numberOfPackagesOptimized, numberOfPackagesSkipped, numberOfPackagesFailed};
    }

    public void notifyPackageUse(String packageName, int reason) {
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            if (getInstantAppPackageName(callingUid) != null) {
                if (!isCallerSameApp(packageName, callingUid)) {
                    return;
                }
            } else if (isInstantApp(packageName, callingUserId)) {
                return;
            }
            notifyPackageUseLocked(packageName, reason);
        }
    }

    private void notifyPackageUseLocked(String packageName, int reason) {
        Package p = (Package) this.mPackages.get(packageName);
        if (p != null) {
            p.mLastPackageUsageTimeInMills[reason] = System.currentTimeMillis();
        }
    }

    public void notifyDexLoad(String loadingPackageName, List<String> classLoaderNames, List<String> classPaths, String loaderIsa) {
        int userId = UserHandle.getCallingUserId();
        ApplicationInfo ai = getApplicationInfo(loadingPackageName, 0, userId);
        if (ai == null) {
            Slog.w(TAG, "Loading a package that does not exist for the calling user. package=" + loadingPackageName + ", user=" + userId);
        } else {
            this.mDexManager.notifyDexLoad(ai, classLoaderNames, classPaths, loaderIsa, userId);
        }
    }

    public void registerDexModule(String packageName, String dexModulePath, boolean isSharedModule, IDexModuleRegisterCallback callback) {
        RegisterDexModuleResult result;
        int userId = UserHandle.getCallingUserId();
        ApplicationInfo ai = getApplicationInfo(packageName, 0, userId);
        if (ai == null) {
            Slog.w(TAG, "Registering a dex module for a package that does not exist for the calling user. package=" + packageName + ", user=" + userId);
            result = new RegisterDexModuleResult(false, "Package not installed");
        } else {
            result = this.mDexManager.registerDexModule(ai, dexModulePath, isSharedModule, userId);
        }
        if (callback != null) {
            this.mHandler.post(new -$Lambda$kozCdtU4hxwnpbopzC6ZLMsBV5E(callback, dexModulePath, result));
        }
    }

    static /* synthetic */ void lambda$-com_android_server_pm_PackageManagerService_550493(IDexModuleRegisterCallback callback, String dexModulePath, RegisterDexModuleResult result) {
        try {
            callback.onDexModuleRegistered(dexModulePath, result.success, result.message);
        } catch (RemoteException e) {
            Slog.w(TAG, "Failed to callback after module registration " + dexModulePath, e);
        }
    }

    public boolean performDexOptMode(String packageName, boolean checkProfiles, String targetCompilerFilter, boolean force, boolean bootComplete, String splitName) {
        int i;
        int i2;
        int i3 = 0;
        if (checkProfiles) {
            i = 1;
        } else {
            i = 0;
        }
        if (force) {
            i2 = 2;
        } else {
            i2 = 0;
        }
        i2 |= i;
        if (bootComplete) {
            i3 = 4;
        }
        return performDexOpt(new DexoptOptions(packageName, targetCompilerFilter, splitName, i2 | i3));
    }

    public boolean performDexOptSecondary(String packageName, String compilerFilter, boolean force) {
        return performDexOpt(new DexoptOptions(packageName, compilerFilter, (force ? 2 : 0) | 13));
    }

    boolean performDexOpt(DexoptOptions options) {
        boolean z = false;
        if (getInstantAppPackageName(Binder.getCallingUid()) != null || isInstantApp(options.getPackageName(), UserHandle.getCallingUserId())) {
            return false;
        }
        if (options.isDexoptOnlySecondaryDex()) {
            return this.mDexManager.dexoptSecondaryDex(options);
        }
        if (performDexOptWithStatus(options) != -1) {
            z = true;
        }
        return z;
    }

    int performDexOptWithStatus(DexoptOptions options) {
        return performDexOptTraced(options);
    }

    private int performDexOptTraced(DexoptOptions options) {
        Trace.traceBegin(262144, "dexopt");
        try {
            int performDexOptInternal = performDexOptInternal(options);
            return performDexOptInternal;
        } finally {
            Trace.traceEnd(262144);
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private int performDexOptInternal(DexoptOptions options) {
        int i = this.mPackages;
        synchronized (i) {
            Package p = (Package) this.mPackages.get(options.getPackageName());
            if (p == null) {
                return -1;
            }
            this.mPackageUsage.maybeWriteAsync(this.mPackages);
            this.mCompilerStats.maybeWriteAsync();
        }
        return i;
    }

    public ArraySet<String> getOptimizablePackages() {
        ArraySet<String> pkgs = new ArraySet();
        synchronized (this.mPackages) {
            for (Package p : this.mPackages.values()) {
                if (PackageDexOptimizer.canOptimizePackage(p)) {
                    pkgs.add(p.packageName);
                }
            }
        }
        return pkgs;
    }

    private int performDexOptInternalWithDependenciesLI(Package p, DexoptOptions options) {
        PackageDexOptimizer pdo;
        if (options.isForce()) {
            pdo = new ForcedUpdatePackageDexOptimizer(this.mPackageDexOptimizer);
        } else {
            pdo = this.mPackageDexOptimizer;
        }
        Collection<Package> deps = findSharedNonSystemLibraries(p);
        String[] instructionSets = InstructionSets.getAppDexInstructionSets(p.applicationInfo);
        if (!deps.isEmpty()) {
            DexoptOptions libraryOptions = new DexoptOptions(options.getPackageName(), options.getCompilerFilter(), options.getSplitName(), options.getFlags() | 64);
            for (Package depPackage : deps) {
                pdo.performDexOpt(depPackage, null, instructionSets, getOrCreateCompilerPackageStats(depPackage), this.mDexManager.getPackageUseInfoOrDefault(depPackage.packageName), libraryOptions);
            }
        }
        return pdo.performDexOpt(p, p.usesLibraryFiles, instructionSets, getOrCreateCompilerPackageStats(p), this.mDexManager.getPackageUseInfoOrDefault(p.packageName), options);
    }

    public void reconcileSecondaryDexFiles(String packageName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && !isInstantApp(packageName, UserHandle.getCallingUserId())) {
            this.mDexManager.reconcileSecondaryDexFiles(packageName);
        }
    }

    DexManager getDexManager() {
        return this.mDexManager;
    }

    public boolean runBackgroundDexoptJob() {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return false;
        }
        return BackgroundDexOptService.runIdleOptimizationsNow(this, this.mContext);
    }

    List<Package> findSharedNonSystemLibraries(Package p) {
        if (p.usesLibraries == null && p.usesOptionalLibraries == null && p.usesStaticLibraries == null) {
            return Collections.emptyList();
        }
        ArrayList<Package> retValue = new ArrayList();
        findSharedNonSystemLibrariesRecursive(p, retValue, new HashSet());
        retValue.remove(p);
        return retValue;
    }

    private void findSharedNonSystemLibrariesRecursive(Package p, ArrayList<Package> collected, Set<String> collectedNames) {
        if (!collectedNames.contains(p.packageName)) {
            collectedNames.add(p.packageName);
            collected.add(p);
            if (p.usesLibraries != null) {
                findSharedNonSystemLibrariesRecursive(p.usesLibraries, null, collected, collectedNames);
            }
            if (p.usesOptionalLibraries != null) {
                findSharedNonSystemLibrariesRecursive(p.usesOptionalLibraries, null, collected, collectedNames);
            }
            if (p.usesStaticLibraries != null) {
                findSharedNonSystemLibrariesRecursive(p.usesStaticLibraries, p.usesStaticLibrariesVersions, collected, collectedNames);
            }
        }
    }

    private void findSharedNonSystemLibrariesRecursive(ArrayList<String> libs, int[] versions, ArrayList<Package> collected, Set<String> collectedNames) {
        int libNameCount = libs.size();
        int i = 0;
        while (i < libNameCount) {
            String libName = (String) libs.get(i);
            int version = (versions == null || versions.length != libNameCount) ? -1 : versions[i];
            Package libPkg = findSharedNonSystemLibrary(libName, version);
            if (libPkg != null) {
                findSharedNonSystemLibrariesRecursive(libPkg, collected, collectedNames);
            }
            i++;
        }
    }

    private Package findSharedNonSystemLibrary(String name, int version) {
        synchronized (this.mPackages) {
            SharedLibraryEntry libEntry = getSharedLibraryEntryLPr(name, version);
            if (libEntry != null) {
                Package packageR = (Package) this.mPackages.get(libEntry.apk);
                return packageR;
            }
            return null;
        }
    }

    private SharedLibraryEntry getSharedLibraryEntryLPr(String name, int version) {
        SparseArray<SharedLibraryEntry> versionedLib = (SparseArray) this.mSharedLibraries.get(name);
        if (versionedLib == null) {
            return null;
        }
        return (SharedLibraryEntry) versionedLib.get(version);
    }

    private SharedLibraryEntry getLatestSharedLibraVersionLPr(Package pkg) {
        SparseArray<SharedLibraryEntry> versionedLib = (SparseArray) this.mSharedLibraries.get(pkg.staticSharedLibName);
        if (versionedLib == null) {
            return null;
        }
        int previousLibVersion = -1;
        int versionCount = versionedLib.size();
        for (int i = 0; i < versionCount; i++) {
            int libVersion = versionedLib.keyAt(i);
            if (libVersion < pkg.staticSharedLibVersion) {
                previousLibVersion = Math.max(previousLibVersion, libVersion);
            }
        }
        if (previousLibVersion >= 0) {
            return (SharedLibraryEntry) versionedLib.get(previousLibVersion);
        }
        return null;
    }

    public void shutdown() {
        this.mPackageUsage.writeNow(this.mPackages);
        this.mCompilerStats.writeNow();
        this.mDexManager.writePackageDexUsageNow();
    }

    public void dumpProfiles(String packageName) {
        Package pkg;
        synchronized (this.mPackages) {
            pkg = (Package) this.mPackages.get(packageName);
            if (pkg == null) {
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        int callingUid = Binder.getCallingUid();
        if (callingUid == 2000 || callingUid == 0 || callingUid == pkg.applicationInfo.uid) {
            synchronized (this.mInstallLock) {
                Trace.traceBegin(262144, "dump profiles");
                int sharedGid = UserHandle.getSharedAppGid(pkg.applicationInfo.uid);
                try {
                    this.mInstaller.dumpProfiles(sharedGid, packageName, TextUtils.join(";", pkg.getAllCodePathsExcludingResourceOnly()));
                } catch (InstallerException e) {
                    Slog.w(TAG, "Failed to dump profiles", e);
                }
                Trace.traceEnd(262144);
            }
            return;
        }
        throw new SecurityException("dumpProfiles");
    }

    public void forceDexOpt(String packageName) {
        Package pkg;
        enforceSystemOrRoot("forceDexOpt");
        synchronized (this.mPackages) {
            pkg = (Package) this.mPackages.get(packageName);
            if (pkg == null) {
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        synchronized (this.mInstallLock) {
            Trace.traceBegin(262144, "dexopt");
            int res = performDexOptInternalWithDependenciesLI(pkg, new DexoptOptions(packageName, PackageManagerServiceCompilerMapping.getDefaultCompilerFilter(), 6));
            Trace.traceEnd(262144);
            if (res != 1) {
                throw new IllegalStateException("Failed to dexopt: " + res);
            }
        }
    }

    private boolean verifyPackageUpdateLPr(PackageSetting oldPkg, Package newPkg) {
        if ((oldPkg.pkgFlags & 1) == 0) {
            Slog.w(TAG, "Unable to update from " + oldPkg.name + " to " + newPkg.packageName + ": old package not in system partition");
            return false;
        } else if (this.mPackages.get(oldPkg.name) == null) {
            return true;
        } else {
            Slog.w(TAG, "Unable to update from " + oldPkg.name + " to " + newPkg.packageName + ": old package still exists");
            return false;
        }
    }

    void removeCodePathLI(File codePath) {
        if (codePath.isDirectory()) {
            try {
                this.mInstaller.rmPackageDir(codePath.getAbsolutePath());
                return;
            } catch (InstallerException e) {
                Slog.w(TAG, "Failed to remove code path", e);
                return;
            }
        }
        codePath.delete();
    }

    private int[] resolveUserIds(int userId) {
        if (userId == -1) {
            return sUserManager.getUserIds();
        }
        return new int[]{userId};
    }

    private void clearAppDataLIF(Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        clearAppDataLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            clearAppDataLeafLIF((Package) pkg.childPackages.get(i), userId, flags);
        }
    }

    private void clearAppDataLeafLIF(Package pkg, int userId, int flags) {
        PackageSetting ps;
        synchronized (this.mPackages) {
            ps = (PackageSetting) this.mSettings.mPackages.get(pkg.packageName);
        }
        for (int realUserId : resolveUserIds(userId)) {
            try {
                this.mInstaller.clearAppData(pkg.volumeUuid, pkg.packageName, realUserId, flags, ps != null ? ps.getCeDataInode(realUserId) : 0);
            } catch (InstallerException e) {
                Slog.w(TAG, String.valueOf(e));
            }
        }
    }

    private void destroyAppDataLIF(Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        destroyAppDataLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            destroyAppDataLeafLIF((Package) pkg.childPackages.get(i), userId, flags);
        }
    }

    private void destroyAppDataLeafLIF(Package pkg, int userId, int flags) {
        PackageSetting ps;
        synchronized (this.mPackages) {
            ps = (PackageSetting) this.mSettings.mPackages.get(pkg.packageName);
        }
        for (int realUserId : resolveUserIds(userId)) {
            try {
                this.mInstaller.destroyAppData(pkg.volumeUuid, pkg.packageName, realUserId, flags, ps != null ? ps.getCeDataInode(realUserId) : 0);
            } catch (InstallerException e) {
                Slog.w(TAG, String.valueOf(e));
            }
            this.mDexManager.notifyPackageDataDestroyed(pkg.packageName, userId);
        }
    }

    private void destroyAppProfilesLIF(Package pkg, int userId) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        destroyAppProfilesLeafLIF(pkg);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            destroyAppProfilesLeafLIF((Package) pkg.childPackages.get(i));
        }
    }

    private void destroyAppProfilesLeafLIF(Package pkg) {
        try {
            this.mInstaller.destroyAppProfiles(pkg.packageName);
        } catch (InstallerException e) {
            Slog.w(TAG, String.valueOf(e));
        }
    }

    private void clearAppProfilesLIF(Package pkg, int userId) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        clearAppProfilesLeafLIF(pkg);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            clearAppProfilesLeafLIF((Package) pkg.childPackages.get(i));
        }
    }

    private void clearAppProfilesLeafLIF(Package pkg) {
        try {
            this.mInstaller.clearAppProfiles(pkg.packageName);
        } catch (InstallerException e) {
            Slog.w(TAG, String.valueOf(e));
        }
    }

    private void setInstallAndUpdateTime(Package pkg, long firstInstallTime, long lastUpdateTime) {
        PackageSetting ps = pkg.mExtras;
        if (ps != null) {
            ps.firstInstallTime = firstInstallTime;
            ps.lastUpdateTime = lastUpdateTime;
        }
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            ps = ((Package) pkg.childPackages.get(i)).mExtras;
            if (ps != null) {
                ps.firstInstallTime = firstInstallTime;
                ps.lastUpdateTime = lastUpdateTime;
            }
        }
    }

    private void addSharedLibraryLPr(ArraySet<String> usesLibraryFiles, SharedLibraryEntry file, Package changingLib) {
        if (file.path != null) {
            usesLibraryFiles.add(file.path);
            return;
        }
        Package p = (Package) this.mPackages.get(file.apk);
        if (changingLib != null && changingLib.packageName.equals(file.apk) && (p == null || p.packageName.equals(changingLib.packageName))) {
            p = changingLib;
        }
        if (p != null) {
            usesLibraryFiles.addAll(p.getAllCodePaths());
            if (p.usesLibraryFiles != null) {
                Collections.addAll(usesLibraryFiles, p.usesLibraryFiles);
            }
        }
    }

    private void updateSharedLibrariesLPr(Package pkg, Package changingLib) throws PackageManagerException {
        if (pkg != null) {
            ArraySet arraySet = null;
            if (pkg.usesLibraries != null) {
                arraySet = addSharedLibrariesLPw(pkg.usesLibraries, null, null, pkg.packageName, changingLib, true, pkg.applicationInfo.targetSdkVersion, null);
            }
            if (pkg.usesStaticLibraries != null) {
                arraySet = addSharedLibrariesLPw(pkg.usesStaticLibraries, pkg.usesStaticLibrariesVersions, pkg.usesStaticLibrariesCertDigests, pkg.packageName, changingLib, true, pkg.applicationInfo.targetSdkVersion, arraySet);
            }
            if (pkg.usesOptionalLibraries != null) {
                arraySet = addSharedLibrariesLPw(pkg.usesOptionalLibraries, null, null, pkg.packageName, changingLib, false, pkg.applicationInfo.targetSdkVersion, arraySet);
            }
            if (ArrayUtils.isEmpty(arraySet)) {
                pkg.usesLibraryFiles = null;
            } else {
                pkg.usesLibraryFiles = (String[]) arraySet.toArray(new String[arraySet.size()]);
            }
        }
    }

    private ArraySet<String> addSharedLibrariesLPw(List<String> requestedLibraries, int[] requiredVersions, String[][] requiredCertDigests, String packageName, Package changingLib, boolean required, int targetSdk, ArraySet<String> outUsedLibraries) throws PackageManagerException {
        int libCount = requestedLibraries.size();
        for (int i = 0; i < libCount; i++) {
            int libVersion;
            String libName = (String) requestedLibraries.get(i);
            if (requiredVersions != null) {
                libVersion = requiredVersions[i];
            } else {
                libVersion = -1;
            }
            SharedLibraryEntry libEntry = getSharedLibraryEntryLPr(libName, libVersion);
            if (libEntry != null) {
                if (!(requiredVersions == null || requiredCertDigests == null)) {
                    if (libEntry.info.getVersion() != requiredVersions[i]) {
                        throw new PackageManagerException(-9, "Package " + packageName + " requires unavailable static shared" + " library " + libName + " version " + libEntry.info.getVersion() + "; failing!");
                    }
                    Package libPkg = (Package) this.mPackages.get(libEntry.apk);
                    if (libPkg == null) {
                        throw new PackageManagerException(-9, "Package " + packageName + " requires unavailable static shared" + " library; failing!");
                    }
                    String[] libCertDigests;
                    String[] expectedCertDigests = requiredCertDigests[i];
                    if (targetSdk > 26) {
                        libCertDigests = PackageUtils.computeSignaturesSha256Digests(libPkg.mSignatures);
                    } else {
                        libCertDigests = PackageUtils.computeSignaturesSha256Digests(new Signature[]{libPkg.mSignatures[0]});
                    }
                    if (expectedCertDigests.length != libCertDigests.length) {
                        throw new PackageManagerException(-9, "Package " + packageName + " requires differently signed" + " static sDexLoadReporter.java:45.19hared library; failing!");
                    }
                    Arrays.sort(libCertDigests);
                    Arrays.sort(expectedCertDigests);
                    int certCount = libCertDigests.length;
                    int j = 0;
                    while (j < certCount) {
                        if (libCertDigests[j].equalsIgnoreCase(expectedCertDigests[j])) {
                            j++;
                        } else {
                            throw new PackageManagerException(-9, "Package " + packageName + " requires differently signed" + " static shared library; failing!");
                        }
                    }
                }
                if (outUsedLibraries == null) {
                    outUsedLibraries = new ArraySet();
                }
                addSharedLibraryLPr(outUsedLibraries, libEntry, changingLib);
            } else if (required) {
                throw new PackageManagerException(-9, "Package " + packageName + " requires unavailable shared library " + libName + "; failing!");
            }
        }
        return outUsedLibraries;
    }

    private static boolean hasString(List<String> list, List<String> which) {
        if (list == null) {
            return false;
        }
        for (int i = list.size() - 1; i >= 0; i--) {
            for (int j = which.size() - 1; j >= 0; j--) {
                if (((String) which.get(j)).equals(list.get(i))) {
                    return true;
                }
            }
        }
        return false;
    }

    private ArrayList<Package> updateAllSharedLibrariesLPw(Package changingPkg) {
        ArrayList<Package> res = null;
        for (Package pkg : this.mPackages.values()) {
            if (changingPkg != null && (hasString(pkg.usesLibraries, changingPkg.libraryNames) ^ 1) != 0 && (hasString(pkg.usesOptionalLibraries, changingPkg.libraryNames) ^ 1) != 0 && (ArrayUtils.contains(pkg.usesStaticLibraries, changingPkg.staticSharedLibName) ^ 1) != 0) {
                return null;
            }
            if (res == null) {
                res = new ArrayList();
            }
            res.add(pkg);
            try {
                updateSharedLibrariesLPr(pkg, changingPkg);
            } catch (PackageManagerException e) {
                if (!pkg.isSystemApp() || pkg.isUpdatedSystemApp()) {
                    deletePackageLIF(pkg.packageName, null, true, sUserManager.getUserIds(), pkg.isUpdatedSystemApp() ? 1 : 0, null, true, null);
                }
                Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e.getMessage());
            }
        }
        return res;
    }

    private static String deriveAbiOverride(String abiOverride, PackageSetting settings) {
        if (INSTALL_PACKAGE_SUFFIX.equals(abiOverride)) {
            return null;
        }
        if (abiOverride != null) {
            return abiOverride;
        }
        if (settings != null) {
            return settings.cpuAbiOverrideString;
        }
        return null;
    }

    private Package scanPackageTracedLI(Package pkg, int policyFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        Trace.traceBegin(262144, "scanPackage");
        if ((scanFlags & 8192) != 0) {
            scanFlags &= -8193;
        } else if (pkg.childPackages != null && pkg.childPackages.size() > 0) {
            scanFlags |= 8192;
        }
        try {
            Package scannedPkg = scanPackageLI(pkg, policyFlags, scanFlags, currentTime, user);
            int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                scanPackageLI((Package) pkg.childPackages.get(i), policyFlags, scanFlags, currentTime, user);
            }
            if ((scanFlags & 8192) != 0) {
                return scanPackageTracedLI(pkg, policyFlags, scanFlags, currentTime, user);
            }
            return scannedPkg;
        } finally {
            Trace.traceEnd(262144);
        }
    }

    private Package scanPackageLI(Package pkg, int policyFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        boolean success = false;
        try {
            Package res = scanPackageDirtyLI(pkg, policyFlags, scanFlags, currentTime, user);
            success = true;
            return res;
        } finally {
            if (!(success || (scanFlags & 256) == 0)) {
                destroyAppDataLIF(pkg, -1, 3);
                destroyAppProfilesLIF(pkg, -1);
            }
        }
    }

    private static boolean apkHasCode(String fileName) {
        Throwable th;
        boolean z = false;
        StrictJarFile jarFile = null;
        try {
            StrictJarFile jarFile2 = new StrictJarFile(fileName, false, false);
            try {
                if (jarFile2.findEntry("classes.dex") != null) {
                    z = true;
                }
                if (jarFile2 != null) {
                    try {
                        jarFile2.close();
                    } catch (IOException e) {
                    }
                }
                return z;
            } catch (IOException e2) {
                jarFile = jarFile2;
            } catch (Throwable th2) {
                th = th2;
                jarFile = jarFile2;
                if (jarFile != null) {
                    try {
                        jarFile.close();
                    } catch (IOException e3) {
                    }
                }
                throw th;
            }
        } catch (IOException e4) {
            if (jarFile != null) {
                try {
                    jarFile.close();
                } catch (IOException e5) {
                }
            }
            return false;
        } catch (Throwable th3) {
            th = th3;
            if (jarFile != null) {
                try {
                    jarFile.close();
                } catch (IOException e32) {
                }
            }
            throw th;
        }
    }

    private static void assertCodePolicy(Package pkg) throws PackageManagerException {
        if (((pkg.applicationInfo.flags & 4) != 0) && (apkHasCode(pkg.baseCodePath) ^ 1) != 0) {
            throw new PackageManagerException(-2, "Package " + pkg.baseCodePath + " code is missing");
        } else if (!ArrayUtils.isEmpty(pkg.splitCodePaths)) {
            int i = 0;
            while (i < pkg.splitCodePaths.length) {
                if (!((pkg.splitFlags[i] & 4) != 0) || (apkHasCode(pkg.splitCodePaths[i]) ^ 1) == 0) {
                    i++;
                } else {
                    throw new PackageManagerException(-2, "Package " + pkg.splitCodePaths[i] + " code is missing");
                }
            }
        }
    }

    private android.content.pm.PackageParser.Package scanPackageDirtyLI(android.content.pm.PackageParser.Package r61, int r62, int r63, long r64, android.os.UserHandle r66) throws com.android.server.pm.PackageManagerException {
        /* JADX: method processing error */
/*
Error: jadx.core.utils.exceptions.JadxRuntimeException: Unknown predecessor block by arg (r47_2 'oldPkgSetting' com.android.server.pm.PackageSetting) in PHI: PHI: (r47_1 'oldPkgSetting' com.android.server.pm.PackageSetting) = (r47_0 'oldPkgSetting' com.android.server.pm.PackageSetting), (r47_2 'oldPkgSetting' com.android.server.pm.PackageSetting) binds: {(r47_0 'oldPkgSetting' com.android.server.pm.PackageSetting)=B:48:0x01ba, (r47_2 'oldPkgSetting' com.android.server.pm.PackageSetting)=B:135:?}
	at jadx.core.dex.instructions.PhiInsn.replaceArg(PhiInsn.java:78)
	at jadx.core.dex.visitors.ModVisitor.processInvoke(ModVisitor.java:222)
	at jadx.core.dex.visitors.ModVisitor.replaceStep(ModVisitor.java:83)
	at jadx.core.dex.visitors.ModVisitor.visit(ModVisitor.java:68)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:27)
	at jadx.core.dex.visitors.DepthTraversal.lambda$visit$1(DepthTraversal.java:14)
	at java.util.ArrayList.forEach(ArrayList.java:1251)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:14)
	at jadx.core.ProcessClass.process(ProcessClass.java:32)
	at jadx.core.ProcessClass.lambda$processDependencies$0(ProcessClass.java:51)
	at java.lang.Iterable.forEach(Iterable.java:75)
	at jadx.core.ProcessClass.processDependencies(ProcessClass.java:51)
	at jadx.core.ProcessClass.process(ProcessClass.java:37)
	at jadx.api.JadxDecompiler.processClass(JadxDecompiler.java:286)
	at jadx.api.JavaClass.decompile(JavaClass.java:62)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
*/
        /*
        r60 = this;
        r4 = DEBUG_PACKAGE_SCANNING;
        if (r4 == 0) goto L_0x0026;
    L_0x0004:
        r4 = r62 & 2;
        if (r4 == 0) goto L_0x0026;
    L_0x0008:
        r4 = "PackageManager";
        r11 = new java.lang.StringBuilder;
        r11.<init>();
        r12 = "Scanning package ";
        r11 = r11.append(r12);
        r0 = r61;
        r12 = r0.packageName;
        r11 = r11.append(r12);
        r11 = r11.toString();
        android.util.Log.d(r4, r11);
    L_0x0026:
        r60.applyPolicy(r61, r62);
        r60.assertPackageIsValid(r61, r62, r63);
        r53 = new java.io.File;
        r0 = r61;
        r4 = r0.codePath;
        r0 = r53;
        r0.<init>(r4);
        r9 = new java.io.File;
        r0 = r61;
        r4 = r0.applicationInfo;
        r4 = r4.getCodePath();
        r9.<init>(r4);
        r10 = new java.io.File;
        r0 = r61;
        r4 = r0.applicationInfo;
        r4 = r4.getResourcePath();
        r10.<init>(r4);
        r8 = 0;
        r13 = 0;
        r45 = 0;
        r51 = 0;
        r56 = 0;
        r0 = r60;
        r0 = r0.mPackages;
        r59 = r0;
        monitor-enter(r59);
        r0 = r61;	 Catch:{ all -> 0x046f }
        r4 = r0.mSharedUserId;	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x00b5;	 Catch:{ all -> 0x046f }
    L_0x0066:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r4 = r0.mSettings;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r11 = r0.mSharedUserId;	 Catch:{ all -> 0x046f }
        r12 = 0;	 Catch:{ all -> 0x046f }
        r14 = 0;	 Catch:{ all -> 0x046f }
        r15 = 1;	 Catch:{ all -> 0x046f }
        r8 = r4.getSharedUserLPw(r11, r12, r14, r15);	 Catch:{ all -> 0x046f }
        r4 = DEBUG_PACKAGE_SCANNING;	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x00b5;	 Catch:{ all -> 0x046f }
    L_0x0079:
        r4 = r62 & 2;	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x00b5;	 Catch:{ all -> 0x046f }
    L_0x007d:
        r4 = "PackageManager";	 Catch:{ all -> 0x046f }
        r11 = new java.lang.StringBuilder;	 Catch:{ all -> 0x046f }
        r11.<init>();	 Catch:{ all -> 0x046f }
        r12 = "Shared UserID ";	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r12 = r0.mSharedUserId;	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r12 = " (uid=";	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r12 = r8.userId;	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r12 = "): packages=";	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r12 = r8.packages;	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r11 = r11.toString();	 Catch:{ all -> 0x046f }
        android.util.Log.d(r4, r11);	 Catch:{ all -> 0x046f }
    L_0x00b5:
        r5 = 0;	 Catch:{ all -> 0x046f }
        r7 = 0;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r4 = r0.mOriginalPackages;	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x00ec;	 Catch:{ all -> 0x046f }
    L_0x00bd:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r4 = r0.mSettings;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r11 = r0.mRealPackage;	 Catch:{ all -> 0x046f }
        r52 = r4.getRenamedPackageLPr(r11);	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r4 = r0.mOriginalPackages;	 Catch:{ all -> 0x046f }
        r0 = r52;	 Catch:{ all -> 0x046f }
        r4 = r4.contains(r0);	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x03b1;	 Catch:{ all -> 0x046f }
    L_0x00d5:
        r0 = r61;	 Catch:{ all -> 0x046f }
        r7 = r0.mRealPackage;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r4 = r0.packageName;	 Catch:{ all -> 0x046f }
        r0 = r52;	 Catch:{ all -> 0x046f }
        r4 = r4.equals(r0);	 Catch:{ all -> 0x046f }
        if (r4 != 0) goto L_0x00ec;	 Catch:{ all -> 0x046f }
    L_0x00e5:
        r0 = r61;	 Catch:{ all -> 0x046f }
        r1 = r52;	 Catch:{ all -> 0x046f }
        r0.setPackageName(r1);	 Catch:{ all -> 0x046f }
    L_0x00ec:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r4 = r0.mTransferedPackages;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r11 = r0.packageName;	 Catch:{ all -> 0x046f }
        r4 = r4.contains(r11);	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x011f;	 Catch:{ all -> 0x046f }
    L_0x00fa:
        r4 = "PackageManager";	 Catch:{ all -> 0x046f }
        r11 = new java.lang.StringBuilder;	 Catch:{ all -> 0x046f }
        r11.<init>();	 Catch:{ all -> 0x046f }
        r12 = "Package ";	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r12 = r0.packageName;	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r12 = " was transferred to another, but its .apk remains";	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r11 = r11.toString();	 Catch:{ all -> 0x046f }
        android.util.Slog.w(r4, r11);	 Catch:{ all -> 0x046f }
    L_0x011f:
        r0 = r63;	 Catch:{ all -> 0x046f }
        r4 = r0 & 8192;	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x013e;	 Catch:{ all -> 0x046f }
    L_0x0125:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r4 = r0.mSettings;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r11 = r0.packageName;	 Catch:{ all -> 0x046f }
        r41 = r4.getPackageLPr(r11);	 Catch:{ all -> 0x046f }
        if (r41 == 0) goto L_0x013e;	 Catch:{ all -> 0x046f }
    L_0x0133:
        r46 = new com.android.server.pm.PackageSetting;	 Catch:{ all -> 0x046f }
        r0 = r46;	 Catch:{ all -> 0x046f }
        r1 = r41;	 Catch:{ all -> 0x046f }
        r0.<init>(r1);	 Catch:{ all -> 0x046f }
        r45 = r46;	 Catch:{ all -> 0x046f }
    L_0x013e:
        r4 = 65536; // 0x10000 float:9.18355E-41 double:3.2379E-319;	 Catch:{ all -> 0x046f }
        r4 = r4 & r63;	 Catch:{ all -> 0x046f }
        if (r4 != 0) goto L_0x015e;	 Catch:{ all -> 0x046f }
    L_0x0144:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r4 = r0.mSettings;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r11 = r0.packageName;	 Catch:{ all -> 0x046f }
        r41 = r4.getPackageLPr(r11);	 Catch:{ all -> 0x046f }
        if (r41 == 0) goto L_0x015e;	 Catch:{ all -> 0x046f }
    L_0x0152:
        r0 = r41;	 Catch:{ all -> 0x046f }
        r0 = r0.primaryCpuAbiString;	 Catch:{ all -> 0x046f }
        r51 = r0;	 Catch:{ all -> 0x046f }
        r0 = r41;	 Catch:{ all -> 0x046f }
        r0 = r0.secondaryCpuAbiString;	 Catch:{ all -> 0x046f }
        r56 = r0;	 Catch:{ all -> 0x046f }
    L_0x015e:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r4 = r0.mSettings;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r11 = r0.packageName;	 Catch:{ all -> 0x046f }
        r13 = r4.getPackageLPr(r11);	 Catch:{ all -> 0x046f }
        if (r13 == 0) goto L_0x0472;	 Catch:{ all -> 0x046f }
    L_0x016c:
        r4 = r13.sharedUser;	 Catch:{ all -> 0x046f }
        if (r4 == r8) goto L_0x0472;	 Catch:{ all -> 0x046f }
    L_0x0170:
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x046f }
        r4.<init>();	 Catch:{ all -> 0x046f }
        r11 = "Package ";	 Catch:{ all -> 0x046f }
        r4 = r4.append(r11);	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r11 = r0.packageName;	 Catch:{ all -> 0x046f }
        r4 = r4.append(r11);	 Catch:{ all -> 0x046f }
        r11 = " shared user changed from ";	 Catch:{ all -> 0x046f }
        r11 = r4.append(r11);	 Catch:{ all -> 0x046f }
        r4 = r13.sharedUser;	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x0476;	 Catch:{ all -> 0x046f }
    L_0x018f:
        r4 = r13.sharedUser;	 Catch:{ all -> 0x046f }
        r4 = r4.name;	 Catch:{ all -> 0x046f }
    L_0x0193:
        r4 = r11.append(r4);	 Catch:{ all -> 0x046f }
        r11 = " to ";	 Catch:{ all -> 0x046f }
        r11 = r4.append(r11);	 Catch:{ all -> 0x046f }
        if (r8 == 0) goto L_0x047b;	 Catch:{ all -> 0x046f }
    L_0x01a0:
        r4 = r8.name;	 Catch:{ all -> 0x046f }
    L_0x01a2:
        r4 = r11.append(r4);	 Catch:{ all -> 0x046f }
        r11 = "; replacing with new";	 Catch:{ all -> 0x046f }
        r4 = r4.append(r11);	 Catch:{ all -> 0x046f }
        r4 = r4.toString();	 Catch:{ all -> 0x046f }
        r11 = 5;	 Catch:{ all -> 0x046f }
        reportSettingsProblem(r11, r4);	 Catch:{ all -> 0x046f }
        r13 = 0;
        r50 = r13;
    L_0x01b8:
        if (r50 != 0) goto L_0x0480;
    L_0x01ba:
        r47 = 0;
    L_0x01bc:
        r0 = r60;	 Catch:{ all -> 0x08aa }
        r4 = r0.mSettings;	 Catch:{ all -> 0x08aa }
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r11 = r0.packageName;	 Catch:{ all -> 0x08aa }
        r6 = r4.getDisabledSystemPkgLPr(r11);	 Catch:{ all -> 0x08aa }
        r24 = 0;	 Catch:{ all -> 0x08aa }
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r4 = r0.usesStaticLibraries;	 Catch:{ all -> 0x08aa }
        if (r4 == 0) goto L_0x01e5;	 Catch:{ all -> 0x08aa }
    L_0x01d0:
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r4 = r0.usesStaticLibraries;	 Catch:{ all -> 0x08aa }
        r4 = r4.size();	 Catch:{ all -> 0x08aa }
        r0 = new java.lang.String[r4];	 Catch:{ all -> 0x08aa }
        r24 = r0;	 Catch:{ all -> 0x08aa }
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r4 = r0.usesStaticLibraries;	 Catch:{ all -> 0x08aa }
        r0 = r24;	 Catch:{ all -> 0x08aa }
        r4.toArray(r0);	 Catch:{ all -> 0x08aa }
    L_0x01e5:
        if (r50 != 0) goto L_0x0497;	 Catch:{ all -> 0x08aa }
    L_0x01e7:
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r4 = r0.parentPackage;	 Catch:{ all -> 0x08aa }
        if (r4 == 0) goto L_0x048b;	 Catch:{ all -> 0x08aa }
    L_0x01ed:
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r4 = r0.parentPackage;	 Catch:{ all -> 0x08aa }
        r0 = r4.packageName;	 Catch:{ all -> 0x08aa }
        r21 = r0;	 Catch:{ all -> 0x08aa }
    L_0x01f5:
        r4 = 131072; // 0x20000 float:1.83671E-40 double:6.47582E-319;	 Catch:{ all -> 0x08aa }
        r4 = r4 & r63;	 Catch:{ all -> 0x08aa }
        if (r4 == 0) goto L_0x048f;	 Catch:{ all -> 0x08aa }
    L_0x01fb:
        r19 = 1;	 Catch:{ all -> 0x08aa }
    L_0x01fd:
        r4 = 524288; // 0x80000 float:7.34684E-40 double:2.590327E-318;	 Catch:{ all -> 0x08aa }
        r4 = r4 & r63;	 Catch:{ all -> 0x08aa }
        if (r4 == 0) goto L_0x0493;	 Catch:{ all -> 0x08aa }
    L_0x0203:
        r20 = 1;	 Catch:{ all -> 0x08aa }
    L_0x0205:
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r4 = r0.packageName;	 Catch:{ all -> 0x08aa }
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r11 = r0.applicationInfo;	 Catch:{ all -> 0x08aa }
        r11 = r11.nativeLibraryRootDir;	 Catch:{ all -> 0x08aa }
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r12 = r0.applicationInfo;	 Catch:{ all -> 0x08aa }
        r12 = r12.primaryCpuAbi;	 Catch:{ all -> 0x08aa }
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r14 = r0.applicationInfo;	 Catch:{ all -> 0x08aa }
        r13 = r14.secondaryCpuAbi;	 Catch:{ all -> 0x08aa }
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r14 = r0.mVersionCode;	 Catch:{ all -> 0x08aa }
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r15 = r0.applicationInfo;	 Catch:{ all -> 0x08aa }
        r15 = r15.flags;	 Catch:{ all -> 0x08aa }
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r0 = r0.applicationInfo;	 Catch:{ all -> 0x08aa }
        r16 = r0;	 Catch:{ all -> 0x08aa }
        r0 = r16;	 Catch:{ all -> 0x08aa }
        r0 = r0.privateFlags;	 Catch:{ all -> 0x08aa }
        r16 = r0;	 Catch:{ all -> 0x08aa }
        r22 = r61.getChildPackageNames();	 Catch:{ all -> 0x08aa }
        r23 = com.android.server.pm.UserManagerService.getInstance();	 Catch:{ all -> 0x08aa }
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r0 = r0.usesStaticLibrariesVersions;	 Catch:{ all -> 0x08aa }
        r25 = r0;	 Catch:{ all -> 0x08aa }
        r18 = 1;	 Catch:{ all -> 0x08aa }
        r17 = r66;	 Catch:{ all -> 0x08aa }
        r13 = com.android.server.pm.Settings.createNewSetting(r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25);	 Catch:{ all -> 0x08aa }
        if (r5 == 0) goto L_0x0256;
    L_0x0249:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r4 = r0.mSettings;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r11 = r0.packageName;	 Catch:{ all -> 0x046f }
        r12 = r5.name;	 Catch:{ all -> 0x046f }
        r4.addRenamedPackageLPw(r11, r12);	 Catch:{ all -> 0x046f }
    L_0x0256:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r4 = r0.mSettings;	 Catch:{ all -> 0x046f }
        r4.addUserToSettingLPw(r13);	 Catch:{ all -> 0x046f }
    L_0x025d:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r4 = r0.mSettings;	 Catch:{ all -> 0x046f }
        r0 = r47;	 Catch:{ all -> 0x046f }
        r4.writeUserRestrictionsLPw(r13, r0);	 Catch:{ all -> 0x046f }
        r4 = r13.origPackage;	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x02ac;	 Catch:{ all -> 0x046f }
    L_0x026a:
        r4 = r5.name;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r0.setPackageName(r4);	 Catch:{ all -> 0x046f }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x046f }
        r4.<init>();	 Catch:{ all -> 0x046f }
        r11 = "New package ";	 Catch:{ all -> 0x046f }
        r4 = r4.append(r11);	 Catch:{ all -> 0x046f }
        r11 = r13.realName;	 Catch:{ all -> 0x046f }
        r4 = r4.append(r11);	 Catch:{ all -> 0x046f }
        r11 = " renamed to replace old package ";	 Catch:{ all -> 0x046f }
        r4 = r4.append(r11);	 Catch:{ all -> 0x046f }
        r11 = r13.name;	 Catch:{ all -> 0x046f }
        r4 = r4.append(r11);	 Catch:{ all -> 0x046f }
        r44 = r4.toString();	 Catch:{ all -> 0x046f }
        r4 = 5;	 Catch:{ all -> 0x046f }
        r0 = r44;	 Catch:{ all -> 0x046f }
        reportSettingsProblem(r4, r0);	 Catch:{ all -> 0x046f }
        r0 = r63;	 Catch:{ all -> 0x046f }
        r4 = r0 & 8192;	 Catch:{ all -> 0x046f }
        if (r4 != 0) goto L_0x02a9;	 Catch:{ all -> 0x046f }
    L_0x02a0:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r4 = r0.mTransferedPackages;	 Catch:{ all -> 0x046f }
        r11 = r5.name;	 Catch:{ all -> 0x046f }
        r4.add(r11);	 Catch:{ all -> 0x046f }
    L_0x02a9:
        r4 = 0;	 Catch:{ all -> 0x046f }
        r13.origPackage = r4;	 Catch:{ all -> 0x046f }
    L_0x02ac:
        r0 = r63;	 Catch:{ all -> 0x046f }
        r4 = r0 & 8192;	 Catch:{ all -> 0x046f }
        if (r4 != 0) goto L_0x02bf;	 Catch:{ all -> 0x046f }
    L_0x02b2:
        if (r7 == 0) goto L_0x02bf;	 Catch:{ all -> 0x046f }
    L_0x02b4:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r4 = r0.mTransferedPackages;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r11 = r0.packageName;	 Catch:{ all -> 0x046f }
        r4.add(r11);	 Catch:{ all -> 0x046f }
    L_0x02bf:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r4 = r0.mSettings;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r11 = r0.packageName;	 Catch:{ all -> 0x046f }
        r4 = r4.isDisabledSystemPackageLPr(r11);	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x02d7;	 Catch:{ all -> 0x046f }
    L_0x02cd:
        r0 = r61;	 Catch:{ all -> 0x046f }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x046f }
        r11 = r4.flags;	 Catch:{ all -> 0x046f }
        r11 = r11 | 128;	 Catch:{ all -> 0x046f }
        r4.flags = r11;	 Catch:{ all -> 0x046f }
    L_0x02d7:
        r4 = r63 & 64;	 Catch:{ all -> 0x046f }
        if (r4 != 0) goto L_0x02e7;	 Catch:{ all -> 0x046f }
    L_0x02db:
        r4 = r62 & 64;	 Catch:{ all -> 0x046f }
        if (r4 != 0) goto L_0x02e7;	 Catch:{ all -> 0x046f }
    L_0x02df:
        r4 = 0;	 Catch:{ all -> 0x046f }
        r0 = r60;	 Catch:{ all -> 0x046f }
        r1 = r61;	 Catch:{ all -> 0x046f }
        r0.updateSharedLibrariesLPr(r1, r4);	 Catch:{ all -> 0x046f }
    L_0x02e7:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r4 = r0.mFoundPolicyFile;	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x02f0;	 Catch:{ all -> 0x046f }
    L_0x02ed:
        com.android.server.pm.SELinuxMMAC.assignSeInfoValue(r61);	 Catch:{ all -> 0x046f }
    L_0x02f0:
        r0 = r61;	 Catch:{ all -> 0x046f }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x046f }
        r11 = r13.appId;	 Catch:{ all -> 0x046f }
        r4.uid = r11;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r0.mExtras = r13;	 Catch:{ all -> 0x046f }
        r57 = r13;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x046f }
        r4 = r4.isStaticSharedLibrary();	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x031a;	 Catch:{ all -> 0x046f }
    L_0x0308:
        r43 = r60.getLatestSharedLibraVersionLPr(r61);	 Catch:{ all -> 0x046f }
        if (r43 == 0) goto L_0x031a;	 Catch:{ all -> 0x046f }
    L_0x030e:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r4 = r0.mSettings;	 Catch:{ all -> 0x046f }
        r0 = r43;	 Catch:{ all -> 0x046f }
        r11 = r0.apk;	 Catch:{ all -> 0x046f }
        r57 = r4.getPackageLPr(r11);	 Catch:{ all -> 0x046f }
    L_0x031a:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r1 = r57;	 Catch:{ all -> 0x046f }
        r2 = r63;	 Catch:{ all -> 0x046f }
        r4 = r0.shouldCheckUpgradeKeySetLP(r1, r2);	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x053e;	 Catch:{ all -> 0x046f }
    L_0x0326:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r1 = r57;	 Catch:{ all -> 0x046f }
        r2 = r61;	 Catch:{ all -> 0x046f }
        r4 = r0.checkUpgradeKeySetLP(r1, r2);	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x04de;	 Catch:{ all -> 0x046f }
    L_0x0332:
        r4 = r13.signatures;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r11 = r0.mSignatures;	 Catch:{ all -> 0x046f }
        r4.mSignatures = r11;	 Catch:{ all -> 0x046f }
    L_0x033a:
        r0 = r63;	 Catch:{ all -> 0x046f }
        r4 = r0 & 8192;	 Catch:{ all -> 0x046f }
        if (r4 != 0) goto L_0x05bc;	 Catch:{ all -> 0x046f }
    L_0x0340:
        r0 = r61;	 Catch:{ all -> 0x046f }
        r4 = r0.mAdoptPermissions;	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x05bc;	 Catch:{ all -> 0x046f }
    L_0x0346:
        r0 = r61;	 Catch:{ all -> 0x046f }
        r4 = r0.mAdoptPermissions;	 Catch:{ all -> 0x046f }
        r4 = r4.size();	 Catch:{ all -> 0x046f }
        r42 = r4 + -1;	 Catch:{ all -> 0x046f }
    L_0x0350:
        if (r42 < 0) goto L_0x05bc;	 Catch:{ all -> 0x046f }
    L_0x0352:
        r0 = r61;	 Catch:{ all -> 0x046f }
        r4 = r0.mAdoptPermissions;	 Catch:{ all -> 0x046f }
        r0 = r42;	 Catch:{ all -> 0x046f }
        r49 = r4.get(r0);	 Catch:{ all -> 0x046f }
        r49 = (java.lang.String) r49;	 Catch:{ all -> 0x046f }
        r0 = r60;	 Catch:{ all -> 0x046f }
        r4 = r0.mSettings;	 Catch:{ all -> 0x046f }
        r0 = r49;	 Catch:{ all -> 0x046f }
        r48 = r4.getPackageLPr(r0);	 Catch:{ all -> 0x046f }
        if (r48 == 0) goto L_0x03ae;	 Catch:{ all -> 0x046f }
    L_0x036a:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r1 = r48;	 Catch:{ all -> 0x046f }
        r2 = r61;	 Catch:{ all -> 0x046f }
        r4 = r0.verifyPackageUpdateLPr(r1, r2);	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x03ae;	 Catch:{ all -> 0x046f }
    L_0x0376:
        r4 = "PackageManager";	 Catch:{ all -> 0x046f }
        r11 = new java.lang.StringBuilder;	 Catch:{ all -> 0x046f }
        r11.<init>();	 Catch:{ all -> 0x046f }
        r12 = "Adopting permissions from ";	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r0 = r49;	 Catch:{ all -> 0x046f }
        r11 = r11.append(r0);	 Catch:{ all -> 0x046f }
        r12 = " to ";	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r12 = r0.packageName;	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r11 = r11.toString();	 Catch:{ all -> 0x046f }
        android.util.Slog.i(r4, r11);	 Catch:{ all -> 0x046f }
        r0 = r60;	 Catch:{ all -> 0x046f }
        r4 = r0.mSettings;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r11 = r0.packageName;	 Catch:{ all -> 0x046f }
        r0 = r49;	 Catch:{ all -> 0x046f }
        r4.transferPermissionsLPw(r0, r11);	 Catch:{ all -> 0x046f }
    L_0x03ae:
        r42 = r42 + -1;	 Catch:{ all -> 0x046f }
        goto L_0x0350;	 Catch:{ all -> 0x046f }
    L_0x03b1:
        r0 = r61;	 Catch:{ all -> 0x046f }
        r4 = r0.mOriginalPackages;	 Catch:{ all -> 0x046f }
        r4 = r4.size();	 Catch:{ all -> 0x046f }
        r42 = r4 + -1;	 Catch:{ all -> 0x046f }
    L_0x03bb:
        if (r42 < 0) goto L_0x00ec;	 Catch:{ all -> 0x046f }
    L_0x03bd:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r11 = r0.mSettings;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r4 = r0.mOriginalPackages;	 Catch:{ all -> 0x046f }
        r0 = r42;	 Catch:{ all -> 0x046f }
        r4 = r4.get(r0);	 Catch:{ all -> 0x046f }
        r4 = (java.lang.String) r4;	 Catch:{ all -> 0x046f }
        r5 = r11.getPackageLPr(r4);	 Catch:{ all -> 0x046f }
        if (r5 == 0) goto L_0x03de;	 Catch:{ all -> 0x046f }
    L_0x03d3:
        r0 = r60;	 Catch:{ all -> 0x046f }
        r1 = r61;	 Catch:{ all -> 0x046f }
        r4 = r0.verifyPackageUpdateLPr(r5, r1);	 Catch:{ all -> 0x046f }
        if (r4 != 0) goto L_0x03e1;	 Catch:{ all -> 0x046f }
    L_0x03dd:
        r5 = 0;	 Catch:{ all -> 0x046f }
    L_0x03de:
        r42 = r42 + -1;	 Catch:{ all -> 0x046f }
        goto L_0x03bb;	 Catch:{ all -> 0x046f }
    L_0x03e1:
        r4 = r5.sharedUser;	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x043e;	 Catch:{ all -> 0x046f }
    L_0x03e5:
        r4 = r5.sharedUser;	 Catch:{ all -> 0x046f }
        r4 = r4.name;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r11 = r0.mSharedUserId;	 Catch:{ all -> 0x046f }
        r4 = r4.equals(r11);	 Catch:{ all -> 0x046f }
        if (r4 != 0) goto L_0x00ec;	 Catch:{ all -> 0x046f }
    L_0x03f3:
        r4 = "PackageManager";	 Catch:{ all -> 0x046f }
        r11 = new java.lang.StringBuilder;	 Catch:{ all -> 0x046f }
        r11.<init>();	 Catch:{ all -> 0x046f }
        r12 = "Unable to migrate data from ";	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r12 = r5.name;	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r12 = " to ";	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r12 = r0.packageName;	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r12 = ": old uid ";	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r12 = r5.sharedUser;	 Catch:{ all -> 0x046f }
        r12 = r12.name;	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r12 = " differs from ";	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r12 = r0.mSharedUserId;	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r11 = r11.toString();	 Catch:{ all -> 0x046f }
        android.util.Slog.w(r4, r11);	 Catch:{ all -> 0x046f }
        r5 = 0;	 Catch:{ all -> 0x046f }
        goto L_0x03de;	 Catch:{ all -> 0x046f }
    L_0x043e:
        r4 = DEBUG_UPGRADE;	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x00ec;	 Catch:{ all -> 0x046f }
    L_0x0442:
        r4 = "PackageManager";	 Catch:{ all -> 0x046f }
        r11 = new java.lang.StringBuilder;	 Catch:{ all -> 0x046f }
        r11.<init>();	 Catch:{ all -> 0x046f }
        r12 = "Renaming new package ";	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r12 = r0.packageName;	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r12 = " to old name ";	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r12 = r5.name;	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r11 = r11.toString();	 Catch:{ all -> 0x046f }
        android.util.Log.v(r4, r11);	 Catch:{ all -> 0x046f }
        goto L_0x00ec;
    L_0x046f:
        r4 = move-exception;
    L_0x0470:
        monitor-exit(r59);
        throw r4;
    L_0x0472:
        r50 = r13;
        goto L_0x01b8;
    L_0x0476:
        r4 = "<nothing>";	 Catch:{ all -> 0x046f }
        goto L_0x0193;	 Catch:{ all -> 0x046f }
    L_0x047b:
        r4 = "<nothing>";	 Catch:{ all -> 0x046f }
        goto L_0x01a2;
    L_0x0480:
        r47 = new com.android.server.pm.PackageSetting;	 Catch:{ all -> 0x08aa }
        r0 = r47;	 Catch:{ all -> 0x08aa }
        r1 = r50;	 Catch:{ all -> 0x08aa }
        r0.<init>(r1);	 Catch:{ all -> 0x08aa }
        goto L_0x01bc;	 Catch:{ all -> 0x08aa }
    L_0x048b:
        r21 = 0;	 Catch:{ all -> 0x08aa }
        goto L_0x01f5;	 Catch:{ all -> 0x08aa }
    L_0x048f:
        r19 = 0;	 Catch:{ all -> 0x08aa }
        goto L_0x01fd;	 Catch:{ all -> 0x08aa }
    L_0x0493:
        r20 = 0;	 Catch:{ all -> 0x08aa }
        goto L_0x0205;	 Catch:{ all -> 0x08aa }
    L_0x0497:
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x08aa }
        r0 = r4.nativeLibraryDir;	 Catch:{ all -> 0x08aa }
        r29 = r0;	 Catch:{ all -> 0x08aa }
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x08aa }
        r0 = r4.primaryCpuAbi;	 Catch:{ all -> 0x08aa }
        r30 = r0;	 Catch:{ all -> 0x08aa }
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x08aa }
        r0 = r4.secondaryCpuAbi;	 Catch:{ all -> 0x08aa }
        r31 = r0;	 Catch:{ all -> 0x08aa }
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x08aa }
        r0 = r4.flags;	 Catch:{ all -> 0x08aa }
        r32 = r0;	 Catch:{ all -> 0x08aa }
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x08aa }
        r0 = r4.privateFlags;	 Catch:{ all -> 0x08aa }
        r33 = r0;	 Catch:{ all -> 0x08aa }
        r34 = r61.getChildPackageNames();	 Catch:{ all -> 0x08aa }
        r35 = com.android.server.pm.UserManagerService.getInstance();	 Catch:{ all -> 0x08aa }
        r0 = r61;	 Catch:{ all -> 0x08aa }
        r0 = r0.usesStaticLibrariesVersions;	 Catch:{ all -> 0x08aa }
        r37 = r0;	 Catch:{ all -> 0x08aa }
        r25 = r50;	 Catch:{ all -> 0x08aa }
        r26 = r6;	 Catch:{ all -> 0x08aa }
        r27 = r8;	 Catch:{ all -> 0x08aa }
        r28 = r9;	 Catch:{ all -> 0x08aa }
        r36 = r24;	 Catch:{ all -> 0x08aa }
        com.android.server.pm.Settings.updatePackageSetting(r25, r26, r27, r28, r29, r30, r31, r32, r33, r34, r35, r36, r37);	 Catch:{ all -> 0x08aa }
        r13 = r50;
        goto L_0x025d;
    L_0x04de:
        r4 = r62 & 64;
        if (r4 != 0) goto L_0x050f;
    L_0x04e2:
        r4 = new com.android.server.pm.PackageManagerException;	 Catch:{ all -> 0x046f }
        r11 = new java.lang.StringBuilder;	 Catch:{ all -> 0x046f }
        r11.<init>();	 Catch:{ all -> 0x046f }
        r12 = "Package ";	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r12 = r0.packageName;	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r12 = " upgrade keys do not match the ";	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r12 = "previously installed version";	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r11 = r11.toString();	 Catch:{ all -> 0x046f }
        r12 = -7;	 Catch:{ all -> 0x046f }
        r4.<init>(r12, r11);	 Catch:{ all -> 0x046f }
        throw r4;	 Catch:{ all -> 0x046f }
    L_0x050f:
        r4 = r13.signatures;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r11 = r0.mSignatures;	 Catch:{ all -> 0x046f }
        r4.mSignatures = r11;	 Catch:{ all -> 0x046f }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x046f }
        r4.<init>();	 Catch:{ all -> 0x046f }
        r11 = "System package ";	 Catch:{ all -> 0x046f }
        r4 = r4.append(r11);	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r11 = r0.packageName;	 Catch:{ all -> 0x046f }
        r4 = r4.append(r11);	 Catch:{ all -> 0x046f }
        r11 = " signature changed; retaining data.";	 Catch:{ all -> 0x046f }
        r4 = r4.append(r11);	 Catch:{ all -> 0x046f }
        r44 = r4.toString();	 Catch:{ all -> 0x046f }
        r4 = 5;	 Catch:{ all -> 0x046f }
        r0 = r44;	 Catch:{ all -> 0x046f }
        reportSettingsProblem(r4, r0);	 Catch:{ all -> 0x046f }
        goto L_0x033a;
    L_0x053e:
        r0 = r60;	 Catch:{ PackageManagerException -> 0x0551 }
        r1 = r57;	 Catch:{ PackageManagerException -> 0x0551 }
        r2 = r61;	 Catch:{ PackageManagerException -> 0x0551 }
        r0.verifySignaturesLP(r1, r2);	 Catch:{ PackageManagerException -> 0x0551 }
        r4 = r13.signatures;	 Catch:{ PackageManagerException -> 0x0551 }
        r0 = r61;	 Catch:{ PackageManagerException -> 0x0551 }
        r11 = r0.mSignatures;	 Catch:{ PackageManagerException -> 0x0551 }
        r4.mSignatures = r11;	 Catch:{ PackageManagerException -> 0x0551 }
        goto L_0x033a;
    L_0x0551:
        r39 = move-exception;
        r4 = r62 & 64;
        if (r4 != 0) goto L_0x0557;
    L_0x0556:
        throw r39;	 Catch:{ all -> 0x046f }
    L_0x0557:
        r4 = r13.signatures;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r11 = r0.mSignatures;	 Catch:{ all -> 0x046f }
        r4.mSignatures = r11;	 Catch:{ all -> 0x046f }
        r0 = r57;	 Catch:{ all -> 0x046f }
        r4 = r0.sharedUser;	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x0595;	 Catch:{ all -> 0x046f }
    L_0x0565:
        r0 = r57;	 Catch:{ all -> 0x046f }
        r4 = r0.sharedUser;	 Catch:{ all -> 0x046f }
        r4 = r4.signatures;	 Catch:{ all -> 0x046f }
        r4 = r4.mSignatures;	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r11 = r0.mSignatures;	 Catch:{ all -> 0x046f }
        r4 = compareSignatures(r4, r11);	 Catch:{ all -> 0x046f }
        if (r4 == 0) goto L_0x0595;	 Catch:{ all -> 0x046f }
    L_0x0577:
        r4 = new com.android.server.pm.PackageManagerException;	 Catch:{ all -> 0x046f }
        r11 = new java.lang.StringBuilder;	 Catch:{ all -> 0x046f }
        r11.<init>();	 Catch:{ all -> 0x046f }
        r12 = "Signature mismatch for shared user: ";	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r12 = r13.sharedUser;	 Catch:{ all -> 0x046f }
        r11 = r11.append(r12);	 Catch:{ all -> 0x046f }
        r11 = r11.toString();	 Catch:{ all -> 0x046f }
        r12 = -104; // 0xffffffffffffff98 float:NaN double:NaN;	 Catch:{ all -> 0x046f }
        r4.<init>(r12, r11);	 Catch:{ all -> 0x046f }
        throw r4;	 Catch:{ all -> 0x046f }
    L_0x0595:
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x046f }
        r4.<init>();	 Catch:{ all -> 0x046f }
        r11 = "System package ";	 Catch:{ all -> 0x046f }
        r4 = r4.append(r11);	 Catch:{ all -> 0x046f }
        r0 = r61;	 Catch:{ all -> 0x046f }
        r11 = r0.packageName;	 Catch:{ all -> 0x046f }
        r4 = r4.append(r11);	 Catch:{ all -> 0x046f }
        r11 = " signature changed; retaining data.";	 Catch:{ all -> 0x046f }
        r4 = r4.append(r11);	 Catch:{ all -> 0x046f }
        r44 = r4.toString();	 Catch:{ all -> 0x046f }
        r4 = 5;	 Catch:{ all -> 0x046f }
        r0 = r44;	 Catch:{ all -> 0x046f }
        reportSettingsProblem(r4, r0);	 Catch:{ all -> 0x046f }
        goto L_0x033a;
    L_0x05bc:
        monitor-exit(r59);
        r0 = r61;
        r4 = r0.applicationInfo;
        r0 = r61;
        r11 = r0.applicationInfo;
        r11 = r11.packageName;
        r0 = r61;
        r12 = r0.applicationInfo;
        r12 = r12.processName;
        r11 = fixProcessName(r11, r12);
        r4.processName = r11;
        r0 = r60;
        r4 = r0.mPlatformPackage;
        r0 = r61;
        if (r0 == r4) goto L_0x05e3;
    L_0x05db:
        r0 = r61;
        r4 = r0.applicationInfo;
        r11 = 0;
        r4.initForUser(r11);
    L_0x05e3:
        r0 = r61;
        r4 = r0.cpuAbiOverride;
        r38 = deriveAbiOverride(r4, r13);
        r4 = r63 & 16;
        if (r4 != 0) goto L_0x0821;
    L_0x05ef:
        r4 = 65536; // 0x10000 float:9.18355E-41 double:3.2379E-319;
        r4 = r4 & r63;
        if (r4 == 0) goto L_0x07c2;
    L_0x05f5:
        r4 = "derivePackageAbi";
        r14 = 262144; // 0x40000 float:3.67342E-40 double:1.295163E-318;
        android.os.Trace.traceBegin(r14, r4);
        r4 = r61.isLibrary();
        r40 = r4 ^ 1;
        r0 = r60;
        r4 = r0.mAppLib32InstallDir;
        r0 = r61;
        r1 = r53;
        r2 = r38;
        r3 = r40;
        derivePackageAbi(r0, r1, r2, r3, r4);
        r14 = 262144; // 0x40000 float:3.67342E-40 double:1.295163E-318;
        android.os.Trace.traceEnd(r14);
        r4 = isSystemApp(r61);
        if (r4 == 0) goto L_0x063d;
    L_0x061f:
        r4 = r61.isUpdatedSystemApp();
        r4 = r4 ^ 1;
        if (r4 == 0) goto L_0x063d;
    L_0x0627:
        r0 = r61;
        r4 = r0.applicationInfo;
        r4 = r4.primaryCpuAbi;
        if (r4 != 0) goto L_0x063d;
    L_0x062f:
        r0 = r61;
        setBundledAppAbisAndRoots(r0, r13);
        r0 = r60;
        r4 = r0.mAppLib32InstallDir;
        r0 = r61;
        setNativeLibraryPaths(r0, r4);
    L_0x063d:
        r0 = r60;
        r4 = r0.mPlatformPackage;
        r0 = r61;
        if (r4 != r0) goto L_0x065a;
    L_0x0645:
        r0 = r61;
        r11 = r0.applicationInfo;
        r4 = dalvik.system.VMRuntime.getRuntime();
        r4 = r4.is64Bit();
        if (r4 == 0) goto L_0x0842;
    L_0x0653:
        r4 = android.os.Build.SUPPORTED_64_BIT_ABIS;
        r12 = 0;
        r4 = r4[r12];
    L_0x0658:
        r11.primaryCpuAbi = r4;
    L_0x065a:
        r4 = r63 & 2;
        if (r4 != 0) goto L_0x0693;
    L_0x065e:
        r4 = r63 & 16;
        if (r4 == 0) goto L_0x0693;
    L_0x0662:
        if (r38 != 0) goto L_0x0693;
    L_0x0664:
        r4 = r13.cpuAbiOverrideString;
        if (r4 == 0) goto L_0x0693;
    L_0x0668:
        r4 = "PackageManager";
        r11 = new java.lang.StringBuilder;
        r11.<init>();
        r12 = "Ignoring persisted ABI override ";
        r11 = r11.append(r12);
        r0 = r38;
        r11 = r11.append(r0);
        r12 = " for package ";
        r11 = r11.append(r12);
        r0 = r61;
        r12 = r0.packageName;
        r11 = r11.append(r12);
        r11 = r11.toString();
        android.util.Slog.w(r4, r11);
    L_0x0693:
        r0 = r61;
        r4 = r0.applicationInfo;
        r4 = r4.primaryCpuAbi;
        r13.primaryCpuAbiString = r4;
        r0 = r61;
        r4 = r0.applicationInfo;
        r4 = r4.secondaryCpuAbi;
        r13.secondaryCpuAbiString = r4;
        r0 = r38;
        r13.cpuAbiOverrideString = r0;
        r0 = r38;
        r1 = r61;
        r1.cpuAbiOverride = r0;
        r4 = DEBUG_ABI_SELECTION;
        if (r4 == 0) goto L_0x06f3;
    L_0x06b1:
        r4 = "PackageManager";
        r11 = new java.lang.StringBuilder;
        r11.<init>();
        r12 = "Resolved nativeLibraryRoot for ";
        r11 = r11.append(r12);
        r0 = r61;
        r12 = r0.applicationInfo;
        r12 = r12.packageName;
        r11 = r11.append(r12);
        r12 = " to root=";
        r11 = r11.append(r12);
        r0 = r61;
        r12 = r0.applicationInfo;
        r12 = r12.nativeLibraryRootDir;
        r11 = r11.append(r12);
        r12 = ", isa=";
        r11 = r11.append(r12);
        r0 = r61;
        r12 = r0.applicationInfo;
        r12 = r12.nativeLibraryRootRequiresIsa;
        r11 = r11.append(r12);
        r11 = r11.toString();
        android.util.Slog.d(r4, r11);
    L_0x06f3:
        r0 = r61;
        r4 = r0.applicationInfo;
        r4 = r4.nativeLibraryRootDir;
        r13.legacyNativeLibraryPathString = r4;
        r4 = DEBUG_ABI_SELECTION;
        if (r4 == 0) goto L_0x0746;
    L_0x06ff:
        r4 = "PackageManager";
        r11 = new java.lang.StringBuilder;
        r11.<init>();
        r12 = "Abis for package[";
        r11 = r11.append(r12);
        r0 = r61;
        r12 = r0.packageName;
        r11 = r11.append(r12);
        r12 = "] are";
        r11 = r11.append(r12);
        r12 = " primary=";
        r11 = r11.append(r12);
        r0 = r61;
        r12 = r0.applicationInfo;
        r12 = r12.primaryCpuAbi;
        r11 = r11.append(r12);
        r12 = " secondary=";
        r11 = r11.append(r12);
        r0 = r61;
        r12 = r0.applicationInfo;
        r12 = r12.secondaryCpuAbi;
        r11 = r11.append(r12);
        r11 = r11.toString();
        android.util.Log.d(r4, r11);
    L_0x0746:
        r4 = r63 & 64;
        if (r4 != 0) goto L_0x0759;
    L_0x074a:
        r4 = r13.sharedUser;
        if (r4 == 0) goto L_0x0759;
    L_0x074e:
        r4 = r13.sharedUser;
        r4 = r4.packages;
        r0 = r60;
        r1 = r61;
        r0.adjustCpuAbisForSharedUserLPw(r4, r1);
    L_0x0759:
        r0 = r60;
        r4 = r0.mFactoryTest;
        if (r4 == 0) goto L_0x0776;
    L_0x075f:
        r0 = r61;
        r4 = r0.requestedPermissions;
        r11 = "android.permission.FACTORY_TEST";
        r4 = r4.contains(r11);
        if (r4 == 0) goto L_0x0776;
    L_0x076c:
        r0 = r61;
        r4 = r0.applicationInfo;
        r11 = r4.flags;
        r11 = r11 | 16;
        r4.flags = r11;
    L_0x0776:
        r4 = isSystemApp(r61);
        if (r4 == 0) goto L_0x077f;
    L_0x077c:
        r4 = 1;
        r13.isOrphaned = r4;
    L_0x077f:
        r0 = r60;
        r1 = r61;
        r2 = r53;
        r54 = r0.getLastModifiedTime(r1, r2);
        r14 = 0;
        r4 = (r64 > r14 ? 1 : (r64 == r14 ? 0 : -1));
        if (r4 == 0) goto L_0x0853;
    L_0x078f:
        r14 = r13.firstInstallTime;
        r16 = 0;
        r4 = (r14 > r16 ? 1 : (r14 == r16 ? 0 : -1));
        if (r4 != 0) goto L_0x0849;
    L_0x0797:
        r0 = r64;
        r13.lastUpdateTime = r0;
        r0 = r64;
        r13.firstInstallTime = r0;
    L_0x079f:
        r0 = r54;
        r13.setTimeStamp(r0);
        r0 = r63;
        r4 = r0 & 8192;
        if (r4 == 0) goto L_0x0878;
    L_0x07aa:
        if (r45 == 0) goto L_0x07c1;
    L_0x07ac:
        r0 = r60;
        r11 = r0.mPackages;
        monitor-enter(r11);
        r0 = r60;	 Catch:{ all -> 0x0875 }
        r4 = r0.mSettings;	 Catch:{ all -> 0x0875 }
        r4 = r4.mPackages;	 Catch:{ all -> 0x0875 }
        r0 = r45;	 Catch:{ all -> 0x0875 }
        r12 = r0.name;	 Catch:{ all -> 0x0875 }
        r0 = r45;	 Catch:{ all -> 0x0875 }
        r4.put(r12, r0);	 Catch:{ all -> 0x0875 }
        monitor-exit(r11);
    L_0x07c1:
        return r61;
    L_0x07c2:
        r0 = r61;
        r4 = r0.applicationInfo;
        r0 = r51;
        r4.primaryCpuAbi = r0;
        r0 = r61;
        r4 = r0.applicationInfo;
        r0 = r56;
        r4.secondaryCpuAbi = r0;
        r0 = r60;
        r4 = r0.mAppLib32InstallDir;
        r0 = r61;
        setNativeLibraryPaths(r0, r4);
        r4 = DEBUG_ABI_SELECTION;
        if (r4 == 0) goto L_0x063d;
    L_0x07df:
        r4 = "PackageManager";
        r11 = new java.lang.StringBuilder;
        r11.<init>();
        r12 = "Using ABIS and native lib paths from settings : ";
        r11 = r11.append(r12);
        r0 = r61;
        r12 = r0.packageName;
        r11 = r11.append(r12);
        r12 = " ";
        r11 = r11.append(r12);
        r0 = r61;
        r12 = r0.applicationInfo;
        r12 = r12.primaryCpuAbi;
        r11 = r11.append(r12);
        r12 = ", ";
        r11 = r11.append(r12);
        r0 = r61;
        r12 = r0.applicationInfo;
        r12 = r12.secondaryCpuAbi;
        r11 = r11.append(r12);
        r11 = r11.toString();
        android.util.Slog.i(r4, r11);
        goto L_0x063d;
    L_0x0821:
        r0 = r63;
        r4 = r0 & 2048;
        if (r4 == 0) goto L_0x0837;
    L_0x0827:
        r0 = r61;
        r4 = r0.applicationInfo;
        r11 = r13.primaryCpuAbiString;
        r4.primaryCpuAbi = r11;
        r0 = r61;
        r4 = r0.applicationInfo;
        r11 = r13.secondaryCpuAbiString;
        r4.secondaryCpuAbi = r11;
    L_0x0837:
        r0 = r60;
        r4 = r0.mAppLib32InstallDir;
        r0 = r61;
        setNativeLibraryPaths(r0, r4);
        goto L_0x063d;
    L_0x0842:
        r4 = android.os.Build.SUPPORTED_32_BIT_ABIS;
        r12 = 0;
        r4 = r4[r12];
        goto L_0x0658;
    L_0x0849:
        r4 = r63 & 32;
        if (r4 == 0) goto L_0x079f;
    L_0x084d:
        r0 = r64;
        r13.lastUpdateTime = r0;
        goto L_0x079f;
    L_0x0853:
        r14 = r13.firstInstallTime;
        r16 = 0;
        r4 = (r14 > r16 ? 1 : (r14 == r16 ? 0 : -1));
        if (r4 != 0) goto L_0x0865;
    L_0x085b:
        r0 = r54;
        r13.lastUpdateTime = r0;
        r0 = r54;
        r13.firstInstallTime = r0;
        goto L_0x079f;
    L_0x0865:
        r4 = r62 & 64;
        if (r4 == 0) goto L_0x079f;
    L_0x0869:
        r14 = r13.timeStamp;
        r4 = (r54 > r14 ? 1 : (r54 == r14 ? 0 : -1));
        if (r4 == 0) goto L_0x079f;
    L_0x086f:
        r0 = r54;
        r13.lastUpdateTime = r0;
        goto L_0x079f;
    L_0x0875:
        r4 = move-exception;
        monitor-exit(r11);
        throw r4;
    L_0x0878:
        if (r66 != 0) goto L_0x08a2;
    L_0x087a:
        r58 = 0;
    L_0x087c:
        r4 = r62 & 2;
        if (r4 == 0) goto L_0x08a7;
    L_0x0880:
        r16 = 1;
    L_0x0882:
        r11 = r60;
        r12 = r61;
        r14 = r66;
        r15 = r63;
        r11.commitPackageSettings(r12, r13, r14, r15, r16);
        r0 = r58;
        r4 = r13.getInstantApp(r0);
        if (r4 == 0) goto L_0x07c1;
    L_0x0895:
        r0 = r60;
        r4 = r0.mInstantAppRegistry;
        r11 = r13.appId;
        r0 = r58;
        r4.addInstantAppLPw(r0, r11);
        goto L_0x07c1;
    L_0x08a2:
        r58 = r66.getIdentifier();
        goto L_0x087c;
    L_0x08a7:
        r16 = 0;
        goto L_0x0882;
    L_0x08aa:
        r4 = move-exception;
        r13 = r50;
        goto L_0x0470;
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.pm.PackageManagerService.scanPackageDirtyLI(android.content.pm.PackageParser$Package, int, int, long, android.os.UserHandle):android.content.pm.PackageParser$Package");
    }

    private void applyPolicy(Package pkg, int policyFlags) {
        boolean z = true;
        ApplicationInfo applicationInfo;
        if ((policyFlags & 1) != 0) {
            applicationInfo = pkg.applicationInfo;
            applicationInfo.flags |= 1;
            if (pkg.applicationInfo.isDirectBootAware()) {
                ActivityInfo activityInfo;
                for (Service s : pkg.services) {
                    ServiceInfo serviceInfo = s.info;
                    s.info.directBootAware = true;
                    serviceInfo.encryptionAware = true;
                }
                for (Provider p : pkg.providers) {
                    ProviderInfo providerInfo = p.info;
                    p.info.directBootAware = true;
                    providerInfo.encryptionAware = true;
                }
                for (Activity a : pkg.activities) {
                    activityInfo = a.info;
                    a.info.directBootAware = true;
                    activityInfo.encryptionAware = true;
                }
                for (Activity r : pkg.receivers) {
                    activityInfo = r.info;
                    r.info.directBootAware = true;
                    activityInfo.encryptionAware = true;
                }
            }
            if (compressedFileExists(pkg.codePath)) {
                pkg.isStub = true;
            }
        } else {
            pkg.coreApp = false;
            applicationInfo = pkg.applicationInfo;
            applicationInfo.privateFlags &= -33;
            applicationInfo = pkg.applicationInfo;
            applicationInfo.privateFlags &= -65;
        }
        if ((policyFlags & 512) == 0) {
            z = false;
        }
        pkg.mTrustedOverlay = z;
        if ((policyFlags & 128) != 0) {
            ApplicationInfo applicationInfo2 = pkg.applicationInfo;
            applicationInfo2.privateFlags |= 8;
        }
        if (!isSystemApp(pkg)) {
            pkg.mOriginalPackages = null;
            pkg.mRealPackage = null;
            pkg.mAdoptPermissions = null;
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void assertPackageIsValid(Package pkg, int policyFlags, int scanFlags) throws PackageManagerException {
        if ((policyFlags & 1024) != 0) {
            assertCodePolicy(pkg);
        }
        if (pkg.applicationInfo.getCodePath() == null || pkg.applicationInfo.getResourcePath() == null) {
            throw new PackageManagerException(-2, "Code and resource paths haven't been set correctly");
        }
        this.mSettings.mKeySetManagerService.assertScannedPackageValid(pkg);
        synchronized (this.mPackages) {
            if (!pkg.packageName.equals(PLATFORM_PACKAGE_NAME) || this.mAndroidApplication == null) {
                if (this.mPackages.containsKey(pkg.packageName)) {
                    throw new PackageManagerException(-5, "Application package " + pkg.packageName + " already installed.  Skipping duplicate.");
                }
                int i;
                if (pkg.applicationInfo.isStaticSharedLibrary()) {
                    if (this.mPackages.containsKey(pkg.manifestPackageName)) {
                        throw new PackageManagerException("Duplicate static shared lib provider package");
                    } else if (pkg.applicationInfo.targetSdkVersion < 26) {
                        throw new PackageManagerException("Packages declaring static-shared libs must target O SDK or higher");
                    } else if ((131072 & scanFlags) != 0) {
                        throw new PackageManagerException("Packages declaring static-shared libs cannot be instant apps");
                    } else if (!ArrayUtils.isEmpty(pkg.mOriginalPackages)) {
                        throw new PackageManagerException("Packages declaring static-shared libs cannot be renamed");
                    } else if (!ArrayUtils.isEmpty(pkg.childPackages)) {
                        throw new PackageManagerException("Packages declaring static-shared libs cannot have child packages");
                    } else if (!ArrayUtils.isEmpty(pkg.libraryNames)) {
                        throw new PackageManagerException("Packages declaring static-shared libs cannot declare dynamic libs");
                    } else if (pkg.mSharedUserId != null) {
                        throw new PackageManagerException("Packages declaring static-shared libs cannot declare shared users");
                    } else if (!pkg.activities.isEmpty()) {
                        throw new PackageManagerException("Static shared libs cannot declare activities");
                    } else if (!pkg.services.isEmpty()) {
                        throw new PackageManagerException("Static shared libs cannot declare services");
                    } else if (!pkg.providers.isEmpty()) {
                        throw new PackageManagerException("Static shared libs cannot declare content providers");
                    } else if (!pkg.receivers.isEmpty()) {
                        throw new PackageManagerException("Static shared libs cannot declare broadcast receivers");
                    } else if (!pkg.permissionGroups.isEmpty()) {
                        throw new PackageManagerException("Static shared libs cannot declare permission groups");
                    } else if (!pkg.permissions.isEmpty()) {
                        throw new PackageManagerException("Static shared libs cannot declare permissions");
                    } else if (pkg.protectedBroadcasts != null) {
                        throw new PackageManagerException("Static shared libs cannot declare protected broadcasts");
                    } else if (pkg.mOverlayTarget != null) {
                        throw new PackageManagerException("Static shared libs cannot be overlay targets");
                    } else {
                        int minVersionCode = Integer.MIN_VALUE;
                        int maxVersionCode = Integer.MAX_VALUE;
                        SparseArray<SharedLibraryEntry> versionedLib = (SparseArray) this.mSharedLibraries.get(pkg.staticSharedLibName);
                        if (versionedLib != null) {
                            int versionCount = versionedLib.size();
                            for (i = 0; i < versionCount; i++) {
                                SharedLibraryInfo libInfo = ((SharedLibraryEntry) versionedLib.valueAt(i)).info;
                                int libVersionCode = libInfo.getDeclaringPackage().getVersionCode();
                                if (libInfo.getVersion() >= pkg.staticSharedLibVersion) {
                                    if (libInfo.getVersion() <= pkg.staticSharedLibVersion) {
                                        maxVersionCode = libVersionCode;
                                        minVersionCode = libVersionCode;
                                        break;
                                    }
                                    maxVersionCode = Math.min(maxVersionCode, libVersionCode - 1);
                                } else {
                                    minVersionCode = Math.max(minVersionCode, libVersionCode + 1);
                                }
                            }
                        }
                        if (pkg.mVersionCode < minVersionCode || pkg.mVersionCode > maxVersionCode) {
                            throw new PackageManagerException("Static shared lib version codes must be ordered as lib versions");
                        }
                    }
                }
                if (!(pkg.childPackages == null || (pkg.childPackages.isEmpty() ^ 1) == 0)) {
                    if ((policyFlags & 128) == 0) {
                        throw new PackageManagerException("Only privileged apps can add child packages. Ignoring package " + pkg.packageName);
                    }
                    int childCount = pkg.childPackages.size();
                    for (i = 0; i < childCount; i++) {
                        if (this.mSettings.hasOtherDisabledSystemPkgWithChildLPr(pkg.packageName, ((Package) pkg.childPackages.get(i)).packageName)) {
                            throw new PackageManagerException("Can't override child of another disabled app. Ignoring package " + pkg.packageName);
                        }
                    }
                }
                if ((scanFlags & 1024) != 0) {
                    if (this.mExpectingBetter.containsKey(pkg.packageName)) {
                        logCriticalInfo(5, "Relax SCAN_REQUIRE_KNOWN requirement for package " + pkg.packageName);
                    } else {
                        PackageSetting known = this.mSettings.getPackageLPr(pkg.packageName);
                        if (known != null) {
                            if (DEBUG_PACKAGE_SCANNING) {
                                Log.d(TAG, "Examining " + pkg.codePath + " and requiring known paths " + known.codePathString + " & " + known.resourcePathString);
                            }
                            if (pkg.applicationInfo.getCodePath().equals(known.codePathString)) {
                            }
                            throw new PackageManagerException(-23, "Application package " + pkg.packageName + " found at " + pkg.applicationInfo.getCodePath() + " but expected at " + known.codePathString + "; ignoring.");
                        }
                        Log.d(TAG, "assertPackageIsValid ignoring" + pkg.packageName);
                    }
                }
                if ((scanFlags & 16) != 0) {
                    int N = pkg.providers.size();
                    for (i = 0; i < N; i++) {
                        Provider p = (Provider) pkg.providers.get(i);
                        if (p.info.authority != null) {
                            String[] names = p.info.authority.split(";");
                            int j = 0;
                            while (j < names.length) {
                                if (this.mProvidersByAuthority.containsKey(names[j])) {
                                    Provider other = (Provider) this.mProvidersByAuthority.get(names[j]);
                                    String otherPackageName = (other == null || other.getComponentName() == null) ? "?" : other.getComponentName().getPackageName();
                                    throw new PackageManagerException(-13, "Can't install because provider name " + names[j] + " (in package " + pkg.applicationInfo.packageName + ") is already used by " + otherPackageName);
                                } else if (EXP_VERSION && "com.qti.atfwd.gf_stub_P00".equalsIgnoreCase(names[j])) {
                                    throw new PackageManagerException(-2, "Can't install because this is very risky");
                                } else {
                                    j++;
                                }
                            }
                            continue;
                        }
                    }
                }
            } else {
                Slog.w(TAG, "*************************************************");
                Slog.w(TAG, "Core android package being redefined.  Skipping.");
                Slog.w(TAG, " codePath=" + pkg.codePath);
                Slog.w(TAG, "*************************************************");
                throw new PackageManagerException(-5, "Core android package being redefined.  Skipping.");
            }
        }
    }

    private boolean addSharedLibraryLPw(String path, String apk, String name, int version, int type, String declaringPackageName, int declaringVersionCode) {
        SparseArray<SharedLibraryEntry> versionedLib = (SparseArray) this.mSharedLibraries.get(name);
        if (versionedLib == null) {
            versionedLib = new SparseArray();
            this.mSharedLibraries.put(name, versionedLib);
            if (type == 2) {
                this.mStaticLibsByDeclaringPackage.put(declaringPackageName, versionedLib);
            }
        } else if (versionedLib.indexOfKey(version) >= 0) {
            return false;
        }
        versionedLib.put(version, new SharedLibraryEntry(path, apk, name, version, type, declaringPackageName, declaringVersionCode));
        return true;
    }

    private boolean removeSharedLibraryLPw(String name, int version) {
        SparseArray<SharedLibraryEntry> versionedLib = (SparseArray) this.mSharedLibraries.get(name);
        if (versionedLib == null) {
            return false;
        }
        int libIdx = versionedLib.indexOfKey(version);
        if (libIdx < 0) {
            return false;
        }
        SharedLibraryEntry libEntry = (SharedLibraryEntry) versionedLib.valueAt(libIdx);
        versionedLib.remove(version);
        if (versionedLib.size() <= 0) {
            this.mSharedLibraries.remove(name);
            if (libEntry.info.getType() == 2) {
                this.mStaticLibsByDeclaringPackage.remove(libEntry.info.getDeclaringPackage().getPackageName());
            }
        }
        return true;
    }

    private void commitPackageSettings(android.content.pm.PackageParser.Package r42, com.android.server.pm.PackageSetting r43, android.os.UserHandle r44, int r45, boolean r46) throws com.android.server.pm.PackageManagerException {
        /* JADX: method processing error */
/*
Error: jadx.core.utils.exceptions.JadxRuntimeException: Unknown predecessor block by arg (r36_2 'r' java.lang.StringBuilder) in PHI: PHI: (r36_3 'r' java.lang.StringBuilder) = (r36_2 'r' java.lang.StringBuilder), (r36_1 'r' java.lang.StringBuilder) binds: {(r36_2 'r' java.lang.StringBuilder)=B:127:0x047b, (r36_1 'r' java.lang.StringBuilder)=B:130:0x0493}
	at jadx.core.dex.instructions.PhiInsn.replaceArg(PhiInsn.java:78)
	at jadx.core.dex.visitors.ModVisitor.processInvoke(ModVisitor.java:222)
	at jadx.core.dex.visitors.ModVisitor.replaceStep(ModVisitor.java:83)
	at jadx.core.dex.visitors.ModVisitor.visit(ModVisitor.java:68)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:27)
	at jadx.core.dex.visitors.DepthTraversal.lambda$visit$1(DepthTraversal.java:14)
	at java.util.ArrayList.forEach(ArrayList.java:1251)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:14)
	at jadx.core.ProcessClass.process(ProcessClass.java:32)
	at jadx.core.ProcessClass.lambda$processDependencies$0(ProcessClass.java:51)
	at java.lang.Iterable.forEach(Iterable.java:75)
	at jadx.core.ProcessClass.processDependencies(ProcessClass.java:51)
	at jadx.core.ProcessClass.process(ProcessClass.java:37)
	at jadx.api.JadxDecompiler.processClass(JadxDecompiler.java:286)
	at jadx.api.JavaClass.decompile(JavaClass.java:62)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
*/
        /*
        r41 = this;
        r0 = r42;
        r0 = r0.packageName;
        r35 = r0;
        r0 = r41;
        r2 = r0.mCustomResolverComponentName;
        if (r2 == 0) goto L_0x0021;
    L_0x000c:
        r0 = r41;
        r2 = r0.mCustomResolverComponentName;
        r2 = r2.getPackageName();
        r0 = r42;
        r3 = r0.packageName;
        r2 = r2.equals(r3);
        if (r2 == 0) goto L_0x0021;
    L_0x001e:
        r41.setUpCustomResolverActivity(r42);
    L_0x0021:
        r0 = r42;
        r2 = r0.packageName;
        r3 = "android";
        r2 = r2.equals(r3);
        if (r2 == 0) goto L_0x00f1;
    L_0x002e:
        r0 = r41;
        r3 = r0.mPackages;
        monitor-enter(r3);
        r0 = r45;
        r2 = r0 & 8192;
        if (r2 != 0) goto L_0x00f0;
    L_0x0039:
        r0 = r42;	 Catch:{ all -> 0x01de }
        r1 = r41;	 Catch:{ all -> 0x01de }
        r1.mPlatformPackage = r0;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r2 = r0.mSdkVersion;	 Catch:{ all -> 0x01de }
        r0 = r42;	 Catch:{ all -> 0x01de }
        r0.mVersionCode = r2;	 Catch:{ all -> 0x01de }
        r0 = r42;	 Catch:{ all -> 0x01de }
        r2 = r0.applicationInfo;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r0.mAndroidApplication = r2;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r2 = r0.mResolverReplaced;	 Catch:{ all -> 0x01de }
        if (r2 != 0) goto L_0x00f0;	 Catch:{ all -> 0x01de }
    L_0x0055:
        r0 = r41;	 Catch:{ all -> 0x01de }
        r2 = r0.mResolveActivity;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r4 = r0.mAndroidApplication;	 Catch:{ all -> 0x01de }
        r2.applicationInfo = r4;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r2 = r0.mResolveActivity;	 Catch:{ all -> 0x01de }
        r4 = com.android.internal.app.ResolverActivity.class;	 Catch:{ all -> 0x01de }
        r4 = r4.getName();	 Catch:{ all -> 0x01de }
        r2.name = r4;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r2 = r0.mResolveActivity;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r4 = r0.mAndroidApplication;	 Catch:{ all -> 0x01de }
        r4 = r4.packageName;	 Catch:{ all -> 0x01de }
        r2.packageName = r4;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r2 = r0.mResolveActivity;	 Catch:{ all -> 0x01de }
        r4 = "system:ui";	 Catch:{ all -> 0x01de }
        r2.processName = r4;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r2 = r0.mResolveActivity;	 Catch:{ all -> 0x01de }
        r4 = 0;	 Catch:{ all -> 0x01de }
        r2.launchMode = r4;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r2 = r0.mResolveActivity;	 Catch:{ all -> 0x01de }
        r4 = 3;	 Catch:{ all -> 0x01de }
        r2.documentLaunchMode = r4;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r2 = r0.mResolveActivity;	 Catch:{ all -> 0x01de }
        r4 = 32;	 Catch:{ all -> 0x01de }
        r2.flags = r4;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r2 = r0.mResolveActivity;	 Catch:{ all -> 0x01de }
        r4 = 16974374; // 0x1030226 float:2.4062441E-38 double:8.386455E-317;	 Catch:{ all -> 0x01de }
        r2.theme = r4;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r2 = r0.mResolveActivity;	 Catch:{ all -> 0x01de }
        r4 = 1;	 Catch:{ all -> 0x01de }
        r2.exported = r4;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r2 = r0.mResolveActivity;	 Catch:{ all -> 0x01de }
        r4 = 1;	 Catch:{ all -> 0x01de }
        r2.enabled = r4;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r2 = r0.mResolveActivity;	 Catch:{ all -> 0x01de }
        r4 = 2;	 Catch:{ all -> 0x01de }
        r2.resizeMode = r4;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r2 = r0.mResolveActivity;	 Catch:{ all -> 0x01de }
        r4 = 3504; // 0xdb0 float:4.91E-42 double:1.731E-320;	 Catch:{ all -> 0x01de }
        r2.configChanges = r4;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r2 = r0.mResolveInfo;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r4 = r0.mResolveActivity;	 Catch:{ all -> 0x01de }
        r2.activityInfo = r4;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r2 = r0.mResolveInfo;	 Catch:{ all -> 0x01de }
        r4 = 0;	 Catch:{ all -> 0x01de }
        r2.priority = r4;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r2 = r0.mResolveInfo;	 Catch:{ all -> 0x01de }
        r4 = 0;	 Catch:{ all -> 0x01de }
        r2.preferredOrder = r4;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r2 = r0.mResolveInfo;	 Catch:{ all -> 0x01de }
        r4 = 0;	 Catch:{ all -> 0x01de }
        r2.match = r4;	 Catch:{ all -> 0x01de }
        r2 = new android.content.ComponentName;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r4 = r0.mAndroidApplication;	 Catch:{ all -> 0x01de }
        r4 = r4.packageName;	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r6 = r0.mResolveActivity;	 Catch:{ all -> 0x01de }
        r6 = r6.name;	 Catch:{ all -> 0x01de }
        r2.<init>(r4, r6);	 Catch:{ all -> 0x01de }
        r0 = r41;	 Catch:{ all -> 0x01de }
        r0.mResolveComponentName = r2;	 Catch:{ all -> 0x01de }
    L_0x00f0:
        monitor-exit(r3);
    L_0x00f1:
        r15 = 0;
        r0 = r41;
        r0 = r0.mPackages;
        r40 = r0;
        monitor-enter(r40);
        r20 = 0;
        r0 = r42;	 Catch:{ all -> 0x0217 }
        r2 = r0.staticSharedLibName;	 Catch:{ all -> 0x0217 }
        if (r2 == 0) goto L_0x0121;	 Catch:{ all -> 0x0217 }
    L_0x0101:
        r0 = r42;	 Catch:{ all -> 0x0217 }
        r4 = r0.packageName;	 Catch:{ all -> 0x0217 }
        r0 = r42;	 Catch:{ all -> 0x0217 }
        r5 = r0.staticSharedLibName;	 Catch:{ all -> 0x0217 }
        r0 = r42;	 Catch:{ all -> 0x0217 }
        r6 = r0.staticSharedLibVersion;	 Catch:{ all -> 0x0217 }
        r0 = r42;	 Catch:{ all -> 0x0217 }
        r8 = r0.manifestPackageName;	 Catch:{ all -> 0x0217 }
        r0 = r42;	 Catch:{ all -> 0x0217 }
        r9 = r0.mVersionCode;	 Catch:{ all -> 0x0217 }
        r3 = 0;	 Catch:{ all -> 0x0217 }
        r7 = 2;	 Catch:{ all -> 0x0217 }
        r2 = r41;	 Catch:{ all -> 0x0217 }
        r2 = r2.addSharedLibraryLPw(r3, r4, r5, r6, r7, r8, r9);	 Catch:{ all -> 0x0217 }
        if (r2 == 0) goto L_0x01e1;	 Catch:{ all -> 0x0217 }
    L_0x011f:
        r20 = 1;	 Catch:{ all -> 0x0217 }
    L_0x0121:
        if (r20 != 0) goto L_0x025a;	 Catch:{ all -> 0x0217 }
    L_0x0123:
        r0 = r42;	 Catch:{ all -> 0x0217 }
        r2 = r0.applicationInfo;	 Catch:{ all -> 0x0217 }
        r2 = r2.flags;	 Catch:{ all -> 0x0217 }
        r2 = r2 & 1;	 Catch:{ all -> 0x0217 }
        if (r2 == 0) goto L_0x025a;	 Catch:{ all -> 0x0217 }
    L_0x012d:
        r0 = r42;	 Catch:{ all -> 0x0217 }
        r2 = r0.libraryNames;	 Catch:{ all -> 0x0217 }
        if (r2 == 0) goto L_0x025a;	 Catch:{ all -> 0x0217 }
    L_0x0133:
        r21 = 0;	 Catch:{ all -> 0x0217 }
    L_0x0135:
        r0 = r42;	 Catch:{ all -> 0x0217 }
        r2 = r0.libraryNames;	 Catch:{ all -> 0x0217 }
        r2 = r2.size();	 Catch:{ all -> 0x0217 }
        r0 = r21;	 Catch:{ all -> 0x0217 }
        if (r0 >= r2) goto L_0x0252;	 Catch:{ all -> 0x0217 }
    L_0x0141:
        r0 = r42;	 Catch:{ all -> 0x0217 }
        r2 = r0.libraryNames;	 Catch:{ all -> 0x0217 }
        r0 = r21;	 Catch:{ all -> 0x0217 }
        r5 = r2.get(r0);	 Catch:{ all -> 0x0217 }
        r5 = (java.lang.String) r5;	 Catch:{ all -> 0x0217 }
        r13 = 0;	 Catch:{ all -> 0x0217 }
        r2 = r42.isUpdatedSystemApp();	 Catch:{ all -> 0x0217 }
        if (r2 == 0) goto L_0x021e;	 Catch:{ all -> 0x0217 }
    L_0x0154:
        r0 = r41;	 Catch:{ all -> 0x0217 }
        r2 = r0.mSettings;	 Catch:{ all -> 0x0217 }
        r0 = r42;	 Catch:{ all -> 0x0217 }
        r3 = r0.packageName;	 Catch:{ all -> 0x0217 }
        r38 = r2.getDisabledSystemPkgLPr(r3);	 Catch:{ all -> 0x0217 }
        r0 = r38;	 Catch:{ all -> 0x0217 }
        r2 = r0.pkg;	 Catch:{ all -> 0x0217 }
        if (r2 == 0) goto L_0x0191;	 Catch:{ all -> 0x0217 }
    L_0x0166:
        r0 = r38;	 Catch:{ all -> 0x0217 }
        r2 = r0.pkg;	 Catch:{ all -> 0x0217 }
        r2 = r2.libraryNames;	 Catch:{ all -> 0x0217 }
        if (r2 == 0) goto L_0x0191;	 Catch:{ all -> 0x0217 }
    L_0x016e:
        r25 = 0;	 Catch:{ all -> 0x0217 }
    L_0x0170:
        r0 = r38;	 Catch:{ all -> 0x0217 }
        r2 = r0.pkg;	 Catch:{ all -> 0x0217 }
        r2 = r2.libraryNames;	 Catch:{ all -> 0x0217 }
        r2 = r2.size();	 Catch:{ all -> 0x0217 }
        r0 = r25;	 Catch:{ all -> 0x0217 }
        if (r0 >= r2) goto L_0x0191;	 Catch:{ all -> 0x0217 }
    L_0x017e:
        r0 = r38;	 Catch:{ all -> 0x0217 }
        r2 = r0.pkg;	 Catch:{ all -> 0x0217 }
        r2 = r2.libraryNames;	 Catch:{ all -> 0x0217 }
        r0 = r25;	 Catch:{ all -> 0x0217 }
        r2 = r2.get(r0);	 Catch:{ all -> 0x0217 }
        r2 = r5.equals(r2);	 Catch:{ all -> 0x0217 }
        if (r2 == 0) goto L_0x021a;	 Catch:{ all -> 0x0217 }
    L_0x0190:
        r13 = 1;	 Catch:{ all -> 0x0217 }
    L_0x0191:
        if (r13 == 0) goto L_0x0221;	 Catch:{ all -> 0x0217 }
    L_0x0193:
        r0 = r42;	 Catch:{ all -> 0x0217 }
        r4 = r0.packageName;	 Catch:{ all -> 0x0217 }
        r0 = r42;	 Catch:{ all -> 0x0217 }
        r8 = r0.packageName;	 Catch:{ all -> 0x0217 }
        r0 = r42;	 Catch:{ all -> 0x0217 }
        r9 = r0.mVersionCode;	 Catch:{ all -> 0x0217 }
        r3 = 0;	 Catch:{ all -> 0x0217 }
        r6 = -1;	 Catch:{ all -> 0x0217 }
        r7 = 1;	 Catch:{ all -> 0x0217 }
        r2 = r41;	 Catch:{ all -> 0x0217 }
        r2 = r2.addSharedLibraryLPw(r3, r4, r5, r6, r7, r8, r9);	 Catch:{ all -> 0x0217 }
        if (r2 != 0) goto L_0x01da;	 Catch:{ all -> 0x0217 }
    L_0x01aa:
        r2 = "PackageManager";	 Catch:{ all -> 0x0217 }
        r3 = new java.lang.StringBuilder;	 Catch:{ all -> 0x0217 }
        r3.<init>();	 Catch:{ all -> 0x0217 }
        r4 = "Package ";	 Catch:{ all -> 0x0217 }
        r3 = r3.append(r4);	 Catch:{ all -> 0x0217 }
        r0 = r42;	 Catch:{ all -> 0x0217 }
        r4 = r0.packageName;	 Catch:{ all -> 0x0217 }
        r3 = r3.append(r4);	 Catch:{ all -> 0x0217 }
        r4 = " library ";	 Catch:{ all -> 0x0217 }
        r3 = r3.append(r4);	 Catch:{ all -> 0x0217 }
        r3 = r3.append(r5);	 Catch:{ all -> 0x0217 }
        r4 = " already exists; skipping";	 Catch:{ all -> 0x0217 }
        r3 = r3.append(r4);	 Catch:{ all -> 0x0217 }
        r3 = r3.toString();	 Catch:{ all -> 0x0217 }
        android.util.Slog.w(r2, r3);	 Catch:{ all -> 0x0217 }
    L_0x01da:
        r21 = r21 + 1;
        goto L_0x0135;
    L_0x01de:
        r2 = move-exception;
        monitor-exit(r3);
        throw r2;
    L_0x01e1:
        r2 = "PackageManager";	 Catch:{ all -> 0x0217 }
        r3 = new java.lang.StringBuilder;	 Catch:{ all -> 0x0217 }
        r3.<init>();	 Catch:{ all -> 0x0217 }
        r4 = "Package ";	 Catch:{ all -> 0x0217 }
        r3 = r3.append(r4);	 Catch:{ all -> 0x0217 }
        r0 = r42;	 Catch:{ all -> 0x0217 }
        r4 = r0.packageName;	 Catch:{ all -> 0x0217 }
        r3 = r3.append(r4);	 Catch:{ all -> 0x0217 }
        r4 = " library ";	 Catch:{ all -> 0x0217 }
        r3 = r3.append(r4);	 Catch:{ all -> 0x0217 }
        r0 = r42;	 Catch:{ all -> 0x0217 }
        r4 = r0.staticSharedLibName;	 Catch:{ all -> 0x0217 }
        r3 = r3.append(r4);	 Catch:{ all -> 0x0217 }
        r4 = " already exists; skipping";	 Catch:{ all -> 0x0217 }
        r3 = r3.append(r4);	 Catch:{ all -> 0x0217 }
        r3 = r3.toString();	 Catch:{ all -> 0x0217 }
        android.util.Slog.w(r2, r3);	 Catch:{ all -> 0x0217 }
        goto L_0x0121;
    L_0x0217:
        r2 = move-exception;
        monitor-exit(r40);
        throw r2;
    L_0x021a:
        r25 = r25 + 1;
        goto L_0x0170;
    L_0x021e:
        r13 = 1;
        goto L_0x0191;
    L_0x0221:
        r2 = "PackageManager";	 Catch:{ all -> 0x0217 }
        r3 = new java.lang.StringBuilder;	 Catch:{ all -> 0x0217 }
        r3.<init>();	 Catch:{ all -> 0x0217 }
        r4 = "Package ";	 Catch:{ all -> 0x0217 }
        r3 = r3.append(r4);	 Catch:{ all -> 0x0217 }
        r0 = r42;	 Catch:{ all -> 0x0217 }
        r4 = r0.packageName;	 Catch:{ all -> 0x0217 }
        r3 = r3.append(r4);	 Catch:{ all -> 0x0217 }
        r4 = " declares lib ";	 Catch:{ all -> 0x0217 }
        r3 = r3.append(r4);	 Catch:{ all -> 0x0217 }
        r3 = r3.append(r5);	 Catch:{ all -> 0x0217 }
        r4 = " that is not declared on system image; skipping";	 Catch:{ all -> 0x0217 }
        r3 = r3.append(r4);	 Catch:{ all -> 0x0217 }
        r3 = r3.toString();	 Catch:{ all -> 0x0217 }
        android.util.Slog.w(r2, r3);	 Catch:{ all -> 0x0217 }
        goto L_0x01da;	 Catch:{ all -> 0x0217 }
    L_0x0252:
        r2 = r45 & 64;	 Catch:{ all -> 0x0217 }
        if (r2 != 0) goto L_0x025a;	 Catch:{ all -> 0x0217 }
    L_0x0256:
        r15 = r41.updateAllSharedLibrariesLPw(r42);	 Catch:{ all -> 0x0217 }
    L_0x025a:
        monitor-exit(r40);
        r2 = r45 & 64;
        if (r2 == 0) goto L_0x028a;
    L_0x025f:
        if (r15 == 0) goto L_0x029f;
    L_0x0261:
        r21 = 0;
    L_0x0263:
        r2 = r15.size();
        r0 = r21;
        if (r0 >= r2) goto L_0x029f;
    L_0x026b:
        r0 = r21;
        r16 = r15.get(r0);
        r16 = (android.content.pm.PackageParser.Package) r16;
        r0 = r16;
        r2 = r0.applicationInfo;
        r2 = r2.packageName;
        r0 = r16;
        r3 = r0.applicationInfo;
        r3 = r3.uid;
        r4 = "update lib";
        r0 = r41;
        r0.killApplication(r2, r3, r4);
        r21 = r21 + 1;
        goto L_0x0263;
    L_0x028a:
        r0 = r45;
        r2 = r0 & 16384;
        if (r2 != 0) goto L_0x025f;
    L_0x0290:
        r2 = 32768; // 0x8000 float:4.5918E-41 double:1.61895E-319;
        r2 = r2 & r45;
        if (r2 != 0) goto L_0x025f;
    L_0x0297:
        r0 = r41;
        r1 = r35;
        r0.checkPackageFrozen(r1);
        goto L_0x025f;
    L_0x029f:
        r2 = "updateSettings";
        r6 = 262144; // 0x40000 float:3.67342E-40 double:1.295163E-318;
        android.os.Trace.traceBegin(r6, r2);
        r0 = r41;
        r3 = r0.mPackages;
        monitor-enter(r3);
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r2 = r0.mSettings;	 Catch:{ all -> 0x02ed }
        r0 = r43;	 Catch:{ all -> 0x02ed }
        r1 = r42;	 Catch:{ all -> 0x02ed }
        r2.insertPackageSettingLPw(r0, r1);	 Catch:{ all -> 0x02ed }
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r2 = r0.mPackages;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r4 = r4.packageName;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2.put(r4, r0);	 Catch:{ all -> 0x02ed }
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r2 = r0.mSettings;	 Catch:{ all -> 0x02ed }
        r2 = r2.mPackagesToBeCleaned;	 Catch:{ all -> 0x02ed }
        r24 = r2.iterator();	 Catch:{ all -> 0x02ed }
    L_0x02d1:
        r2 = r24.hasNext();	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x02f0;	 Catch:{ all -> 0x02ed }
    L_0x02d7:
        r23 = r24.next();	 Catch:{ all -> 0x02ed }
        r23 = (android.content.pm.PackageCleanItem) r23;	 Catch:{ all -> 0x02ed }
        r0 = r23;	 Catch:{ all -> 0x02ed }
        r2 = r0.packageName;	 Catch:{ all -> 0x02ed }
        r0 = r35;	 Catch:{ all -> 0x02ed }
        r2 = r0.equals(r2);	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x02d1;	 Catch:{ all -> 0x02ed }
    L_0x02e9:
        r24.remove();	 Catch:{ all -> 0x02ed }
        goto L_0x02d1;
    L_0x02ed:
        r2 = move-exception;
        monitor-exit(r3);
        throw r2;
    L_0x02f0:
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r2 = r0.mSettings;	 Catch:{ all -> 0x02ed }
        r0 = r2.mKeySetManagerService;	 Catch:{ all -> 0x02ed }
        r26 = r0;	 Catch:{ all -> 0x02ed }
        r0 = r26;	 Catch:{ all -> 0x02ed }
        r1 = r42;	 Catch:{ all -> 0x02ed }
        r0.addScannedPackageLPw(r1);	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.providers;	 Catch:{ all -> 0x02ed }
        r10 = r2.size();	 Catch:{ all -> 0x02ed }
        r36 = 0;	 Catch:{ all -> 0x02ed }
        r21 = 0;	 Catch:{ all -> 0x02ed }
    L_0x030b:
        r0 = r21;	 Catch:{ all -> 0x02ed }
        if (r0 >= r10) goto L_0x049b;	 Catch:{ all -> 0x02ed }
    L_0x030f:
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.providers;	 Catch:{ all -> 0x02ed }
        r0 = r21;	 Catch:{ all -> 0x02ed }
        r31 = r2.get(r0);	 Catch:{ all -> 0x02ed }
        r31 = (android.content.pm.PackageParser.Provider) r31;	 Catch:{ all -> 0x02ed }
        r0 = r31;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r4 = r4.processName;	 Catch:{ all -> 0x02ed }
        r0 = r31;	 Catch:{ all -> 0x02ed }
        r6 = r0.info;	 Catch:{ all -> 0x02ed }
        r6 = r6.processName;	 Catch:{ all -> 0x02ed }
        r4 = fixProcessName(r4, r6);	 Catch:{ all -> 0x02ed }
        r2.processName = r4;	 Catch:{ all -> 0x02ed }
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r2 = r0.mProviders;	 Catch:{ all -> 0x02ed }
        r0 = r31;	 Catch:{ all -> 0x02ed }
        r2.addProvider(r0);	 Catch:{ all -> 0x02ed }
        r0 = r31;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.isSyncable;	 Catch:{ all -> 0x02ed }
        r0 = r31;	 Catch:{ all -> 0x02ed }
        r0.syncable = r2;	 Catch:{ all -> 0x02ed }
        r0 = r31;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.authority;	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x0477;	 Catch:{ all -> 0x02ed }
    L_0x034c:
        r0 = r31;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.authority;	 Catch:{ all -> 0x02ed }
        r4 = ";";	 Catch:{ all -> 0x02ed }
        r28 = r2.split(r4);	 Catch:{ all -> 0x02ed }
        r0 = r31;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r4 = 0;	 Catch:{ all -> 0x02ed }
        r2.authority = r4;	 Catch:{ all -> 0x02ed }
        r25 = 0;	 Catch:{ all -> 0x02ed }
        r32 = r31;	 Catch:{ all -> 0x02ed }
    L_0x0364:
        r0 = r28;	 Catch:{ all -> 0x02ed }
        r2 = r0.length;	 Catch:{ all -> 0x02ed }
        r0 = r25;	 Catch:{ all -> 0x02ed }
        if (r0 >= r2) goto L_0x0475;	 Catch:{ all -> 0x02ed }
    L_0x036b:
        r2 = 1;	 Catch:{ all -> 0x02ed }
        r0 = r25;	 Catch:{ all -> 0x02ed }
        if (r0 != r2) goto L_0x03f1;	 Catch:{ all -> 0x02ed }
    L_0x0370:
        r0 = r32;	 Catch:{ all -> 0x02ed }
        r2 = r0.syncable;	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x0b6a;	 Catch:{ all -> 0x02ed }
    L_0x0376:
        r31 = new android.content.pm.PackageParser$Provider;	 Catch:{ all -> 0x02ed }
        r31.<init>(r32);	 Catch:{ all -> 0x02ed }
        r2 = 0;	 Catch:{ all -> 0x02ed }
        r0 = r31;	 Catch:{ all -> 0x02ed }
        r0.syncable = r2;	 Catch:{ all -> 0x02ed }
    L_0x0380:
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r2 = r0.mProvidersByAuthority;	 Catch:{ all -> 0x02ed }
        r4 = r28[r25];	 Catch:{ all -> 0x02ed }
        r2 = r2.containsKey(r4);	 Catch:{ all -> 0x02ed }
        if (r2 != 0) goto L_0x041b;	 Catch:{ all -> 0x02ed }
    L_0x038c:
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r2 = r0.mProvidersByAuthority;	 Catch:{ all -> 0x02ed }
        r4 = r28[r25];	 Catch:{ all -> 0x02ed }
        r0 = r31;	 Catch:{ all -> 0x02ed }
        r2.put(r4, r0);	 Catch:{ all -> 0x02ed }
        r0 = r31;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.authority;	 Catch:{ all -> 0x02ed }
        if (r2 != 0) goto L_0x03f4;	 Catch:{ all -> 0x02ed }
    L_0x039f:
        r0 = r31;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r4 = r28[r25];	 Catch:{ all -> 0x02ed }
        r2.authority = r4;	 Catch:{ all -> 0x02ed }
    L_0x03a7:
        r2 = DEBUG_PACKAGE_SCANNING;	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x03eb;	 Catch:{ all -> 0x02ed }
    L_0x03ab:
        if (r46 == 0) goto L_0x03eb;	 Catch:{ all -> 0x02ed }
    L_0x03ad:
        r2 = "PackageManager";	 Catch:{ all -> 0x02ed }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r4.<init>();	 Catch:{ all -> 0x02ed }
        r6 = "Registered content provider: ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = r28[r25];	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = ", className = ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r31;	 Catch:{ all -> 0x02ed }
        r6 = r0.info;	 Catch:{ all -> 0x02ed }
        r6 = r6.name;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = ", isSyncable = ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r31;	 Catch:{ all -> 0x02ed }
        r6 = r0.info;	 Catch:{ all -> 0x02ed }
        r6 = r6.isSyncable;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r4 = r4.toString();	 Catch:{ all -> 0x02ed }
        android.util.Log.d(r2, r4);	 Catch:{ all -> 0x02ed }
    L_0x03eb:
        r25 = r25 + 1;	 Catch:{ all -> 0x02ed }
        r32 = r31;	 Catch:{ all -> 0x02ed }
        goto L_0x0364;	 Catch:{ all -> 0x02ed }
    L_0x03f1:
        r31 = r32;	 Catch:{ all -> 0x02ed }
        goto L_0x0380;	 Catch:{ all -> 0x02ed }
    L_0x03f4:
        r0 = r31;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r4.<init>();	 Catch:{ all -> 0x02ed }
        r0 = r31;	 Catch:{ all -> 0x02ed }
        r6 = r0.info;	 Catch:{ all -> 0x02ed }
        r6 = r6.authority;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = ";";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = r28[r25];	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r4 = r4.toString();	 Catch:{ all -> 0x02ed }
        r2.authority = r4;	 Catch:{ all -> 0x02ed }
        goto L_0x03a7;	 Catch:{ all -> 0x02ed }
    L_0x041b:
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r2 = r0.mProvidersByAuthority;	 Catch:{ all -> 0x02ed }
        r4 = r28[r25];	 Catch:{ all -> 0x02ed }
        r29 = r2.get(r4);	 Catch:{ all -> 0x02ed }
        r29 = (android.content.pm.PackageParser.Provider) r29;	 Catch:{ all -> 0x02ed }
        r4 = "PackageManager";	 Catch:{ all -> 0x02ed }
        r2 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r2.<init>();	 Catch:{ all -> 0x02ed }
        r6 = "Skipping provider name ";	 Catch:{ all -> 0x02ed }
        r2 = r2.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = r28[r25];	 Catch:{ all -> 0x02ed }
        r2 = r2.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = " (in package ";	 Catch:{ all -> 0x02ed }
        r2 = r2.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r6 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r6 = r6.packageName;	 Catch:{ all -> 0x02ed }
        r2 = r2.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = "): name already used by ";	 Catch:{ all -> 0x02ed }
        r6 = r2.append(r6);	 Catch:{ all -> 0x02ed }
        if (r29 == 0) goto L_0x0471;	 Catch:{ all -> 0x02ed }
    L_0x0456:
        r2 = r29.getComponentName();	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x0471;	 Catch:{ all -> 0x02ed }
    L_0x045c:
        r2 = r29.getComponentName();	 Catch:{ all -> 0x02ed }
        r2 = r2.getPackageName();	 Catch:{ all -> 0x02ed }
    L_0x0464:
        r2 = r6.append(r2);	 Catch:{ all -> 0x02ed }
        r2 = r2.toString();	 Catch:{ all -> 0x02ed }
        android.util.Slog.w(r4, r2);	 Catch:{ all -> 0x02ed }
        goto L_0x03eb;	 Catch:{ all -> 0x02ed }
    L_0x0471:
        r2 = "?";	 Catch:{ all -> 0x02ed }
        goto L_0x0464;	 Catch:{ all -> 0x02ed }
    L_0x0475:
        r31 = r32;	 Catch:{ all -> 0x02ed }
    L_0x0477:
        if (r46 == 0) goto L_0x048f;	 Catch:{ all -> 0x02ed }
    L_0x0479:
        if (r36 != 0) goto L_0x0493;	 Catch:{ all -> 0x02ed }
    L_0x047b:
        r36 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r2 = 256; // 0x100 float:3.59E-43 double:1.265E-321;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.<init>(r2);	 Catch:{ all -> 0x02ed }
    L_0x0484:
        r0 = r31;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.name;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
    L_0x048f:
        r21 = r21 + 1;	 Catch:{ all -> 0x02ed }
        goto L_0x030b;	 Catch:{ all -> 0x02ed }
    L_0x0493:
        r2 = 32;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
        goto L_0x0484;	 Catch:{ all -> 0x02ed }
    L_0x049b:
        if (r36 == 0) goto L_0x04bd;	 Catch:{ all -> 0x02ed }
    L_0x049d:
        r2 = DEBUG_PACKAGE_SCANNING;	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x04bd;	 Catch:{ all -> 0x02ed }
    L_0x04a1:
        r2 = "PackageManager";	 Catch:{ all -> 0x02ed }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r4.<init>();	 Catch:{ all -> 0x02ed }
        r6 = "  Providers: ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r0);	 Catch:{ all -> 0x02ed }
        r4 = r4.toString();	 Catch:{ all -> 0x02ed }
        android.util.Log.d(r2, r4);	 Catch:{ all -> 0x02ed }
    L_0x04bd:
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.services;	 Catch:{ all -> 0x02ed }
        r10 = r2.size();	 Catch:{ all -> 0x02ed }
        r36 = 0;	 Catch:{ all -> 0x02ed }
        r21 = 0;	 Catch:{ all -> 0x02ed }
    L_0x04c9:
        r0 = r21;	 Catch:{ all -> 0x02ed }
        if (r0 >= r10) goto L_0x051b;	 Catch:{ all -> 0x02ed }
    L_0x04cd:
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.services;	 Catch:{ all -> 0x02ed }
        r0 = r21;	 Catch:{ all -> 0x02ed }
        r37 = r2.get(r0);	 Catch:{ all -> 0x02ed }
        r37 = (android.content.pm.PackageParser.Service) r37;	 Catch:{ all -> 0x02ed }
        r0 = r37;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r4 = r4.processName;	 Catch:{ all -> 0x02ed }
        r0 = r37;	 Catch:{ all -> 0x02ed }
        r6 = r0.info;	 Catch:{ all -> 0x02ed }
        r6 = r6.processName;	 Catch:{ all -> 0x02ed }
        r4 = fixProcessName(r4, r6);	 Catch:{ all -> 0x02ed }
        r2.processName = r4;	 Catch:{ all -> 0x02ed }
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r2 = r0.mServices;	 Catch:{ all -> 0x02ed }
        r0 = r37;	 Catch:{ all -> 0x02ed }
        r2.addService(r0);	 Catch:{ all -> 0x02ed }
        if (r46 == 0) goto L_0x0510;	 Catch:{ all -> 0x02ed }
    L_0x04fa:
        if (r36 != 0) goto L_0x0513;	 Catch:{ all -> 0x02ed }
    L_0x04fc:
        r36 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r2 = 256; // 0x100 float:3.59E-43 double:1.265E-321;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.<init>(r2);	 Catch:{ all -> 0x02ed }
    L_0x0505:
        r0 = r37;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.name;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
    L_0x0510:
        r21 = r21 + 1;	 Catch:{ all -> 0x02ed }
        goto L_0x04c9;	 Catch:{ all -> 0x02ed }
    L_0x0513:
        r2 = 32;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
        goto L_0x0505;	 Catch:{ all -> 0x02ed }
    L_0x051b:
        if (r36 == 0) goto L_0x053d;	 Catch:{ all -> 0x02ed }
    L_0x051d:
        r2 = DEBUG_PACKAGE_SCANNING;	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x053d;	 Catch:{ all -> 0x02ed }
    L_0x0521:
        r2 = "PackageManager";	 Catch:{ all -> 0x02ed }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r4.<init>();	 Catch:{ all -> 0x02ed }
        r6 = "  Services: ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r0);	 Catch:{ all -> 0x02ed }
        r4 = r4.toString();	 Catch:{ all -> 0x02ed }
        android.util.Log.d(r2, r4);	 Catch:{ all -> 0x02ed }
    L_0x053d:
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.receivers;	 Catch:{ all -> 0x02ed }
        r10 = r2.size();	 Catch:{ all -> 0x02ed }
        r36 = 0;	 Catch:{ all -> 0x02ed }
        r21 = 0;	 Catch:{ all -> 0x02ed }
    L_0x0549:
        r0 = r21;	 Catch:{ all -> 0x02ed }
        if (r0 >= r10) goto L_0x0596;	 Catch:{ all -> 0x02ed }
    L_0x054d:
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.receivers;	 Catch:{ all -> 0x02ed }
        r0 = r21;	 Catch:{ all -> 0x02ed }
        r11 = r2.get(r0);	 Catch:{ all -> 0x02ed }
        r11 = (android.content.pm.PackageParser.Activity) r11;	 Catch:{ all -> 0x02ed }
        r2 = r11.info;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r4 = r4.processName;	 Catch:{ all -> 0x02ed }
        r6 = r11.info;	 Catch:{ all -> 0x02ed }
        r6 = r6.processName;	 Catch:{ all -> 0x02ed }
        r4 = fixProcessName(r4, r6);	 Catch:{ all -> 0x02ed }
        r2.processName = r4;	 Catch:{ all -> 0x02ed }
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r2 = r0.mReceivers;	 Catch:{ all -> 0x02ed }
        r4 = "receiver";	 Catch:{ all -> 0x02ed }
        r2.addActivity(r11, r4);	 Catch:{ all -> 0x02ed }
        if (r46 == 0) goto L_0x058b;	 Catch:{ all -> 0x02ed }
    L_0x0577:
        if (r36 != 0) goto L_0x058e;	 Catch:{ all -> 0x02ed }
    L_0x0579:
        r36 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r2 = 256; // 0x100 float:3.59E-43 double:1.265E-321;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.<init>(r2);	 Catch:{ all -> 0x02ed }
    L_0x0582:
        r2 = r11.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.name;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
    L_0x058b:
        r21 = r21 + 1;	 Catch:{ all -> 0x02ed }
        goto L_0x0549;	 Catch:{ all -> 0x02ed }
    L_0x058e:
        r2 = 32;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
        goto L_0x0582;	 Catch:{ all -> 0x02ed }
    L_0x0596:
        if (r36 == 0) goto L_0x05b8;	 Catch:{ all -> 0x02ed }
    L_0x0598:
        r2 = DEBUG_PACKAGE_SCANNING;	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x05b8;	 Catch:{ all -> 0x02ed }
    L_0x059c:
        r2 = "PackageManager";	 Catch:{ all -> 0x02ed }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r4.<init>();	 Catch:{ all -> 0x02ed }
        r6 = "  Receivers: ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r0);	 Catch:{ all -> 0x02ed }
        r4 = r4.toString();	 Catch:{ all -> 0x02ed }
        android.util.Log.d(r2, r4);	 Catch:{ all -> 0x02ed }
    L_0x05b8:
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.activities;	 Catch:{ all -> 0x02ed }
        r10 = r2.size();	 Catch:{ all -> 0x02ed }
        r36 = 0;	 Catch:{ all -> 0x02ed }
        r21 = 0;	 Catch:{ all -> 0x02ed }
    L_0x05c4:
        r0 = r21;	 Catch:{ all -> 0x02ed }
        if (r0 >= r10) goto L_0x0611;	 Catch:{ all -> 0x02ed }
    L_0x05c8:
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.activities;	 Catch:{ all -> 0x02ed }
        r0 = r21;	 Catch:{ all -> 0x02ed }
        r11 = r2.get(r0);	 Catch:{ all -> 0x02ed }
        r11 = (android.content.pm.PackageParser.Activity) r11;	 Catch:{ all -> 0x02ed }
        r2 = r11.info;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r4 = r4.processName;	 Catch:{ all -> 0x02ed }
        r6 = r11.info;	 Catch:{ all -> 0x02ed }
        r6 = r6.processName;	 Catch:{ all -> 0x02ed }
        r4 = fixProcessName(r4, r6);	 Catch:{ all -> 0x02ed }
        r2.processName = r4;	 Catch:{ all -> 0x02ed }
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r2 = r0.mActivities;	 Catch:{ all -> 0x02ed }
        r4 = "activity";	 Catch:{ all -> 0x02ed }
        r2.addActivity(r11, r4);	 Catch:{ all -> 0x02ed }
        if (r46 == 0) goto L_0x0606;	 Catch:{ all -> 0x02ed }
    L_0x05f2:
        if (r36 != 0) goto L_0x0609;	 Catch:{ all -> 0x02ed }
    L_0x05f4:
        r36 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r2 = 256; // 0x100 float:3.59E-43 double:1.265E-321;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.<init>(r2);	 Catch:{ all -> 0x02ed }
    L_0x05fd:
        r2 = r11.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.name;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
    L_0x0606:
        r21 = r21 + 1;	 Catch:{ all -> 0x02ed }
        goto L_0x05c4;	 Catch:{ all -> 0x02ed }
    L_0x0609:
        r2 = 32;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
        goto L_0x05fd;	 Catch:{ all -> 0x02ed }
    L_0x0611:
        if (r36 == 0) goto L_0x0633;	 Catch:{ all -> 0x02ed }
    L_0x0613:
        r2 = DEBUG_PACKAGE_SCANNING;	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x0633;	 Catch:{ all -> 0x02ed }
    L_0x0617:
        r2 = "PackageManager";	 Catch:{ all -> 0x02ed }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r4.<init>();	 Catch:{ all -> 0x02ed }
        r6 = "  Activities: ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r0);	 Catch:{ all -> 0x02ed }
        r4 = r4.toString();	 Catch:{ all -> 0x02ed }
        android.util.Log.d(r2, r4);	 Catch:{ all -> 0x02ed }
    L_0x0633:
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.permissionGroups;	 Catch:{ all -> 0x02ed }
        r10 = r2.size();	 Catch:{ all -> 0x02ed }
        r36 = 0;	 Catch:{ all -> 0x02ed }
        r21 = 0;	 Catch:{ all -> 0x02ed }
    L_0x063f:
        r0 = r21;	 Catch:{ all -> 0x02ed }
        if (r0 >= r10) goto L_0x0763;	 Catch:{ all -> 0x02ed }
    L_0x0643:
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.permissionGroups;	 Catch:{ all -> 0x02ed }
        r0 = r21;	 Catch:{ all -> 0x02ed }
        r34 = r2.get(r0);	 Catch:{ all -> 0x02ed }
        r34 = (android.content.pm.PackageParser.PermissionGroup) r34;	 Catch:{ all -> 0x02ed }
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r2 = r0.mPermissionGroups;	 Catch:{ all -> 0x02ed }
        r0 = r34;	 Catch:{ all -> 0x02ed }
        r4 = r0.info;	 Catch:{ all -> 0x02ed }
        r4 = r4.name;	 Catch:{ all -> 0x02ed }
        r17 = r2.get(r4);	 Catch:{ all -> 0x02ed }
        r17 = (android.content.pm.PackageParser.PermissionGroup) r17;	 Catch:{ all -> 0x02ed }
        if (r17 != 0) goto L_0x06a4;	 Catch:{ all -> 0x02ed }
    L_0x0661:
        r18 = 0;	 Catch:{ all -> 0x02ed }
    L_0x0663:
        r2 = 131072; // 0x20000 float:1.83671E-40 double:6.47582E-319;	 Catch:{ all -> 0x02ed }
        r2 = r2 & r45;	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x06ad;	 Catch:{ all -> 0x02ed }
    L_0x0669:
        r2 = "PackageManager";	 Catch:{ all -> 0x02ed }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r4.<init>();	 Catch:{ all -> 0x02ed }
        r6 = "Permission group ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r34;	 Catch:{ all -> 0x02ed }
        r6 = r0.info;	 Catch:{ all -> 0x02ed }
        r6 = r6.name;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = " from package ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r34;	 Catch:{ all -> 0x02ed }
        r6 = r0.info;	 Catch:{ all -> 0x02ed }
        r6 = r6.packageName;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = " ignored: instant apps cannot define new permission groups.";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r4 = r4.toString();	 Catch:{ all -> 0x02ed }
        android.util.Slog.w(r2, r4);	 Catch:{ all -> 0x02ed }
    L_0x06a1:
        r21 = r21 + 1;	 Catch:{ all -> 0x02ed }
        goto L_0x063f;	 Catch:{ all -> 0x02ed }
    L_0x06a4:
        r0 = r17;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r0 = r2.packageName;	 Catch:{ all -> 0x02ed }
        r18 = r0;	 Catch:{ all -> 0x02ed }
        goto L_0x0663;	 Catch:{ all -> 0x02ed }
    L_0x06ad:
        r0 = r34;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.packageName;	 Catch:{ all -> 0x02ed }
        r0 = r18;	 Catch:{ all -> 0x02ed }
        r22 = r2.equals(r0);	 Catch:{ all -> 0x02ed }
        if (r17 == 0) goto L_0x06bd;	 Catch:{ all -> 0x02ed }
    L_0x06bb:
        if (r22 == 0) goto L_0x06f7;	 Catch:{ all -> 0x02ed }
    L_0x06bd:
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r2 = r0.mPermissionGroups;	 Catch:{ all -> 0x02ed }
        r0 = r34;	 Catch:{ all -> 0x02ed }
        r4 = r0.info;	 Catch:{ all -> 0x02ed }
        r4 = r4.name;	 Catch:{ all -> 0x02ed }
        r0 = r34;	 Catch:{ all -> 0x02ed }
        r2.put(r4, r0);	 Catch:{ all -> 0x02ed }
        if (r46 == 0) goto L_0x06a1;	 Catch:{ all -> 0x02ed }
    L_0x06ce:
        if (r36 != 0) goto L_0x06ef;	 Catch:{ all -> 0x02ed }
    L_0x06d0:
        r36 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r2 = 256; // 0x100 float:3.59E-43 double:1.265E-321;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.<init>(r2);	 Catch:{ all -> 0x02ed }
    L_0x06d9:
        if (r22 == 0) goto L_0x06e3;	 Catch:{ all -> 0x02ed }
    L_0x06db:
        r2 = "UPD:";	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
    L_0x06e3:
        r0 = r34;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.name;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
        goto L_0x06a1;	 Catch:{ all -> 0x02ed }
    L_0x06ef:
        r2 = 32;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
        goto L_0x06d9;	 Catch:{ all -> 0x02ed }
    L_0x06f7:
        r2 = "PackageManager";	 Catch:{ all -> 0x02ed }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r4.<init>();	 Catch:{ all -> 0x02ed }
        r6 = "Permission group ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r34;	 Catch:{ all -> 0x02ed }
        r6 = r0.info;	 Catch:{ all -> 0x02ed }
        r6 = r6.name;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = " from package ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r34;	 Catch:{ all -> 0x02ed }
        r6 = r0.info;	 Catch:{ all -> 0x02ed }
        r6 = r6.packageName;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = " ignored: original from ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r17;	 Catch:{ all -> 0x02ed }
        r6 = r0.info;	 Catch:{ all -> 0x02ed }
        r6 = r6.packageName;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r4 = r4.toString();	 Catch:{ all -> 0x02ed }
        android.util.Slog.w(r2, r4);	 Catch:{ all -> 0x02ed }
        if (r46 == 0) goto L_0x06a1;	 Catch:{ all -> 0x02ed }
    L_0x073b:
        if (r36 != 0) goto L_0x075b;	 Catch:{ all -> 0x02ed }
    L_0x073d:
        r36 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r2 = 256; // 0x100 float:3.59E-43 double:1.265E-321;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.<init>(r2);	 Catch:{ all -> 0x02ed }
    L_0x0746:
        r2 = "DUP:";	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
        r0 = r34;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.name;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
        goto L_0x06a1;	 Catch:{ all -> 0x02ed }
    L_0x075b:
        r2 = 32;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
        goto L_0x0746;	 Catch:{ all -> 0x02ed }
    L_0x0763:
        if (r36 == 0) goto L_0x0785;	 Catch:{ all -> 0x02ed }
    L_0x0765:
        r2 = DEBUG_PACKAGE_SCANNING;	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x0785;	 Catch:{ all -> 0x02ed }
    L_0x0769:
        r2 = "PackageManager";	 Catch:{ all -> 0x02ed }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r4.<init>();	 Catch:{ all -> 0x02ed }
        r6 = "  Permission Groups: ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r0);	 Catch:{ all -> 0x02ed }
        r4 = r4.toString();	 Catch:{ all -> 0x02ed }
        android.util.Log.d(r2, r4);	 Catch:{ all -> 0x02ed }
    L_0x0785:
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.permissions;	 Catch:{ all -> 0x02ed }
        r10 = r2.size();	 Catch:{ all -> 0x02ed }
        r36 = 0;	 Catch:{ all -> 0x02ed }
        r21 = 0;	 Catch:{ all -> 0x02ed }
    L_0x0791:
        r0 = r21;	 Catch:{ all -> 0x02ed }
        if (r0 >= r10) goto L_0x0a2c;	 Catch:{ all -> 0x02ed }
    L_0x0795:
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.permissions;	 Catch:{ all -> 0x02ed }
        r0 = r21;	 Catch:{ all -> 0x02ed }
        r30 = r2.get(r0);	 Catch:{ all -> 0x02ed }
        r30 = (android.content.pm.PackageParser.Permission) r30;	 Catch:{ all -> 0x02ed }
        r2 = 131072; // 0x20000 float:1.83671E-40 double:6.47582E-319;	 Catch:{ all -> 0x02ed }
        r2 = r2 & r45;	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x07e2;	 Catch:{ all -> 0x02ed }
    L_0x07a7:
        r2 = "PackageManager";	 Catch:{ all -> 0x02ed }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r4.<init>();	 Catch:{ all -> 0x02ed }
        r6 = "Permission ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r6 = r0.info;	 Catch:{ all -> 0x02ed }
        r6 = r6.name;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = " from package ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r6 = r0.info;	 Catch:{ all -> 0x02ed }
        r6 = r6.packageName;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = " ignored: instant apps cannot define new permissions.";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r4 = r4.toString();	 Catch:{ all -> 0x02ed }
        android.util.Slog.w(r2, r4);	 Catch:{ all -> 0x02ed }
    L_0x07df:
        r21 = r21 + 1;	 Catch:{ all -> 0x02ed }
        goto L_0x0791;	 Catch:{ all -> 0x02ed }
    L_0x07e2:
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r4 = r2.flags;	 Catch:{ all -> 0x02ed }
        r6 = -1073741825; // 0xffffffffbfffffff float:-1.9999999 double:NaN;	 Catch:{ all -> 0x02ed }
        r4 = r4 & r6;	 Catch:{ all -> 0x02ed }
        r2.flags = r4;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r2 = r2.targetSdkVersion;	 Catch:{ all -> 0x02ed }
        r4 = 22;	 Catch:{ all -> 0x02ed }
        if (r2 <= r4) goto L_0x080c;	 Catch:{ all -> 0x02ed }
    L_0x07f8:
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r2 = r0.mPermissionGroups;	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r4 = r0.info;	 Catch:{ all -> 0x02ed }
        r4 = r4.group;	 Catch:{ all -> 0x02ed }
        r2 = r2.get(r4);	 Catch:{ all -> 0x02ed }
        r2 = (android.content.pm.PackageParser.PermissionGroup) r2;	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r0.group = r2;	 Catch:{ all -> 0x02ed }
    L_0x080c:
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r2 = r0.tree;	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x091a;	 Catch:{ all -> 0x02ed }
    L_0x0812:
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r2 = r0.mSettings;	 Catch:{ all -> 0x02ed }
        r0 = r2.mPermissionTrees;	 Catch:{ all -> 0x02ed }
        r33 = r0;	 Catch:{ all -> 0x02ed }
    L_0x081a:
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.name;	 Catch:{ all -> 0x02ed }
        r0 = r33;	 Catch:{ all -> 0x02ed }
        r14 = r0.get(r2);	 Catch:{ all -> 0x02ed }
        r14 = (com.android.server.pm.BasePermission) r14;	 Catch:{ all -> 0x02ed }
        if (r14 == 0) goto L_0x087c;	 Catch:{ all -> 0x02ed }
    L_0x082a:
        r2 = r14.sourcePackage;	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r4 = r0.info;	 Catch:{ all -> 0x02ed }
        r4 = r4.packageName;	 Catch:{ all -> 0x02ed }
        r2 = java.util.Objects.equals(r2, r4);	 Catch:{ all -> 0x02ed }
        r2 = r2 ^ 1;	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x087c;	 Catch:{ all -> 0x02ed }
    L_0x083a:
        r2 = r14.perm;	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x0924;	 Catch:{ all -> 0x02ed }
    L_0x083e:
        r2 = r14.perm;	 Catch:{ all -> 0x02ed }
        r2 = r2.owner;	 Catch:{ all -> 0x02ed }
        r19 = isSystemApp(r2);	 Catch:{ all -> 0x02ed }
    L_0x0846:
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r2 = r0.owner;	 Catch:{ all -> 0x02ed }
        r2 = isSystemApp(r2);	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x087c;	 Catch:{ all -> 0x02ed }
    L_0x0850:
        r2 = r14.type;	 Catch:{ all -> 0x02ed }
        r4 = 1;	 Catch:{ all -> 0x02ed }
        if (r2 != r4) goto L_0x0928;	 Catch:{ all -> 0x02ed }
    L_0x0855:
        r2 = r14.perm;	 Catch:{ all -> 0x02ed }
        if (r2 != 0) goto L_0x0928;	 Catch:{ all -> 0x02ed }
    L_0x0859:
        r0 = r43;	 Catch:{ all -> 0x02ed }
        r14.packageSetting = r0;	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r14.perm = r0;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r2 = r2.uid;	 Catch:{ all -> 0x02ed }
        r14.uid = r2;	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.packageName;	 Catch:{ all -> 0x02ed }
        r14.sourcePackage = r2;	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r4 = r2.flags;	 Catch:{ all -> 0x02ed }
        r6 = 1073741824; // 0x40000000 float:2.0 double:5.304989477E-315;	 Catch:{ all -> 0x02ed }
        r4 = r4 | r6;	 Catch:{ all -> 0x02ed }
        r2.flags = r4;	 Catch:{ all -> 0x02ed }
    L_0x087c:
        if (r14 != 0) goto L_0x089b;	 Catch:{ all -> 0x02ed }
    L_0x087e:
        r14 = new com.android.server.pm.BasePermission;	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.name;	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r4 = r0.info;	 Catch:{ all -> 0x02ed }
        r4 = r4.packageName;	 Catch:{ all -> 0x02ed }
        r6 = 0;	 Catch:{ all -> 0x02ed }
        r14.<init>(r2, r4, r6);	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.name;	 Catch:{ all -> 0x02ed }
        r0 = r33;	 Catch:{ all -> 0x02ed }
        r0.put(r2, r14);	 Catch:{ all -> 0x02ed }
    L_0x089b:
        r2 = r14.perm;	 Catch:{ all -> 0x02ed }
        if (r2 != 0) goto L_0x0a02;	 Catch:{ all -> 0x02ed }
    L_0x089f:
        r2 = r14.sourcePackage;	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x08b1;	 Catch:{ all -> 0x02ed }
    L_0x08a3:
        r2 = r14.sourcePackage;	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r4 = r0.info;	 Catch:{ all -> 0x02ed }
        r4 = r4.packageName;	 Catch:{ all -> 0x02ed }
        r2 = r2.equals(r4);	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x09c2;	 Catch:{ all -> 0x02ed }
    L_0x08b1:
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.name;	 Catch:{ all -> 0x02ed }
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r39 = r0.findPermissionTreeLP(r2);	 Catch:{ all -> 0x02ed }
        if (r39 == 0) goto L_0x08cf;	 Catch:{ all -> 0x02ed }
    L_0x08bf:
        r0 = r39;	 Catch:{ all -> 0x02ed }
        r2 = r0.sourcePackage;	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r4 = r0.info;	 Catch:{ all -> 0x02ed }
        r4 = r4.packageName;	 Catch:{ all -> 0x02ed }
        r2 = r2.equals(r4);	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x0971;	 Catch:{ all -> 0x02ed }
    L_0x08cf:
        r0 = r43;	 Catch:{ all -> 0x02ed }
        r14.packageSetting = r0;	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r14.perm = r0;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r2 = r2.uid;	 Catch:{ all -> 0x02ed }
        r14.uid = r2;	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.packageName;	 Catch:{ all -> 0x02ed }
        r14.sourcePackage = r2;	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r4 = r2.flags;	 Catch:{ all -> 0x02ed }
        r6 = 1073741824; // 0x40000000 float:2.0 double:5.304989477E-315;	 Catch:{ all -> 0x02ed }
        r4 = r4 | r6;	 Catch:{ all -> 0x02ed }
        r2.flags = r4;	 Catch:{ all -> 0x02ed }
        if (r46 == 0) goto L_0x090a;	 Catch:{ all -> 0x02ed }
    L_0x08f4:
        if (r36 != 0) goto L_0x0969;	 Catch:{ all -> 0x02ed }
    L_0x08f6:
        r36 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r2 = 256; // 0x100 float:3.59E-43 double:1.265E-321;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.<init>(r2);	 Catch:{ all -> 0x02ed }
    L_0x08ff:
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.name;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
    L_0x090a:
        r2 = r14.perm;	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        if (r2 != r0) goto L_0x07df;	 Catch:{ all -> 0x02ed }
    L_0x0910:
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.protectionLevel;	 Catch:{ all -> 0x02ed }
        r14.protectionLevel = r2;	 Catch:{ all -> 0x02ed }
        goto L_0x07df;	 Catch:{ all -> 0x02ed }
    L_0x091a:
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r2 = r0.mSettings;	 Catch:{ all -> 0x02ed }
        r0 = r2.mPermissions;	 Catch:{ all -> 0x02ed }
        r33 = r0;	 Catch:{ all -> 0x02ed }
        goto L_0x081a;	 Catch:{ all -> 0x02ed }
    L_0x0924:
        r19 = 0;	 Catch:{ all -> 0x02ed }
        goto L_0x0846;	 Catch:{ all -> 0x02ed }
    L_0x0928:
        if (r19 != 0) goto L_0x087c;	 Catch:{ all -> 0x02ed }
    L_0x092a:
        r2 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r2.<init>();	 Catch:{ all -> 0x02ed }
        r4 = "New decl ";	 Catch:{ all -> 0x02ed }
        r2 = r2.append(r4);	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r4 = r0.owner;	 Catch:{ all -> 0x02ed }
        r2 = r2.append(r4);	 Catch:{ all -> 0x02ed }
        r4 = " of permission  ";	 Catch:{ all -> 0x02ed }
        r2 = r2.append(r4);	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r4 = r0.info;	 Catch:{ all -> 0x02ed }
        r4 = r4.name;	 Catch:{ all -> 0x02ed }
        r2 = r2.append(r4);	 Catch:{ all -> 0x02ed }
        r4 = " is system; overriding ";	 Catch:{ all -> 0x02ed }
        r2 = r2.append(r4);	 Catch:{ all -> 0x02ed }
        r4 = r14.sourcePackage;	 Catch:{ all -> 0x02ed }
        r2 = r2.append(r4);	 Catch:{ all -> 0x02ed }
        r27 = r2.toString();	 Catch:{ all -> 0x02ed }
        r2 = 5;	 Catch:{ all -> 0x02ed }
        r0 = r27;	 Catch:{ all -> 0x02ed }
        reportSettingsProblem(r2, r0);	 Catch:{ all -> 0x02ed }
        r14 = 0;	 Catch:{ all -> 0x02ed }
        goto L_0x087c;	 Catch:{ all -> 0x02ed }
    L_0x0969:
        r2 = 32;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
        goto L_0x08ff;	 Catch:{ all -> 0x02ed }
    L_0x0971:
        r2 = "PackageManager";	 Catch:{ all -> 0x02ed }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r4.<init>();	 Catch:{ all -> 0x02ed }
        r6 = "Permission ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r6 = r0.info;	 Catch:{ all -> 0x02ed }
        r6 = r6.name;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = " from package ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r6 = r0.info;	 Catch:{ all -> 0x02ed }
        r6 = r6.packageName;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = " ignored: base tree ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r39;	 Catch:{ all -> 0x02ed }
        r6 = r0.name;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = " is from package ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r39;	 Catch:{ all -> 0x02ed }
        r6 = r0.sourcePackage;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r4 = r4.toString();	 Catch:{ all -> 0x02ed }
        android.util.Slog.w(r2, r4);	 Catch:{ all -> 0x02ed }
        goto L_0x090a;	 Catch:{ all -> 0x02ed }
    L_0x09c2:
        r2 = "PackageManager";	 Catch:{ all -> 0x02ed }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r4.<init>();	 Catch:{ all -> 0x02ed }
        r6 = "Permission ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r6 = r0.info;	 Catch:{ all -> 0x02ed }
        r6 = r6.name;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = " from package ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r6 = r0.info;	 Catch:{ all -> 0x02ed }
        r6 = r6.packageName;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = " ignored: original from ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r6 = r14.sourcePackage;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r4 = r4.toString();	 Catch:{ all -> 0x02ed }
        android.util.Slog.w(r2, r4);	 Catch:{ all -> 0x02ed }
        goto L_0x090a;	 Catch:{ all -> 0x02ed }
    L_0x0a02:
        if (r46 == 0) goto L_0x090a;	 Catch:{ all -> 0x02ed }
    L_0x0a04:
        if (r36 != 0) goto L_0x0a24;	 Catch:{ all -> 0x02ed }
    L_0x0a06:
        r36 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r2 = 256; // 0x100 float:3.59E-43 double:1.265E-321;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.<init>(r2);	 Catch:{ all -> 0x02ed }
    L_0x0a0f:
        r2 = "DUP:";	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
        r0 = r30;	 Catch:{ all -> 0x02ed }
        r2 = r0.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.name;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
        goto L_0x090a;	 Catch:{ all -> 0x02ed }
    L_0x0a24:
        r2 = 32;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
        goto L_0x0a0f;	 Catch:{ all -> 0x02ed }
    L_0x0a2c:
        if (r36 == 0) goto L_0x0a4e;	 Catch:{ all -> 0x02ed }
    L_0x0a2e:
        r2 = DEBUG_PACKAGE_SCANNING;	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x0a4e;	 Catch:{ all -> 0x02ed }
    L_0x0a32:
        r2 = "PackageManager";	 Catch:{ all -> 0x02ed }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r4.<init>();	 Catch:{ all -> 0x02ed }
        r6 = "  Permissions: ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r0);	 Catch:{ all -> 0x02ed }
        r4 = r4.toString();	 Catch:{ all -> 0x02ed }
        android.util.Log.d(r2, r4);	 Catch:{ all -> 0x02ed }
    L_0x0a4e:
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.instrumentation;	 Catch:{ all -> 0x02ed }
        r10 = r2.size();	 Catch:{ all -> 0x02ed }
        r36 = 0;	 Catch:{ all -> 0x02ed }
        r21 = 0;	 Catch:{ all -> 0x02ed }
    L_0x0a5a:
        r0 = r21;	 Catch:{ all -> 0x02ed }
        if (r0 >= r10) goto L_0x0b0d;	 Catch:{ all -> 0x02ed }
    L_0x0a5e:
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.instrumentation;	 Catch:{ all -> 0x02ed }
        r0 = r21;	 Catch:{ all -> 0x02ed }
        r12 = r2.get(r0);	 Catch:{ all -> 0x02ed }
        r12 = (android.content.pm.PackageParser.Instrumentation) r12;	 Catch:{ all -> 0x02ed }
        r2 = r12.info;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r4 = r4.packageName;	 Catch:{ all -> 0x02ed }
        r2.packageName = r4;	 Catch:{ all -> 0x02ed }
        r2 = r12.info;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r4 = r4.sourceDir;	 Catch:{ all -> 0x02ed }
        r2.sourceDir = r4;	 Catch:{ all -> 0x02ed }
        r2 = r12.info;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r4 = r4.publicSourceDir;	 Catch:{ all -> 0x02ed }
        r2.publicSourceDir = r4;	 Catch:{ all -> 0x02ed }
        r2 = r12.info;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r4 = r0.splitNames;	 Catch:{ all -> 0x02ed }
        r2.splitNames = r4;	 Catch:{ all -> 0x02ed }
        r2 = r12.info;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r4 = r4.splitSourceDirs;	 Catch:{ all -> 0x02ed }
        r2.splitSourceDirs = r4;	 Catch:{ all -> 0x02ed }
        r2 = r12.info;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r4 = r4.splitPublicSourceDirs;	 Catch:{ all -> 0x02ed }
        r2.splitPublicSourceDirs = r4;	 Catch:{ all -> 0x02ed }
        r2 = r12.info;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r4 = r4.splitDependencies;	 Catch:{ all -> 0x02ed }
        r2.splitDependencies = r4;	 Catch:{ all -> 0x02ed }
        r2 = r12.info;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r4 = r4.dataDir;	 Catch:{ all -> 0x02ed }
        r2.dataDir = r4;	 Catch:{ all -> 0x02ed }
        r2 = r12.info;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r4 = r4.deviceProtectedDataDir;	 Catch:{ all -> 0x02ed }
        r2.deviceProtectedDataDir = r4;	 Catch:{ all -> 0x02ed }
        r2 = r12.info;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r4 = r4.credentialProtectedDataDir;	 Catch:{ all -> 0x02ed }
        r2.credentialProtectedDataDir = r4;	 Catch:{ all -> 0x02ed }
        r2 = r12.info;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r4 = r4.nativeLibraryDir;	 Catch:{ all -> 0x02ed }
        r2.nativeLibraryDir = r4;	 Catch:{ all -> 0x02ed }
        r2 = r12.info;	 Catch:{ all -> 0x02ed }
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r4 = r0.applicationInfo;	 Catch:{ all -> 0x02ed }
        r4 = r4.secondaryNativeLibraryDir;	 Catch:{ all -> 0x02ed }
        r2.secondaryNativeLibraryDir = r4;	 Catch:{ all -> 0x02ed }
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r2 = r0.mInstrumentation;	 Catch:{ all -> 0x02ed }
        r4 = r12.getComponentName();	 Catch:{ all -> 0x02ed }
        r2.put(r4, r12);	 Catch:{ all -> 0x02ed }
        if (r46 == 0) goto L_0x0b01;	 Catch:{ all -> 0x02ed }
    L_0x0aed:
        if (r36 != 0) goto L_0x0b05;	 Catch:{ all -> 0x02ed }
    L_0x0aef:
        r36 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r2 = 256; // 0x100 float:3.59E-43 double:1.265E-321;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.<init>(r2);	 Catch:{ all -> 0x02ed }
    L_0x0af8:
        r2 = r12.info;	 Catch:{ all -> 0x02ed }
        r2 = r2.name;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
    L_0x0b01:
        r21 = r21 + 1;	 Catch:{ all -> 0x02ed }
        goto L_0x0a5a;	 Catch:{ all -> 0x02ed }
    L_0x0b05:
        r2 = 32;	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r0.append(r2);	 Catch:{ all -> 0x02ed }
        goto L_0x0af8;	 Catch:{ all -> 0x02ed }
    L_0x0b0d:
        if (r36 == 0) goto L_0x0b2f;	 Catch:{ all -> 0x02ed }
    L_0x0b0f:
        r2 = DEBUG_PACKAGE_SCANNING;	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x0b2f;	 Catch:{ all -> 0x02ed }
    L_0x0b13:
        r2 = "PackageManager";	 Catch:{ all -> 0x02ed }
        r4 = new java.lang.StringBuilder;	 Catch:{ all -> 0x02ed }
        r4.<init>();	 Catch:{ all -> 0x02ed }
        r6 = "  Instrumentation: ";	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r6);	 Catch:{ all -> 0x02ed }
        r0 = r36;	 Catch:{ all -> 0x02ed }
        r4 = r4.append(r0);	 Catch:{ all -> 0x02ed }
        r4 = r4.toString();	 Catch:{ all -> 0x02ed }
        android.util.Log.d(r2, r4);	 Catch:{ all -> 0x02ed }
    L_0x0b2f:
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.protectedBroadcasts;	 Catch:{ all -> 0x02ed }
        if (r2 == 0) goto L_0x0b5f;	 Catch:{ all -> 0x02ed }
    L_0x0b35:
        r0 = r42;	 Catch:{ all -> 0x02ed }
        r2 = r0.protectedBroadcasts;	 Catch:{ all -> 0x02ed }
        r10 = r2.size();	 Catch:{ all -> 0x02ed }
        r0 = r41;	 Catch:{ all -> 0x02ed }
        r4 = r0.mProtectedBroadcasts;	 Catch:{ all -> 0x02ed }
        monitor-enter(r4);	 Catch:{ all -> 0x02ed }
        r21 = 0;
    L_0x0b44:
        r0 = r21;
        if (r0 >= r10) goto L_0x0b5e;
    L_0x0b48:
        r0 = r41;	 Catch:{ all -> 0x0b67 }
        r6 = r0.mProtectedBroadcasts;	 Catch:{ all -> 0x0b67 }
        r0 = r42;	 Catch:{ all -> 0x0b67 }
        r2 = r0.protectedBroadcasts;	 Catch:{ all -> 0x0b67 }
        r0 = r21;	 Catch:{ all -> 0x0b67 }
        r2 = r2.get(r0);	 Catch:{ all -> 0x0b67 }
        r2 = (java.lang.String) r2;	 Catch:{ all -> 0x0b67 }
        r6.add(r2);	 Catch:{ all -> 0x0b67 }
        r21 = r21 + 1;
        goto L_0x0b44;
    L_0x0b5e:
        monitor-exit(r4);	 Catch:{ all -> 0x02ed }
    L_0x0b5f:
        monitor-exit(r3);
        r2 = 262144; // 0x40000 float:3.67342E-40 double:1.295163E-318;
        android.os.Trace.traceEnd(r2);
        return;
    L_0x0b67:
        r2 = move-exception;
        monitor-exit(r4);	 Catch:{ all -> 0x02ed }
        throw r2;	 Catch:{ all -> 0x02ed }
    L_0x0b6a:
        r31 = r32;
        goto L_0x0380;
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.pm.PackageManagerService.commitPackageSettings(android.content.pm.PackageParser$Package, com.android.server.pm.PackageSetting, android.os.UserHandle, int, boolean):void");
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private static void derivePackageAbi(Package pkg, File scanFile, String cpuAbiOverride, boolean extractLibs, File appLib32InstallDir) throws PackageManagerException {
        setNativeLibraryPaths(pkg, appLib32InstallDir);
        if (pkg.isForwardLocked() || pkg.applicationInfo.isExternalAsec() || (isSystemApp(pkg) && (pkg.isUpdatedSystemApp() ^ 1) != 0)) {
            extractLibs = false;
        }
        String nativeLibraryRootStr = pkg.applicationInfo.nativeLibraryRootDir;
        boolean useIsaSpecificSubdirs = pkg.applicationInfo.nativeLibraryRootRequiresIsa;
        AutoCloseable handle = null;
        try {
            handle = Handle.create(pkg);
            File nativeLibraryRoot = new File(nativeLibraryRootStr);
            pkg.applicationInfo.primaryCpuAbi = null;
            pkg.applicationInfo.secondaryCpuAbi = null;
            if (isMultiArch(pkg.applicationInfo)) {
                if (!(pkg.cpuAbiOverride == null || (INSTALL_PACKAGE_SUFFIX.equals(pkg.cpuAbiOverride) ^ 1) == 0)) {
                    Slog.w(TAG, "Ignoring abiOverride for multi arch application.");
                }
                int abi32 = -114;
                int abi64 = -114;
                if (Build.SUPPORTED_32_BIT_ABIS.length > 0) {
                    if (extractLibs) {
                        Trace.traceBegin(262144, "copyNativeBinaries");
                        abi32 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, Build.SUPPORTED_32_BIT_ABIS, useIsaSpecificSubdirs);
                    } else {
                        Trace.traceBegin(262144, "findSupportedAbi");
                        abi32 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_32_BIT_ABIS);
                    }
                    Trace.traceEnd(262144);
                }
                if (abi32 >= 0 && pkg.isLibrary() && extractLibs) {
                    throw new PackageManagerException(-110, "Shared library native lib extraction not supported");
                }
                maybeThrowExceptionForMultiArchCopy("Error unpackaging 32 bit native libs for multiarch app.", abi32);
                if (Build.SUPPORTED_64_BIT_ABIS.length > 0) {
                    if (extractLibs) {
                        Trace.traceBegin(262144, "copyNativeBinaries");
                        abi64 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, Build.SUPPORTED_64_BIT_ABIS, useIsaSpecificSubdirs);
                    } else {
                        Trace.traceBegin(262144, "findSupportedAbi");
                        abi64 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_64_BIT_ABIS);
                    }
                    Trace.traceEnd(262144);
                }
                maybeThrowExceptionForMultiArchCopy("Error unpackaging 64 bit native libs for multiarch app.", abi64);
                if (abi64 >= 0) {
                    if (extractLibs && pkg.isLibrary()) {
                        throw new PackageManagerException(-110, "Shared library native lib extraction not supported");
                    }
                    pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[abi64];
                }
                if (abi32 >= 0) {
                    String abi = Build.SUPPORTED_32_BIT_ABIS[abi32];
                    if (abi64 < 0) {
                        pkg.applicationInfo.primaryCpuAbi = abi;
                    } else if (pkg.use32bitAbi) {
                        pkg.applicationInfo.secondaryCpuAbi = pkg.applicationInfo.primaryCpuAbi;
                        pkg.applicationInfo.primaryCpuAbi = abi;
                    } else {
                        pkg.applicationInfo.secondaryCpuAbi = abi;
                    }
                }
            } else {
                int copyRet;
                String[] abiList = cpuAbiOverride != null ? new String[]{cpuAbiOverride} : Build.SUPPORTED_ABIS;
                boolean needsRenderScriptOverride = false;
                if (Build.SUPPORTED_64_BIT_ABIS.length > 0 && cpuAbiOverride == null && NativeLibraryHelper.hasRenderscriptBitcode(handle)) {
                    abiList = Build.SUPPORTED_32_BIT_ABIS;
                    needsRenderScriptOverride = true;
                }
                if (extractLibs) {
                    Trace.traceBegin(262144, "copyNativeBinaries");
                    copyRet = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, abiList, useIsaSpecificSubdirs);
                } else {
                    Trace.traceBegin(262144, "findSupportedAbi");
                    copyRet = NativeLibraryHelper.findSupportedAbi(handle, abiList);
                }
                Trace.traceEnd(262144);
                if (copyRet < 0 && copyRet != -114) {
                    throw new PackageManagerException(-110, "Error unpackaging native libs for app, errorCode=" + copyRet);
                } else if (copyRet >= 0) {
                    if (pkg.isLibrary()) {
                        throw new PackageManagerException(-110, "Shared library with native libs must be multiarch");
                    }
                    pkg.applicationInfo.primaryCpuAbi = abiList[copyRet];
                } else if (copyRet == -114 && cpuAbiOverride != null) {
                    pkg.applicationInfo.primaryCpuAbi = cpuAbiOverride;
                } else if (needsRenderScriptOverride) {
                    pkg.applicationInfo.primaryCpuAbi = abiList[0];
                }
            }
            IoUtils.closeQuietly(handle);
        } catch (IOException ioe) {
            Slog.e(TAG, "Unable to get canonical file " + ioe.toString());
        } catch (Throwable th) {
            IoUtils.closeQuietly(handle);
        }
        setNativeLibraryPaths(pkg, appLib32InstallDir);
    }

    private void adjustCpuAbisForSharedUserLPw(Set<PackageSetting> packagesForUser, Package scannedPackage) {
        CompatibilityHelper compatibilityHelper;
        String requiredInstructionSet = null;
        if (!(scannedPackage == null || scannedPackage.applicationInfo.primaryCpuAbi == null)) {
            requiredInstructionSet = VMRuntime.getInstructionSet(scannedPackage.applicationInfo.primaryCpuAbi);
        }
        int mismatchTime = 0;
        int[] mismatchArray = new int[]{0, 0, 0};
        PackageSetting requirer = null;
        for (PackageSetting ps : packagesForUser) {
            if ((scannedPackage == null || (scannedPackage.packageName.equals(ps.name) ^ 1) != 0) && ps.primaryCpuAbiString != null) {
                String instructionSet = VMRuntime.getInstructionSet(ps.primaryCpuAbiString);
                compatibilityHelper = mCompatibilityHelper;
                int convertAbi2Int = CompatibilityHelper.convertAbi2Int(ps.primaryCpuAbiString);
                mismatchArray[convertAbi2Int] = mismatchArray[convertAbi2Int] + 1;
                if (!(requiredInstructionSet == null || (instructionSet.equals(requiredInstructionSet) ^ 1) == 0)) {
                    Object obj;
                    StringBuilder append = new StringBuilder().append("Instruction set mismatch, ");
                    if (requirer == null) {
                        obj = "[caller]";
                    } else {
                        PackageSetting obj2 = requirer;
                    }
                    Slog.w(TAG, append.append(obj2).append(" requires ").append(requiredInstructionSet).append(" whereas ").append(ps).append(" requires ").append(instructionSet).toString());
                    mismatchTime++;
                }
                if (requiredInstructionSet == null) {
                    requiredInstructionSet = instructionSet;
                    requirer = ps;
                }
            }
        }
        if (requiredInstructionSet != null) {
            String adjustedAbi;
            if (requirer != null) {
                adjustedAbi = requirer.primaryCpuAbiString;
                if (DEBUG_PMS) {
                    Slog.d(TAG, "abi64=" + mismatchArray[0] + " abiv7a=" + mismatchArray[1] + "abi=" + mismatchArray[2]);
                }
                if (mismatchTime > 1) {
                    int tmp = 0;
                    int index = -1;
                    for (int i = 0; i < mismatchArray.length; i++) {
                        if (mismatchArray[i] > tmp) {
                            tmp = mismatchArray[i];
                            index = i;
                        }
                    }
                    if (index >= 0) {
                        compatibilityHelper = mCompatibilityHelper;
                        adjustedAbi = CompatibilityHelper.convertAbi2String(index);
                    }
                }
                if (scannedPackage != null) {
                    scannedPackage.applicationInfo.primaryCpuAbi = adjustedAbi;
                }
            } else {
                adjustedAbi = scannedPackage.applicationInfo.primaryCpuAbi;
            }
            for (PackageSetting ps2 : packagesForUser) {
                if ((scannedPackage == null || (scannedPackage.packageName.equals(ps2.name) ^ 1) != 0) && ps2.primaryCpuAbiString == null) {
                    ps2.primaryCpuAbiString = adjustedAbi;
                    if (!(ps2.pkg == null || ps2.pkg.applicationInfo == null || (TextUtils.equals(adjustedAbi, ps2.pkg.applicationInfo.primaryCpuAbi) ^ 1) == 0)) {
                        ps2.pkg.applicationInfo.primaryCpuAbi = adjustedAbi;
                        if (DEBUG_ABI_SELECTION) {
                            Slog.i(TAG, "Adjusting ABI for " + ps2.name + " to " + adjustedAbi + " (requirer=" + (requirer != null ? requirer.pkg : "null") + ", scannedPackage=" + (scannedPackage != null ? scannedPackage : "null") + ")");
                        }
                        try {
                            this.mInstaller.rmdex(ps2.codePathString, InstructionSets.getDexCodeInstructionSet(InstructionSets.getPreferredInstructionSet()));
                        } catch (InstallerException e) {
                        }
                    }
                }
            }
        }
    }

    private void setUpCustomResolverActivity(Package pkg) {
        synchronized (this.mPackages) {
            this.mResolverReplaced = true;
            this.mResolveActivity.applicationInfo = pkg.applicationInfo;
            this.mResolveActivity.name = this.mCustomResolverComponentName.getClassName();
            this.mResolveActivity.packageName = pkg.applicationInfo.packageName;
            this.mResolveActivity.processName = pkg.applicationInfo.packageName;
            this.mResolveActivity.launchMode = 0;
            this.mResolveActivity.flags = 288;
            this.mResolveActivity.theme = 0;
            this.mResolveActivity.exported = true;
            this.mResolveActivity.enabled = true;
            this.mResolveInfo.activityInfo = this.mResolveActivity;
            this.mResolveInfo.priority = 0;
            this.mResolveInfo.preferredOrder = 0;
            this.mResolveInfo.match = 0;
            this.mResolveComponentName = this.mCustomResolverComponentName;
            Slog.i(TAG, "Replacing default ResolverActivity with custom activity: " + this.mResolveComponentName);
        }
    }

    private void setUpInstantAppInstallerActivityLP(ActivityInfo installerActivity) {
        if (installerActivity == null) {
            if (DEBUG_EPHEMERAL) {
                Slog.d(TAG, "Clear ephemeral installer activity");
            }
            this.mInstantAppInstallerActivity = null;
            return;
        }
        if (DEBUG_EPHEMERAL) {
            Slog.d(TAG, "Set ephemeral installer activity: " + installerActivity.getComponentName());
        }
        this.mInstantAppInstallerActivity = installerActivity;
        ActivityInfo activityInfo = this.mInstantAppInstallerActivity;
        activityInfo.flags |= 288;
        this.mInstantAppInstallerActivity.exported = true;
        this.mInstantAppInstallerActivity.enabled = true;
        this.mInstantAppInstallerInfo.activityInfo = this.mInstantAppInstallerActivity;
        this.mInstantAppInstallerInfo.priority = 0;
        this.mInstantAppInstallerInfo.preferredOrder = 1;
        this.mInstantAppInstallerInfo.isDefault = true;
        this.mInstantAppInstallerInfo.match = 5799936;
    }

    private static String calculateBundledApkRoot(String codePathString) {
        File codeRoot;
        File codePath = new File(codePathString);
        if (FileUtils.contains(Environment.getRootDirectory(), codePath)) {
            codeRoot = Environment.getRootDirectory();
        } else if (FileUtils.contains(Environment.getOemDirectory(), codePath)) {
            codeRoot = Environment.getOemDirectory();
        } else if (FileUtils.contains(Environment.getVendorDirectory(), codePath)) {
            codeRoot = Environment.getVendorDirectory();
        } else {
            try {
                File f = codePath.getCanonicalFile();
                File parent = f.getParentFile();
                while (true) {
                    File tmp = parent.getParentFile();
                    if (tmp == null) {
                        break;
                    }
                    f = parent;
                    parent = tmp;
                }
                codeRoot = f;
                Slog.w(TAG, "Unrecognized code path " + codePath + " - using " + codeRoot);
            } catch (IOException e) {
                Slog.w(TAG, "Can't canonicalize code path " + codePath);
                return Environment.getRootDirectory().getPath();
            }
        }
        return codeRoot.getPath();
    }

    private static void setNativeLibraryPaths(Package pkg, File appLib32InstallDir) {
        ApplicationInfo info = pkg.applicationInfo;
        String codePath = pkg.codePath;
        File codeFile = new File(codePath);
        int bundledApp = info.isSystemApp() ? info.isUpdatedSystemApp() ^ 1 : 0;
        boolean asecApp = !info.isForwardLocked() ? info.isExternalAsec() : true;
        info.nativeLibraryRootDir = null;
        info.nativeLibraryRootRequiresIsa = false;
        info.nativeLibraryDir = null;
        info.secondaryNativeLibraryDir = null;
        if (PackageParser.isApkFile(codeFile)) {
            if (bundledApp != 0) {
                String apkRoot = calculateBundledApkRoot(info.sourceDir);
                boolean is64Bit = VMRuntime.is64BitInstructionSet(InstructionSets.getPrimaryInstructionSet(info));
                String apkName = deriveCodePathName(codePath);
                String libDir = is64Bit ? "lib64" : "lib";
                info.nativeLibraryRootDir = Environment.buildPath(new File(apkRoot), new String[]{libDir, apkName}).getAbsolutePath();
                if (info.secondaryCpuAbi != null) {
                    String secondaryLibDir = is64Bit ? "lib" : "lib64";
                    info.secondaryNativeLibraryDir = Environment.buildPath(new File(apkRoot), new String[]{secondaryLibDir, apkName}).getAbsolutePath();
                }
            } else if (asecApp) {
                info.nativeLibraryRootDir = new File(codeFile.getParentFile(), "lib").getAbsolutePath();
            } else {
                info.nativeLibraryRootDir = new File(appLib32InstallDir, deriveCodePathName(codePath)).getAbsolutePath();
            }
            info.nativeLibraryRootRequiresIsa = false;
            info.nativeLibraryDir = info.nativeLibraryRootDir;
        } else {
            info.nativeLibraryRootDir = new File(codeFile, "lib").getAbsolutePath();
            info.nativeLibraryRootRequiresIsa = true;
            info.nativeLibraryDir = new File(info.nativeLibraryRootDir, InstructionSets.getPrimaryInstructionSet(info)).getAbsolutePath();
            if (info.secondaryCpuAbi != null) {
                info.secondaryNativeLibraryDir = new File(info.nativeLibraryRootDir, VMRuntime.getInstructionSet(info.secondaryCpuAbi)).getAbsolutePath();
            }
        }
        if (!info.isSystemApp() && info.nativeLibraryDir != null && (info.nativeLibraryDir.contains(".tmp") ^ 1) != 0) {
            mCompatibilityHelper.customizeNativeLibrariesIfNeeded(pkg);
        }
    }

    private static void setBundledAppAbisAndRoots(Package pkg, PackageSetting pkgSetting) {
        setBundledAppAbi(pkg, calculateBundledApkRoot(pkg.applicationInfo.sourceDir), deriveCodePathName(pkg.applicationInfo.getCodePath()));
        if (pkgSetting != null) {
            pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;
            pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;
        }
    }

    private static void setBundledAppAbi(Package pkg, String apkRoot, String apkName) {
        int has64BitLibs;
        int has32BitLibs;
        File codeFile = new File(pkg.codePath);
        if (PackageParser.isApkFile(codeFile)) {
            has64BitLibs = new File(apkRoot, new File("lib64", apkName).getPath()).exists();
            has32BitLibs = new File(apkRoot, new File("lib", apkName).getPath()).exists();
        } else {
            File rootDir = new File(codeFile, "lib");
            if (ArrayUtils.isEmpty(Build.SUPPORTED_64_BIT_ABIS) || (TextUtils.isEmpty(Build.SUPPORTED_64_BIT_ABIS[0]) ^ 1) == 0) {
                has64BitLibs = 0;
            } else {
                has64BitLibs = new File(rootDir, VMRuntime.getInstructionSet(Build.SUPPORTED_64_BIT_ABIS[0])).exists();
            }
            if (ArrayUtils.isEmpty(Build.SUPPORTED_32_BIT_ABIS) || (TextUtils.isEmpty(Build.SUPPORTED_32_BIT_ABIS[0]) ^ 1) == 0) {
                has32BitLibs = 0;
            } else {
                has32BitLibs = new File(rootDir, VMRuntime.getInstructionSet(Build.SUPPORTED_32_BIT_ABIS[0])).exists();
            }
        }
        if (has64BitLibs != 0 && (has32BitLibs ^ 1) != 0) {
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = null;
        } else if (has32BitLibs != 0 && (has64BitLibs ^ 1) != 0) {
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = null;
        } else if (has32BitLibs == 0 || has64BitLibs == 0) {
            pkg.applicationInfo.primaryCpuAbi = null;
            pkg.applicationInfo.secondaryCpuAbi = null;
        } else {
            if ((pkg.applicationInfo.flags & Integer.MIN_VALUE) == 0) {
                Slog.e(TAG, "Package " + pkg + " has multiple bundled libs, but is not multiarch.");
            }
            if (VMRuntime.is64BitInstructionSet(InstructionSets.getPreferredInstructionSet())) {
                pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
                pkg.applicationInfo.secondaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
                return;
            }
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
        }
    }

    private void killApplication(String pkgName, int appId, String reason) {
        killApplication(pkgName, appId, -1, reason);
    }

    private void killApplication(String pkgName, int appId, int userId, String reason) {
        long token = Binder.clearCallingIdentity();
        try {
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                try {
                    am.killApplication(pkgName, appId, userId, reason);
                } catch (RemoteException e) {
                }
            }
            Binder.restoreCallingIdentity(token);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(token);
        }
    }

    private void removePackageLI(Package pkg, boolean chatty) {
        PackageSetting ps = pkg.mExtras;
        if (ps != null) {
            removePackageLI(ps, chatty);
        }
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            ps = ((Package) pkg.childPackages.get(i)).mExtras;
            if (ps != null) {
                removePackageLI(ps, chatty);
            }
        }
    }

    void removePackageLI(PackageSetting ps, boolean chatty) {
        if (DEBUG_INSTALL && chatty) {
            Log.d(TAG, "Removing package " + ps.name);
        }
        synchronized (this.mPackages) {
            this.mPackages.remove(ps.name);
            Package pkg = ps.pkg;
            if (pkg != null) {
                cleanPackageDataStructuresLILPw(pkg, chatty);
            }
        }
    }

    void removeInstalledPackageLI(Package pkg, boolean chatty) {
        if (DEBUG_INSTALL && chatty) {
            Log.d(TAG, "Removing package " + pkg.applicationInfo.packageName);
        }
        synchronized (this.mPackages) {
            this.mPackages.remove(pkg.applicationInfo.packageName);
            cleanPackageDataStructuresLILPw(pkg, chatty);
            int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                Package childPkg = (Package) pkg.childPackages.get(i);
                this.mPackages.remove(childPkg.applicationInfo.packageName);
                cleanPackageDataStructuresLILPw(childPkg, chatty);
            }
        }
    }

    void cleanPackageDataStructuresLILPw(Package pkg, boolean chatty) {
        int i;
        Activity a;
        BasePermission bp;
        ArraySet<String> appOpPkgs;
        int N = pkg.providers.size();
        StringBuilder r = null;
        for (i = 0; i < N; i++) {
            Provider p = (Provider) pkg.providers.get(i);
            this.mProviders.removeProvider(p);
            if (p.info.authority != null) {
                String[] names = p.info.authority.split(";");
                for (int j = 0; j < names.length; j++) {
                    if (this.mProvidersByAuthority.get(names[j]) == p) {
                        this.mProvidersByAuthority.remove(names[j]);
                        if (DEBUG_REMOVE && chatty) {
                            Log.d(TAG, "Unregistered content provider: " + names[j] + ", className = " + p.info.name + ", isSyncable = " + p.info.isSyncable);
                        }
                    }
                }
                if (DEBUG_REMOVE && chatty) {
                    if (r == null) {
                        r = new StringBuilder(256);
                    } else {
                        r.append(' ');
                    }
                    r.append(p.info.name);
                }
            }
        }
        if (r != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Providers: " + r);
        }
        N = pkg.services.size();
        r = null;
        for (i = 0; i < N; i++) {
            Service s = (Service) pkg.services.get(i);
            this.mServices.removeService(s);
            if (chatty) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(s.info.name);
            }
        }
        if (r != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Services: " + r);
        }
        N = pkg.receivers.size();
        r = null;
        for (i = 0; i < N; i++) {
            a = (Activity) pkg.receivers.get(i);
            this.mReceivers.removeActivity(a, "receiver");
            if (DEBUG_REMOVE && chatty) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Receivers: " + r);
        }
        N = pkg.activities.size();
        r = null;
        for (i = 0; i < N; i++) {
            a = (Activity) pkg.activities.get(i);
            this.mActivities.removeActivity(a, OppoAppStartupManager.TYPE_ACTIVITY);
            if (DEBUG_REMOVE && chatty) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Activities: " + r);
        }
        N = pkg.permissions.size();
        r = null;
        for (i = 0; i < N; i++) {
            Permission p2 = (Permission) pkg.permissions.get(i);
            bp = (BasePermission) this.mSettings.mPermissions.get(p2.info.name);
            if (bp == null) {
                bp = (BasePermission) this.mSettings.mPermissionTrees.get(p2.info.name);
            }
            if (bp != null && bp.perm == p2) {
                bp.perm = null;
                if (DEBUG_REMOVE && chatty) {
                    if (r == null) {
                        r = new StringBuilder(256);
                    } else {
                        r.append(' ');
                    }
                    r.append(p2.info.name);
                }
            }
            if ((p2.info.protectionLevel & 64) != 0) {
                appOpPkgs = (ArraySet) this.mAppOpPermissionPackages.get(p2.info.name);
                if (appOpPkgs != null) {
                    appOpPkgs.remove(pkg.packageName);
                }
            }
        }
        if (r != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Permissions: " + r);
        }
        N = pkg.requestedPermissions.size();
        for (i = 0; i < N; i++) {
            String perm = (String) pkg.requestedPermissions.get(i);
            bp = (BasePermission) this.mSettings.mPermissions.get(perm);
            if (!(bp == null || (bp.protectionLevel & 64) == 0)) {
                appOpPkgs = (ArraySet) this.mAppOpPermissionPackages.get(perm);
                if (appOpPkgs != null) {
                    appOpPkgs.remove(pkg.packageName);
                    if (appOpPkgs.isEmpty()) {
                        this.mAppOpPermissionPackages.remove(perm);
                    }
                }
            }
        }
        N = pkg.instrumentation.size();
        r = null;
        for (i = 0; i < N; i++) {
            Instrumentation a2 = (Instrumentation) pkg.instrumentation.get(i);
            this.mInstrumentation.remove(a2.getComponentName());
            if (DEBUG_REMOVE && chatty) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a2.info.name);
            }
        }
        if (r != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Instrumentation: " + r);
        }
        r = null;
        if (!((pkg.applicationInfo.flags & 1) == 0 || pkg.libraryNames == null)) {
            for (i = 0; i < pkg.libraryNames.size(); i++) {
                String name = (String) pkg.libraryNames.get(i);
                if (removeSharedLibraryLPw(name, 0) && DEBUG_REMOVE && chatty) {
                    if (r == null) {
                        r = new StringBuilder(256);
                    } else {
                        r.append(' ');
                    }
                    r.append(name);
                }
            }
        }
        Object r2 = null;
        if (pkg.staticSharedLibName != null) {
            if (removeSharedLibraryLPw(pkg.staticSharedLibName, pkg.staticSharedLibVersion) && DEBUG_REMOVE && chatty) {
                r2 = new StringBuilder(256);
                r2.append(pkg.staticSharedLibName);
            }
        }
        if (r2 != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Libraries: " + r2);
        }
    }

    private static boolean hasPermission(Package pkgInfo, String perm) {
        for (int i = pkgInfo.permissions.size() - 1; i >= 0; i--) {
            if (((Permission) pkgInfo.permissions.get(i)).info.name.equals(perm)) {
                return true;
            }
        }
        return false;
    }

    private void updatePermissionsLPw(Package pkg, int flags) {
        updatePermissionsLPw(pkg.packageName, pkg, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            Package childPkg = (Package) pkg.childPackages.get(i);
            updatePermissionsLPw(childPkg.packageName, childPkg, flags);
        }
    }

    private void updatePermissionsLPw(String changingPkg, Package pkgInfo, int flags) {
        updatePermissionsLPw(changingPkg, pkgInfo, pkgInfo != null ? getVolumeUuidForPackage(pkgInfo) : null, flags);
    }

    private void updatePermissionsLPw(String changingPkg, Package pkgInfo, String replaceVolumeUuid, int flags) {
        BasePermission bp;
        String volumeUuid;
        boolean replace;
        Iterator<BasePermission> it = this.mSettings.mPermissionTrees.values().iterator();
        while (it.hasNext()) {
            bp = (BasePermission) it.next();
            if (bp.packageSetting == null) {
                bp.packageSetting = (PackageSettingBase) this.mSettings.mPackages.get(bp.sourcePackage);
            }
            if (bp.packageSetting == null) {
                Slog.w(TAG, "Removing dangling permission tree: " + bp.name + " from package " + bp.sourcePackage);
                it.remove();
            } else if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
                if (pkgInfo == null || (hasPermission(pkgInfo, bp.name) ^ 1) != 0) {
                    Slog.i(TAG, "Removing old permission tree: " + bp.name + " from package " + bp.sourcePackage);
                    flags |= 1;
                    it.remove();
                }
            }
        }
        it = this.mSettings.mPermissions.values().iterator();
        while (it.hasNext()) {
            bp = (BasePermission) it.next();
            if (bp.type == 2) {
                if (DEBUG_SETTINGS) {
                    Log.v(TAG, "Dynamic permission: name=" + bp.name + " pkg=" + bp.sourcePackage + " info=" + bp.pendingInfo);
                }
                if (bp.packageSetting == null && bp.pendingInfo != null) {
                    BasePermission tree = findPermissionTreeLP(bp.name);
                    if (!(tree == null || tree.perm == null)) {
                        bp.packageSetting = tree.packageSetting;
                        bp.perm = new Permission(tree.perm.owner, new PermissionInfo(bp.pendingInfo));
                        bp.perm.info.packageName = tree.perm.info.packageName;
                        bp.perm.info.name = bp.name;
                        bp.uid = tree.uid;
                    }
                }
            }
            if (bp.packageSetting == null) {
                bp.packageSetting = (PackageSettingBase) this.mSettings.mPackages.get(bp.sourcePackage);
            }
            if (bp.packageSetting == null) {
                Slog.w(TAG, "Removing dangling permission: " + bp.name + " from package " + bp.sourcePackage);
                it.remove();
            } else if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
                if (pkgInfo == null || (hasPermission(pkgInfo, bp.name) ^ 1) != 0) {
                    Slog.i(TAG, "Removing old permission: " + bp.name + " from package " + bp.sourcePackage);
                    flags |= 1;
                    it.remove();
                }
            }
        }
        Trace.traceBegin(262144, "grantPermissions");
        if ((flags & 1) != 0) {
            for (Package pkg : this.mPackages.values()) {
                if (pkg != pkgInfo) {
                    volumeUuid = getVolumeUuidForPackage(pkg);
                    if ((flags & 4) != 0) {
                        replace = Objects.equals(replaceVolumeUuid, volumeUuid);
                    } else {
                        replace = false;
                    }
                    grantPermissionsLPw(pkg, replace, changingPkg);
                }
            }
        }
        if (pkgInfo != null) {
            volumeUuid = getVolumeUuidForPackage(pkgInfo);
            if ((flags & 2) != 0) {
                replace = Objects.equals(replaceVolumeUuid, volumeUuid);
            } else {
                replace = false;
            }
            grantPermissionsLPw(pkgInfo, replace, changingPkg);
        }
        Trace.traceEnd(262144);
    }

    private void grantPermissionsLPw(android.content.pm.PackageParser.Package r32, boolean r33, java.lang.String r34) {
        /* JADX: method processing error */
/*
Error: jadx.core.utils.exceptions.JadxRuntimeException: Unknown predecessor block by arg (r16_1 'origPermissions' com.android.server.pm.PermissionsState) in PHI: PHI: (r16_2 'origPermissions' com.android.server.pm.PermissionsState) = (r16_0 'origPermissions' com.android.server.pm.PermissionsState), (r16_1 'origPermissions' com.android.server.pm.PermissionsState), (r16_0 'origPermissions' com.android.server.pm.PermissionsState), (r16_0 'origPermissions' com.android.server.pm.PermissionsState) binds: {(r16_0 'origPermissions' com.android.server.pm.PermissionsState)=B:4:0x001e, (r16_1 'origPermissions' com.android.server.pm.PermissionsState)=B:7:0x002e, (r16_0 'origPermissions' com.android.server.pm.PermissionsState)=B:23:0x0110, (r16_0 'origPermissions' com.android.server.pm.PermissionsState)=B:24:0x0112}
	at jadx.core.dex.instructions.PhiInsn.replaceArg(PhiInsn.java:78)
	at jadx.core.dex.visitors.ModVisitor.processInvoke(ModVisitor.java:222)
	at jadx.core.dex.visitors.ModVisitor.replaceStep(ModVisitor.java:83)
	at jadx.core.dex.visitors.ModVisitor.visit(ModVisitor.java:68)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:27)
	at jadx.core.dex.visitors.DepthTraversal.lambda$visit$1(DepthTraversal.java:14)
	at java.util.ArrayList.forEach(ArrayList.java:1251)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:14)
	at jadx.core.ProcessClass.process(ProcessClass.java:32)
	at jadx.core.ProcessClass.lambda$processDependencies$0(ProcessClass.java:51)
	at java.lang.Iterable.forEach(Iterable.java:75)
	at jadx.core.ProcessClass.processDependencies(ProcessClass.java:51)
	at jadx.core.ProcessClass.process(ProcessClass.java:37)
	at jadx.api.JadxDecompiler.processClass(JadxDecompiler.java:286)
	at jadx.api.JavaClass.decompile(JavaClass.java:62)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
*/
        /*
        r31 = this;
        r0 = r32;
        r0 = r0.mExtras;
        r21 = r0;
        r21 = (com.android.server.pm.PackageSetting) r21;
        if (r21 != 0) goto L_0x000b;
    L_0x000a:
        return;
    L_0x000b:
        r19 = r21.getPermissionsState();
        r16 = r19;
        r26 = com.android.server.pm.UserManagerService.getInstance();
        r10 = r26.getUserIds();
        r23 = 0;
        r9 = EMPTY_INT_ARRAY;
        r8 = 0;
        if (r33 == 0) goto L_0x003a;
    L_0x0020:
        r26 = 0;
        r0 = r26;
        r1 = r21;
        r1.installPermissionsFixed = r0;
        r26 = r21.isSharedUser();
        if (r26 != 0) goto L_0x00f4;
    L_0x002e:
        r16 = new com.android.server.pm.PermissionsState;
        r0 = r16;
        r1 = r19;
        r0.<init>(r1);
        r19.reset();
    L_0x003a:
        r0 = r31;
        r0 = r0.mGlobalGids;
        r26 = r0;
        r0 = r19;
        r1 = r26;
        r0.setGlobalGids(r1);
        r26 = "oppo.runtime.permission.alert.support";
        r27 = 0;
        r0 = r31;
        r1 = r26;
        r2 = r27;
        r24 = r0.hasSystemFeature(r1, r2);
        r0 = r32;
        r0 = r0.requestedPermissions;
        r26 = r0;
        r4 = r26.size();
        r13 = 0;
    L_0x0061:
        if (r13 >= r4) goto L_0x0456;
    L_0x0063:
        r0 = r32;
        r0 = r0.requestedPermissions;
        r26 = r0;
        r0 = r26;
        r15 = r0.get(r13);
        r15 = (java.lang.String) r15;
        r0 = r31;
        r0 = r0.mSettings;
        r26 = r0;
        r0 = r26;
        r0 = r0.mPermissions;
        r26 = r0;
        r0 = r26;
        r7 = r0.get(r15);
        r7 = (com.android.server.pm.BasePermission) r7;
        r0 = r32;
        r0 = r0.applicationInfo;
        r26 = r0;
        r0 = r26;
        r0 = r0.targetSdkVersion;
        r26 = r0;
        r27 = 23;
        r0 = r26;
        r1 = r27;
        if (r0 < r1) goto L_0x0116;
    L_0x0099:
        r6 = 1;
    L_0x009a:
        r26 = DEBUG_INSTALL;
        if (r26 == 0) goto L_0x00d8;
    L_0x009e:
        r26 = "PackageManager";
        r27 = new java.lang.StringBuilder;
        r27.<init>();
        r28 = "Package ";
        r27 = r27.append(r28);
        r0 = r32;
        r0 = r0.packageName;
        r28 = r0;
        r27 = r27.append(r28);
        r28 = " checking ";
        r27 = r27.append(r28);
        r0 = r27;
        r27 = r0.append(r15);
        r28 = ": ";
        r27 = r27.append(r28);
        r0 = r27;
        r27 = r0.append(r7);
        r27 = r27.toString();
        android.util.Log.i(r26, r27);
    L_0x00d8:
        if (r7 == 0) goto L_0x00e0;
    L_0x00da:
        r0 = r7.packageSetting;
        r26 = r0;
        if (r26 != 0) goto L_0x0118;
    L_0x00e0:
        if (r34 == 0) goto L_0x00f0;
    L_0x00e2:
        r0 = r32;
        r0 = r0.packageName;
        r26 = r0;
        r0 = r34;
        r1 = r26;
        r26 = r0.equals(r1);
    L_0x00f0:
        r13 = r13 + 1;
        goto L_0x0061;
    L_0x00f4:
        r0 = r21;
        r0 = r0.sharedUser;
        r26 = r0;
        r27 = com.android.server.pm.UserManagerService.getInstance();
        r27 = r27.getUserIds();
        r0 = r31;
        r1 = r26;
        r2 = r27;
        r9 = r0.revokeUnusedSharedUserPermissionsLPw(r1, r2);
        r26 = com.android.internal.util.ArrayUtils.isEmpty(r9);
        if (r26 != 0) goto L_0x003a;
    L_0x0112:
        r23 = 1;
        goto L_0x003a;
    L_0x0116:
        r6 = 0;
        goto L_0x009a;
    L_0x0118:
        r0 = r32;
        r0 = r0.applicationInfo;
        r26 = r0;
        r26 = r26.isInstantApp();
        if (r26 == 0) goto L_0x012c;
    L_0x0124:
        r26 = r7.isInstant();
        r26 = r26 ^ 1;
        if (r26 != 0) goto L_0x00f0;
    L_0x012c:
        r26 = r7.isRuntimeOnly();
        if (r26 == 0) goto L_0x0136;
    L_0x0132:
        r26 = r6 ^ 1;
        if (r26 != 0) goto L_0x00f0;
    L_0x0136:
        r0 = r7.name;
        r17 = r0;
        r5 = 0;
        r12 = 1;
        r0 = r7.protectionLevel;
        r26 = r0;
        r26 = r26 & 64;
        if (r26 == 0) goto L_0x017b;
    L_0x0144:
        r0 = r31;
        r0 = r0.mAppOpPermissionPackages;
        r26 = r0;
        r0 = r7.name;
        r27 = r0;
        r20 = r26.get(r27);
        r20 = (android.util.ArraySet) r20;
        if (r20 != 0) goto L_0x016e;
    L_0x0156:
        r20 = new android.util.ArraySet;
        r20.<init>();
        r0 = r31;
        r0 = r0.mAppOpPermissionPackages;
        r26 = r0;
        r0 = r7.name;
        r27 = r0;
        r0 = r26;
        r1 = r27;
        r2 = r20;
        r0.put(r1, r2);
    L_0x016e:
        r0 = r32;
        r0 = r0.packageName;
        r26 = r0;
        r0 = r20;
        r1 = r26;
        r0.add(r1);
    L_0x017b:
        r0 = r7.protectionLevel;
        r26 = r0;
        r14 = r26 & 15;
        switch(r14) {
            case 0: goto L_0x01ea;
            case 1: goto L_0x01ec;
            case 2: goto L_0x0231;
            default: goto L_0x0184;
        };
    L_0x0184:
        r26 = android.os.OppoManager.isInnerVersion;
        r26 = r26.booleanValue();
        if (r26 == 0) goto L_0x01aa;
    L_0x018c:
        r26 = android.os.OppoManager.grList;
        r0 = r32;
        r0 = r0.packageName;
        r27 = r0;
        r26 = r26.contains(r27);
        if (r26 != 0) goto L_0x01a9;
    L_0x019a:
        r26 = "com.android.vending";
        r0 = r32;
        r0 = r0.packageName;
        r27 = r0;
        r26 = r26.equals(r27);
        if (r26 == 0) goto L_0x01aa;
    L_0x01a9:
        r12 = 2;
    L_0x01aa:
        r26 = 1;
        r0 = r26;
        if (r12 == r0) goto L_0x03cc;
    L_0x01b0:
        r26 = isSystemApp(r21);
        if (r26 != 0) goto L_0x01d5;
    L_0x01b6:
        r0 = r21;
        r0 = r0.installPermissionsFixed;
        r26 = r0;
        if (r26 == 0) goto L_0x01d5;
    L_0x01be:
        if (r5 != 0) goto L_0x01d5;
    L_0x01c0:
        r26 = r16.hasInstallPermission(r17);
        r26 = r26 ^ 1;
        if (r26 == 0) goto L_0x01d5;
    L_0x01c8:
        r0 = r31;
        r1 = r17;
        r2 = r32;
        r26 = r0.isNewPlatformPermissionForPackage(r1, r2);
        if (r26 != 0) goto L_0x01d5;
    L_0x01d4:
        r12 = 1;
    L_0x01d5:
        switch(r12) {
            case 2: goto L_0x0242;
            case 3: goto L_0x0299;
            case 4: goto L_0x0367;
            default: goto L_0x01d8;
        };
    L_0x01d8:
        if (r34 == 0) goto L_0x00f0;
    L_0x01da:
        r0 = r32;
        r0 = r0.packageName;
        r26 = r0;
        r0 = r34;
        r1 = r26;
        r26 = r0.equals(r1);
        goto L_0x00f0;
    L_0x01ea:
        r12 = 2;
        goto L_0x0184;
    L_0x01ec:
        if (r6 != 0) goto L_0x01fa;
    L_0x01ee:
        r0 = r31;
        r0 = r0.mPermissionReviewRequired;
        r26 = r0;
        r26 = r26 ^ 1;
        if (r26 == 0) goto L_0x01fa;
    L_0x01f8:
        r12 = 2;
        goto L_0x0184;
    L_0x01fa:
        r0 = r7.name;
        r26 = r0;
        r0 = r16;
        r1 = r26;
        r26 = r0.hasInstallPermission(r1);
        if (r26 == 0) goto L_0x020b;
    L_0x0208:
        r12 = 4;
        goto L_0x0184;
    L_0x020b:
        r0 = r31;
        r0 = r0.mPromoteSystemApps;
        r26 = r0;
        if (r26 == 0) goto L_0x022e;
    L_0x0213:
        r26 = isSystemApp(r21);
        if (r26 == 0) goto L_0x022e;
    L_0x0219:
        r0 = r31;
        r0 = r0.mExistingSystemPackages;
        r26 = r0;
        r0 = r21;
        r0 = r0.name;
        r27 = r0;
        r26 = r26.contains(r27);
        if (r26 == 0) goto L_0x022e;
    L_0x022b:
        r12 = 4;
        goto L_0x0184;
    L_0x022e:
        r12 = 3;
        goto L_0x0184;
    L_0x0231:
        r0 = r31;
        r1 = r17;
        r2 = r32;
        r3 = r16;
        r5 = r0.grantSignaturePermission(r1, r2, r7, r3);
        if (r5 == 0) goto L_0x0184;
    L_0x023f:
        r12 = 2;
        goto L_0x0184;
    L_0x0242:
        r26 = com.android.server.pm.UserManagerService.getInstance();
        r27 = r26.getUserIds();
        r26 = 0;
        r0 = r27;
        r0 = r0.length;
        r28 = r0;
    L_0x0251:
        r0 = r26;
        r1 = r28;
        if (r0 >= r1) goto L_0x0288;
    L_0x0257:
        r25 = r27[r26];
        r0 = r7.name;
        r29 = r0;
        r0 = r16;
        r1 = r29;
        r2 = r25;
        r29 = r0.getRuntimePermissionState(r1, r2);
        if (r29 == 0) goto L_0x0285;
    L_0x0269:
        r0 = r16;
        r1 = r25;
        r0.revokeRuntimePermission(r7, r1);
        r29 = 255; // 0xff float:3.57E-43 double:1.26E-321;
        r30 = 0;
        r0 = r16;
        r1 = r25;
        r2 = r29;
        r3 = r30;
        r0.updatePermissionFlags(r7, r1, r2, r3);
        r0 = r25;
        r9 = com.android.internal.util.ArrayUtils.appendInt(r9, r0);
    L_0x0285:
        r26 = r26 + 1;
        goto L_0x0251;
    L_0x0288:
        r0 = r19;
        r26 = r0.grantInstallPermission(r7);
        r27 = -1;
        r0 = r26;
        r1 = r27;
        if (r0 == r1) goto L_0x00f0;
    L_0x0296:
        r8 = 1;
        goto L_0x00f0;
    L_0x0299:
        r26 = com.android.server.pm.UserManagerService.getInstance();
        r27 = r26.getUserIds();
        r26 = 0;
        r0 = r27;
        r0 = r0.length;
        r28 = r0;
    L_0x02a8:
        r0 = r26;
        r1 = r28;
        if (r0 >= r1) goto L_0x00f0;
    L_0x02ae:
        r25 = r27[r26];
        r0 = r7.name;
        r29 = r0;
        r0 = r16;
        r1 = r29;
        r2 = r25;
        r18 = r0.getRuntimePermissionState(r1, r2);
        if (r18 == 0) goto L_0x0326;
    L_0x02c0:
        r11 = r18.getFlags();
    L_0x02c4:
        r0 = r7.name;
        r29 = r0;
        r0 = r16;
        r1 = r29;
        r2 = r25;
        r29 = r0.hasRuntimePermission(r1, r2);
        if (r29 == 0) goto L_0x032b;
    L_0x02d4:
        r29 = r11 & 8;
        if (r29 == 0) goto L_0x0328;
    L_0x02d8:
        r22 = 1;
    L_0x02da:
        if (r22 == 0) goto L_0x02e4;
    L_0x02dc:
        r11 = r11 & -9;
        r0 = r25;
        r9 = com.android.internal.util.ArrayUtils.appendInt(r9, r0);
    L_0x02e4:
        r0 = r31;
        r0 = r0.mPermissionReviewRequired;
        r29 = r0;
        if (r29 == 0) goto L_0x02f0;
    L_0x02ec:
        r29 = r22 ^ 1;
        if (r29 == 0) goto L_0x0306;
    L_0x02f0:
        r0 = r19;
        r1 = r25;
        r29 = r0.grantRuntimePermission(r7, r1);
        r30 = -1;
        r0 = r29;
        r1 = r30;
        if (r0 != r1) goto L_0x0306;
    L_0x0300:
        r0 = r25;
        r9 = com.android.internal.util.ArrayUtils.appendInt(r9, r0);
    L_0x0306:
        r0 = r31;
        r0 = r0.mPermissionReviewRequired;
        r29 = r0;
        if (r29 == 0) goto L_0x031c;
    L_0x030e:
        if (r6 == 0) goto L_0x031c;
    L_0x0310:
        r29 = r11 & 64;
        if (r29 == 0) goto L_0x031c;
    L_0x0314:
        r11 = r11 & -65;
        r0 = r25;
        r9 = com.android.internal.util.ArrayUtils.appendInt(r9, r0);
    L_0x031c:
        r0 = r19;
        r1 = r25;
        r0.updatePermissionFlags(r7, r1, r11, r11);
        r26 = r26 + 1;
        goto L_0x02a8;
    L_0x0326:
        r11 = 0;
        goto L_0x02c4;
    L_0x0328:
        r22 = 0;
        goto L_0x02da;
    L_0x032b:
        r0 = r31;
        r0 = r0.mPermissionReviewRequired;
        r29 = r0;
        if (r29 == 0) goto L_0x031c;
    L_0x0333:
        r29 = r6 ^ 1;
        if (r29 == 0) goto L_0x031c;
    L_0x0337:
        r29 = "android";
        r0 = r7.sourcePackage;
        r30 = r0;
        r29 = r29.equals(r30);
        if (r29 == 0) goto L_0x0350;
    L_0x0344:
        r29 = r11 & 64;
        if (r29 != 0) goto L_0x0350;
    L_0x0348:
        r11 = r11 | 64;
        r0 = r25;
        r9 = com.android.internal.util.ArrayUtils.appendInt(r9, r0);
    L_0x0350:
        r0 = r19;
        r1 = r25;
        r29 = r0.grantRuntimePermission(r7, r1);
        r30 = -1;
        r0 = r29;
        r1 = r30;
        if (r0 == r1) goto L_0x031c;
    L_0x0360:
        r0 = r25;
        r9 = com.android.internal.util.ArrayUtils.appendInt(r9, r0);
        goto L_0x031c;
    L_0x0367:
        r0 = r7.name;
        r26 = r0;
        r0 = r16;
        r1 = r26;
        r18 = r0.getInstallPermissionState(r1);
        if (r18 == 0) goto L_0x03ca;
    L_0x0375:
        r11 = r18.getFlags();
    L_0x0379:
        r0 = r16;
        r26 = r0.revokeInstallPermission(r7);
        r27 = -1;
        r0 = r26;
        r1 = r27;
        if (r0 == r1) goto L_0x0399;
    L_0x0387:
        r26 = -1;
        r27 = 255; // 0xff float:3.57E-43 double:1.26E-321;
        r28 = 0;
        r0 = r16;
        r1 = r26;
        r2 = r27;
        r3 = r28;
        r0.updatePermissionFlags(r7, r1, r2, r3);
        r8 = 1;
    L_0x0399:
        r26 = r11 & 8;
        if (r26 != 0) goto L_0x00f0;
    L_0x039d:
        r26 = 0;
        r0 = r10.length;
        r27 = r0;
    L_0x03a2:
        r0 = r26;
        r1 = r27;
        if (r0 >= r1) goto L_0x00f0;
    L_0x03a8:
        r25 = r10[r26];
        r0 = r19;
        r1 = r25;
        r28 = r0.grantRuntimePermission(r7, r1);
        r29 = -1;
        r0 = r28;
        r1 = r29;
        if (r0 == r1) goto L_0x03c7;
    L_0x03ba:
        r0 = r19;
        r1 = r25;
        r0.updatePermissionFlags(r7, r1, r11, r11);
        r0 = r25;
        r9 = com.android.internal.util.ArrayUtils.appendInt(r9, r0);
    L_0x03c7:
        r26 = r26 + 1;
        goto L_0x03a2;
    L_0x03ca:
        r11 = 0;
        goto L_0x0379;
    L_0x03cc:
        r0 = r19;
        r26 = r0.revokeInstallPermission(r7);
        r27 = -1;
        r0 = r26;
        r1 = r27;
        if (r0 == r1) goto L_0x044e;
    L_0x03da:
        r26 = -1;
        r27 = 255; // 0xff float:3.57E-43 double:1.26E-321;
        r28 = 0;
        r0 = r19;
        r1 = r26;
        r2 = r27;
        r3 = r28;
        r0.updatePermissionFlags(r7, r1, r2, r3);
        r8 = 1;
        r26 = "PackageManager";
        r27 = new java.lang.StringBuilder;
        r27.<init>();
        r28 = "Un-granting permission ";
        r27 = r27.append(r28);
        r0 = r27;
        r1 = r17;
        r27 = r0.append(r1);
        r28 = " from package ";
        r27 = r27.append(r28);
        r0 = r32;
        r0 = r0.packageName;
        r28 = r0;
        r27 = r27.append(r28);
        r28 = " (protectionLevel=";
        r27 = r27.append(r28);
        r0 = r7.protectionLevel;
        r28 = r0;
        r27 = r27.append(r28);
        r28 = " flags=0x";
        r27 = r27.append(r28);
        r0 = r32;
        r0 = r0.applicationInfo;
        r28 = r0;
        r0 = r28;
        r0 = r0.flags;
        r28 = r0;
        r28 = java.lang.Integer.toHexString(r28);
        r27 = r27.append(r28);
        r28 = ")";
        r27 = r27.append(r28);
        r27 = r27.toString();
        android.util.Slog.i(r26, r27);
        goto L_0x00f0;
    L_0x044e:
        r0 = r7.protectionLevel;
        r26 = r0;
        r26 = r26 & 64;
        goto L_0x00f0;
    L_0x0456:
        if (r8 != 0) goto L_0x045a;
    L_0x0458:
        if (r33 == 0) goto L_0x046c;
    L_0x045a:
        r0 = r21;
        r0 = r0.installPermissionsFixed;
        r26 = r0;
        r26 = r26 ^ 1;
        if (r26 == 0) goto L_0x046c;
    L_0x0464:
        r26 = isSystemApp(r21);
        r26 = r26 ^ 1;
        if (r26 != 0) goto L_0x0472;
    L_0x046c:
        r26 = isUpdatedSystemApp(r21);
        if (r26 == 0) goto L_0x047a;
    L_0x0472:
        r26 = 1;
        r0 = r26;
        r1 = r21;
        r1.installPermissionsFixed = r0;
    L_0x047a:
        r26 = 0;
        r0 = r9.length;
        r27 = r0;
    L_0x047f:
        r0 = r26;
        r1 = r27;
        if (r0 >= r1) goto L_0x0499;
    L_0x0485:
        r25 = r9[r26];
        r0 = r31;
        r0 = r0.mSettings;
        r28 = r0;
        r0 = r28;
        r1 = r25;
        r2 = r23;
        r0.writeRuntimePermissionsForUserLPr(r1, r2);
        r26 = r26 + 1;
        goto L_0x047f;
    L_0x0499:
        return;
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.pm.PackageManagerService.grantPermissionsLPw(android.content.pm.PackageParser$Package, boolean, java.lang.String):void");
    }

    private boolean isNewPlatformPermissionForPackage(String perm, Package pkg) {
        int NP = PackageParser.NEW_PERMISSIONS.length;
        int ip = 0;
        while (ip < NP) {
            NewPermissionInfo npi = PackageParser.NEW_PERMISSIONS[ip];
            if (!npi.name.equals(perm) || pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
                ip++;
            } else {
                Log.i(TAG, "Auto-granting " + perm + " to old pkg " + pkg.packageName);
                return true;
            }
        }
        return false;
    }

    private boolean grantSignaturePermission(String perm, Package pkg, BasePermission bp, PermissionsState origPermissions) {
        boolean privilegedPermission = (bp.protectionLevel & 16) != 0;
        boolean privappPermissionsDisable = RoSystemProperties.CONTROL_PRIVAPP_PERMISSIONS_DISABLE;
        boolean platformPermission = PLATFORM_PACKAGE_NAME.equals(bp.sourcePackage);
        boolean platformPackage = PLATFORM_PACKAGE_NAME.equals(pkg.packageName);
        if (!privappPermissionsDisable && privilegedPermission && pkg.isPrivilegedApp() && (platformPackage ^ 1) != 0 && platformPermission) {
            ArraySet<String> allowedPermissions = SystemConfig.getInstance().getPrivAppPermissions(pkg.packageName);
            if (!(allowedPermissions != null ? allowedPermissions.contains(perm) : false)) {
                Slog.w(TAG, "Privileged permission " + perm + " for package " + pkg.packageName + " - not in privapp-permissions whitelist");
                if (!(this.mSystemReady || (pkg.isUpdatedSystemApp() ^ 1) == 0)) {
                    ArraySet<String> deniedPermissions = SystemConfig.getInstance().getPrivAppDenyPermissions(pkg.packageName);
                    if ((deniedPermissions != null ? deniedPermissions.contains(perm) ^ 1 : 1) == 0) {
                        return false;
                    }
                    if (this.mPrivappPermissionsViolations == null) {
                        this.mPrivappPermissionsViolations = new ArraySet();
                    }
                    this.mPrivappPermissionsViolations.add(pkg.packageName + ": " + perm);
                }
                if (RoSystemProperties.CONTROL_PRIVAPP_PERMISSIONS_ENFORCE) {
                    return false;
                }
            }
        }
        boolean allowed = compareSignatures(bp.packageSetting.signatures.mSignatures, pkg.mSignatures) != 0 ? compareSignatures(this.mPlatformPackage.mSignatures, pkg.mSignatures) == 0 : true;
        if (pkg.mSharedUserId != null) {
            if (ColorPackageManagerHelper.isGrantedPermissionForShareUid(pkg.mSharedUserId, perm)) {
                allowed = true;
            }
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(GAME_CENTER_SYSTEM_APP);
            if (GAME_CENTER_PKGNAME.equals(pkg.packageName) && ps != null && isSystemApp(ps) && ColorPackageManagerHelper.isGrantedPermissionForGameCenter(pkg.mSharedUserId, perm)) {
                allowed = true;
            }
        }
        if (!allowed && ColorPackageManagerHelper.isAllowSigPermForDataApp(pkg, perm)) {
            Slog.d(TAG, "isAllowSigPermForDataApp " + perm + " for " + pkg.packageName);
            allowed = true;
        }
        if (!allowed && privilegedPermission && isSystemApp(pkg)) {
            if (pkg.isUpdatedSystemApp()) {
                PackageSetting sysPs = this.mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                if (sysPs == null || !sysPs.getPermissionsState().hasInstallPermission(perm)) {
                    if (sysPs != null && sysPs.pkg != null && sysPs.isPrivileged()) {
                        for (int j = 0; j < sysPs.pkg.requestedPermissions.size(); j++) {
                            if (perm.equals(sysPs.pkg.requestedPermissions.get(j))) {
                                allowed = true;
                                break;
                            }
                        }
                    }
                    if (pkg.parentPackage != null) {
                        PackageSetting disabledSysParentPs = this.mSettings.getDisabledSystemPkgLPr(pkg.parentPackage.packageName);
                        if (disabledSysParentPs != null && disabledSysParentPs.pkg != null && disabledSysParentPs.isPrivileged()) {
                            if (isPackageRequestingPermission(disabledSysParentPs.pkg, perm)) {
                                allowed = true;
                            } else if (disabledSysParentPs.pkg.childPackages != null) {
                                int count = disabledSysParentPs.pkg.childPackages.size();
                                for (int i = 0; i < count; i++) {
                                    if (isPackageRequestingPermission((Package) disabledSysParentPs.pkg.childPackages.get(i), perm)) {
                                        allowed = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                } else if (sysPs.isPrivileged()) {
                    allowed = true;
                }
            } else {
                allowed = isPrivilegedApp(pkg);
            }
        }
        if (!allowed) {
            if (!(allowed || (bp.protectionLevel & 128) == 0 || pkg.applicationInfo.targetSdkVersion >= 23)) {
                allowed = true;
            }
            if (!(allowed || (bp.protectionLevel & 256) == 0 || !pkg.packageName.equals(this.mRequiredInstallerPackage))) {
                allowed = true;
            }
            if (!(allowed || (bp.protectionLevel & 512) == 0 || !pkg.packageName.equals(this.mRequiredVerifierPackage))) {
                allowed = true;
            }
            if (!(allowed || (bp.protectionLevel & 1024) == 0 || !isSystemApp(pkg))) {
                allowed = true;
            }
            if (!(allowed || (bp.protectionLevel & 32) == 0)) {
                allowed = origPermissions.hasInstallPermission(perm);
            }
            if (!(allowed || (bp.protectionLevel & 2048) == 0 || !pkg.packageName.equals(this.mSetupWizardPackage))) {
                allowed = true;
            }
        }
        if ("oppo.permission.OPPO_COMPONENT_SAFE".equals(perm) && (allowed ^ 1) != 0 && isSystemApp(pkg)) {
            allowed = true;
        }
        return allowed;
    }

    private boolean isPackageRequestingPermission(Package pkg, String permission) {
        int permCount = pkg.requestedPermissions.size();
        for (int j = 0; j < permCount; j++) {
            if (permission.equals((String) pkg.requestedPermissions.get(j))) {
                return true;
            }
        }
        return false;
    }

    public void sendPackageBroadcast(String action, String pkg, Bundle extras, int flags, String targetPkg, IIntentReceiver finishedReceiver, int[] userIds) {
        final int[] iArr = userIds;
        final String str = action;
        final String str2 = pkg;
        final Bundle bundle = extras;
        final String str3 = targetPkg;
        final int i = flags;
        final IIntentReceiver iIntentReceiver = finishedReceiver;
        this.mHandler.post(new Runnable() {
            public void run() {
                try {
                    IActivityManager am = ActivityManager.getService();
                    if (am != null) {
                        int[] resolvedUserIds;
                        if (iArr == null) {
                            resolvedUserIds = am.getRunningUserIds();
                        } else {
                            resolvedUserIds = iArr;
                        }
                        int i = 0;
                        int length = resolvedUserIds.length;
                        while (true) {
                            int i2 = i;
                            if (i2 >= length) {
                                break;
                            }
                            int id = resolvedUserIds[i2];
                            String pkgAction = str;
                            if (id == OppoMultiAppManager.USER_ID && OppoMultiAppManagerUtil.getInstance().isMultiAllowedApp(str2)) {
                                if ("android.intent.action.PACKAGE_REMOVED".equals(pkgAction)) {
                                    pkgAction = "oppo.intent.action.MULTI_APP_PACKAGE_REMOVED";
                                    id = 0;
                                    if (PackageManagerService.DEBUG_PMS) {
                                        Slog.d(PackageManagerService.TAG, "multi app: PMS " + pkgAction + " removed " + str2 + " userId= " + 0);
                                    }
                                }
                                if ("android.intent.action.PACKAGE_ADDED".equals(pkgAction)) {
                                    pkgAction = "oppo.intent.action.MULTI_APP_PACKAGE_ADDED";
                                    id = 0;
                                    if (PackageManagerService.DEBUG_PMS) {
                                        Slog.d(PackageManagerService.TAG, "multi app: PMS " + pkgAction + " added " + str2 + " userId= " + 0);
                                    }
                                }
                            }
                            Intent intent = new Intent(pkgAction, str2 != null ? Uri.fromParts(PackageManagerService.PACKAGE_SCHEME, str2, null) : null);
                            if (bundle != null) {
                                intent.putExtras(bundle);
                            }
                            if (str3 != null) {
                                intent.setPackage(str3);
                            }
                            int uid = intent.getIntExtra("android.intent.extra.UID", -1);
                            if (uid > 0 && UserHandle.getUserId(uid) != id) {
                                intent.putExtra("android.intent.extra.UID", UserHandle.getUid(id, UserHandle.getAppId(uid)));
                            }
                            intent.putExtra("android.intent.extra.user_handle", id);
                            intent.addFlags(i | 67108864);
                            if ("android.intent.action.PACKAGE_REMOVED".equals(str)) {
                                String callingPackage = OppoPackageManagerHelper.getProcessNameByPid(OppoPackageManagerHelper.sPid);
                                if (callingPackage == null || callingPackage == "") {
                                    callingPackage = PackageManagerService.this.getNameForUid(OppoPackageManagerHelper.sUid);
                                }
                                String str = "oppo_extra_pkg_name";
                                if (callingPackage == null) {
                                    callingPackage = "";
                                }
                                intent.putExtra(str, callingPackage);
                                if (OppoPackageManagerHelper.sDeleteInfo != null) {
                                    intent.putExtra(OppoPackageManagerHelper.OPPO_EXTRA_VERSION_NAME, OppoPackageManagerHelper.sDeleteInfo.versionName);
                                    intent.putExtra(OppoPackageManagerHelper.OPPO_EXTRA_VERSION_CODE, OppoPackageManagerHelper.sDeleteInfo.versionCode);
                                    OppoPackageManagerHelper.resetDeleteInfo();
                                }
                            }
                            if ("android.intent.action.PACKAGE_REMOVED".equals(pkgAction)) {
                                PackageManagerService.this.onPackageRemoved(str2);
                            }
                            if (PackageManagerService.DEBUG_BROADCASTS) {
                                Throwable runtimeException = new RuntimeException("here");
                                runtimeException.fillInStackTrace();
                                Slog.d(PackageManagerService.TAG, "Sending to user " + id + ": " + intent.toShortString(false, true, false, false) + " " + intent.getExtras(), runtimeException);
                            }
                            am.broadcastIntent(null, intent, null, iIntentReceiver, 0, null, null, null, -1, null, iIntentReceiver != null, false, id);
                            if ("android.intent.action.PACKAGE_ADDED".equals(pkgAction)) {
                                Message msg = PackageManagerService.this.mHandler.obtainMessage(21);
                                msg.obj = str2;
                                PackageManagerService.this.mHandler.sendMessage(msg);
                            }
                            if (str3 == null) {
                                if ("android.intent.action.PACKAGE_ADDED".equals(pkgAction)) {
                                    intent.setAction("oppo.intent.action.PACKAGE_ADDED");
                                    intent.setPackage("com.android.packageinstaller");
                                    am.broadcastIntent(null, intent, null, iIntentReceiver, 0, null, null, null, -1, null, iIntentReceiver != null, false, id);
                                } else if ("android.intent.action.PACKAGE_REMOVED".equals(pkgAction)) {
                                    intent.setAction("oppo.intent.action.PACKAGE_REMOVED");
                                    intent.setPackage("com.android.packageinstaller");
                                    am.broadcastIntent(null, intent, null, iIntentReceiver, 0, null, null, null, -1, null, iIntentReceiver != null, false, id);
                                }
                            }
                            i = i2 + 1;
                        }
                    }
                } catch (RemoteException e) {
                }
            }
        });
    }

    private boolean isExternalMediaAvailable() {
        return !this.mMediaMounted ? Environment.isExternalStorageEmulated() : true;
    }

    public PackageCleanItem nextPackageToClean(PackageCleanItem lastPackage) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            if (isExternalMediaAvailable()) {
                ArrayList<PackageCleanItem> pkgs = this.mSettings.mPackagesToBeCleaned;
                if (lastPackage != null) {
                    pkgs.remove(lastPackage);
                }
                if (pkgs.size() > 0) {
                    PackageCleanItem packageCleanItem = (PackageCleanItem) pkgs.get(0);
                    return packageCleanItem;
                }
                return null;
            }
            return null;
        }
    }

    void schedulePackageCleaning(String packageName, int userId, boolean andCode) {
        Message msg = this.mHandler.obtainMessage(7, userId, andCode ? 1 : 0, packageName);
        if (this.mSystemReady) {
            msg.sendToTarget();
            return;
        }
        if (this.mPostSystemReadyMessages == null) {
            this.mPostSystemReadyMessages = new ArrayList();
        }
        this.mPostSystemReadyMessages.add(msg);
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    void startCleaningPackages() {
        if (isExternalMediaAvailable()) {
            synchronized (this.mPackages) {
                if (this.mSettings.mPackagesToBeCleaned.isEmpty()) {
                }
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void installPackageAsUser(String originPath, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, int userId) {
        SeempLog.record(90);
        int callingUid = Binder.getCallingUid();
        String[] packageNames = getPackagesForUid(callingUid);
        if (hasSystemFeature("oppo.customize.function.silentinstall", 0) && packageNames != null && packageNames.length == 1 && checkWhiteList(packageNames[0])) {
            Slog.d(TAG, "PMS, no check permission for customize ");
        } else {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INSTALL_PACKAGES", null);
        }
        enforceCrossUserPermission(callingUid, userId, true, true, "installPackageAsUser");
        if (hasSystemFeature("oppo.business.custom", 0) && isInstallSourceEnable()) {
            List<String> pkgwhitelist = getInstallSourceList();
            if (callingUid == getUidForSharedUser("oppo.uid.nearme")) {
                if (pkgwhitelist.contains("com.oppo.market")) {
                    Log.d(TAG, "com.oppo.market has added to white list");
                } else {
                    Log.d(TAG, "0.com.oppo.market : " + callingUid + "  is not allow to install !!!");
                    if (observer != null) {
                        try {
                            observer.onPackageInstalled("", -111, null, null);
                        } catch (RemoteException e) {
                        }
                    }
                    sendBroadcastForArmy();
                    return;
                }
            } else if (packageNames != null && packageNames.length == 1 && packageNames[0].equals("com.android.packageinstaller")) {
                Log.d(TAG, "1.packageinstaller : " + packageNames[0] + "  always allow to install");
            } else {
                if (packageNames != null && packageNames.length == 1) {
                    if (pkgwhitelist.contains(packageNames[0])) {
                        Log.d(TAG, "2.market's uid = " + packageNames[0] + "  and allow to install");
                    }
                }
                if (callingUid == 1000) {
                    Log.d(TAG, "3.system uid always allow to install!!");
                } else {
                    Log.d(TAG, "4.app come from the market uid =  " + callingUid + "  is not allow to install !!!");
                    if (observer != null) {
                        try {
                            observer.onPackageInstalled("", -111, null, null);
                        } catch (RemoteException e2) {
                        }
                    }
                    sendBroadcastForArmy();
                    return;
                }
            }
        }
        if (isUserRestricted(userId, "no_install_apps")) {
            if (observer != null) {
                try {
                    observer.onPackageInstalled("", -111, null, null);
                } catch (RemoteException e3) {
                }
            }
        } else if (prohibitChildInstallation(userId, true)) {
            if (observer != null) {
                try {
                    observer.onPackageInstalled("", -111, null, null);
                } catch (RemoteException e4) {
                }
            }
        } else {
            if (callingUid == 2000 || callingUid == 0) {
                installFlags |= 32;
            } else {
                installFlags = (installFlags & -33) & -65;
            }
            String curExtraInstallPkgNameExp = null;
            if (EXP_VERSION && installerPackageName != null && installerPackageName.length() > 0) {
                curExtraInstallPkgNameExp = installerPackageName;
            }
            if ((268435456 & installFlags) != 0) {
                Slog.d(TAG, "install from oppo adb installer, set INSTALL_FROM_ADB flag");
                installFlags = (installFlags | 32) & -268435457;
            }
            int callingPid = Binder.getCallingPid();
            String callingProcess = OppoPackageManagerHelper.getProcessNameByPid(callingPid);
            if (!this.mIsCtsAppInstall) {
                if (callingProcess != null) {
                    if ((callingProcess.equals("") ^ 1) != 0) {
                        installerPackageName = callingProcess;
                    }
                }
                if (callingUid == 2000 || callingUid == 0) {
                    installerPackageName = "pc";
                }
                if (installerPackageName != null) {
                }
                installerPackageName = getNameForUid(callingUid);
            }
            Slog.d(TAG, "installPackageAsUser callingProcess=" + callingProcess + "/" + callingPid + ", callingUid=" + callingUid + ", installerPackageName=" + installerPackageName + ", installFlags=" + installFlags + ", full=" + this.mIsCtsAppInstall);
            long token = Binder.clearCallingIdentity();
            try {
                UserHandle user;
                ColorPackageManagerHelper.sendOppoStartInstallBro(originPath, installerPackageName, null, 0);
                if ((installFlags & 64) != 0) {
                    user = UserHandle.ALL;
                    if ((installFlags & 32) != 0) {
                        boolean isMultiUserExist = false;
                        for (int i : sUserManager.getUserIds()) {
                            if (i == 999) {
                                isMultiUserExist = true;
                                break;
                            }
                        }
                        if (len == 2 && isMultiUserExist) {
                            Slog.d(TAG, "multi app: change adb install all to owner");
                            user = new UserHandle(0);
                        }
                    }
                } else {
                    user = new UserHandle(userId);
                }
                if ((installFlags & 256) != 0 && this.mContext.checkCallingOrSelfPermission("android.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS") == -1) {
                    throw new SecurityException("You need the android.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS permission to use the PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS flag");
                } else if ((installFlags & 1) == 0 && (installFlags & 8) == 0) {
                    OriginInfo origin = OriginInfo.fromUntrustedFile(new File(originPath));
                    if (EXP_VERSION && curExtraInstallPkgNameExp != null) {
                        if (installerPackageName.equals("com.google.android.packageinstaller")) {
                            Slog.i(TAG, "first origin : " + origin.toString() + " curExtraInstallPkgNameExp: " + curExtraInstallPkgNameExp);
                            synchronized (this.mRunningInstallerPkgName) {
                                this.mRunningInstallerPkgName.put(origin, curExtraInstallPkgNameExp);
                            }
                        }
                    }
                    Message msg = this.mHandler.obtainMessage(5);
                    InstallParams params = new InstallParams(origin, null, observer, installFlags, installerPackageName, null, new VerificationInfo(null, null, -1, callingUid), user, null, null, null, 0);
                    params.setTraceMethod("installAsUser").setTraceCookie(System.identityHashCode(params));
                    msg.obj = params;
                    Trace.asyncTraceBegin(262144, "installAsUser", System.identityHashCode(msg.obj));
                    Trace.asyncTraceBegin(262144, "queueInstall", System.identityHashCode(msg.obj));
                    this.mHandler.sendMessage(msg);
                } else {
                    throw new IllegalArgumentException("New installs into ASEC containers no longer supported");
                }
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        }
    }

    private int fixUpInstallReason(String installerPackageName, int installerUid, int installReason) {
        if (checkUidPermission("android.permission.INSTALL_PACKAGES", installerUid) == 0) {
            return installReason;
        }
        IDevicePolicyManager dpm = IDevicePolicyManager.Stub.asInterface(ServiceManager.getService("device_policy"));
        if (dpm != null) {
            ComponentName owner = null;
            try {
                owner = dpm.getDeviceOwnerComponent(true);
                if (owner == null) {
                    owner = dpm.getProfileOwner(UserHandle.getUserId(installerUid));
                }
            } catch (RemoteException e) {
            }
            if (owner != null && owner.getPackageName().equals(installerPackageName)) {
                return 1;
            }
        }
        if (installReason == 1) {
            return 0;
        }
        return installReason;
    }

    void installStage(java.lang.String r27, java.io.File r28, java.lang.String r29, android.content.pm.IPackageInstallObserver2 r30, android.content.pm.PackageInstaller.SessionParams r31, java.lang.String r32, int r33, android.os.UserHandle r34, java.security.cert.Certificate[][] r35) {
        /* JADX: method processing error */
/*
Error: jadx.core.utils.exceptions.JadxRuntimeException: Unknown predecessor block by arg (r34_1 'user' android.os.UserHandle) in PHI: PHI: (r34_2 'user' android.os.UserHandle) = (r34_0 'user' android.os.UserHandle), (r34_0 'user' android.os.UserHandle), (r34_0 'user' android.os.UserHandle), (r34_1 'user' android.os.UserHandle) binds: {(r34_0 'user' android.os.UserHandle)=B:9:0x0047, (r34_0 'user' android.os.UserHandle)=B:11:0x0053, (r34_0 'user' android.os.UserHandle)=B:13:0x0059, (r34_1 'user' android.os.UserHandle)=B:14:0x005b}
	at jadx.core.dex.instructions.PhiInsn.replaceArg(PhiInsn.java:78)
	at jadx.core.dex.visitors.ModVisitor.processInvoke(ModVisitor.java:222)
	at jadx.core.dex.visitors.ModVisitor.replaceStep(ModVisitor.java:83)
	at jadx.core.dex.visitors.ModVisitor.visit(ModVisitor.java:68)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:27)
	at jadx.core.dex.visitors.DepthTraversal.lambda$visit$1(DepthTraversal.java:14)
	at java.util.ArrayList.forEach(ArrayList.java:1251)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:14)
	at jadx.core.ProcessClass.process(ProcessClass.java:32)
	at jadx.core.ProcessClass.lambda$processDependencies$0(ProcessClass.java:51)
	at java.lang.Iterable.forEach(Iterable.java:75)
	at jadx.core.ProcessClass.processDependencies(ProcessClass.java:51)
	at jadx.core.ProcessClass.process(ProcessClass.java:37)
	at jadx.api.JadxDecompiler.processClass(JadxDecompiler.java:286)
	at jadx.api.JavaClass.decompile(JavaClass.java:62)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
*/
        /*
        r26 = this;
        r5 = DEBUG_EPHEMERAL;
        if (r5 == 0) goto L_0x0028;
    L_0x0004:
        r0 = r31;
        r5 = r0.installFlags;
        r5 = r5 & 2048;
        if (r5 == 0) goto L_0x0028;
    L_0x000c:
        r5 = "PackageManager";
        r7 = new java.lang.StringBuilder;
        r7.<init>();
        r8 = "Ephemeral install of ";
        r7 = r7.append(r8);
        r0 = r27;
        r7 = r7.append(r0);
        r7 = r7.toString();
        android.util.Slog.d(r5, r7);
    L_0x0028:
        r12 = new com.android.server.pm.PackageManagerService$VerificationInfo;
        r0 = r31;
        r5 = r0.originatingUri;
        r0 = r31;
        r7 = r0.referrerUri;
        r0 = r31;
        r8 = r0.originatingUid;
        r0 = r33;
        r12.<init>(r5, r7, r8, r0);
        if (r28 == 0) goto L_0x00de;
    L_0x003d:
        r6 = com.android.server.pm.PackageManagerService.OriginInfo.fromStagedFile(r28);
    L_0x0041:
        r0 = r31;
        r5 = r0.installFlags;
        r5 = r5 & 32;
        if (r5 == 0) goto L_0x006c;
    L_0x0049:
        r5 = sUserManager;
        r23 = r5.getUserIds();
        r0 = r26;
        r5 = r0.mIsCtsAppInstall;
        if (r5 != 0) goto L_0x006c;
    L_0x0055:
        r0 = r23;
        r5 = r0.length;
        r7 = 1;
        if (r5 <= r7) goto L_0x006c;
    L_0x005b:
        r5 = "PackageManager";
        r7 = "multi app: change adb install all to owner";
        android.util.Slog.d(r5, r7);
        r34 = new android.os.UserHandle;
        r5 = 0;
        r0 = r34;
        r0.<init>(r5);
    L_0x006c:
        r5 = "oppo.root.silent.install";
        r7 = 1;
        r18 = android.os.SystemProperties.getBoolean(r5, r7);
        r0 = r31;
        r5 = r0.installFlags;
        r5 = r5 & 32;
        if (r5 == 0) goto L_0x00e4;
    L_0x007c:
        if (r33 != 0) goto L_0x0084;
    L_0x007e:
        if (r33 != 0) goto L_0x00e4;
    L_0x0080:
        r5 = r18 ^ 1;
        if (r5 == 0) goto L_0x00e4;
    L_0x0084:
        if (r28 == 0) goto L_0x00e4;
    L_0x0086:
        if (r27 == 0) goto L_0x00e4;
    L_0x0088:
        r5 = new java.lang.StringBuilder;
        r5.<init>();
        r7 = r28.getAbsolutePath();
        r5 = r5.append(r7);
        r7 = "/base.apk";
        r5 = r5.append(r7);
        r22 = r5.toString();
        r5 = "PackageManager";
        r7 = new java.lang.StringBuilder;
        r7.<init>();
        r8 = "installStage send adb install pkg:";
        r7 = r7.append(r8);
        r0 = r27;
        r7 = r7.append(r0);
        r8 = "   path: ";
        r7 = r7.append(r8);
        r0 = r22;
        r7 = r7.append(r0);
        r7 = r7.toString();
        android.util.Slog.d(r5, r7);
        r5 = com.android.server.pm.OppoAdbInstallerManager.getInstance();
        r0 = r31;
        r7 = r0.installFlags;
        r0 = r27;
        r1 = r22;
        r2 = r30;
        r5 = r5.handleForAdbSessionInstaller(r0, r1, r2, r7);
        if (r5 == 0) goto L_0x00e4;
    L_0x00dd:
        return;
    L_0x00de:
        r6 = com.android.server.pm.PackageManagerService.OriginInfo.fromStagedContainer(r29);
        goto L_0x0041;
    L_0x00e4:
        r0 = r31;
        r5 = r0.installFlags;
        r7 = 268435456; // 0x10000000 float:2.5243549E-29 double:1.32624737E-315;
        r5 = r5 & r7;
        if (r5 == 0) goto L_0x010c;
    L_0x00ed:
        r5 = "PackageManager";
        r7 = "installStage from oppo adb installer, set INSTALL_FROM_ADB flag";
        android.util.Slog.d(r5, r7);
        r0 = r31;
        r5 = r0.installFlags;
        r5 = r5 | 32;
        r0 = r31;
        r0.installFlags = r5;
        r0 = r31;
        r5 = r0.installFlags;
        r7 = -268435457; // 0xffffffffefffffff float:-1.5845632E29 double:NaN;
        r5 = r5 & r7;
        r0 = r31;
        r0.installFlags = r5;
    L_0x010c:
        r20 = 0;
        r5 = EXP_VERSION;
        if (r5 == 0) goto L_0x0174;
    L_0x0112:
        if (r32 == 0) goto L_0x0174;
    L_0x0114:
        r5 = r32.length();
        if (r5 <= 0) goto L_0x0174;
    L_0x011a:
        r5 = "oppo.exp.install.collect";
        r7 = "";
        r20 = android.os.SystemProperties.get(r5, r7);
        r5 = "";
        r0 = r20;
        r5 = r5.equals(r0);
        if (r5 != 0) goto L_0x0174;
    L_0x012f:
        r5 = "com.google.android.packageinstaller";
        r0 = r32;
        r5 = r0.equals(r5);
        if (r5 == 0) goto L_0x0174;
    L_0x013a:
        r5 = "PackageManager";
        r7 = new java.lang.StringBuilder;
        r7.<init>();
        r8 = "first origin : ";
        r7 = r7.append(r8);
        r8 = r6.toString();
        r7 = r7.append(r8);
        r8 = " curExtraInstallPkgNameExp: ";
        r7 = r7.append(r8);
        r0 = r20;
        r7 = r7.append(r0);
        r7 = r7.toString();
        android.util.Slog.i(r5, r7);
        r0 = r26;
        r7 = r0.mRunningInstallerPkgName;
        monitor-enter(r7);
        r0 = r26;	 Catch:{ all -> 0x028a }
        r5 = r0.mRunningInstallerPkgName;	 Catch:{ all -> 0x028a }
        r0 = r20;	 Catch:{ all -> 0x028a }
        r5.put(r6, r0);	 Catch:{ all -> 0x028a }
        monitor-exit(r7);
    L_0x0174:
        r0 = r26;
        r5 = r0.mIsCtsAppInstall;
        if (r5 != 0) goto L_0x019a;
    L_0x017a:
        r5 = 2000; // 0x7d0 float:2.803E-42 double:9.88E-321;
        r0 = r33;
        if (r0 == r5) goto L_0x0182;
    L_0x0180:
        if (r33 != 0) goto L_0x0185;
    L_0x0182:
        r32 = "pc";
    L_0x0185:
        if (r32 == 0) goto L_0x0192;
    L_0x0187:
        r5 = "";
        r0 = r32;
        r5 = r0.equals(r5);
        if (r5 == 0) goto L_0x019a;
    L_0x0192:
        r0 = r26;
        r1 = r33;
        r32 = r0.getNameForUid(r1);
    L_0x019a:
        r5 = "PackageManager";
        r7 = new java.lang.StringBuilder;
        r7.<init>();
        r8 = "installStage ";
        r7 = r7.append(r8);
        r0 = r27;
        r7 = r7.append(r0);
        r8 = ", dir=";
        r7 = r7.append(r8);
        r0 = r28;
        r7 = r7.append(r0);
        r8 = ", installerPackageName=";
        r7 = r7.append(r8);
        r0 = r32;
        r7 = r7.append(r0);
        r8 = ", installerUid=";
        r7 = r7.append(r8);
        r0 = r33;
        r7 = r7.append(r0);
        r8 = ", full=";
        r7 = r7.append(r8);
        r0 = r26;
        r8 = r0.mIsCtsAppInstall;
        r7 = r7.append(r8);
        r7 = r7.toString();
        android.util.Slog.d(r5, r7);
        r5 = new java.lang.StringBuilder;
        r5.<init>();
        r7 = r28.getAbsolutePath();
        r5 = r5.append(r7);
        r7 = "/base.apk";
        r5 = r5.append(r7);
        r19 = r5.toString();
        r24 = android.os.Binder.clearCallingIdentity();
        r5 = 0;
        r0 = r19;	 Catch:{ all -> 0x028d }
        r1 = r32;	 Catch:{ all -> 0x028d }
        r2 = r27;	 Catch:{ all -> 0x028d }
        com.android.server.pm.ColorPackageManagerHelper.sendOppoStartInstallBro(r0, r1, r2, r5);	 Catch:{ all -> 0x028d }
        android.os.Binder.restoreCallingIdentity(r24);
        r0 = r26;
        r5 = r0.mHandler;
        r7 = 5;
        r21 = r5.obtainMessage(r7);
        r0 = r31;
        r5 = r0.installReason;
        r0 = r26;
        r1 = r32;
        r2 = r33;
        r17 = r0.fixUpInstallReason(r1, r2, r5);
        r4 = new com.android.server.pm.PackageManagerService$InstallParams;
        r0 = r31;
        r9 = r0.installFlags;
        r0 = r31;
        r11 = r0.volumeUuid;
        r0 = r31;
        r14 = r0.abiOverride;
        r0 = r31;
        r15 = r0.grantedRuntimePermissions;
        r7 = 0;
        r5 = r26;
        r8 = r30;
        r10 = r32;
        r13 = r34;
        r16 = r35;
        r4.<init>(r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17);
        r5 = "installStage";
        r5 = r4.setTraceMethod(r5);
        r7 = java.lang.System.identityHashCode(r4);
        r5.setTraceCookie(r7);
        r0 = r21;
        r0.obj = r4;
        r5 = "installStage";
        r0 = r21;
        r7 = r0.obj;
        r7 = java.lang.System.identityHashCode(r7);
        r8 = 262144; // 0x40000 float:3.67342E-40 double:1.295163E-318;
        android.os.Trace.asyncTraceBegin(r8, r5, r7);
        r5 = "queueInstall";
        r0 = r21;
        r7 = r0.obj;
        r7 = java.lang.System.identityHashCode(r7);
        r8 = 262144; // 0x40000 float:3.67342E-40 double:1.295163E-318;
        android.os.Trace.asyncTraceBegin(r8, r5, r7);
        r0 = r26;
        r5 = r0.mHandler;
        r0 = r21;
        r5.sendMessage(r0);
        return;
    L_0x028a:
        r5 = move-exception;
        monitor-exit(r7);
        throw r5;
    L_0x028d:
        r5 = move-exception;
        android.os.Binder.restoreCallingIdentity(r24);
        throw r5;
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.pm.PackageManagerService.installStage(java.lang.String, java.io.File, java.lang.String, android.content.pm.IPackageInstallObserver2, android.content.pm.PackageInstaller$SessionParams, java.lang.String, int, android.os.UserHandle, java.security.cert.Certificate[][]):void");
    }

    private void sendPackageAddedForUser(String packageName, PackageSetting pkgSetting, int userId) {
        sendPackageAddedForNewUsers(packageName, !isSystemApp(pkgSetting) ? isUpdatedSystemApp(pkgSetting) : true, false, pkgSetting.appId, userId);
        SessionInfo info = new SessionInfo();
        info.installReason = pkgSetting.getInstallReason(userId);
        info.appPackageName = packageName;
        sendSessionCommitBroadcast(info, userId);
    }

    public void sendPackageAddedForNewUsers(String packageName, boolean sendBootCompleted, boolean includeStopped, int appId, int... userIds) {
        if (!ArrayUtils.isEmpty(userIds)) {
            Bundle extras = new Bundle(1);
            extras.putInt("android.intent.extra.UID", UserHandle.getUid(userIds[0], appId));
            sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName, extras, 0, null, null, userIds);
            if (sendBootCompleted) {
                this.mHandler.post(new com.android.server.pm.-$Lambda$kozCdtU4hxwnpbopzC6ZLMsBV5E.AnonymousClass3(includeStopped, this, userIds, packageName));
            }
        }
    }

    /* synthetic */ void lambda$-com_android_server_pm_PackageManagerService_810819(int[] userIds, String packageName, boolean includeStopped) {
        for (int userId : userIds) {
            sendBootCompletedBroadcastToSystemApp(packageName, includeStopped, userId);
        }
    }

    private void sendBootCompletedBroadcastToSystemApp(String packageName, boolean includeStopped, int userId) {
        if (this.mUserManagerInternal.isUserRunning(userId)) {
            IActivityManager am = ActivityManager.getService();
            try {
                Intent lockedBcIntent = new Intent("android.intent.action.LOCKED_BOOT_COMPLETED").setPackage(packageName);
                if (includeStopped) {
                    lockedBcIntent.addFlags(32);
                }
                String[] requiredPermissions = new String[]{"android.permission.RECEIVE_BOOT_COMPLETED"};
                am.broadcastIntent(null, lockedBcIntent, null, null, 0, null, null, requiredPermissions, -1, null, false, false, userId);
                if (this.mUserManagerInternal.isUserUnlockingOrUnlocked(userId)) {
                    Intent bcIntent = new Intent("android.intent.action.BOOT_COMPLETED").setPackage(packageName);
                    if (includeStopped) {
                        bcIntent.addFlags(32);
                    }
                    am.broadcastIntent(null, bcIntent, null, null, 0, null, null, requiredPermissions, -1, null, false, false, userId);
                }
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean setApplicationHiddenSettingAsUser(String packageName, boolean hidden, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MANAGE_USERS", null);
        int callingUid = Binder.getCallingUid();
        enforceCrossUserPermission(callingUid, userId, true, true, "setApplicationHiddenSetting for user " + userId);
        if (hidden && isPackageDeviceAdmin(packageName, userId)) {
            Slog.w(TAG, "Not hiding package " + packageName + ": has active device admin");
            return false;
        }
        long callingId = Binder.clearCallingIdentity();
        boolean sendAdded = false;
        boolean sendRemoved = false;
        try {
            synchronized (this.mPackages) {
                PackageSetting pkgSetting = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (pkgSetting != null) {
                    if (filterAppAccessLPr(pkgSetting, callingUid, userId)) {
                        Binder.restoreCallingIdentity(callingId);
                        return false;
                    } else if (PLATFORM_PACKAGE_NAME.equals(packageName)) {
                        Slog.w(TAG, "Cannot hide package: android");
                        Binder.restoreCallingIdentity(callingId);
                        return false;
                    } else {
                        if (hidden) {
                            if (isSystemApp(pkgSetting) && (ActivityManagerService.OPPO_LAUNCHER.equals(packageName) || "com.coloros.safecenter".equals(packageName) || "com.coloros.sau".equals(packageName) || "com.coloros.sauhelper".equals(packageName) || "com.oppo.ota".equals(packageName) || "com.nearme.romupdate".equals(packageName))) {
                                Slog.w(TAG, "Cannot hiding system app " + packageName);
                                Binder.restoreCallingIdentity(callingId);
                                return false;
                            }
                        }
                        Package pkg = (Package) this.mPackages.get(packageName);
                        if (pkg == null || pkg.staticSharedLibName == null) {
                            if (hidden) {
                                if ((UserHandle.isSameApp(callingUid, pkgSetting.appId) ^ 1) != 0 && this.mProtectedPackages.isPackageStateProtected(userId, packageName)) {
                                    Slog.w(TAG, "Not hiding protected package: " + packageName);
                                    Binder.restoreCallingIdentity(callingId);
                                    return false;
                                }
                            }
                            if (pkgSetting.getHidden(userId) != hidden) {
                                pkgSetting.setHidden(hidden, userId);
                                this.mSettings.writePackageRestrictionsLPr(userId);
                                if (hidden) {
                                    sendRemoved = true;
                                } else {
                                    sendAdded = true;
                                }
                            }
                        } else {
                            Slog.w(TAG, "Cannot hide package: " + packageName + " providing static shared library: " + pkg.staticSharedLibName);
                            Binder.restoreCallingIdentity(callingId);
                            return false;
                        }
                    }
                }
            }
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
        return false;
    }

    private void sendApplicationHiddenForUser(String packageName, PackageSetting pkgSetting, int userId) {
        PackageRemovedInfo info = new PackageRemovedInfo(this);
        info.removedPackage = packageName;
        info.installerPackageName = pkgSetting.installerPackageName;
        info.removedUsers = new int[]{userId};
        info.broadcastUsers = new int[]{userId};
        info.uid = UserHandle.getUid(userId, pkgSetting.appId);
        info.sendPackageRemovedBroadcasts(true);
    }

    private void sendPackagesSuspendedForUser(String[] pkgList, int userId, boolean suspended) {
        if (pkgList.length > 0) {
            String str;
            Bundle extras = new Bundle(1);
            extras.putStringArray("android.intent.extra.changed_package_list", pkgList);
            if (suspended) {
                str = "android.intent.action.PACKAGES_SUSPENDED";
            } else {
                str = "android.intent.action.PACKAGES_UNSUSPENDED";
            }
            sendPackageBroadcast(str, null, extras, 1073741824, null, null, new int[]{userId});
        }
    }

    public boolean getApplicationHiddenSettingAsUser(String packageName, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MANAGE_USERS", null);
        int callingUid = Binder.getCallingUid();
        enforceCrossUserPermission(callingUid, userId, true, false, "getApplicationHidden for user " + userId);
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this.mPackages) {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (ps != null) {
                    if (filterAppAccessLPr(ps, callingUid, userId)) {
                        Binder.restoreCallingIdentity(callingId);
                        return true;
                    }
                    boolean hidden = ps.getHidden(userId);
                    Binder.restoreCallingIdentity(callingId);
                    return hidden;
                }
            }
            return true;
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public int installExistingPackageAsUser(String packageName, int userId, int installFlags, int installReason) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INSTALL_PACKAGES", null);
        int callingUid = Binder.getCallingUid();
        enforceCrossUserPermission(callingUid, userId, true, true, "installExistingPackage for user " + userId);
        if (isUserRestricted(userId, "no_install_apps")) {
            return -111;
        }
        long callingId = Binder.clearCallingIdentity();
        boolean installed = false;
        boolean instantApp = (installFlags & 2048) != 0;
        boolean fullApp = (installFlags & 16384) != 0;
        try {
            synchronized (this.mPackages) {
                PackageSetting pkgSetting = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (pkgSetting == null) {
                    Binder.restoreCallingIdentity(callingId);
                    return -3;
                }
                if (!canViewInstantApps(callingUid, UserHandle.getUserId(callingUid))) {
                    boolean installAllowed = false;
                    for (int checkUserId : sUserManager.getUserIds()) {
                        installAllowed = pkgSetting.getInstantApp(checkUserId) ^ 1;
                        if (installAllowed) {
                            break;
                        }
                    }
                    if (!installAllowed) {
                        Binder.restoreCallingIdentity(callingId);
                        return -3;
                    }
                }
                if (!pkgSetting.getInstalled(userId)) {
                    pkgSetting.setInstalled(true, userId);
                    pkgSetting.setHidden(false, userId);
                    pkgSetting.setInstallReason(installReason, userId);
                    this.mSettings.writePackageRestrictionsLPr(userId);
                    this.mSettings.writeKernelMappingLPr(pkgSetting);
                    installed = true;
                } else if (fullApp) {
                    if (pkgSetting.getInstantApp(userId)) {
                        installed = true;
                    }
                }
                setInstantAppForUser(pkgSetting, userId, instantApp, fullApp);
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    void setInstantAppForUser(PackageSetting pkgSetting, int userId, boolean instantApp, boolean fullApp) {
        if (instantApp || (fullApp ^ 1) == 0) {
            if (userId == -1) {
                for (int currentUserId : sUserManager.getUserIds()) {
                    if (instantApp && (pkgSetting.getInstantApp(currentUserId) ^ 1) != 0) {
                        pkgSetting.setInstantApp(true, currentUserId);
                    } else if (fullApp && pkgSetting.getInstantApp(currentUserId)) {
                        pkgSetting.setInstantApp(false, currentUserId);
                    }
                }
            } else if (instantApp && (pkgSetting.getInstantApp(userId) ^ 1) != 0) {
                pkgSetting.setInstantApp(true, userId);
            } else if (fullApp && pkgSetting.getInstantApp(userId)) {
                pkgSetting.setInstantApp(false, userId);
            }
        }
    }

    boolean isUserRestricted(int userId, String restrictionKey) {
        if (!sUserManager.getUserRestrictions(userId).getBoolean(restrictionKey, false)) {
            return false;
        }
        Log.w(TAG, "User is restricted: " + restrictionKey);
        return true;
    }

    public String[] setPackagesSuspendedAsUser(String[] packageNames, boolean suspended, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MANAGE_USERS", null);
        int callingUid = Binder.getCallingUid();
        enforceCrossUserPermission(callingUid, userId, true, true, "setPackagesSuspended for user " + userId);
        if (ArrayUtils.isEmpty(packageNames)) {
            return packageNames;
        }
        List<String> changedPackages = new ArrayList(packageNames.length);
        List<String> arrayList = new ArrayList(packageNames.length);
        long callingId = Binder.clearCallingIdentity();
        for (String packageName : packageNames) {
            boolean changed = false;
            synchronized (this.mPackages) {
                PackageSetting pkgSetting = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (pkgSetting == null || filterAppAccessLPr(pkgSetting, callingUid, userId)) {
                    Slog.w(TAG, "Could not find package setting for package \"" + packageName + "\". Skipping suspending/un-suspending.");
                    arrayList.add(packageName);
                } else {
                    int appId = pkgSetting.appId;
                    if (pkgSetting.getSuspended(userId) != suspended) {
                        if (canSuspendPackageForUserLocked(packageName, userId)) {
                            pkgSetting.setSuspended(suspended, userId);
                            this.mSettings.writePackageRestrictionsLPr(userId);
                            changed = true;
                            changedPackages.add(packageName);
                        } else {
                            arrayList.add(packageName);
                        }
                    }
                    try {
                        if (changed && suspended) {
                            killApplication(packageName, UserHandle.getUid(userId, appId), "suspending package");
                        }
                    } catch (Throwable th) {
                        Binder.restoreCallingIdentity(callingId);
                    }
                }
            }
        }
        Binder.restoreCallingIdentity(callingId);
        if (!changedPackages.isEmpty()) {
            sendPackagesSuspendedForUser((String[]) changedPackages.toArray(new String[changedPackages.size()]), userId, suspended);
        }
        return (String[]) arrayList.toArray(new String[arrayList.size()]);
    }

    public boolean isPackageSuspendedForUser(String packageName, int userId) {
        boolean suspended;
        int callingUid = Binder.getCallingUid();
        enforceCrossUserPermission(callingUid, userId, true, false, "isPackageSuspendedForUser for user " + userId);
        synchronized (this.mPackages) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                throw new IllegalArgumentException("Unknown target package: " + packageName);
            }
            suspended = ps.getSuspended(userId);
        }
        return suspended;
    }

    private boolean canSuspendPackageForUserLocked(String packageName, int userId) {
        if (isPackageDeviceAdmin(packageName, userId)) {
            Slog.w(TAG, "Cannot suspend/un-suspend package \"" + packageName + "\": has an active device admin");
            return false;
        } else if (packageName.equals(getActiveLauncherPackageName(userId))) {
            Slog.w(TAG, "Cannot suspend/un-suspend package \"" + packageName + "\": contains the active launcher");
            return false;
        } else if (packageName.equals(this.mRequiredInstallerPackage)) {
            Slog.w(TAG, "Cannot suspend/un-suspend package \"" + packageName + "\": required for package installation");
            return false;
        } else if (packageName.equals(this.mRequiredUninstallerPackage)) {
            Slog.w(TAG, "Cannot suspend/un-suspend package \"" + packageName + "\": required for package uninstallation");
            return false;
        } else if (packageName.equals(this.mRequiredVerifierPackage)) {
            Slog.w(TAG, "Cannot suspend/un-suspend package \"" + packageName + "\": required for package verification");
            return false;
        } else if (packageName.equals(getDefaultDialerPackageName(userId))) {
            Slog.w(TAG, "Cannot suspend/un-suspend package \"" + packageName + "\": is the default dialer");
            return false;
        } else if (this.mProtectedPackages.isPackageStateProtected(userId, packageName)) {
            Slog.w(TAG, "Cannot suspend/un-suspend package \"" + packageName + "\": protected package");
            return false;
        } else {
            Package pkg = (Package) this.mPackages.get(packageName);
            if (pkg == null || !pkg.applicationInfo.isStaticSharedLibrary()) {
                return true;
            }
            Slog.w(TAG, "Cannot suspend package: " + packageName + " providing static shared library: " + pkg.staticSharedLibName);
            return false;
        }
    }

    private String getActiveLauncherPackageName(int userId) {
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory("android.intent.category.HOME");
        ResolveInfo resolveInfo = resolveIntent(intent, intent.resolveTypeIfNeeded(this.mContext.getContentResolver()), 65536, userId);
        if (resolveInfo == null) {
            return null;
        }
        return resolveInfo.activityInfo.packageName;
    }

    private String getDefaultDialerPackageName(int userId) {
        String defaultDialerPackageNameLPw;
        synchronized (this.mPackages) {
            defaultDialerPackageNameLPw = this.mSettings.getDefaultDialerPackageNameLPw(userId);
        }
        return defaultDialerPackageNameLPw;
    }

    public void verifyPendingInstall(int id, int verificationCode) throws RemoteException {
        this.mContext.enforceCallingOrSelfPermission("android.permission.PACKAGE_VERIFICATION_AGENT", "Only package verification agents can verify applications");
        Message msg = this.mHandler.obtainMessage(15);
        PackageVerificationResponse response = new PackageVerificationResponse(verificationCode, Binder.getCallingUid());
        msg.arg1 = id;
        msg.obj = response;
        this.mHandler.sendMessage(msg);
    }

    public void extendVerificationTimeout(int id, int verificationCodeAtTimeout, long millisecondsToDelay) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.PACKAGE_VERIFICATION_AGENT", "Only package verification agents can extend verification timeouts");
        PackageVerificationState state = (PackageVerificationState) this.mPendingVerification.get(id);
        PackageVerificationResponse response = new PackageVerificationResponse(verificationCodeAtTimeout, Binder.getCallingUid());
        if (millisecondsToDelay > 3600000) {
            millisecondsToDelay = 3600000;
        }
        if (millisecondsToDelay < 0) {
            millisecondsToDelay = 0;
        }
        if (!(verificationCodeAtTimeout == 1 || verificationCodeAtTimeout == -1)) {
        }
        if (state != null && (state.timeoutExtended() ^ 1) != 0) {
            state.extendTimeout();
            Message msg = this.mHandler.obtainMessage(15);
            msg.arg1 = id;
            msg.obj = response;
            this.mHandler.sendMessageDelayed(msg, millisecondsToDelay);
        }
    }

    private void broadcastPackageVerified(int verificationId, Uri packageUri, int verificationCode, UserHandle user) {
        Intent intent = new Intent("android.intent.action.PACKAGE_VERIFIED");
        intent.setDataAndType(packageUri, PACKAGE_MIME_TYPE);
        intent.addFlags(1);
        intent.putExtra("android.content.pm.extra.VERIFICATION_ID", verificationId);
        intent.putExtra("android.content.pm.extra.VERIFICATION_RESULT", verificationCode);
        this.mContext.sendBroadcastAsUser(intent, user, "android.permission.PACKAGE_VERIFICATION_AGENT");
    }

    private ComponentName matchComponentForVerifier(String packageName, List<ResolveInfo> receivers) {
        if (packageName == null) {
            return null;
        }
        ActivityInfo targetReceiver = null;
        int NR = receivers.size();
        for (int i = 0; i < NR; i++) {
            ResolveInfo info = (ResolveInfo) receivers.get(i);
            if (info.activityInfo != null && packageName.equals(info.activityInfo.packageName)) {
                targetReceiver = info.activityInfo;
                break;
            }
        }
        if (targetReceiver == null) {
            return null;
        }
        return new ComponentName(targetReceiver.packageName, targetReceiver.name);
    }

    private List<ComponentName> matchVerifiers(PackageInfoLite pkgInfo, List<ResolveInfo> receivers, PackageVerificationState verificationState) {
        if (pkgInfo.verifiers.length == 0) {
            return null;
        }
        List<ComponentName> sufficientVerifiers = new ArrayList(N + 1);
        for (VerifierInfo verifierInfo : pkgInfo.verifiers) {
            ComponentName comp = matchComponentForVerifier(verifierInfo.packageName, receivers);
            if (comp != null) {
                int verifierUid = getUidForVerifier(verifierInfo);
                if (verifierUid != -1) {
                    if (DEBUG_VERIFY) {
                        Slog.d(TAG, "Added sufficient verifier " + verifierInfo.packageName + " with the correct signature");
                    }
                    sufficientVerifiers.add(comp);
                    verificationState.addSufficientVerifier(verifierUid);
                }
            }
        }
        return sufficientVerifiers;
    }

    private int getUidForVerifier(VerifierInfo verifierInfo) {
        synchronized (this.mPackages) {
            Package pkg = (Package) this.mPackages.get(verifierInfo.packageName);
            if (pkg == null) {
                return -1;
            } else if (pkg.mSignatures.length != 1) {
                Slog.i(TAG, "Verifier package " + verifierInfo.packageName + " has more than one signature; ignoring");
                return -1;
            } else {
                try {
                    if (Arrays.equals(verifierInfo.publicKey.getEncoded(), pkg.mSignatures[0].getPublicKey().getEncoded())) {
                        int i = pkg.applicationInfo.uid;
                        return i;
                    }
                    Slog.i(TAG, "Verifier package " + verifierInfo.packageName + " does not have the expected public key; ignoring");
                    return -1;
                } catch (CertificateException e) {
                    return -1;
                }
            }
        }
    }

    public void finishPackageInstall(int token, boolean didLaunch) {
        enforceSystemOrRoot("Only the system is allowed to finish installs");
        if (DEBUG_INSTALL) {
            Slog.v(TAG, "BM finishing package install for " + token);
        }
        Trace.asyncTraceEnd(262144, "restore", token);
        this.mHandler.sendMessage(this.mHandler.obtainMessage(9, token, didLaunch ? 1 : 0));
    }

    private long getVerificationTimeout() {
        return Global.getLong(this.mContext.getContentResolver(), "verifier_timeout", 10000);
    }

    private int getDefaultVerificationResponse(UserHandle user) {
        if (sUserManager.hasUserRestriction("ensure_verify_apps", user.getIdentifier())) {
            return -1;
        }
        return Global.getInt(this.mContext.getContentResolver(), "verifier_default_response", 1);
    }

    private boolean isVerificationEnabled(int userId, int installFlags, int installerUid) {
        boolean ensureVerifyAppsEnabled = isUserRestricted(userId, "ensure_verify_apps");
        if ((installFlags & 32) != 0) {
            if (ActivityManager.isRunningInTestHarness()) {
                return false;
            }
            if (ensureVerifyAppsEnabled) {
                return true;
            }
            if (Global.getInt(this.mContext.getContentResolver(), "verifier_verify_adb_installs", 1) == 0) {
                return false;
            }
        } else if (!((installFlags & 2048) == 0 || this.mInstantAppInstallerActivity == null || !this.mInstantAppInstallerActivity.packageName.equals(this.mRequiredVerifierPackage))) {
            try {
                ((AppOpsManager) this.mContext.getSystemService(AppOpsManager.class)).checkPackage(installerUid, this.mRequiredVerifierPackage);
                if (DEBUG_VERIFY) {
                    Slog.i(TAG, "disable verification for instant app");
                }
                return false;
            } catch (SecurityException e) {
            }
        }
        if (ensureVerifyAppsEnabled) {
            return true;
        }
        return Global.getInt(this.mContext.getContentResolver(), "package_verifier_enable", 1) == 1;
    }

    public void verifyIntentFilter(int id, int verificationCode, List<String> failedDomains) throws RemoteException {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTENT_FILTER_VERIFICATION_AGENT", "Only intentfilter verification agents can verify applications");
        Message msg = this.mHandler.obtainMessage(18);
        IntentFilterVerificationResponse response = new IntentFilterVerificationResponse(Binder.getCallingUid(), verificationCode, failedDomains);
        msg.arg1 = id;
        msg.obj = response;
        this.mHandler.sendMessage(msg);
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public int getIntentVerificationStatus(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        if (UserHandle.getUserId(callingUid) != userId) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "getIntentVerificationStatus" + userId);
        }
        if (getInstantAppPackageName(callingUid) != null) {
            return 0;
        }
        synchronized (this.mPackages) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (ps == null || filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
            } else {
                int intentFilterVerificationStatusLPr = this.mSettings.getIntentFilterVerificationStatusLPr(packageName, userId);
                return intentFilterVerificationStatusLPr;
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public boolean updateIntentVerificationStatus(String packageName, int status, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        synchronized (this.mPackages) {
            if (filterAppAccessLPr((PackageSetting) this.mSettings.mPackages.get(packageName), Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                return false;
            }
            boolean result = this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, status, userId);
        }
    }

    public ParceledListSlice<IntentFilterVerificationInfo> getIntentFilterVerifications(String packageName) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return ParceledListSlice.emptyList();
        }
        synchronized (this.mPackages) {
            ParceledListSlice<IntentFilterVerificationInfo> emptyList;
            if (filterAppAccessLPr((PackageSetting) this.mSettings.mPackages.get(packageName), callingUid, UserHandle.getUserId(callingUid))) {
                emptyList = ParceledListSlice.emptyList();
                return emptyList;
            }
            emptyList = new ParceledListSlice(this.mSettings.getIntentFilterVerificationsLPr(packageName));
            return emptyList;
        }
    }

    public ParceledListSlice<IntentFilter> getAllIntentFilters(String packageName) {
        if (TextUtils.isEmpty(packageName)) {
            return ParceledListSlice.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        synchronized (this.mPackages) {
            Package pkg = (Package) this.mPackages.get(packageName);
            ParceledListSlice<IntentFilter> emptyList;
            if (pkg == null || pkg.activities == null) {
                emptyList = ParceledListSlice.emptyList();
                return emptyList;
            } else if (pkg.mExtras == null) {
                emptyList = ParceledListSlice.emptyList();
                return emptyList;
            } else if (filterAppAccessLPr(pkg.mExtras, callingUid, callingUserId)) {
                emptyList = ParceledListSlice.emptyList();
                return emptyList;
            } else {
                int count = pkg.activities.size();
                ArrayList<IntentFilter> result = new ArrayList();
                for (int n = 0; n < count; n++) {
                    Activity activity = (Activity) pkg.activities.get(n);
                    if (activity.intents != null && activity.intents.size() > 0) {
                        result.addAll(activity.intents);
                    }
                }
                emptyList = new ParceledListSlice(result);
                return emptyList;
            }
        }
    }

    public boolean setDefaultBrowserPackageName(String packageName, int userId) {
        boolean result;
        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        if (UserHandle.getCallingUserId() != userId) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        }
        synchronized (this.mPackages) {
            result = this.mSettings.setDefaultBrowserPackageNameLPw(packageName, userId);
            if (packageName != null) {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultBrowserLPr(packageName, userId);
            }
        }
        return result;
    }

    public String getDefaultBrowserPackageName(int userId) {
        boolean isMultiapp = false;
        if (UserHandle.getCallingUserId() == OppoMultiAppManager.USER_ID) {
            try {
                String[] packages = getPackagesForUid(Binder.getCallingUid());
                if (packages != null) {
                    for (String pkgName : packages) {
                        if (OppoMultiAppManagerUtil.getInstance().isMultiApp(pkgName)) {
                            isMultiapp = true;
                            break;
                        }
                    }
                }
            } catch (Exception e) {
            }
        }
        if (!(UserHandle.getCallingUserId() == userId || (isMultiapp ^ 1) == 0)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        }
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
        }
        return this.mSettings.getDefaultBrowserPackageNameLPw(userId);
    }

    private int getUnknownSourcesSettings() {
        return Secure.getInt(this.mContext.getContentResolver(), "install_non_market_apps", -1);
    }

    public void setInstallerPackageName(String targetPackage, String installerPackageName) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null) {
            synchronized (this.mPackages) {
                PackageSetting targetPackageSetting = (PackageSetting) this.mSettings.mPackages.get(targetPackage);
                if (targetPackageSetting == null || filterAppAccessLPr(targetPackageSetting, callingUid, UserHandle.getUserId(callingUid))) {
                    throw new IllegalArgumentException("Unknown target package: " + targetPackage);
                }
                PackageSetting packageSetting;
                if (installerPackageName != null) {
                    packageSetting = (PackageSetting) this.mSettings.mPackages.get(installerPackageName);
                    if (packageSetting == null) {
                        throw new IllegalArgumentException("Unknown installer package: " + installerPackageName);
                    }
                }
                packageSetting = null;
                Object obj = this.mSettings.getUserIdLPr(callingUid);
                if (obj != null) {
                    Signature[] callerSignature;
                    if (obj instanceof SharedUserSetting) {
                        callerSignature = ((SharedUserSetting) obj).signatures.mSignatures;
                    } else if (obj instanceof PackageSetting) {
                        callerSignature = ((PackageSetting) obj).signatures.mSignatures;
                    } else {
                        throw new SecurityException("Bad object " + obj + " for uid " + callingUid);
                    }
                    if (packageSetting == null || compareSignatures(callerSignature, packageSetting.signatures.mSignatures) == 0) {
                        if (targetPackageSetting.installerPackageName != null) {
                            PackageSetting setting = (PackageSetting) this.mSettings.mPackages.get(targetPackageSetting.installerPackageName);
                            if (!(setting == null || compareSignatures(callerSignature, setting.signatures.mSignatures) == 0)) {
                                throw new SecurityException("Caller does not have same cert as old installer package " + targetPackageSetting.installerPackageName);
                            }
                        }
                        targetPackageSetting.installerPackageName = installerPackageName;
                        if (installerPackageName != null) {
                            this.mSettings.mInstallerPackages.add(installerPackageName);
                        }
                        scheduleWriteSettingsLocked();
                    } else {
                        throw new SecurityException("Caller does not have same cert as new installer package " + installerPackageName);
                    }
                }
                throw new SecurityException("Unknown calling UID: " + callingUid);
            }
        }
    }

    public void setApplicationCategoryHint(String packageName, int categoryHint, String callerPackageName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            throw new SecurityException("Instant applications don't have access to this method");
        }
        ((AppOpsManager) this.mContext.getSystemService(AppOpsManager.class)).checkPackage(Binder.getCallingUid(), callerPackageName);
        synchronized (this.mPackages) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                throw new IllegalArgumentException("Unknown target package " + packageName);
            } else if (filterAppAccessLPr(ps, Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                throw new IllegalArgumentException("Unknown target package " + packageName);
            } else if (Objects.equals(callerPackageName, ps.installerPackageName)) {
                if (ps.categoryHint != categoryHint) {
                    ps.categoryHint = categoryHint;
                    scheduleWriteSettingsLocked();
                }
            } else {
                throw new IllegalArgumentException("Calling package " + callerPackageName + " is not installer for " + packageName);
            }
        }
    }

    private void processPendingInstall(final InstallArgs args, final int currentStatus) {
        this.mHandler.post(new Runnable() {
            public void run() {
                PackageManagerService.this.mHandler.removeCallbacks(this);
                PackageInstalledInfo res = new PackageInstalledInfo();
                res.setReturnCode(currentStatus);
                res.uid = -1;
                res.pkg = null;
                res.removedInfo = null;
                if (res.returnCode == 1) {
                    if (PackageManagerService.mHyp == null) {
                        PackageManagerService.mHyp = Hypnus.getHypnus();
                    }
                    if (PackageManagerService.mHyp != null) {
                        PackageManagerService.mHyp.hypnusSetAction(15, com.android.server.am.EventLogTags.AM_CREATE_ACTIVITY);
                    }
                    args.doPreInstall(res.returnCode);
                    synchronized (PackageManagerService.this.mInstallLock) {
                        PackageManagerService.this.installPackageTracedLI(args, res);
                    }
                    args.doPostInstall(res.returnCode, res.uid);
                }
                boolean update = res.removedInfo != null ? res.removedInfo.removedPackage != null : false;
                boolean doRestore = !update ? (32768 & (res.pkg == null ? 0 : res.pkg.applicationInfo.flags)) != 0 : false;
                if (PackageManagerService.this.mNextInstallToken < 0) {
                    PackageManagerService.this.mNextInstallToken = 1;
                }
                PackageManagerService packageManagerService = PackageManagerService.this;
                int token = packageManagerService.mNextInstallToken;
                packageManagerService.mNextInstallToken = token + 1;
                PackageManagerService.this.mRunningInstalls.put(token, new PostInstallData(args, res));
                if (PackageManagerService.DEBUG_INSTALL) {
                    Log.v(PackageManagerService.TAG, "+ starting restore round-trip " + token);
                }
                if (res.returnCode == 1 && doRestore) {
                    IBackupManager bm = IBackupManager.Stub.asInterface(ServiceManager.getService("backup"));
                    if (bm != null) {
                        if (PackageManagerService.DEBUG_INSTALL) {
                            Log.v(PackageManagerService.TAG, "token " + token + " to BM for possible restore");
                        }
                        Trace.asyncTraceBegin(262144, "restore", token);
                        try {
                            if (bm.isBackupServiceActive(0)) {
                                bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);
                            } else {
                                doRestore = false;
                            }
                        } catch (RemoteException e) {
                        } catch (Exception e2) {
                            Slog.e(PackageManagerService.TAG, "Exception trying to enqueue restore", e2);
                            doRestore = false;
                        }
                    } else {
                        Slog.e(PackageManagerService.TAG, "Backup Manager not found!");
                        doRestore = false;
                    }
                }
                if (!doRestore) {
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Log.v(PackageManagerService.TAG, "No restore - queue post-install for " + token);
                    }
                    Trace.asyncTraceBegin(262144, "postInstall", token);
                    PackageManagerService.this.mHandler.sendMessage(PackageManagerService.this.mHandler.obtainMessage(9, token, 0));
                }
            }
        });
    }

    void notifyFirstLaunch(final String pkgName, final String installerPackage, final int userId) {
        this.mHandler.post(new Runnable() {
            public void run() {
                for (int i = 0; i < PackageManagerService.this.mRunningInstalls.size(); i++) {
                    PostInstallData data = (PostInstallData) PackageManagerService.this.mRunningInstalls.valueAt(i);
                    if (data.res.returnCode == 1 && pkgName.equals(data.res.pkg.applicationInfo.packageName)) {
                        int uIndex = 0;
                        while (uIndex < data.res.newUsers.length) {
                            if (userId != data.res.newUsers[uIndex]) {
                                uIndex++;
                            } else {
                                return;
                            }
                        }
                        continue;
                    }
                }
                PackageManagerService.this.sendFirstLaunchBroadcast(pkgName, installerPackage, new int[]{userId});
            }
        });
    }

    private void sendFirstLaunchBroadcast(String pkgName, String installerPkg, int[] userIds) {
        sendPackageBroadcast("android.intent.action.PACKAGE_FIRST_LAUNCH", pkgName, null, 0, installerPkg, null, userIds);
    }

    private static void clearDirectory(IMediaContainerService mcs, File[] paths) {
        for (File path : paths) {
            try {
                mcs.clearDirectory(path.getAbsolutePath());
            } catch (RemoteException e) {
            }
        }
    }

    private static boolean installOnExternalAsec(int installFlags) {
        if ((installFlags & 16) == 0 && (installFlags & 8) != 0) {
            return true;
        }
        return false;
    }

    private static boolean installForwardLocked(int installFlags) {
        return (installFlags & 1) != 0;
    }

    private InstallArgs createInstallArgs(InstallParams params) {
        if (params.move != null) {
            return new MoveInstallArgs(params);
        }
        if (installOnExternalAsec(params.installFlags) || params.isForwardLocked()) {
            return new AsecInstallArgs(params);
        }
        return new FileInstallArgs(params);
    }

    private InstallArgs createInstallArgsForExisting(int installFlags, String codePath, String resourcePath, String[] instructionSets) {
        boolean isInAsec;
        if (installOnExternalAsec(installFlags)) {
            isInAsec = true;
        } else if (!installForwardLocked(installFlags) || (codePath.startsWith(this.mDrmAppPrivateInstallDir.getAbsolutePath()) ^ 1) == 0) {
            isInAsec = false;
        } else {
            isInAsec = true;
        }
        if (!isInAsec) {
            return new FileInstallArgs(codePath, resourcePath, instructionSets);
        }
        return new AsecInstallArgs(codePath, instructionSets, installOnExternalAsec(installFlags), installForwardLocked(installFlags));
    }

    void removeDexFiles(List<String> allCodePaths, String[] instructionSets) {
        if (!allCodePaths.isEmpty()) {
            if (instructionSets == null) {
                throw new IllegalStateException("instructionSet == null");
            }
            String[] dexCodeInstructionSets = InstructionSets.getDexCodeInstructionSets(instructionSets);
            for (String codePath : allCodePaths) {
                for (String dexCodeInstructionSet : dexCodeInstructionSets) {
                    try {
                        this.mInstaller.rmdex(codePath, dexCodeInstructionSet);
                    } catch (InstallerException e) {
                    }
                }
            }
        }
    }

    private boolean isAsecExternal(String cid) {
        return PackageHelper.getSdFilesystem(cid).startsWith(this.mAsecInternalPath) ^ 1;
    }

    private static void maybeThrowExceptionForMultiArchCopy(String message, int copyRet) throws PackageManagerException {
        if (copyRet < 0 && copyRet != -114 && copyRet != -113) {
            throw new PackageManagerException(copyRet, message);
        }
    }

    static String cidFromCodePath(String fullCodePath) {
        int eidx = fullCodePath.lastIndexOf("/");
        String subStr1 = fullCodePath.substring(0, eidx);
        return subStr1.substring(subStr1.lastIndexOf("/") + 1, eidx);
    }

    static String getAsecPackageName(String packageCid) {
        int idx = packageCid.lastIndexOf(INSTALL_PACKAGE_SUFFIX);
        if (idx == -1) {
            return packageCid;
        }
        return packageCid.substring(0, idx);
    }

    private static String getNextCodePath(String oldCodePath, String prefix, String suffix) {
        String idxStr = "";
        int idx = 1;
        if (oldCodePath != null) {
            String subStr = oldCodePath;
            if (suffix != null && oldCodePath.endsWith(suffix)) {
                subStr = oldCodePath.substring(0, oldCodePath.length() - suffix.length());
            }
            int sidx = subStr.lastIndexOf(prefix);
            if (sidx != -1) {
                subStr = subStr.substring(prefix.length() + sidx);
                if (subStr != null) {
                    if (subStr.startsWith(INSTALL_PACKAGE_SUFFIX)) {
                        subStr = subStr.substring(INSTALL_PACKAGE_SUFFIX.length());
                    }
                    try {
                        idx = Integer.parseInt(subStr);
                        idx = idx <= 1 ? idx + 1 : idx - 1;
                    } catch (NumberFormatException e) {
                    }
                }
            }
        }
        return prefix + (INSTALL_PACKAGE_SUFFIX + Integer.toString(idx));
    }

    private File getNextCodePath(File targetDir, String packageName) {
        File result;
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[16];
        do {
            random.nextBytes(bytes);
            result = new File(targetDir, packageName + INSTALL_PACKAGE_SUFFIX + Base64.encodeToString(bytes, 10));
        } while (result.exists());
        return result;
    }

    static String deriveCodePathName(String codePath) {
        if (codePath == null) {
            return null;
        }
        File codeFile = new File(codePath);
        String name = codeFile.getName();
        if (codeFile.isDirectory()) {
            return name;
        }
        if (name.endsWith(".apk") || name.endsWith(".tmp")) {
            return name.substring(0, name.lastIndexOf(46));
        }
        Slog.w(TAG, "Odd, " + codePath + " doesn't look like an APK");
        return null;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void installNewPackageLIF(Package pkg, int policyFlags, int scanFlags, UserHandle user, String installerPackageName, String volumeUuid, PackageInstalledInfo res, int installReason) {
        Trace.traceBegin(262144, "installNewPackage");
        String pkgName = pkg.packageName;
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "installNewPackageLI: " + pkg);
        }
        synchronized (this.mPackages) {
            String renamedPackage = this.mSettings.getRenamedPackageLPr(pkgName);
            if (renamedPackage != null) {
                res.setError(-1, "Attempt to re-install " + pkgName + " without first uninstalling package running as " + renamedPackage);
                return;
            } else if (this.mPackages.containsKey(pkgName)) {
                res.setError(-1, "Attempt to re-install " + pkgName + " without first uninstalling.");
                return;
            }
        }
        Trace.traceEnd(262144);
    }

    private boolean shouldCheckUpgradeKeySetLP(PackageSetting oldPs, int scanFlags) {
        if (oldPs == null || (scanFlags & 4096) != 0 || oldPs.sharedUser != null || (oldPs.keySetData.isUsingUpgradeKeySets() ^ 1) != 0) {
            return false;
        }
        KeySetManagerService ksms = this.mSettings.mKeySetManagerService;
        long[] upgradeKeySets = oldPs.keySetData.getUpgradeKeySets();
        int i = 0;
        while (i < upgradeKeySets.length) {
            if (ksms.isIdValidKeySetId(upgradeKeySets[i])) {
                i++;
            } else {
                Slog.wtf(TAG, "Package " + (oldPs.name != null ? oldPs.name : "<null>") + " contains upgrade-key-set reference to unknown key-set: " + upgradeKeySets[i] + " reverting to signatures check.");
                return false;
            }
        }
        return true;
    }

    private boolean checkUpgradeKeySetLP(PackageSetting oldPS, Package newPkg) {
        long[] upgradeKeySets = oldPS.keySetData.getUpgradeKeySets();
        KeySetManagerService ksms = this.mSettings.mKeySetManagerService;
        for (long publicKeysFromKeySetLPr : upgradeKeySets) {
            Set<PublicKey> upgradeSet = ksms.getPublicKeysFromKeySetLPr(publicKeysFromKeySetLPr);
            if (upgradeSet != null && newPkg.mSigningKeys.containsAll(upgradeSet)) {
                return true;
            }
        }
        return false;
    }

    private static void updateDigest(MessageDigest digest, File file) throws IOException {
        Throwable th;
        Throwable th2 = null;
        DigestInputStream digestStream = null;
        try {
            DigestInputStream digestStream2 = new DigestInputStream(new FileInputStream(file), digest);
            do {
                try {
                } catch (Throwable th3) {
                    th = th3;
                    digestStream = digestStream2;
                }
            } while (digestStream2.read() != -1);
            if (digestStream2 != null) {
                try {
                    digestStream2.close();
                } catch (Throwable th4) {
                    th2 = th4;
                }
            }
            if (th2 != null) {
                throw th2;
            }
        } catch (Throwable th5) {
            th = th5;
            if (digestStream != null) {
                try {
                    digestStream.close();
                } catch (Throwable th6) {
                    if (th2 == null) {
                        th2 = th6;
                    } else if (th2 != th6) {
                        th2.addSuppressed(th6);
                    }
                }
            }
            if (th2 != null) {
                throw th2;
            }
            throw th;
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void replacePackageLIF(Package pkg, int policyFlags, int scanFlags, UserHandle user, String installerPackageName, PackageInstalledInfo res, int installReason) {
        boolean isInstantApp = (131072 & scanFlags) != 0;
        String pkgName = pkg.packageName;
        synchronized (this.mPackages) {
            Package oldPackage = (Package) this.mPackages.get(pkgName);
            if (DEBUG_INSTALL) {
                Slog.d(TAG, "replacePackageLI: new=" + pkg + ", old=" + oldPackage);
            }
            boolean oldTargetsPreRelease = oldPackage.applicationInfo.targetSdkVersion == 10000;
            boolean newTargetsPreRelease = pkg.applicationInfo.targetSdkVersion == 10000;
            if (oldTargetsPreRelease && (newTargetsPreRelease ^ 1) != 0 && (policyFlags & 4096) == 0) {
                Slog.w(TAG, "Can't install package targeting released sdk");
                res.setReturnCode(-7);
                return;
            }
            int i;
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(pkgName);
            if (shouldCheckUpgradeKeySetLP(ps, scanFlags)) {
                if (!checkUpgradeKeySetLP(ps, pkg)) {
                    res.setError(-7, "New package not signed by keys specified by upgrade-keysets: " + pkgName);
                    return;
                }
            } else if (compareSignatures(oldPackage.mSignatures, pkg.mSignatures) != 0) {
                res.setError(-7, "New package has a different signature: " + pkgName);
                return;
            }
            if (oldPackage.restrictUpdateHash != null && oldPackage.isSystemApp()) {
                try {
                    MessageDigest digest = MessageDigest.getInstance("SHA-512");
                    updateDigest(digest, new File(pkg.baseCodePath));
                    if (!ArrayUtils.isEmpty(pkg.splitCodePaths)) {
                        for (String path : pkg.splitCodePaths) {
                            updateDigest(digest, new File(path));
                        }
                    }
                    if (Arrays.equals(oldPackage.restrictUpdateHash, digest.digest())) {
                        pkg.restrictUpdateHash = oldPackage.restrictUpdateHash;
                    } else {
                        res.setError(-2, "New package fails restrict-update check: " + pkgName);
                        return;
                    }
                } catch (NoSuchAlgorithmException e) {
                    res.setError(-2, "Could not compute hash: " + pkgName);
                    return;
                }
            }
            String invalidPackageName = getParentOrChildPackageChangedSharedUser(oldPackage, pkg);
            if (invalidPackageName != null) {
                res.setError(-8, "Package " + invalidPackageName + " tried to change user " + oldPackage.mSharedUserId);
                return;
            }
            int[] allUsers = sUserManager.getUserIds();
            int[] installedUsers = ps.queryInstalledUsers(allUsers, true);
            if (isInstantApp) {
                if (user == null || user.getIdentifier() == -1) {
                    i = 0;
                    int length = allUsers.length;
                    while (i < length) {
                        int currentUser = allUsers[i];
                        if (ps.getInstantApp(currentUser)) {
                            i++;
                        } else {
                            Slog.w(TAG, "Can't replace full app with instant app: " + pkgName + " for user: " + currentUser);
                            res.setReturnCode(-116);
                            return;
                        }
                    }
                }
                if (!ps.getInstantApp(user.getIdentifier())) {
                    Slog.w(TAG, "Can't replace full app with instant app: " + pkgName + " for user: " + user.getIdentifier());
                    res.setReturnCode(-116);
                }
            }
        }
    }

    public List<String> getPreviousCodePaths(String packageName) {
        int callingUid = Binder.getCallingUid();
        List<String> result = new ArrayList();
        if (getInstantAppPackageName(callingUid) != null) {
            return result;
        }
        PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
        if (!(ps == null || ps.oldCodePaths == null || (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid)) ^ 1) == 0)) {
            result.addAll(ps.oldCodePaths);
        }
        return result;
    }

    private void replaceNonSystemPackageLIF(Package deletedPackage, Package pkg, int policyFlags, int scanFlags, UserHandle user, int[] allUsers, String installerPackageName, PackageInstalledInfo res, int installReason) {
        PackageSetting ps;
        int i;
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "replaceNonSystemPackageLI: new=" + pkg + ", old=" + deletedPackage);
        }
        String pkgName = deletedPackage.packageName;
        boolean deletedPkg = true;
        boolean addedPkg = false;
        boolean killApp = (scanFlags & 16384) == 0;
        int deleteFlags = (killApp ? 0 : 8) | 1;
        long origUpdateTime = pkg.mExtras != null ? ((PackageSetting) pkg.mExtras).lastUpdateTime : 0;
        if (deletePackageLIF(pkgName, null, true, allUsers, deleteFlags, res.removedInfo, true, pkg)) {
            if (deletedPackage.isForwardLocked() || isExternal(deletedPackage)) {
                if (DEBUG_INSTALL) {
                    Slog.i(TAG, "upgrading pkg " + deletedPackage + " is ASEC-hosted -> UNAVAILABLE");
                }
                int[] uidArray = new int[]{deletedPackage.applicationInfo.uid};
                ArrayList pkgList = new ArrayList(1);
                pkgList.add(deletedPackage.applicationInfo.packageName);
                sendResourcesChangedBroadcast(false, true, pkgList, uidArray, null);
            }
            clearAppDataLIF(pkg, -1, UsbTerminalTypes.TERMINAL_IN_PERSONAL_MIC);
            clearAppProfilesLIF(deletedPackage, -1);
            try {
                Package newPackage = scanPackageTracedLI(pkg, policyFlags, scanFlags | 32, System.currentTimeMillis(), user);
                updateSettingsLI(newPackage, installerPackageName, allUsers, res, user, installReason);
                ps = (PackageSetting) this.mSettings.mPackages.get(pkgName);
                if (killApp) {
                    ps.oldCodePaths = null;
                } else {
                    if (ps.oldCodePaths == null) {
                        ps.oldCodePaths = new ArraySet();
                    }
                    Collections.addAll(ps.oldCodePaths, new String[]{deletedPackage.baseCodePath});
                    if (deletedPackage.splitCodePaths != null) {
                        Collections.addAll(ps.oldCodePaths, deletedPackage.splitCodePaths);
                    }
                }
                if (ps.childPackageNames != null) {
                    for (i = ps.childPackageNames.size() - 1; i >= 0; i--) {
                        ((PackageSetting) this.mSettings.mPackages.get((String) ps.childPackageNames.get(i))).oldCodePaths = ps.oldCodePaths;
                    }
                }
                setInstantAppForUser(ps, user.getIdentifier(), (131072 & scanFlags) != 0, (262144 & scanFlags) != 0);
                prepareAppDataAfterInstallLIF(newPackage);
                addedPkg = true;
                this.mDexManager.notifyPackageUpdated(newPackage.packageName, newPackage.baseCodePath, newPackage.splitCodePaths);
            } catch (PackageManagerException e) {
                res.setError("Package couldn't be installed in " + pkg.codePath, e);
            }
        } else {
            res.setError(-10, "replaceNonSystemPackageLI");
            deletedPkg = false;
        }
        if (res.returnCode != 1) {
            if (DEBUG_INSTALL) {
                Slog.d(TAG, "Install failed, rolling pack: " + pkgName);
            }
            if (addedPkg) {
                deletePackageLIF(pkgName, null, true, allUsers, deleteFlags, res.removedInfo, true, null);
            }
            if (deletedPkg) {
                if (DEBUG_INSTALL) {
                    Slog.d(TAG, "Install failed, reinstalling: " + deletedPackage);
                }
                try {
                    scanPackageTracedLI(new File(deletedPackage.codePath), ((this.mDefParseFlags | 2) | (deletedPackage.isForwardLocked() ? 16 : 0)) | (isExternal(deletedPackage) ? 32 : 0), 40, origUpdateTime, null);
                    synchronized (this.mPackages) {
                        setInstallerPackageNameLPw(deletedPackage, installerPackageName);
                        updatePermissionsLPw(deletedPackage, 1);
                        this.mSettings.writeLPr();
                    }
                    Slog.i(TAG, "Successfully restored package : " + pkgName + " after failed upgrade");
                } catch (PackageManagerException e2) {
                    Slog.e(TAG, "Failed to restore package : " + pkgName + " after failed upgrade: " + e2.getMessage());
                    return;
                }
            }
        }
        synchronized (this.mPackages) {
            ps = this.mSettings.getPackageLPr(pkg.packageName);
            if (ps != null) {
                res.removedInfo.removedForAllUsers = this.mPackages.get(ps.name) == null;
                if (res.removedInfo.removedChildPackages != null) {
                    for (i = res.removedInfo.removedChildPackages.size() - 1; i >= 0; i--) {
                        if (res.addedChildPackages.containsKey((String) res.removedInfo.removedChildPackages.keyAt(i))) {
                            res.removedInfo.removedChildPackages.removeAt(i);
                        } else {
                            boolean z;
                            PackageRemovedInfo childInfo = (PackageRemovedInfo) res.removedInfo.removedChildPackages.valueAt(i);
                            if (this.mPackages.get(childInfo.removedPackage) == null) {
                                z = true;
                            } else {
                                z = false;
                            }
                            childInfo.removedForAllUsers = z;
                        }
                    }
                }
            }
        }
    }

    private void replaceSystemPackageLIF(Package deletedPackage, Package pkg, int policyFlags, int scanFlags, UserHandle user, int[] allUsers, String installerPackageName, PackageInstalledInfo res, int installReason) {
        boolean disabledSystem;
        Package newPackage;
        PackageManagerException e;
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "replaceSystemPackageLI: new=" + pkg + ", old=" + deletedPackage);
        }
        removePackageLI(deletedPackage, true);
        synchronized (this.mPackages) {
            disabledSystem = disableSystemPackageLPw(deletedPackage, pkg);
        }
        if (disabledSystem) {
            res.removedInfo.args = null;
        } else {
            res.removedInfo.args = createInstallArgsForExisting(0, deletedPackage.applicationInfo.getCodePath(), deletedPackage.applicationInfo.getResourcePath(), InstructionSets.getAppDexInstructionSets(deletedPackage.applicationInfo));
        }
        clearAppDataLIF(pkg, -1, UsbTerminalTypes.TERMINAL_IN_PERSONAL_MIC);
        clearAppProfilesLIF(deletedPackage, -1);
        res.setReturnCode(1);
        pkg.setApplicationInfoFlags(128, 128);
        try {
            newPackage = scanPackageTracedLI(pkg, policyFlags, scanFlags, 0, user);
            try {
                setInstallAndUpdateTime(newPackage, deletedPackage.mExtras.firstInstallTime, System.currentTimeMillis());
                if (res.returnCode == 1) {
                    int deletedChildCount = deletedPackage.childPackages != null ? deletedPackage.childPackages.size() : 0;
                    int newChildCount = newPackage.childPackages != null ? newPackage.childPackages.size() : 0;
                    for (int i = 0; i < deletedChildCount; i++) {
                        Package deletedChildPkg = (Package) deletedPackage.childPackages.get(i);
                        boolean childPackageDeleted = true;
                        for (int j = 0; j < newChildCount; j++) {
                            if (deletedChildPkg.packageName.equals(((Package) newPackage.childPackages.get(j)).packageName)) {
                                childPackageDeleted = false;
                                break;
                            }
                        }
                        if (childPackageDeleted) {
                            PackageSetting ps = this.mSettings.getDisabledSystemPkgLPr(deletedChildPkg.packageName);
                            if (!(ps == null || res.removedInfo.removedChildPackages == null)) {
                                boolean z;
                                PackageRemovedInfo removedChildRes = (PackageRemovedInfo) res.removedInfo.removedChildPackages.get(deletedChildPkg.packageName);
                                removePackageDataLIF(ps, allUsers, removedChildRes, 0, false);
                                if (this.mPackages.get(ps.name) == null) {
                                    z = true;
                                } else {
                                    z = false;
                                }
                                removedChildRes.removedForAllUsers = z;
                            }
                        }
                    }
                    updateSettingsLI(newPackage, installerPackageName, allUsers, res, user, installReason);
                    prepareAppDataAfterInstallLIF(newPackage);
                    this.mDexManager.notifyPackageUpdated(newPackage.packageName, newPackage.baseCodePath, newPackage.splitCodePaths);
                }
            } catch (PackageManagerException e2) {
                e = e2;
                res.setReturnCode(-110);
                res.setError("Package couldn't be installed in " + pkg.codePath, e);
                if (res.returnCode != 1) {
                    if (newPackage != null) {
                        removeInstalledPackageLI(newPackage, true);
                    }
                    try {
                        scanPackageTracedLI(deletedPackage, policyFlags, 8, 0, user);
                    } catch (PackageManagerException e3) {
                        Slog.e(TAG, "Failed to restore original package: " + e3.getMessage());
                    }
                    synchronized (this.mPackages) {
                        if (disabledSystem) {
                            enableSystemPackageLPw(deletedPackage);
                        }
                        setInstallerPackageNameLPw(deletedPackage, installerPackageName);
                        updatePermissionsLPw(deletedPackage, 1);
                        this.mSettings.writeLPr();
                    }
                    Slog.i(TAG, "Successfully restored package : " + deletedPackage.packageName + " after failed upgrade");
                }
            }
        } catch (PackageManagerException e4) {
            e3 = e4;
            newPackage = null;
        }
        if (res.returnCode != 1) {
            if (newPackage != null) {
                removeInstalledPackageLI(newPackage, true);
            }
            try {
                scanPackageTracedLI(deletedPackage, policyFlags, 8, 0, user);
            } catch (PackageManagerException e32) {
                Slog.e(TAG, "Failed to restore original package: " + e32.getMessage());
            }
            synchronized (this.mPackages) {
                if (disabledSystem) {
                    enableSystemPackageLPw(deletedPackage);
                }
                setInstallerPackageNameLPw(deletedPackage, installerPackageName);
                updatePermissionsLPw(deletedPackage, 1);
                this.mSettings.writeLPr();
            }
            Slog.i(TAG, "Successfully restored package : " + deletedPackage.packageName + " after failed upgrade");
        }
    }

    private String getParentOrChildPackageChangedSharedUser(Package oldPkg, Package newPkg) {
        if (!Objects.equals(oldPkg.mSharedUserId, newPkg.mSharedUserId)) {
            return newPkg.packageName;
        }
        int oldChildCount = oldPkg.childPackages != null ? oldPkg.childPackages.size() : 0;
        int newChildCount = newPkg.childPackages != null ? newPkg.childPackages.size() : 0;
        for (int i = 0; i < newChildCount; i++) {
            Package newChildPkg = (Package) newPkg.childPackages.get(i);
            for (int j = 0; j < oldChildCount; j++) {
                Package oldChildPkg = (Package) oldPkg.childPackages.get(j);
                if (newChildPkg.packageName.equals(oldChildPkg.packageName) && (Objects.equals(newChildPkg.mSharedUserId, oldChildPkg.mSharedUserId) ^ 1) != 0) {
                    return newChildPkg.packageName;
                }
            }
        }
        return null;
    }

    private void removeNativeBinariesLI(PackageSetting ps) {
        if (ps != null) {
            NativeLibraryHelper.removeNativeBinariesLI(ps.legacyNativeLibraryPathString);
            int childCount = ps.childPackageNames != null ? ps.childPackageNames.size() : 0;
            for (int i = 0; i < childCount; i++) {
                PackageSetting childPs;
                synchronized (this.mPackages) {
                    childPs = this.mSettings.getPackageLPr((String) ps.childPackageNames.get(i));
                }
                if (childPs != null) {
                    NativeLibraryHelper.removeNativeBinariesLI(childPs.legacyNativeLibraryPathString);
                }
            }
        }
    }

    private void enableSystemPackageLPw(Package pkg) {
        this.mSettings.enableSystemPackageLPw(pkg.packageName);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            this.mSettings.enableSystemPackageLPw(((Package) pkg.childPackages.get(i)).packageName);
        }
    }

    private boolean disableSystemPackageLPw(Package oldPkg, Package newPkg) {
        boolean disabled = this.mSettings.disableSystemPackageLPw(oldPkg.packageName, true);
        for (int i = 0; i < (oldPkg.childPackages != null ? oldPkg.childPackages.size() : 0); i++) {
            Package childPkg = (Package) oldPkg.childPackages.get(i);
            disabled |= this.mSettings.disableSystemPackageLPw(childPkg.packageName, newPkg.hasChildPackage(childPkg.packageName));
        }
        return disabled;
    }

    private void setInstallerPackageNameLPw(Package pkg, String installerPackageName) {
        this.mSettings.setInstallerPackageName(pkg.packageName, installerPackageName);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            this.mSettings.setInstallerPackageName(((Package) pkg.childPackages.get(i)).packageName, installerPackageName);
        }
    }

    private int[] revokeUnusedSharedUserPermissionsLPw(SharedUserSetting su, int[] allUserIds) {
        int i;
        PermissionState permissionState;
        BasePermission bp;
        ArraySet<String> usedPermissions = new ArraySet();
        int packageCount = su.packages.size();
        for (i = 0; i < packageCount; i++) {
            PackageSetting ps = (PackageSetting) su.packages.valueAt(i);
            if (ps.pkg != null) {
                int requestedPermCount = ps.pkg.requestedPermissions.size();
                for (int j = 0; j < requestedPermCount; j++) {
                    String permission = (String) ps.pkg.requestedPermissions.get(j);
                    if (((BasePermission) this.mSettings.mPermissions.get(permission)) != null) {
                        usedPermissions.add(permission);
                    }
                }
            }
        }
        PermissionsState permissionsState = su.getPermissionsState();
        List<PermissionState> installPermStates = permissionsState.getInstallPermissionStates();
        for (i = installPermStates.size() - 1; i >= 0; i--) {
            permissionState = (PermissionState) installPermStates.get(i);
            if (!usedPermissions.contains(permissionState.getName())) {
                bp = (BasePermission) this.mSettings.mPermissions.get(permissionState.getName());
                if (bp != null) {
                    permissionsState.revokeInstallPermission(bp);
                    permissionsState.updatePermissionFlags(bp, -1, 255, 0);
                }
            }
        }
        int[] runtimePermissionChangedUserIds = EmptyArray.INT;
        for (int userId : allUserIds) {
            List<PermissionState> runtimePermStates = permissionsState.getRuntimePermissionStates(userId);
            for (i = runtimePermStates.size() - 1; i >= 0; i--) {
                permissionState = (PermissionState) runtimePermStates.get(i);
                if (!usedPermissions.contains(permissionState.getName())) {
                    bp = (BasePermission) this.mSettings.mPermissions.get(permissionState.getName());
                    if (bp != null) {
                        permissionsState.revokeRuntimePermission(bp, userId);
                        permissionsState.updatePermissionFlags(bp, userId, 255, 0);
                        runtimePermissionChangedUserIds = ArrayUtils.appendInt(runtimePermissionChangedUserIds, userId);
                    }
                }
            }
        }
        return runtimePermissionChangedUserIds;
    }

    private void updateSettingsLI(Package newPackage, String installerPackageName, int[] allUsers, PackageInstalledInfo res, UserHandle user, int installReason) {
        updateSettingsInternalLI(newPackage, installerPackageName, allUsers, res.origUsers, res, user, installReason);
        int childCount = newPackage.childPackages != null ? newPackage.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            Package childPackage = (Package) newPackage.childPackages.get(i);
            PackageInstalledInfo childRes = (PackageInstalledInfo) res.addedChildPackages.get(childPackage.packageName);
            updateSettingsInternalLI(childPackage, installerPackageName, allUsers, childRes.origUsers, childRes, user, installReason);
        }
    }

    private void updateSettingsInternalLI(Package newPackage, String installerPackageName, int[] allUsers, int[] installedForUsers, PackageInstalledInfo res, UserHandle user, int installReason) {
        Trace.traceBegin(262144, "updateSettings");
        String pkgName = newPackage.packageName;
        synchronized (this.mPackages) {
            this.mSettings.setInstallStatus(pkgName, 0);
            Trace.traceBegin(262144, "writeSettings");
            this.mSettings.writeLPr();
            Trace.traceEnd(262144);
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "New package installed in " + newPackage.codePath);
        }
        synchronized (this.mPackages) {
            updatePermissionsLPw(newPackage.packageName, newPackage, (newPackage.permissions.size() > 0 ? 1 : 0) | 2);
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(pkgName);
            int userId = user.getIdentifier();
            if (ps != null) {
                if (isSystemApp(newPackage)) {
                    if (DEBUG_INSTALL) {
                        Slog.d(TAG, "Implicitly enabling system package on upgrade: " + pkgName);
                    }
                    if (res.origUsers != null) {
                        for (int origUserId : res.origUsers) {
                            if (userId == -1 || userId == origUserId) {
                                ps.setEnabled(0, origUserId, installerPackageName);
                            }
                        }
                    }
                    if (!(allUsers == null || installedForUsers == null)) {
                        for (int currentUserId : allUsers) {
                            boolean installed = ArrayUtils.contains(installedForUsers, currentUserId);
                            if (DEBUG_INSTALL) {
                                Slog.d(TAG, "    user " + currentUserId + " => " + installed);
                            }
                            ps.setInstalled(installed, currentUserId);
                        }
                    }
                }
                if (userId != -1) {
                    ps.setInstalled(true, userId);
                    ps.setEnabled(0, userId, installerPackageName);
                }
                Set<Integer> previousUserIds = new ArraySet();
                if (!(res.removedInfo == null || res.removedInfo.installReasons == null)) {
                    int installReasonCount = res.removedInfo.installReasons.size();
                    for (int i = 0; i < installReasonCount; i++) {
                        int previousUserId = res.removedInfo.installReasons.keyAt(i);
                        ps.setInstallReason(((Integer) res.removedInfo.installReasons.valueAt(i)).intValue(), previousUserId);
                        previousUserIds.add(Integer.valueOf(previousUserId));
                    }
                }
                if (userId == -1) {
                    for (int currentUserId2 : sUserManager.getUserIds()) {
                        if (!previousUserIds.contains(Integer.valueOf(currentUserId2))) {
                            ps.setInstallReason(installReason, currentUserId2);
                        }
                    }
                } else if (!previousUserIds.contains(Integer.valueOf(userId))) {
                    ps.setInstallReason(installReason, userId);
                }
                this.mSettings.writeKernelMappingLPr(ps);
            }
            res.name = pkgName;
            res.uid = newPackage.applicationInfo.uid;
            res.pkg = newPackage;
            this.mSettings.setInstallStatus(pkgName, 1);
            this.mSettings.setInstallerPackageName(pkgName, installerPackageName);
            res.setReturnCode(1);
            Trace.traceBegin(262144, "writeSettings");
            this.mSettings.writeLPr();
            Trace.traceEnd(262144);
        }
        Trace.traceEnd(262144);
    }

    private void installPackageTracedLI(InstallArgs args, PackageInstalledInfo res) {
        try {
            Trace.traceBegin(262144, "installPackage");
            installPackageLI(args, res);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {
        int parseFlags;
        Package pkg;
        int childCount;
        int i;
        Package childPkg;
        PackageInstalledInfo childRes;
        PackageSetting childPs;
        String pkgName;
        String oldCodePath;
        PackageSetting ps;
        Throwable th;
        int installFlags = adjustBackgroundInstallerParameter(args.installerPackageName, args.installFlags);
        String installerPackageName = args.installerPackageName;
        String volumeUuid = args.volumeUuid;
        File file = new File(args.getCodePath());
        boolean forwardLocked = (installFlags & 1) != 0;
        boolean onExternal = (installFlags & 8) == 0 ? args.volumeUuid != null : true;
        boolean instantApp = (installFlags & 2048) != 0;
        boolean fullApp = (installFlags & 16384) != 0;
        boolean forceSdk = (installFlags & 8192) != 0;
        boolean virtualPreload = (65536 & installFlags) != 0;
        boolean replace = false;
        int scanFlags = 24;
        if (args.move != null) {
            scanFlags = 4120;
        }
        if ((installFlags & 4096) != 0) {
            scanFlags |= 16384;
        }
        if (instantApp) {
            scanFlags |= 131072;
        }
        if (fullApp) {
            scanFlags |= 262144;
        }
        if (virtualPreload) {
            scanFlags |= 524288;
        }
        res.setReturnCode(1);
        res.installerPackageName = installerPackageName;
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "installPackageLI: path=" + file);
        }
        if (instantApp && (forwardLocked || onExternal)) {
            Slog.i(TAG, "Incompatible ephemeral install; fwdLocked=" + forwardLocked + " external=" + onExternal);
            res.setReturnCode(-116);
            return;
        }
        int i2;
        int i3 = ((((this.mDefParseFlags | 2) | 1024) | (forwardLocked ? 16 : 0)) | (onExternal ? 32 : 0)) | (instantApp ? 2048 : 0);
        if (forceSdk) {
            i2 = 4096;
        } else {
            i2 = 0;
        }
        parseFlags = i3 | i2;
        PackageParser pp = new PackageParser();
        pp.setSeparateProcesses(this.mSeparateProcesses);
        pp.setDisplayMetrics(this.mMetrics);
        pp.setCallback(this.mPackageParserCallback);
        Trace.traceBegin(262144, "parsePackage");
        try {
            pkg = pp.parsePackage(file, parseFlags);
            if (hasSystemFeature("oppo.customize.function.checkpermission", 0)) {
                pp.verifyEMMApkIfNeed(this.mContext, pkg);
            }
            Trace.traceEnd(262144);
            if (instantApp && pkg.applicationInfo.targetSdkVersion <= 25) {
                Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target O");
                res.setError(-27, "Instant app package must target O");
                return;
            } else if (!instantApp || pkg.applicationInfo.targetSandboxVersion == 2) {
                if (pkg.applicationInfo.isStaticSharedLibrary()) {
                    renameStaticSharedLibraryPackage(pkg);
                    if (onExternal) {
                        Slog.i(TAG, "Static shared libs can only be installed on internal storage.");
                        res.setError(-19, "Packages declaring static-shared libs cannot be updated");
                        return;
                    }
                }
                mCompatibilityHelper.customizePackageIfNeeded(pkg);
                if (pkg.childPackages != null) {
                    synchronized (this.mPackages) {
                        childCount = pkg.childPackages.size();
                        for (i = 0; i < childCount; i++) {
                            childPkg = (Package) pkg.childPackages.get(i);
                            childRes = new PackageInstalledInfo();
                            childRes.setReturnCode(1);
                            childRes.pkg = childPkg;
                            childRes.name = childPkg.packageName;
                            childPs = this.mSettings.getPackageLPr(childPkg.packageName);
                            if (childPs != null) {
                                childRes.origUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                            }
                            if (this.mPackages.containsKey(childPkg.packageName)) {
                                childRes.removedInfo = new PackageRemovedInfo(this);
                                childRes.removedInfo.removedPackage = childPkg.packageName;
                                childRes.removedInfo.installerPackageName = childPs.installerPackageName;
                            }
                            if (res.addedChildPackages == null) {
                                res.addedChildPackages = new ArrayMap();
                            }
                            res.addedChildPackages.put(childPkg.packageName, childRes);
                        }
                    }
                }
                if (TextUtils.isEmpty(pkg.cpuAbiOverride)) {
                    pkg.cpuAbiOverride = args.abiOverride;
                }
                pkgName = pkg.packageName;
                res.name = pkgName;
                if ("true".equals(SystemProperties.get("persist.version.confidential"))) {
                    if (!getImeiNumber(this.mContext)) {
                        Slog.d(TAG, "install fail because not write IMEI ");
                        if ("1".equals(SystemProperties.get("SPECIAL_OPPO_CONFIG"))) {
                            Slog.d(TAG, "SPECIAL_OPPO_CONFIG version");
                        } else {
                            Toast.makeText(this.mContext, "Please write IMEI number!!!", 0).show();
                        }
                        res.returnCode = -15;
                        return;
                    } else if (inCptWhiteList(CompatibilityHelper.RUN_SCORE_BLACK_LIST, pkgName) || pkgName.toLowerCase().contains("bench")) {
                        Slog.d(TAG, "it is run score packages=" + pkgName);
                        res.setError(-15, "installPackageLI");
                        return;
                    }
                }
                if (hasSystemFeature("oppo.customize.function.control_app_install", 0) && SystemProperties.getBoolean("persist.sys.enable_black_list", false)) {
                    if (this.mSettings.getInstalledAppBlackList().contains(pkgName)) {
                        Slog.d(TAG, "app is in blacklist, " + pkgName);
                        res.setError(-15, "installPackageLI");
                        return;
                    }
                    Slog.d(TAG, "app is not in blacklist, " + pkgName);
                }
                if (hasSystemFeature("oppo.customize.function.control_app_install", 0) && SystemProperties.getBoolean("persist.sys.enable_white_list", false)) {
                    if (this.mSettings.getInstalledAppWhiteList().contains(pkgName) || checkWhiteList(pkgName)) {
                        Slog.d(TAG, "app is in whitelist, " + pkgName);
                    } else {
                        Slog.d(TAG, "app is not in whitelist, " + pkgName);
                        res.setError(-15, "installPackageLI");
                        return;
                    }
                }
                if ((pkg.applicationInfo.flags & 256) == 0 || (installFlags & 4) != 0) {
                    OppoFontUtils.deleteFontLink(pkgName);
                    try {
                        if (args.certificates != null) {
                            try {
                                PackageParser.populateCertificates(pkg, args.certificates);
                            } catch (PackageParserException e) {
                                PackageParser.collectCertificates(pkg, parseFlags);
                            }
                        } else {
                            PackageParser.collectCertificates(pkg, parseFlags);
                        }
                        oldCodePath = null;
                        boolean systemApp = false;
                        synchronized (this.mPackages) {
                            if ((installFlags & 2) != 0) {
                                String oldName = this.mSettings.getRenamedPackageLPr(pkgName);
                                if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName) && this.mPackages.containsKey(oldName)) {
                                    pkg.setPackageName(oldName);
                                    pkgName = pkg.packageName;
                                    replace = true;
                                    if (DEBUG_INSTALL) {
                                        Slog.d(TAG, "Replacing existing renamed package: oldName=" + oldName + " pkgName=" + pkgName);
                                    }
                                } else if (this.mPackages.containsKey(pkgName)) {
                                    replace = true;
                                    if (DEBUG_INSTALL) {
                                        Slog.d(TAG, "Replace existing pacakge: " + pkgName);
                                    }
                                }
                                if (pkg.parentPackage != null) {
                                    res.setError(-106, "Package " + pkg.packageName + " is child of package " + pkg.parentPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                                    return;
                                } else if (replace) {
                                    Package oldPackage = (Package) this.mPackages.get(pkgName);
                                    int oldTargetSdk = oldPackage.applicationInfo.targetSdkVersion;
                                    int newTargetSdk = pkg.applicationInfo.targetSdkVersion;
                                    if (oldTargetSdk <= 22 || newTargetSdk > 22) {
                                        int oldTargetSandbox = oldPackage.applicationInfo.targetSandboxVersion;
                                        int newTargetSandbox = pkg.applicationInfo.targetSandboxVersion;
                                        if (oldTargetSandbox == 2 && newTargetSandbox != 2) {
                                            res.setError(-27, "Package " + pkg.packageName + " new target sandbox " + newTargetSandbox + " is incompatible with the previous value of" + oldTargetSandbox + ".");
                                            return;
                                        } else if (oldPackage.parentPackage != null) {
                                            res.setError(-106, "Package " + pkg.packageName + " is child of package " + oldPackage.parentPackage + ". Child packages " + "can be updated only through the parent package.");
                                            return;
                                        }
                                    }
                                    res.setError(-26, "Package " + pkg.packageName + " new target SDK " + newTargetSdk + " doesn't support runtime permissions but the old" + " target SDK " + oldTargetSdk + " does.");
                                    return;
                                }
                            }
                            ps = (PackageSetting) this.mSettings.mPackages.get(pkgName);
                            if (ps != null) {
                                if (DEBUG_INSTALL) {
                                    Slog.d(TAG, "Existing package: " + ps);
                                }
                                PackageSetting signatureCheckPs = ps;
                                if (pkg.applicationInfo.isStaticSharedLibrary()) {
                                    SharedLibraryEntry libraryEntry = getLatestSharedLibraVersionLPr(pkg);
                                    if (libraryEntry != null) {
                                        signatureCheckPs = this.mSettings.getPackageLPr(libraryEntry.apk);
                                    }
                                }
                                if (!shouldCheckUpgradeKeySetLP(signatureCheckPs, scanFlags)) {
                                    try {
                                        verifySignaturesLP(signatureCheckPs, pkg);
                                    } catch (PackageManagerException e2) {
                                        res.setError(e2.error, e2.getMessage());
                                        return;
                                    }
                                } else if (!checkUpgradeKeySetLP(signatureCheckPs, pkg)) {
                                    res.setError(-7, "Package " + pkg.packageName + " upgrade keys do not match the " + "previously installed version");
                                    return;
                                }
                                oldCodePath = ((PackageSetting) this.mSettings.mPackages.get(pkgName)).codePathString;
                                if (!(ps.pkg == null || ps.pkg.applicationInfo == null)) {
                                    systemApp = (ps.pkg.applicationInfo.flags & 1) != 0;
                                }
                                res.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                            }
                            for (i = pkg.permissions.size() - 1; i >= 0; i--) {
                                Permission perm = (Permission) pkg.permissions.get(i);
                                BasePermission bp = (BasePermission) this.mSettings.mPermissions.get(perm.info.name);
                                if (!((perm.info.protectionLevel & 4096) == 0 || (systemApp ^ 1) == 0)) {
                                    Slog.w(TAG, "Non-System package " + pkg.packageName + " attempting to delcare ephemeral permission " + perm.info.name + "; Removing ephemeral.");
                                    PermissionInfo permissionInfo = perm.info;
                                    permissionInfo.protectionLevel &= -4097;
                                }
                                if (bp != null) {
                                    boolean sigsOk = (bp.sourcePackage.equals(pkg.packageName) && (bp.packageSetting instanceof PackageSetting) && shouldCheckUpgradeKeySetLP((PackageSetting) bp.packageSetting, scanFlags)) ? checkUpgradeKeySetLP((PackageSetting) bp.packageSetting, pkg) : compareSignatures(bp.packageSetting.signatures.mSignatures, pkg.mSignatures) == 0;
                                    if (!sigsOk) {
                                        sigsOk = true;
                                        Slog.w(TAG, "INSTALL_FAILED_DUPLICATE_PERMISSION : Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + bp.sourcePackage);
                                    }
                                    if (sigsOk) {
                                        if (!(PLATFORM_PACKAGE_NAME.equals(pkg.packageName) || (perm.info.protectionLevel & 15) != 1 || bp == null || (bp.isRuntime() ^ 1) == 0)) {
                                            Slog.w(TAG, "Package " + pkg.packageName + " trying to change a " + "non-runtime permission " + perm.info.name + " to runtime; keeping old protection level");
                                            perm.info.protectionLevel = bp.protectionLevel;
                                        }
                                    } else if (bp.sourcePackage.equals(PLATFORM_PACKAGE_NAME)) {
                                        Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare system permission " + perm.info.name + "; ignoring new declaration");
                                        pkg.permissions.remove(i);
                                    } else {
                                        res.setError(-112, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + bp.sourcePackage);
                                        res.origPermission = perm.info.name;
                                        res.origPackage = bp.sourcePackage;
                                        return;
                                    }
                                }
                            }
                        }
                    } catch (PackageParserException e3) {
                        res.setError("Failed collect during installPackageLI", e3);
                        return;
                    }
                }
                res.setError(-15, "installPackageLI");
                return;
            } else {
                Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target targetSandboxVersion 2");
                res.setError(-27, "Instant app package must use targetSanboxVersion 2");
                return;
            }
        } catch (PackageParserException e32) {
            res.setError("Failed parse during installPackageLI", e32);
            return;
        } catch (Throwable th2) {
            Trace.traceEnd(262144);
        }
        Throwable th3;
        PackageFreezer packageFreezer;
        if ((Integer.MIN_VALUE & installFlags) != 0) {
            Slog.w(TAG, "pms install app from background, set 4 thread");
            SystemProperties.set("oppo.dex.thread.number", "4");
        }
        if ((536870912 & installFlags) != 0) {
            Slog.w(TAG, "pms install app midle as midle speed");
            SystemProperties.set("oppo.dex.thread.number", "2");
        }
        if ((1073741824 & installFlags) != 0) {
            Slog.w(TAG, "pms install app  as slow speed");
            SystemProperties.set("oppo.dex.thread.number", "1");
        }
        if (args.doRename(res.returnCode, pkg, oldCodePath)) {
            boolean performDexopt = (forwardLocked || (pkg.applicationInfo.isExternalAsec() ^ 1) == 0) ? false : (instantApp && Global.getInt(this.mContext.getContentResolver(), "instant_app_dexopt_enabled", 0) == 0) ? false : true;
            if (performDexopt) {
                Trace.traceBegin(262144, "dexopt");
                this.mPackageDexOptimizer.performDexOpt(pkg, pkg.usesLibraryFiles, null, getOrCreateCompilerPackageStats(pkg), this.mDexManager.getPackageUseInfoOrDefault(pkg.packageName), new DexoptOptions(pkg.packageName, 2, 4));
                Trace.traceEnd(262144);
            }
            BackgroundDexOptService.notifyPackageChanged(pkg.packageName);
            startIntentFilterVerifications(args.user.getIdentifier(), replace, pkg);
            th3 = null;
            packageFreezer = null;
            try {
                packageFreezer = freezePackageForInstall(pkgName, installFlags, "installPackageLI");
                if (replace) {
                    if (pkg.applicationInfo.isStaticSharedLibrary()) {
                        Package existingPkg = (Package) this.mPackages.get(pkg.packageName);
                        if (!(existingPkg == null || existingPkg.mVersionCode == pkg.mVersionCode)) {
                            res.setError(-5, "Packages declaring static-shared libs cannot be updated");
                            if (packageFreezer != null) {
                                try {
                                    packageFreezer.close();
                                } catch (Throwable th4) {
                                    th3 = th4;
                                }
                            }
                            if (th3 != null) {
                                throw th3;
                            }
                            return;
                        }
                    }
                    replacePackageLIF(pkg, parseFlags, scanFlags | 512, args.user, installerPackageName, res, args.installReason);
                } else {
                    installNewPackageLIF(pkg, parseFlags, scanFlags | 256, args.user, installerPackageName, volumeUuid, res, args.installReason);
                }
                if (packageFreezer != null) {
                    try {
                        packageFreezer.close();
                    } catch (Throwable th5) {
                        th3 = th5;
                    }
                }
                if (th3 == null) {
                    throw th3;
                }
                synchronized (this.mPackages) {
                    ps = (PackageSetting) this.mSettings.mPackages.get(pkgName);
                    if (ps != null) {
                        res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                        ps.setUpdateAvailable(false);
                    }
                    childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
                    for (i = 0; i < childCount; i++) {
                        childPkg = (Package) pkg.childPackages.get(i);
                        childRes = (PackageInstalledInfo) res.addedChildPackages.get(childPkg.packageName);
                        childPs = this.mSettings.getPackageLPr(childPkg.packageName);
                        if (childPs != null) {
                            childRes.newUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                        }
                    }
                    if (res.returnCode == 1) {
                        updateSequenceNumberLP(ps, res.newUsers);
                        updateInstantAppInstallerLocked(pkgName);
                    }
                }
                return;
            } catch (Throwable th32) {
                Throwable th6 = th32;
                th32 = th;
                th = th6;
            }
        } else {
            res.setError(-4, "Failed rename");
            return;
        }
        if (th32 != null) {
            throw th32;
        }
        return;
        if (th32 == null) {
            synchronized (this.mPackages) {
                ps = (PackageSetting) this.mSettings.mPackages.get(pkgName);
                if (ps != null) {
                    res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                    ps.setUpdateAvailable(false);
                }
                childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
                for (i = 0; i < childCount; i++) {
                    childPkg = (Package) pkg.childPackages.get(i);
                    childRes = (PackageInstalledInfo) res.addedChildPackages.get(childPkg.packageName);
                    childPs = this.mSettings.getPackageLPr(childPkg.packageName);
                    if (childPs != null) {
                        childRes.newUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                    }
                }
                if (res.returnCode == 1) {
                    updateSequenceNumberLP(ps, res.newUsers);
                    updateInstantAppInstallerLocked(pkgName);
                }
            }
            return;
        }
        throw th32;
        if (packageFreezer != null) {
            try {
                packageFreezer.close();
            } catch (Throwable th7) {
                if (th32 == null) {
                    th32 = th7;
                } else if (th32 != th7) {
                    th32.addSuppressed(th7);
                }
            }
        }
        if (th32 != null) {
            throw th32;
        }
        throw th;
    }

    private void startIntentFilterVerifications(int userId, boolean replacing, Package pkg) {
        if (this.mIntentFilterVerifierComponent == null) {
            Slog.w(TAG, "No IntentFilter verification will not be done as there is no IntentFilterVerifier available!");
            return;
        }
        int i;
        String packageName = this.mIntentFilterVerifierComponent.getPackageName();
        if (userId == -1) {
            i = 0;
        } else {
            i = userId;
        }
        int verifierUid = getPackageUid(packageName, 268435456, i);
        Message msg = this.mHandler.obtainMessage(17);
        msg.obj = new IFVerificationParams(pkg, replacing, userId, verifierUid);
        this.mHandler.sendMessage(msg);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i2 = 0; i2 < childCount; i2++) {
            Package childPkg = (Package) pkg.childPackages.get(i2);
            msg = this.mHandler.obtainMessage(17);
            msg.obj = new IFVerificationParams(childPkg, replacing, userId, verifierUid);
            this.mHandler.sendMessage(msg);
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private void verifyIntentFiltersIfNeeded(int userId, int verifierUid, boolean replacing, Package pkg) {
        if (pkg.activities.size() != 0 && hasDomainURLs(pkg)) {
            int count = 0;
            String packageName = pkg.packageName;
            synchronized (this.mPackages) {
                if (!replacing) {
                    if (this.mSettings.getIntentFilterVerificationLPr(packageName) != null) {
                        return;
                    }
                }
                boolean needToVerify = false;
                for (Activity a : pkg.activities) {
                    for (ActivityIntentInfo filter : a.intents) {
                        if (filter.needsVerification() && needsNetworkVerificationLPr(filter)) {
                            needToVerify = true;
                            break;
                        }
                    }
                }
                if (needToVerify) {
                    int verificationId = this.mIntentFilterVerificationToken;
                    this.mIntentFilterVerificationToken = verificationId + 1;
                    for (Activity a2 : pkg.activities) {
                        for (ActivityIntentInfo filter2 : a2.intents) {
                            if (filter2.handlesWebUris(true) && needsNetworkVerificationLPr(filter2)) {
                                this.mIntentFilterVerifier.addOneIntentFilterVerification(verifierUid, userId, verificationId, filter2, packageName);
                                count++;
                            }
                        }
                    }
                }
            }
        }
    }

    private boolean needsNetworkVerificationLPr(ActivityIntentInfo filter) {
        IntentFilterVerificationInfo ivi = this.mSettings.getIntentFilterVerificationLPr(filter.activity.getComponentName().getPackageName());
        if (ivi == null) {
            return true;
        }
        switch (ivi.getStatus()) {
            case 0:
            case 1:
                return true;
            default:
                return false;
        }
    }

    private static boolean isMultiArch(ApplicationInfo info) {
        return (info.flags & Integer.MIN_VALUE) != 0;
    }

    private static boolean isExternal(Package pkg) {
        return (pkg.applicationInfo.flags & 262144) != 0;
    }

    private static boolean isExternal(PackageSetting ps) {
        return (ps.pkgFlags & 262144) != 0;
    }

    private static boolean isSystemApp(Package pkg) {
        return (pkg.applicationInfo.flags & 1) != 0;
    }

    private static boolean isPrivilegedApp(Package pkg) {
        return (pkg.applicationInfo.privateFlags & 8) != 0;
    }

    private static boolean hasDomainURLs(Package pkg) {
        return (pkg.applicationInfo.privateFlags & 16) != 0;
    }

    private static boolean isSystemApp(PackageSetting ps) {
        return (ps.pkgFlags & 1) != 0;
    }

    private static boolean isUpdatedSystemApp(PackageSetting ps) {
        return (ps.pkgFlags & 128) != 0;
    }

    private int packageFlagsToInstallFlags(PackageSetting ps) {
        int installFlags = 0;
        if (isExternal(ps) && TextUtils.isEmpty(ps.volumeUuid)) {
            installFlags = 8;
        }
        if (ps.isForwardLocked()) {
            return installFlags | 1;
        }
        return installFlags;
    }

    private String getVolumeUuidForPackage(Package pkg) {
        if (!isExternal(pkg)) {
            return StorageManager.UUID_PRIVATE_INTERNAL;
        }
        if (TextUtils.isEmpty(pkg.volumeUuid)) {
            return "primary_physical";
        }
        return pkg.volumeUuid;
    }

    private VersionInfo getSettingsVersionForPackage(Package pkg) {
        if (!isExternal(pkg)) {
            return this.mSettings.getInternalVersion();
        }
        if (TextUtils.isEmpty(pkg.volumeUuid)) {
            return this.mSettings.getExternalVersion();
        }
        return this.mSettings.findOrCreateVersion(pkg.volumeUuid);
    }

    private void deleteTempPackageFiles() {
        for (File file : this.mDrmAppPrivateInstallDir.listFiles(new FilenameFilter() {
            public boolean accept(File dir, String name) {
                return name.startsWith("vmdl") ? name.endsWith(".tmp") : false;
            }
        })) {
            file.delete();
        }
    }

    public void deletePackageAsUser(String packageName, int versionCode, IPackageDeleteObserver observer, int userId, int flags) {
        deletePackageVersioned(new VersionedPackage(packageName, versionCode), new LegacyPackageDeleteObserver(observer).getBinder(), userId, flags);
    }

    public void deletePackageVersioned(VersionedPackage versionedPackage, IPackageDeleteObserver2 observer, int userId, int deleteFlags) {
        final String internalPackageName;
        final int callingUid = Binder.getCallingUid();
        String[] pkgNames = getPackagesForUid(callingUid);
        if (hasSystemFeature("oppo.customize.function.silentinstall", 0) && pkgNames != null && pkgNames.length == 1 && checkWhiteList(pkgNames[0])) {
            Slog.d(TAG, "PMS, no check permission for customize");
        } else {
            this.mContext.enforceCallingOrSelfPermission("android.permission.DELETE_PACKAGES", null);
        }
        final boolean canViewInstantApps = canViewInstantApps(callingUid, userId);
        OppoPackageManagerHelper.setDataCollection();
        OppoPackageManagerHelper.restoreDeleteInfo(getPackageInfo(versionedPackage.getPackageName(), 128, userId));
        Preconditions.checkNotNull(versionedPackage);
        Preconditions.checkNotNull(observer);
        Preconditions.checkArgumentInRange(versionedPackage.getVersionCode(), -1, Integer.MAX_VALUE, "versionCode must be >= -1");
        final String packageName = versionedPackage.getPackageName();
        final int versionCode = versionedPackage.getVersionCode();
        synchronized (this.mPackages) {
            internalPackageName = resolveInternalPackageNameLPr(versionedPackage.getPackageName(), versionedPackage.getVersionCode());
        }
        final int uid = Binder.getCallingUid();
        if (isOrphaned(internalPackageName) || (isCallerAllowedToSilentlyUninstall(uid, internalPackageName) ^ 1) == 0) {
            final boolean deleteAllUsers = (deleteFlags & 2) != 0;
            final int[] users = deleteAllUsers ? sUserManager.getUserIds() : new int[]{userId};
            if (UserHandle.getUserId(uid) != userId || (deleteAllUsers && users.length > 1)) {
                this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "deletePackage for user " + userId);
            }
            if (getDisallowUninstallApps().contains(packageName)) {
                try {
                    observer.onPackageDeleted(packageName, -3, null);
                } catch (RemoteException e) {
                }
                return;
            }
            if (isUserRestricted(userId, "no_uninstall_apps")) {
                try {
                    observer.onPackageDeleted(packageName, -3, null);
                } catch (RemoteException e2) {
                }
                return;
            } else if (prohibitChildInstallation(userId, false)) {
                try {
                    observer.onPackageDeleted(packageName, -3, null);
                } catch (RemoteException e3) {
                }
                return;
            } else {
                String tmpStr;
                String[] packageNames = getPackagesForUid(uid);
                if (packageNames == null || 1 != packageNames.length) {
                    tmpStr = "pkg-" + getNameForUid(uid);
                } else {
                    tmpStr = packageNames[0];
                }
                final String delCallerPkg = tmpStr;
                if (deleteAllUsers || !getBlockUninstallForUser(internalPackageName, userId)) {
                    if (DEBUG_REMOVE) {
                        Slog.d(TAG, "deletePackageAsUser: pkg=" + internalPackageName + " user=" + userId + " deleteAllUsers: " + deleteAllUsers + " version=" + (versionCode == -1 ? "VERSION_CODE_HIGHEST" : Integer.valueOf(versionCode)));
                    }
                    final IPackageDeleteObserver2 iPackageDeleteObserver2 = observer;
                    final int i = userId;
                    final int i2 = deleteFlags;
                    this.mHandler.post(new Runnable() {
                        public void run() {
                            PackageManagerService.this.mHandler.removeCallbacks(this);
                            if (uid == 2000 && ColorPackageManagerHelper.isOppoHideApp(packageName)) {
                                try {
                                    iPackageDeleteObserver2.onPackageDeleted(packageName, -1, null);
                                    if (PackageManagerService.DEBUG_REMOVE) {
                                        Slog.d(PackageManagerService.TAG, "forbidden to remove cloud app:" + packageName);
                                    }
                                    ColorPackageManagerHelper.sendDcsPreventUninstallSystemApp(PackageManagerService.this.mContext, "pc", packageName);
                                } catch (RemoteException e) {
                                }
                                return;
                            }
                            int returnCode;
                            if (uid != 0) {
                                synchronized (PackageManagerService.this.mPackages) {
                                }
                                if (ColorPackageManagerHelper.isForbidUninstallDataApp((Package) PackageManagerService.this.mPackages.get(packageName))) {
                                    Slog.d(PackageManagerService.TAG, "forbid delete " + packageName + " from normal user");
                                    try {
                                        iPackageDeleteObserver2.onPackageDeleted(packageName, -1, null);
                                    } catch (RemoteException e2) {
                                    }
                                    return;
                                }
                            }
                            PackageSetting ps = (PackageSetting) PackageManagerService.this.mSettings.mPackages.get(internalPackageName);
                            boolean doDeletePackage = true;
                            if (ps != null) {
                                if (ps.getInstantApp(UserHandle.getUserId(callingUid))) {
                                    doDeletePackage = canViewInstantApps;
                                } else {
                                    doDeletePackage = true;
                                }
                            }
                            if (!doDeletePackage) {
                                returnCode = -1;
                            } else if (deleteAllUsers) {
                                int[] blockUninstallUserIds = PackageManagerService.this.getBlockUninstallForUsers(internalPackageName, users);
                                if (ArrayUtils.isEmpty(blockUninstallUserIds)) {
                                    returnCode = PackageManagerService.this.deletePackageX(internalPackageName, versionCode, i, i2);
                                } else {
                                    int userFlags = i2 & -3;
                                    for (int userId : users) {
                                        if (!ArrayUtils.contains(blockUninstallUserIds, userId)) {
                                            returnCode = PackageManagerService.this.deletePackageX(internalPackageName, versionCode, userId, userFlags);
                                            if (returnCode != 1) {
                                                Slog.w(PackageManagerService.TAG, "Package delete failed for user " + userId + ", returnCode " + returnCode);
                                            }
                                        }
                                    }
                                    returnCode = -4;
                                }
                            } else {
                                returnCode = PackageManagerService.this.deletePackageX(internalPackageName, versionCode, i, i2);
                            }
                            try {
                                iPackageDeleteObserver2.onPackageDeleted(packageName, returnCode, null);
                            } catch (RemoteException e3) {
                                Log.i(PackageManagerService.TAG, "Observer no longer exists.");
                            }
                            OppoUsageManager.getOppoUsageManager().recordApkDeleteEvent(packageName, delCallerPkg, null);
                        }
                    });
                    if (OppoManager.isInnerVersion.booleanValue() && OppoManager.grList.contains(packageName) && OppoManager.willUseGrLeader.booleanValue()) {
                        OppoManager.uninstallGrs(this.mContext);
                    }
                    if (userId == 0) {
                        ColorPackageManagerHelper.removePkgFromNotLaunchedList(packageName, false);
                    }
                    return;
                }
                try {
                    observer.onPackageDeleted(packageName, -4, null);
                } catch (RemoteException e4) {
                }
                return;
            }
        }
        try {
            Intent intent = new Intent("android.intent.action.UNINSTALL_PACKAGE");
            intent.setData(Uri.fromParts(PACKAGE_SCHEME, packageName, null));
            intent.putExtra("android.content.pm.extra.CALLBACK", observer.asBinder());
            observer.onUserActionRequired(intent);
        } catch (RemoteException e5) {
        }
    }

    private String resolveExternalPackageNameLPr(Package pkg) {
        if (pkg.staticSharedLibName != null) {
            return pkg.manifestPackageName;
        }
        return pkg.packageName;
    }

    private String resolveInternalPackageNameLPr(String packageName, int versionCode) {
        String normalizedPackageName = this.mSettings.getRenamedPackageLPr(packageName);
        if (normalizedPackageName != null) {
            packageName = normalizedPackageName;
        }
        SparseArray<SharedLibraryEntry> versionedLib = (SparseArray) this.mStaticLibsByDeclaringPackage.get(packageName);
        if (versionedLib == null || versionedLib.size() <= 0) {
            return packageName;
        }
        SparseIntArray versionsCallerCanSee = null;
        int callingAppId = UserHandle.getAppId(Binder.getCallingUid());
        if (!(callingAppId == 1000 || callingAppId == 2000 || callingAppId == 0)) {
            versionsCallerCanSee = new SparseIntArray();
            String libName = ((SharedLibraryEntry) versionedLib.valueAt(0)).info.getName();
            String[] uidPackages = getPackagesForUid(Binder.getCallingUid());
            if (uidPackages != null) {
                for (String uidPackage : uidPackages) {
                    PackageSetting ps = this.mSettings.getPackageLPr(uidPackage);
                    int libIdx = ArrayUtils.indexOf(ps.usesStaticLibraries, libName);
                    if (libIdx >= 0) {
                        int libVersion = ps.usesStaticLibrariesVersions[libIdx];
                        versionsCallerCanSee.append(libVersion, libVersion);
                    }
                }
            }
        }
        if (versionsCallerCanSee != null && versionsCallerCanSee.size() <= 0) {
            return packageName;
        }
        SharedLibraryEntry highestVersion = null;
        int versionCount = versionedLib.size();
        for (int i = 0; i < versionCount; i++) {
            SharedLibraryEntry libEntry = (SharedLibraryEntry) versionedLib.valueAt(i);
            if (versionsCallerCanSee == null || versionsCallerCanSee.indexOfKey(libEntry.info.getVersion()) >= 0) {
                int libVersionCode = libEntry.info.getDeclaringPackage().getVersionCode();
                if (versionCode != -1) {
                    if (libVersionCode == versionCode) {
                        return libEntry.apk;
                    }
                } else if (highestVersion == null) {
                    highestVersion = libEntry;
                } else if (libVersionCode > highestVersion.info.getDeclaringPackage().getVersionCode()) {
                    highestVersion = libEntry;
                }
            }
        }
        if (highestVersion != null) {
            return highestVersion.apk;
        }
        return packageName;
    }

    boolean isCallerVerifier(int callingUid) {
        int callingUserId = UserHandle.getUserId(callingUid);
        if (this.mRequiredVerifierPackage == null || callingUid != getPackageUid(this.mRequiredVerifierPackage, 0, callingUserId)) {
            return false;
        }
        return true;
    }

    private boolean isCallerAllowedToSilentlyUninstall(int callingUid, String pkgName) {
        if (callingUid == 2000 || callingUid == 0 || UserHandle.getAppId(callingUid) == 1000) {
            return true;
        }
        String name = getNameForUid(callingUid);
        if (name != null && name.contains(":")) {
            int index = name.indexOf(":");
            if (index != -1 && OppoPackageManagerHelper.isShareUid(name.substring(0, index))) {
                return true;
            }
        }
        if (hasSystemFeature("oppo.customize.function.silentinstall", 0)) {
            String[] callingPkgNames = getPackagesForUid(callingUid);
            if (callingPkgNames != null && callingPkgNames.length == 1 && checkWhiteList(callingPkgNames[0])) {
                return true;
            }
        }
        int callingUserId = UserHandle.getUserId(callingUid);
        if (callingUid == getPackageUid(getInstallerPackageName(pkgName), 0, callingUserId)) {
            return true;
        }
        if (this.mRequiredVerifierPackage != null && callingUid == getPackageUid(this.mRequiredVerifierPackage, 0, callingUserId)) {
            return true;
        }
        if (this.mRequiredUninstallerPackage == null || callingUid != getPackageUid(this.mRequiredUninstallerPackage, 0, callingUserId)) {
            return (this.mStorageManagerPackage != null && callingUid == getPackageUid(this.mStorageManagerPackage, 0, callingUserId)) || checkUidPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS", callingUid) == 0;
        } else {
            return true;
        }
    }

    private int[] getBlockUninstallForUsers(String packageName, int[] userIds) {
        int[] result = EMPTY_INT_ARRAY;
        for (int userId : userIds) {
            if (getBlockUninstallForUser(packageName, userId)) {
                result = ArrayUtils.appendInt(result, userId);
            }
        }
        return result;
    }

    public boolean isPackageDeviceAdminOnAnyUser(String packageName) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null || (isCallerSameApp(packageName, callingUid) ^ 1) == 0) {
            return isPackageDeviceAdmin(packageName, -1);
        }
        return false;
    }

    private boolean isPackageDeviceAdmin(String packageName, int userId) {
        IDevicePolicyManager dpm = IDevicePolicyManager.Stub.asInterface(ServiceManager.getService("device_policy"));
        if (dpm != null) {
            try {
                Object deviceOwnerPackageName;
                ComponentName deviceOwnerComponentName = dpm.getDeviceOwnerComponent(false);
                if (deviceOwnerComponentName == null) {
                    deviceOwnerPackageName = null;
                } else {
                    deviceOwnerPackageName = deviceOwnerComponentName.getPackageName();
                }
                if (packageName.equals(deviceOwnerPackageName)) {
                    return true;
                }
                int[] users = userId == -1 ? sUserManager.getUserIds() : new int[]{userId};
                for (int packageHasActiveAdmins : users) {
                    if (dpm.packageHasActiveAdmins(packageName, packageHasActiveAdmins)) {
                        return true;
                    }
                }
            } catch (RemoteException e) {
            }
        }
        return false;
    }

    private boolean shouldKeepUninstalledPackageLPr(String packageName) {
        return this.mKeepUninstalledPackages != null ? this.mKeepUninstalledPackages.contains(packageName) : false;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    int deletePackageX(String packageName, int versionCode, int userId, int deleteFlags) {
        PackageSetting uninstalledPs;
        Package pkg;
        int i;
        Throwable th;
        PackageRemovedInfo info = new PackageRemovedInfo(this);
        if (OppoMultiAppManagerUtil.getInstance().isMainApp(userId, packageName) && (deleteFlags & 2) == 0) {
            deleteFlags |= 2;
        }
        int removeUser = (deleteFlags & 2) != 0 ? -1 : userId;
        if (isPackageDeviceAdmin(packageName, removeUser)) {
            if (!mRegion.equals("CN") || hasSystemFeature("oppo.business.custom", 0)) {
                Slog.w(TAG, "Not removing package " + packageName + ": has active device admin");
                return -2;
            }
            OppoPackageManagerHelper.removeActiveAdmin(this, packageName, userId);
        }
        synchronized (this.mPackages) {
            uninstalledPs = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (uninstalledPs == null) {
                Slog.w(TAG, "Not removing non-existent package " + packageName);
                return -1;
            }
            if (versionCode != -1) {
                if (uninstalledPs.versionCode != versionCode) {
                    Slog.w(TAG, "Not removing package " + packageName + " with versionCode " + uninstalledPs.versionCode + " != " + versionCode);
                    return -1;
                }
            }
            pkg = (Package) this.mPackages.get(packageName);
            int[] allUsers = sUserManager.getUserIds();
            if (!(pkg == null || pkg.staticSharedLibName == null)) {
                SharedLibraryEntry libEntry = getSharedLibraryEntryLPr(pkg.staticSharedLibName, pkg.staticSharedLibVersion);
                if (libEntry != null) {
                    for (int currUserId : allUsers) {
                        if (removeUser == -1 || removeUser == currUserId) {
                            List<VersionedPackage> libClientPackages = getPackagesUsingSharedLibraryLPr(libEntry.info, 0, currUserId);
                            if (!ArrayUtils.isEmpty(libClientPackages)) {
                                Slog.w(TAG, "Not removing package " + pkg.manifestPackageName + " hosting lib " + libEntry.info.getName() + " version " + libEntry.info.getVersion() + " used by " + libClientPackages + " for user " + currUserId);
                                return -6;
                            }
                        }
                    }
                }
            }
            info.origUsers = uninstalledPs.queryInstalledUsers(allUsers, true);
        }
        if (th != null) {
            throw th;
        } else {
            synchronized (this.mPackages) {
                if (res) {
                    if (pkg != null) {
                        this.mInstantAppRegistry.onPackageUninstalledLPw(pkg, info.removedUsers);
                    }
                    updateSequenceNumberLP(uninstalledPs, info.removedUsers);
                    updateInstantAppInstallerLocked(packageName);
                }
            }
            if (res) {
                if (OppoMultiAppManagerUtil.getInstance().isMainApp(userId, packageName) || OppoMultiAppManagerUtil.getInstance().isMultiApp(userId, packageName)) {
                    OppoMultiAppManagerUtil.getInstance().removeFromCreatedMultiApp(packageName);
                    if (DEBUG_PMS) {
                        Slog.d(TAG, "multi app: deletePacakgeX delete package: " + packageName + " USER: " + userId);
                    }
                }
                info.sendPackageRemovedBroadcasts((deleteFlags & 8) == 0);
                info.sendSystemPackageUpdatedBroadcasts();
                info.sendSystemPackageAppearedBroadcasts();
            }
            Runtime.getRuntime().gc();
            if (info.args != null) {
                synchronized (this.mInstallLock) {
                    info.args.doPostDeleteLI(true);
                }
            }
            if (res) {
                i = 1;
            } else {
                i = -1;
            }
            return i;
        }
        if (r14 != null) {
            try {
                r14.close();
            } catch (Throwable th2) {
                if (th == null) {
                    th = th2;
                } else if (th != th2) {
                    th.addSuppressed(th2);
                }
            }
        }
        if (th != null) {
            throw th;
        }
        throw th;
    }

    private void removePackageDataLIF(PackageSetting ps, int[] allUserHandles, PackageRemovedInfo outInfo, int flags, boolean writeSettings) {
        Package deletedPkg;
        final PackageSetting deletedPs;
        String packageName = ps.name;
        if (DEBUG_REMOVE) {
            Slog.d(TAG, "removePackageDataLI: " + ps);
        }
        synchronized (this.mPackages) {
            deletedPkg = (Package) this.mPackages.get(packageName);
            deletedPs = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (outInfo != null) {
                int[] iArr;
                outInfo.removedPackage = packageName;
                outInfo.installerPackageName = ps.installerPackageName;
                boolean z = deletedPkg != null ? deletedPkg.staticSharedLibName != null : false;
                outInfo.isStaticSharedLib = z;
                if (deletedPs == null) {
                    iArr = null;
                } else {
                    iArr = deletedPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                }
                outInfo.populateUsers(iArr, deletedPs);
            }
        }
        removePackageLI(ps, (Integer.MIN_VALUE & flags) != 0);
        if ((flags & 1) == 0) {
            Package resolvedPkg;
            if (deletedPkg != null) {
                resolvedPkg = deletedPkg;
            } else {
                resolvedPkg = new Package(ps.name);
                resolvedPkg.setVolumeUuid(ps.volumeUuid);
            }
            destroyAppDataLIF(resolvedPkg, -1, 3);
            destroyAppProfilesLIF(resolvedPkg, -1);
            if (outInfo != null) {
                outInfo.dataRemoved = true;
            }
            schedulePackageCleaning(packageName, -1, true);
        }
        int removedAppId = -1;
        synchronized (this.mPackages) {
            boolean installedStateChanged = false;
            if (deletedPs != null) {
                if ((flags & 1) == 0) {
                    clearIntentFilterVerificationsLPw(deletedPs.name, -1);
                    clearDefaultBrowserIfNeeded(packageName);
                    this.mSettings.mKeySetManagerService.removeAppKeySetDataLPw(packageName);
                    removedAppId = this.mSettings.removePackageLPw(packageName);
                    if (outInfo != null) {
                        outInfo.removedAppId = removedAppId;
                    }
                    updatePermissionsLPw(deletedPs.name, null, 0);
                    if (deletedPs.sharedUser != null) {
                        for (int userId : UserManagerService.getInstance().getUserIds()) {
                            int userIdToKill = this.mSettings.updateSharedUserPermsLPw(deletedPs, userId);
                            if (userIdToKill == -1 || userIdToKill >= 0) {
                                this.mHandler.post(new Runnable() {
                                    public void run() {
                                        PackageManagerService.this.killApplication(deletedPs.name, deletedPs.appId, PackageManagerService.KILL_APP_REASON_GIDS_CHANGED);
                                    }
                                });
                                break;
                            }
                        }
                    }
                    clearPackagePreferredActivitiesLPw(deletedPs.name, -1);
                }
                if (!(allUserHandles == null || outInfo == null || outInfo.origUsers == null)) {
                    if (DEBUG_REMOVE) {
                        Slog.d(TAG, "Propagating install state across downgrade");
                    }
                    for (int userId2 : allUserHandles) {
                        boolean installed = ArrayUtils.contains(outInfo.origUsers, userId2);
                        if (DEBUG_REMOVE) {
                            Slog.d(TAG, "    user " + userId2 + " => " + installed);
                        }
                        if (installed != ps.getInstalled(userId2)) {
                            installedStateChanged = true;
                        }
                        ps.setInstalled(installed, userId2);
                    }
                }
            }
            if (writeSettings) {
                this.mSettings.writeLPr();
            }
            if (installedStateChanged) {
                this.mSettings.writeKernelMappingLPr(ps);
            }
        }
        if (removedAppId != -1) {
            removeKeystoreDataIfNeeded(-1, removedAppId);
        }
    }

    static boolean locationIsPrivileged(File path) {
        try {
            return path.getCanonicalPath().startsWith(new File(Environment.getRootDirectory(), "priv-app").getCanonicalPath());
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    private boolean deleteSystemPackageLIF(Package deletedPkg, PackageSetting deletedPs, int[] allUserHandles, int flags, PackageRemovedInfo outInfo, boolean writeSettings) {
        if (deletedPs.parentPackageName != null) {
            Slog.w(TAG, "Attempt to delete child system package " + deletedPkg.packageName);
            return false;
        }
        PackageSetting disabledPs;
        boolean applyUserRestrictions = (allUserHandles == null || outInfo.origUsers == null) ? false : true;
        synchronized (this.mPackages) {
            try {
                disabledPs = this.mSettings.getDisabledSystemPkgLPr(deletedPs.name);
            } catch (Throwable th) {
                throw th;
            }
        }
        if (DEBUG_REMOVE) {
            Slog.d(TAG, "deleteSystemPackageLI: newPs=" + deletedPkg.packageName + " disabledPs=" + disabledPs);
        }
        if (disabledPs == null) {
            Slog.w(TAG, "Attempt to delete unknown system package " + deletedPkg.packageName);
            return false;
        }
        if (DEBUG_REMOVE) {
            Slog.d(TAG, "Deleting system pkg from data partition");
        }
        if (DEBUG_REMOVE && applyUserRestrictions) {
            Slog.d(TAG, "Remembering install states:");
            for (int userId : allUserHandles) {
                Slog.d(TAG, "   u=" + userId + " inst=" + ArrayUtils.contains(outInfo.origUsers, userId));
            }
        }
        outInfo.isRemovedPackageSystemUpdate = true;
        if (outInfo.removedChildPackages != null) {
            int childCount = deletedPs.childPackageNames != null ? deletedPs.childPackageNames.size() : 0;
            for (int i = 0; i < childCount; i++) {
                String childPackageName = (String) deletedPs.childPackageNames.get(i);
                if (disabledPs.childPackageNames != null && disabledPs.childPackageNames.contains(childPackageName)) {
                    PackageRemovedInfo childInfo = (PackageRemovedInfo) outInfo.removedChildPackages.get(childPackageName);
                    if (childInfo != null) {
                        childInfo.isRemovedPackageSystemUpdate = true;
                    }
                }
            }
        }
        if (disabledPs.versionCode < deletedPs.versionCode) {
            flags &= -2;
        } else {
            flags |= 1;
        }
        if (!deleteInstalledPackageLIF(deletedPs, true, flags, allUserHandles, outInfo, writeSettings, disabledPs.pkg)) {
            return false;
        }
        synchronized (this.mPackages) {
            try {
                enableSystemPackageLPw(disabledPs.pkg);
                removeNativeBinariesLI(deletedPs);
            } catch (Throwable th2) {
                throw th2;
            }
        }
        if (DEBUG_REMOVE) {
            Slog.d(TAG, "Re-installing system package: " + disabledPs);
        }
        try {
            installPackageFromSystemLIF(disabledPs.codePath, false, allUserHandles, outInfo.origUsers, deletedPs.getPermissionsState(), writeSettings);
            if (disabledPs.pkg.isStub) {
                this.mSettings.disableSystemPackageLPw(disabledPs.name, true);
            }
            return true;
        } catch (PackageManagerException e) {
            Slog.w(TAG, "Failed to restore system package:" + deletedPkg.packageName + ": " + e.getMessage());
            if (disabledPs.pkg.isStub) {
                this.mSettings.disableSystemPackageLPw(disabledPs.name, true);
            }
            return false;
        } catch (Throwable th22) {
            if (disabledPs.pkg.isStub) {
                this.mSettings.disableSystemPackageLPw(disabledPs.name, true);
            }
            throw th22;
        }
    }

    private Package installPackageFromSystemLIF(File codePath, boolean isPrivileged, int[] allUserHandles, int[] origUserHandles, PermissionsState origPermissionState, boolean writeSettings) throws PackageManagerException {
        int parseFlags = ((this.mDefParseFlags | 4) | 1) | 64;
        if (isPrivileged || locationIsPrivileged(codePath)) {
            parseFlags |= 128;
        }
        Package newPkg = scanPackageTracedLI(codePath, parseFlags, 0, 0, null);
        try {
            updateSharedLibrariesLPr(newPkg, null);
        } catch (PackageManagerException e) {
            Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e.getMessage());
        }
        prepareAppDataAfterInstallLIF(newPkg);
        synchronized (this.mPackages) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(newPkg.packageName);
            if (origPermissionState != null) {
                ps.getPermissionsState().copyFrom(origPermissionState);
            }
            updatePermissionsLPw(newPkg.packageName, newPkg, 3);
            boolean applyUserRestrictions = (allUserHandles == null || origUserHandles == null) ? false : true;
            if (applyUserRestrictions) {
                boolean installedStateChanged = false;
                if (DEBUG_REMOVE) {
                    Slog.d(TAG, "Propagating install state across reinstall");
                }
                for (int userId : allUserHandles) {
                    boolean installed = ArrayUtils.contains(origUserHandles, userId);
                    if (DEBUG_REMOVE) {
                        Slog.d(TAG, "    user " + userId + " => " + installed);
                    }
                    if (installed != ps.getInstalled(userId)) {
                        installedStateChanged = true;
                    }
                    ps.setInstalled(installed, userId);
                    this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
                }
                this.mSettings.writeAllUsersPackageRestrictionsLPr();
                if (installedStateChanged) {
                    this.mSettings.writeKernelMappingLPr(ps);
                }
            }
            if (writeSettings) {
                this.mSettings.writeLPr();
            }
        }
        return newPkg;
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private boolean deleteInstalledPackageLIF(PackageSetting ps, boolean deleteCodeAndResources, int flags, int[] allUserHandles, PackageRemovedInfo outInfo, boolean writeSettings, Package replacingPackage) {
        synchronized (this.mPackages) {
            if (outInfo != null) {
                outInfo.uid = ps.appId;
            }
            if (!(outInfo == null || outInfo.removedChildPackages == null)) {
                int childCount = ps.childPackageNames != null ? ps.childPackageNames.size() : 0;
                for (int i = 0; i < childCount; i++) {
                    String childPackageName = (String) ps.childPackageNames.get(i);
                    PackageSetting childPs = (PackageSetting) this.mSettings.mPackages.get(childPackageName);
                    if (childPs == null) {
                        return false;
                    }
                    PackageRemovedInfo childInfo = (PackageRemovedInfo) outInfo.removedChildPackages.get(childPackageName);
                    if (childInfo != null) {
                        childInfo.uid = childPs.appId;
                    }
                }
            }
        }
    }

    public boolean setBlockUninstallForUser(String packageName, boolean blockUninstall, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.DELETE_PACKAGES", null);
        synchronized (this.mPackages) {
            Package pkg = (Package) this.mPackages.get(packageName);
            if (pkg == null || pkg.staticSharedLibName == null) {
                this.mSettings.setBlockUninstallLPw(userId, packageName, blockUninstall);
                this.mSettings.writePackageRestrictionsLPr(userId);
                return true;
            }
            Slog.w(TAG, "Cannot block uninstall of package: " + packageName + " providing static shared library: " + pkg.staticSharedLibName);
            return false;
        }
    }

    public boolean getBlockUninstallForUser(String packageName, int userId) {
        synchronized (this.mPackages) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (ps == null || filterAppAccessLPr(ps, Binder.getCallingUid(), userId)) {
                return false;
            }
            boolean blockUninstallLPr = this.mSettings.getBlockUninstallLPr(userId, packageName);
            return blockUninstallLPr;
        }
    }

    public boolean setRequiredForSystemUser(String packageName, boolean systemUserApp) {
        enforceSystemOrRoot("setRequiredForSystemUser can only be run by the system or root");
        synchronized (this.mPackages) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                Log.w(TAG, "Package doesn't exist: " + packageName);
                return false;
            }
            if (systemUserApp) {
                ps.pkgPrivateFlags |= 512;
            } else {
                ps.pkgPrivateFlags &= -513;
            }
            this.mSettings.writeLPr();
            return true;
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private boolean deletePackageLIF(String packageName, UserHandle user, boolean deleteCodeAndResources, int[] allUserHandles, int flags, PackageRemovedInfo outInfo, boolean writeSettings, Package replacingPackage) {
        if (packageName == null) {
            Slog.w(TAG, "Attempt to delete null packageName.");
            return false;
        }
        if (DEBUG_REMOVE) {
            Slog.d(TAG, "deletePackageLI: " + packageName + " user " + user);
        }
        synchronized (this.mPackages) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                Slog.w(TAG, "Package named '" + packageName + "' doesn't exist.");
                return false;
            } else if (ps.parentPackageName == null || (isSystemApp(ps) && (flags & 4) == 0)) {
            } else {
                int removedUserId;
                if (DEBUG_REMOVE) {
                    Object valueOf;
                    String str = TAG;
                    StringBuilder append = new StringBuilder().append("Uninstalled child package:").append(packageName).append(" for user:");
                    if (user == null) {
                        valueOf = Integer.valueOf(-1);
                    } else {
                        UserHandle valueOf2 = user;
                    }
                    Slog.d(str, append.append(valueOf2).toString());
                }
                if (user != null) {
                    removedUserId = user.getIdentifier();
                } else {
                    removedUserId = -1;
                }
                if (clearPackageStateForUserLIF(ps, removedUserId, outInfo)) {
                    markPackageUninstalledForUserLPw(ps, user);
                    scheduleWritePackageRestrictionsLocked(user);
                    return true;
                }
                return false;
            }
        }
    }

    private void markPackageUninstalledForUserLPw(PackageSetting ps, UserHandle user) {
        int[] userIds = (user == null || user.getIdentifier() == -1) ? sUserManager.getUserIds() : new int[]{user.getIdentifier()};
        int i = 0;
        int length = userIds.length;
        while (true) {
            int i2 = i;
            if (i2 < length) {
                int nextUserId = userIds[i2];
                if (DEBUG_REMOVE) {
                    Slog.d(TAG, "Marking package:" + ps.name + " uninstalled for user:" + nextUserId);
                }
                ps.setUserState(nextUserId, 0, 0, false, true, true, false, false, false, false, null, null, null, ps.readUserState(nextUserId).domainVerificationStatus, 0, 0);
                i = i2 + 1;
            } else {
                this.mSettings.writeKernelMappingLPr(ps);
                return;
            }
        }
    }

    private boolean clearPackageStateForUserLIF(PackageSetting ps, int userId, PackageRemovedInfo outInfo) {
        Package pkg;
        boolean z = false;
        synchronized (this.mPackages) {
            pkg = (Package) this.mPackages.get(ps.name);
        }
        int[] userIds = userId == -1 ? sUserManager.getUserIds() : new int[]{userId};
        for (int nextUserId : userIds) {
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "Updating package:" + ps.name + " install state for user:" + nextUserId);
            }
            destroyAppDataLIF(pkg, userId, 3);
            destroyAppProfilesLIF(pkg, userId);
            clearDefaultBrowserIfNeededForUser(ps.name, userId);
            removeKeystoreDataIfNeeded(nextUserId, ps.appId);
            schedulePackageCleaning(ps.name, nextUserId, false);
            synchronized (this.mPackages) {
                if (clearPackagePreferredActivitiesLPw(ps.name, nextUserId)) {
                    scheduleWritePackageRestrictionsLocked(nextUserId);
                }
                resetUserChangesToRuntimePermissionsAndFlagsLPw(ps, nextUserId);
            }
        }
        if (outInfo != null) {
            outInfo.removedPackage = ps.name;
            outInfo.installerPackageName = ps.installerPackageName;
            if (!(pkg == null || pkg.staticSharedLibName == null)) {
                z = true;
            }
            outInfo.isStaticSharedLib = z;
            outInfo.removedAppId = ps.appId;
            outInfo.removedUsers = userIds;
            outInfo.broadcastUsers = userIds;
        }
        return true;
    }

    private void clearExternalStorageDataSync(String packageName, int userId, boolean allData) {
        if (!DEFAULT_CONTAINER_PACKAGE.equals(packageName)) {
            boolean mounted;
            if (Environment.isExternalStorageEmulated()) {
                mounted = true;
            } else {
                String status = Environment.getExternalStorageState();
                if (status.equals("mounted")) {
                    mounted = true;
                } else {
                    mounted = status.equals("mounted_ro");
                }
            }
            if (mounted) {
                Intent containerIntent = new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT);
                int[] users = userId == -1 ? sUserManager.getUserIds() : new int[]{userId};
                PackageManagerService packageManagerService = this;
                ClearStorageConnection conn = new ClearStorageConnection();
                if (this.mContext.bindServiceAsUser(containerIntent, conn, 1, UserHandle.SYSTEM)) {
                    try {
                        for (int curUser : users) {
                            long timeout = SystemClock.uptimeMillis() + FaceDaemonWrapper.TIMEOUT_FACED_BINDERCALL_CHECK;
                            synchronized (conn) {
                                int count = 0;
                                while (conn.mContainerService == null) {
                                    long now = SystemClock.uptimeMillis();
                                    if (now < timeout) {
                                        if (count == 20) {
                                            try {
                                                Slog.w(TAG, "clearExternalStorageDataSync wait mContainerService timeout!");
                                                break;
                                            } catch (InterruptedException e) {
                                            }
                                        } else {
                                            count++;
                                            conn.wait(timeout - now);
                                        }
                                    }
                                }
                            }
                            if (conn.mContainerService == null) {
                                this.mContext.unbindService(conn);
                                return;
                            }
                            UserEnvironment userEnv = new UserEnvironment(curUser);
                            clearDirectory(conn.mContainerService, userEnv.buildExternalStorageAppCacheDirs(packageName));
                            if (allData) {
                                clearDirectory(conn.mContainerService, userEnv.buildExternalStorageAppDataDirs(packageName));
                                clearDirectory(conn.mContainerService, userEnv.buildExternalStorageAppMediaDirs(packageName));
                            }
                        }
                        this.mContext.unbindService(conn);
                    } catch (Throwable th) {
                        this.mContext.unbindService(conn);
                    }
                }
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void clearApplicationProfileData(String packageName) {
        Package pkg;
        Throwable th = null;
        enforceSystemOrRoot("Only the system can clear all profile data");
        synchronized (this.mPackages) {
            pkg = (Package) this.mPackages.get(packageName);
        }
        PackageFreezer packageFreezer = null;
        try {
            packageFreezer = freezePackage(packageName, "clearApplicationProfileData");
            synchronized (this.mInstallLock) {
                clearAppProfilesLIF(pkg, -1);
            }
            if (packageFreezer != null) {
                try {
                    packageFreezer.close();
                } catch (Throwable th2) {
                    th = th2;
                }
            }
            if (th != null) {
                throw th;
            }
        } catch (Throwable th3) {
            Throwable th4 = th3;
            if (packageFreezer != null) {
                try {
                    packageFreezer.close();
                } catch (Throwable th5) {
                    if (th == null) {
                        th = th5;
                    } else if (th != th5) {
                        th.addSuppressed(th5);
                    }
                }
            }
            if (th != null) {
                throw th;
            }
            throw th4;
        }
    }

    public void clearApplicationUserData(String packageName, IPackageDataObserver observer, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_USER_DATA", null);
        int callingUid = Binder.getCallingUid();
        enforceCrossUserPermission(callingUid, userId, true, false, "clear application data");
        PackageSetting ps = this.mSettings.getPackageLPr(packageName);
        final boolean filterApp = ps != null ? filterAppAccessLPr(ps, callingUid, userId) : false;
        if (filterApp || !this.mProtectedPackages.isPackageDataProtected(userId, packageName)) {
            final String str = packageName;
            final int i = userId;
            final IPackageDataObserver iPackageDataObserver = observer;
            this.mHandler.post(new Runnable() {
                /* JADX WARNING: inconsistent code. */
                /* Code decompiled incorrectly, please refer to instructions dump. */
                public void run() {
                    boolean succeeded;
                    Throwable th = null;
                    PackageManagerService.this.mHandler.removeCallbacks(this);
                    if (filterApp) {
                        succeeded = false;
                    } else {
                        PackageFreezer packageFreezer = null;
                        try {
                            packageFreezer = PackageManagerService.this.freezePackage(str, "clearApplicationUserData");
                            synchronized (PackageManagerService.this.mInstallLock) {
                                succeeded = PackageManagerService.this.clearApplicationUserDataLIF(str, i);
                            }
                            PackageManagerService.this.clearExternalStorageDataSync(str, i, true);
                            synchronized (PackageManagerService.this.mPackages) {
                                PackageManagerService.this.mInstantAppRegistry.deleteInstantApplicationMetadataLPw(str, i);
                            }
                            if (packageFreezer != null) {
                                try {
                                    packageFreezer.close();
                                } catch (Throwable th2) {
                                    th = th2;
                                }
                            }
                            if (th != null) {
                                throw th;
                            } else if (succeeded) {
                                DeviceStorageMonitorInternal dsm = (DeviceStorageMonitorInternal) LocalServices.getService(DeviceStorageMonitorInternal.class);
                                if (dsm != null) {
                                    dsm.checkMemory();
                                }
                            }
                        } catch (Throwable th3) {
                            Throwable th4 = th3;
                            if (packageFreezer != null) {
                                try {
                                    packageFreezer.close();
                                } catch (Throwable th5) {
                                    if (th == null) {
                                        th = th5;
                                    } else if (th != th5) {
                                        th.addSuppressed(th5);
                                    }
                                }
                            }
                            if (th != null) {
                                throw th;
                            }
                            throw th4;
                        }
                    }
                    if (iPackageDataObserver != null) {
                        try {
                            iPackageDataObserver.onRemoveCompleted(str, succeeded);
                        } catch (RemoteException e) {
                            Log.i(PackageManagerService.TAG, "Observer no longer exists.");
                        }
                    }
                }
            });
            return;
        }
        throw new SecurityException("Cannot clear data for a protected package: " + packageName);
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private boolean clearApplicationUserDataLIF(String packageName, int userId) {
        if (packageName == null) {
            Slog.w(TAG, "Attempt to delete null packageName.");
            return false;
        }
        synchronized (this.mPackages) {
            Package pkg = (Package) this.mPackages.get(packageName);
            if (pkg == null) {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (ps != null) {
                    pkg = ps.pkg;
                }
            }
            if (pkg == null) {
                Slog.w(TAG, "Package named '" + packageName + "' doesn't exist.");
                return false;
            }
            resetUserChangesToRuntimePermissionsAndFlagsLPw((PackageSetting) pkg.mExtras, userId);
        }
    }

    private void resetUserChangesToRuntimePermissionsAndFlagsLPw(int userId) {
        int packageCount = this.mPackages.size();
        for (int i = 0; i < packageCount; i++) {
            resetUserChangesToRuntimePermissionsAndFlagsLPw(((Package) this.mPackages.valueAt(i)).mExtras, userId);
        }
    }

    private void resetNetworkPolicies(int userId) {
        ((NetworkPolicyManagerInternal) LocalServices.getService(NetworkPolicyManagerInternal.class)).resetUserState(userId);
    }

    private void resetUserChangesToRuntimePermissionsAndFlagsLPw(PackageSetting ps, int userId) {
        if (ps.pkg != null) {
            if (userId == 999 && ps.pkg.packageName != null && OppoMultiAppManagerUtil.getInstance().isMultiApp(ps.pkg.packageName)) {
                String stackTraceString = Log.getStackTraceString(new Throwable());
                if (stackTraceString != null && stackTraceString.contains("deletePackageLI")) {
                    return;
                }
            }
            boolean writeInstallPermissions = false;
            boolean writeRuntimePermissions = false;
            int permissionCount = ps.pkg.requestedPermissions.size();
            for (int i = 0; i < permissionCount; i++) {
                String permission = (String) ps.pkg.requestedPermissions.get(i);
                BasePermission bp = (BasePermission) this.mSettings.mPermissions.get(permission);
                if (bp != null) {
                    if (ps.sharedUser != null) {
                        boolean used = false;
                        int packageCount = ps.sharedUser.packages.size();
                        int j = 0;
                        while (j < packageCount) {
                            PackageSetting pkg = (PackageSetting) ps.sharedUser.packages.valueAt(j);
                            if (pkg.pkg == null || (pkg.pkg.packageName.equals(ps.pkg.packageName) ^ 1) == 0 || !pkg.pkg.requestedPermissions.contains(permission)) {
                                j++;
                            } else {
                                used = true;
                                if (used) {
                                }
                            }
                        }
                        if (used) {
                        }
                    }
                    PermissionsState permissionsState = ps.getPermissionsState();
                    int oldFlags = permissionsState.getPermissionFlags(bp.name, userId);
                    boolean hasInstallState = permissionsState.getInstallPermissionState(bp.name) != null;
                    int flags = 0;
                    if (this.mPermissionReviewRequired && ps.pkg.applicationInfo.targetSdkVersion < 23) {
                        flags = 64;
                    }
                    if (permissionsState.updatePermissionFlags(bp, userId, 75, flags)) {
                        if (hasInstallState) {
                            writeInstallPermissions = true;
                        } else {
                            writeRuntimePermissions = true;
                        }
                    }
                    if (bp.isRuntime() && (oldFlags & 20) == 0) {
                        if ((oldFlags & 32) != 0) {
                            if (permissionsState.grantRuntimePermission(bp, userId) != -1) {
                                writeRuntimePermissions = true;
                            }
                        } else if ((flags & 64) == 0) {
                            switch (permissionsState.revokeRuntimePermission(bp, userId)) {
                                case 0:
                                case 1:
                                    writeRuntimePermissions = true;
                                    final int appId = ps.appId;
                                    final int i2 = userId;
                                    this.mHandler.post(new Runnable() {
                                        public void run() {
                                            PackageManagerService.this.killUid(appId, i2, PackageManagerService.KILL_APP_REASON_PERMISSIONS_REVOKED);
                                        }
                                    });
                                    break;
                                default:
                                    break;
                            }
                        }
                    }
                }
            }
            if (writeRuntimePermissions) {
                this.mSettings.writeRuntimePermissionsForUserLPr(userId, true);
            }
            if (writeInstallPermissions) {
                this.mSettings.writeLPr();
            }
        }
    }

    private static void removeKeystoreDataIfNeeded(int userId, int appId) {
        if (appId >= 0) {
            KeyStore keyStore = KeyStore.getInstance();
            if (keyStore == null) {
                Slog.w(TAG, "Could not contact keystore to clear entries for app id " + appId);
            } else if (userId == -1) {
                for (int individual : sUserManager.getUserIds()) {
                    keyStore.clearUid(UserHandle.getUid(individual, appId));
                }
            } else {
                keyStore.clearUid(UserHandle.getUid(userId, appId));
            }
        }
    }

    public void deleteApplicationCacheFilesCrossUser(String packageName, IPackageDataObserver observer, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.DELETE_CACHE_FILES", null);
        deleteApplicationCacheFilesAsUser(packageName, userId, observer);
    }

    public void deleteApplicationCacheFiles(String packageName, IPackageDataObserver observer) {
        deleteApplicationCacheFilesAsUser(packageName, UserHandle.getCallingUserId(), observer);
    }

    public void deleteApplicationCacheFilesAsUser(String packageName, int userId, IPackageDataObserver observer) {
        final Package pkg;
        int callingUid = Binder.getCallingUid();
        this.mContext.enforceCallingOrSelfPermission("android.permission.DELETE_CACHE_FILES", null);
        enforceCrossUserPermission(callingUid, userId, true, false, "delete application cache files");
        final int hasAccessInstantApps = this.mContext.checkCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS");
        synchronized (this.mPackages) {
            pkg = (Package) this.mPackages.get(packageName);
        }
        final int i = callingUid;
        final int i2 = userId;
        final String str = packageName;
        final IPackageDataObserver iPackageDataObserver = observer;
        this.mHandler.post(new Runnable() {
            public void run() {
                PackageSetting ps = pkg == null ? null : pkg.mExtras;
                boolean doClearData = true;
                if (ps != null) {
                    doClearData = ps.getInstantApp(UserHandle.getUserId(i)) ? hasAccessInstantApps == 0 : true;
                }
                if (doClearData) {
                    synchronized (PackageManagerService.this.mInstallLock) {
                        PackageManagerService.this.clearAppDataLIF(pkg, i2, 259);
                        PackageManagerService.this.clearAppDataLIF(pkg, i2, UsbTerminalTypes.TERMINAL_IN_PERSONAL_MIC);
                    }
                    PackageManagerService.this.clearExternalStorageDataSync(str, i2, false);
                }
                if (iPackageDataObserver != null) {
                    try {
                        iPackageDataObserver.onRemoveCompleted(str, true);
                    } catch (RemoteException e) {
                        Log.i(PackageManagerService.TAG, "Observer no longer exists.");
                    }
                }
            }
        });
    }

    public void getPackageSizeInfo(String packageName, int userHandle, IPackageStatsObserver observer) {
        throw new UnsupportedOperationException("Shame on you for calling the hidden API getPackageSizeInfo(). Shame!");
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    private boolean getPackageSizeInfoLI(String packageName, int userId, PackageStats stats) {
        synchronized (this.mPackages) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                Slog.w(TAG, "Failed to find settings for " + packageName);
                return false;
            }
        }
    }

    private int getUidTargetSdkVersionLockedLPr(int uid) {
        SharedUserSetting obj = this.mSettings.getUserIdLPr(uid);
        PackageSetting ps;
        if (obj instanceof SharedUserSetting) {
            int vers = 10000;
            Iterator<PackageSetting> it = obj.packages.iterator();
            while (it.hasNext()) {
                ps = (PackageSetting) it.next();
                if (ps.pkg != null) {
                    int v = ps.pkg.applicationInfo.targetSdkVersion;
                    if (v < vers) {
                        vers = v;
                    }
                }
            }
            return vers;
        }
        if (obj instanceof PackageSetting) {
            ps = (PackageSetting) obj;
            if (ps.pkg != null) {
                return ps.pkg.applicationInfo.targetSdkVersion;
            }
        }
        return 10000;
    }

    public void addPreferredActivity(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, int userId) {
        String callingPkg = OppoPackageManagerHelper.getProcessNameByPid(Binder.getCallingPid());
        if (callingPkg != null && callingPkg.equals("system:ui") && ColorPackageManagerHelper.isSetContainsOppoDefaultPkg(set, activity)) {
            Slog.d(TAG, "addPreferredActivity called from ResolverActivity and contains oppo default package, skip!");
        } else if (!ColorPackageManagerHelper.forbiddenSetPreferredActivity(this, filter)) {
            addPreferredActivityInternal(filter, match, set, activity, true, userId, "Adding preferred");
        }
    }

    private void addPreferredActivityInternal(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, boolean always, int userId, String opname) {
        int callingUid = Binder.getCallingUid();
        enforceCrossUserPermission(callingUid, userId, true, false, "add preferred activity");
        if (filter.countActions() == 0) {
            Slog.w(TAG, "Cannot set a preferred activity with no filter actions");
            return;
        }
        synchronized (this.mPackages) {
            if (this.mContext.checkCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS") != 0) {
                if (getUidTargetSdkVersionLockedLPr(callingUid) < 8) {
                    Slog.w(TAG, "Ignoring addPreferredActivity() from uid " + callingUid);
                    return;
                }
                this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
            }
            PreferredIntentResolver pir = this.mSettings.editPreferredActivitiesLPw(userId);
            if (DEBUG_PMS) {
                Slog.i(TAG, opname + " activity " + activity.flattenToShortString() + " for user " + userId + ":");
                filter.dump(new LogPrinter(4, TAG), "  ");
            }
            pir.addFilter(new PreferredActivity(filter, match, set, activity, always));
            scheduleWritePackageRestrictionsLocked(userId);
            postPreferredActivityChangedBroadcast(userId);
        }
    }

    private void postPreferredActivityChangedBroadcast(int userId) {
        this.mHandler.post(new com.android.server.pm.-$Lambda$kozCdtU4hxwnpbopzC6ZLMsBV5E.AnonymousClass1(userId));
    }

    static /* synthetic */ void lambda$-com_android_server_pm_PackageManagerService_1106815(int userId) {
        IActivityManager am = ActivityManager.getService();
        if (am != null) {
            Intent intent = new Intent("android.intent.action.ACTION_PREFERRED_ACTIVITY_CHANGED");
            intent.putExtra("android.intent.extra.user_handle", userId);
            try {
                am.broadcastIntent(null, intent, null, null, 0, null, null, null, -1, null, false, false, userId);
            } catch (RemoteException e) {
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void replacePreferredActivity(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, int userId) {
        if (filter.countActions() != 1) {
            throw new IllegalArgumentException("replacePreferredActivity expects filter to have only 1 action.");
        } else if (filter.countDataAuthorities() == 0 && filter.countDataPaths() == 0 && filter.countDataSchemes() <= 1 && filter.countDataTypes() == 0) {
            int callingUid = Binder.getCallingUid();
            if (!ColorPackageManagerHelper.forbiddenSetPreferredActivity(this, filter)) {
                enforceCrossUserPermission(callingUid, userId, true, false, "replace preferred activity");
                synchronized (this.mPackages) {
                    if (this.mContext.checkCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS") != 0) {
                        if (getUidTargetSdkVersionLockedLPr(callingUid) < 8) {
                            Slog.w(TAG, "Ignoring replacePreferredActivity() from uid " + Binder.getCallingUid());
                            return;
                        }
                        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
                    }
                    PreferredIntentResolver pir = (PreferredIntentResolver) this.mSettings.mPreferredActivities.get(userId);
                    if (pir != null) {
                        ArrayList<PreferredActivity> existing = pir.findFilters(filter);
                        if (existing != null && existing.size() == 1) {
                            PreferredActivity cur = (PreferredActivity) existing.get(0);
                            if (DEBUG_PREFERRED) {
                                Slog.i(TAG, "Checking replace of preferred:");
                                filter.dump(new LogPrinter(4, TAG), "  ");
                                if (cur.mPref.mAlways) {
                                    Slog.i(TAG, "  -- CUR: mMatch=" + cur.mPref.mMatch);
                                    Slog.i(TAG, "  -- CUR: mSet=" + Arrays.toString(cur.mPref.mSetComponents));
                                    Slog.i(TAG, "  -- CUR: mComponent=" + cur.mPref.mShortComponent);
                                    Slog.i(TAG, "  -- NEW: mMatch=" + (268369920 & match));
                                    Slog.i(TAG, "  -- CUR: mSet=" + Arrays.toString(set));
                                    Slog.i(TAG, "  -- CUR: mComponent=" + activity.flattenToShortString());
                                } else {
                                    Slog.i(TAG, "  -- CUR; not mAlways!");
                                }
                            }
                            if (cur.mPref.mAlways && cur.mPref.mComponent.equals(activity) && cur.mPref.mMatch == (268369920 & match) && cur.mPref.sameSet(set)) {
                                if (DEBUG_PREFERRED) {
                                    Slog.i(TAG, "Replacing with same preferred activity " + cur.mPref.mShortComponent + " for user " + userId + ":");
                                    filter.dump(new LogPrinter(4, TAG), "  ");
                                }
                            }
                        }
                        if (existing != null) {
                            if (DEBUG_PREFERRED) {
                                Slog.i(TAG, existing.size() + " existing preferred matches for:");
                                filter.dump(new LogPrinter(4, TAG), "  ");
                            }
                            for (int i = 0; i < existing.size(); i++) {
                                PreferredActivity pa = (PreferredActivity) existing.get(i);
                                if (DEBUG_PREFERRED) {
                                    Slog.i(TAG, "Removing existing preferred activity " + pa.mPref.mComponent + ":");
                                    pa.dump(new LogPrinter(4, TAG), "  ");
                                }
                                pir.removeFilter(pa);
                            }
                        }
                    }
                    addPreferredActivityInternal(filter, match, set, activity, true, userId, "Replacing preferred");
                }
            }
        } else {
            throw new IllegalArgumentException("replacePreferredActivity expects filter to have no data authorities, paths, or types; and at most one scheme.");
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void clearPackagePreferredActivities(String packageName) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null) {
            synchronized (this.mPackages) {
                Package pkg = (Package) this.mPackages.get(packageName);
                if ((pkg == null || pkg.applicationInfo.uid != callingUid) && this.mContext.checkCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS") != 0) {
                    if (getUidTargetSdkVersionLockedLPr(callingUid) < 8) {
                        Slog.w(TAG, "Ignoring clearPackagePreferredActivities() from uid " + callingUid);
                        return;
                    }
                    this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
                }
                PackageSetting ps = this.mSettings.getPackageLPr(packageName);
                if (ps == null || !filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    int user = UserHandle.getCallingUserId();
                    if (clearPackagePreferredActivitiesLPw(packageName, user)) {
                        scheduleWritePackageRestrictionsLocked(user);
                    }
                }
            }
        }
    }

    boolean clearPackagePreferredActivitiesLPw(String packageName, int userId) {
        ArrayList removed = null;
        boolean changed = false;
        for (int i = 0; i < this.mSettings.mPreferredActivities.size(); i++) {
            int thisUserId = this.mSettings.mPreferredActivities.keyAt(i);
            PreferredIntentResolver pir = (PreferredIntentResolver) this.mSettings.mPreferredActivities.valueAt(i);
            if (userId == -1 || userId == thisUserId) {
                Iterator<PreferredActivity> it = pir.filterIterator();
                while (it.hasNext()) {
                    PreferredActivity pa = (PreferredActivity) it.next();
                    if (packageName == null || (pa.mPref.mComponent.getPackageName().equals(packageName) && pa.mPref.mAlways)) {
                        if (removed == null) {
                            removed = new ArrayList();
                        }
                        removed.add(pa);
                    }
                }
                if (removed != null) {
                    for (int j = 0; j < removed.size(); j++) {
                        pir.removeFilter((PreferredActivity) removed.get(j));
                    }
                    changed = true;
                }
            }
        }
        if (changed) {
            postPreferredActivityChangedBroadcast(userId);
        }
        return changed;
    }

    private void clearIntentFilterVerificationsLPw(int userId) {
        int packageCount = this.mPackages.size();
        for (int i = 0; i < packageCount; i++) {
            clearIntentFilterVerificationsLPw(((Package) this.mPackages.valueAt(i)).packageName, userId);
        }
    }

    void clearIntentFilterVerificationsLPw(String packageName, int userId) {
        if (userId == -1) {
            if (this.mSettings.removeIntentFilterVerificationLPw(packageName, sUserManager.getUserIds())) {
                for (int oneUserId : sUserManager.getUserIds()) {
                    scheduleWritePackageRestrictionsLocked(oneUserId);
                }
            }
        } else if (this.mSettings.removeIntentFilterVerificationLPw(packageName, userId)) {
            scheduleWritePackageRestrictionsLocked(userId);
        }
    }

    void clearDefaultBrowserIfNeeded(String packageName) {
        for (int oneUserId : sUserManager.getUserIds()) {
            clearDefaultBrowserIfNeededForUser(packageName, oneUserId);
        }
    }

    private void clearDefaultBrowserIfNeededForUser(String packageName, int userId) {
        String defaultBrowserPackageName = getDefaultBrowserPackageName(userId);
        if (!TextUtils.isEmpty(defaultBrowserPackageName) && packageName.equals(defaultBrowserPackageName)) {
            setDefaultBrowserPackageName(null, userId);
        }
    }

    public void resetApplicationPreferences(int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        long identity = Binder.clearCallingIdentity();
        try {
            synchronized (this.mPackages) {
                clearPackagePreferredActivitiesLPw(null, userId);
                this.mSettings.applyDefaultPreferredAppsLPw(this, userId);
                applyFactoryDefaultBrowserLPw(userId);
                clearIntentFilterVerificationsLPw(userId);
                primeDomainVerificationsLPw(userId);
                resetUserChangesToRuntimePermissionsAndFlagsLPw(userId);
                scheduleWritePackageRestrictionsLocked(userId);
            }
            resetNetworkPolicies(userId);
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    public int getPreferredActivities(List<IntentFilter> outFilters, List<ComponentName> outActivities, String packageName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return 0;
        }
        int userId = UserHandle.getCallingUserId();
        synchronized (this.mPackages) {
            PreferredIntentResolver pir = (PreferredIntentResolver) this.mSettings.mPreferredActivities.get(userId);
            if (pir != null) {
                Iterator<PreferredActivity> it = pir.filterIterator();
                while (it.hasNext()) {
                    PreferredActivity pa = (PreferredActivity) it.next();
                    if (packageName == null || (pa.mPref.mComponent.getPackageName().equals(packageName) && pa.mPref.mAlways)) {
                        if (outFilters != null) {
                            outFilters.add(new IntentFilter(pa));
                        }
                        if (outActivities != null) {
                            outActivities.add(pa.mPref.mComponent);
                        }
                    }
                }
            }
        }
        return 0;
    }

    public void addPersistentPreferredActivity(IntentFilter filter, ComponentName activity, int userId) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("addPersistentPreferredActivity can only be run by the system");
        } else if (filter.countActions() == 0) {
            Slog.w(TAG, "Cannot set a preferred activity with no filter actions");
        } else {
            synchronized (this.mPackages) {
                Slog.i(TAG, "Adding persistent preferred activity " + activity + " for user " + userId + ":");
                filter.dump(new LogPrinter(4, TAG), "  ");
                this.mSettings.editPersistentPreferredActivitiesLPw(userId).addFilter(new PersistentPreferredActivity(filter, activity));
                scheduleWritePackageRestrictionsLocked(userId);
                postPreferredActivityChangedBroadcast(userId);
            }
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    public void clearPackagePersistentPreferredActivities(String packageName, int userId) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("clearPackagePersistentPreferredActivities can only be run by the system");
        }
        ArrayList<PersistentPreferredActivity> removed = null;
        boolean changed = false;
        synchronized (this.mPackages) {
            int i = 0;
            while (i < this.mSettings.mPersistentPreferredActivities.size()) {
                try {
                    PersistentPreferredIntentResolver ppir = (PersistentPreferredIntentResolver) this.mSettings.mPersistentPreferredActivities.valueAt(i);
                    if (userId == this.mSettings.mPersistentPreferredActivities.keyAt(i)) {
                        Iterator<PersistentPreferredActivity> it = ppir.filterIterator();
                        while (true) {
                            ArrayList<PersistentPreferredActivity> removed2 = removed;
                            if (!it.hasNext()) {
                                break;
                            }
                            PersistentPreferredActivity ppa = (PersistentPreferredActivity) it.next();
                            if (ppa.mComponent.getPackageName().equals(packageName)) {
                                if (removed2 == null) {
                                    removed = new ArrayList();
                                } else {
                                    removed = removed2;
                                }
                                removed.add(ppa);
                            } else {
                                removed = removed2;
                            }
                        }
                    }
                    i++;
                } catch (Throwable th) {
                    Throwable th2 = th;
                }
            }
            if (changed) {
                scheduleWritePackageRestrictionsLocked(userId);
                postPreferredActivityChangedBroadcast(userId);
            }
        }
    }

    private void restoreFromXml(XmlPullParser parser, int userId, String expectedStartTag, BlobXmlRestorer functor) throws IOException, XmlPullParserException {
        int type;
        do {
            type = parser.next();
            if (type == 2) {
                break;
            }
        } while (type != 1);
        if (type == 2) {
            Slog.v(TAG, ":: restoreFromXml() : got to tag " + parser.getName());
            if (expectedStartTag.equals(parser.getName())) {
                do {
                } while (parser.next() == 4);
                Slog.v(TAG, ":: stepped forward, applying functor at tag " + parser.getName());
                functor.apply(parser, userId);
            }
        }
    }

    public byte[] getPreferredActivityBackup(int userId) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("Only the system may call getPreferredActivityBackup()");
        }
        ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
        try {
            XmlSerializer serializer = new FastXmlSerializer();
            serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
            serializer.startDocument(null, Boolean.valueOf(true));
            serializer.startTag(null, TAG_PREFERRED_BACKUP);
            synchronized (this.mPackages) {
                this.mSettings.writePreferredActivitiesLPr(serializer, userId, true);
            }
            serializer.endTag(null, TAG_PREFERRED_BACKUP);
            serializer.endDocument();
            serializer.flush();
            return dataStream.toByteArray();
        } catch (Exception e) {
            return null;
        }
    }

    public void restorePreferredActivities(byte[] backup, int userId) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("Only the system may call restorePreferredActivities()");
        }
        try {
            XmlPullParser parser = Xml.newPullParser();
            parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
            restoreFromXml(parser, userId, TAG_PREFERRED_BACKUP, new BlobXmlRestorer() {
                public void apply(XmlPullParser parser, int userId) throws XmlPullParserException, IOException {
                    synchronized (PackageManagerService.this.mPackages) {
                        PackageManagerService.this.mSettings.readPreferredActivitiesLPw(parser, userId);
                    }
                }
            });
        } catch (Exception e) {
        }
    }

    public byte[] getDefaultAppsBackup(int userId) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("Only the system may call getDefaultAppsBackup()");
        }
        ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
        try {
            XmlSerializer serializer = new FastXmlSerializer();
            serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
            serializer.startDocument(null, Boolean.valueOf(true));
            serializer.startTag(null, TAG_DEFAULT_APPS);
            synchronized (this.mPackages) {
                this.mSettings.writeDefaultAppsLPr(serializer, userId);
            }
            serializer.endTag(null, TAG_DEFAULT_APPS);
            serializer.endDocument();
            serializer.flush();
            return dataStream.toByteArray();
        } catch (Exception e) {
            return null;
        }
    }

    public void restoreDefaultApps(byte[] backup, int userId) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("Only the system may call restoreDefaultApps()");
        }
        try {
            XmlPullParser parser = Xml.newPullParser();
            parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
            restoreFromXml(parser, userId, TAG_DEFAULT_APPS, new BlobXmlRestorer() {
                public void apply(XmlPullParser parser, int userId) throws XmlPullParserException, IOException {
                    synchronized (PackageManagerService.this.mPackages) {
                        PackageManagerService.this.mSettings.readDefaultAppsLPw(parser, userId);
                    }
                }
            });
        } catch (Exception e) {
        }
    }

    public byte[] getIntentFilterVerificationBackup(int userId) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("Only the system may call getIntentFilterVerificationBackup()");
        }
        ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
        try {
            XmlSerializer serializer = new FastXmlSerializer();
            serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
            serializer.startDocument(null, Boolean.valueOf(true));
            serializer.startTag(null, TAG_INTENT_FILTER_VERIFICATION);
            synchronized (this.mPackages) {
                this.mSettings.writeAllDomainVerificationsLPr(serializer, userId);
            }
            serializer.endTag(null, TAG_INTENT_FILTER_VERIFICATION);
            serializer.endDocument();
            serializer.flush();
            return dataStream.toByteArray();
        } catch (Exception e) {
            return null;
        }
    }

    public void restoreIntentFilterVerification(byte[] backup, int userId) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("Only the system may call restorePreferredActivities()");
        }
        try {
            XmlPullParser parser = Xml.newPullParser();
            parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
            restoreFromXml(parser, userId, TAG_INTENT_FILTER_VERIFICATION, new BlobXmlRestorer() {
                public void apply(XmlPullParser parser, int userId) throws XmlPullParserException, IOException {
                    synchronized (PackageManagerService.this.mPackages) {
                        PackageManagerService.this.mSettings.readAllDomainVerificationsLPr(parser, userId);
                        PackageManagerService.this.mSettings.writeLPr();
                    }
                }
            });
        } catch (Exception e) {
        }
    }

    public byte[] getPermissionGrantBackup(int userId) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("Only the system may call getPermissionGrantBackup()");
        }
        ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
        try {
            XmlSerializer serializer = new FastXmlSerializer();
            serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
            serializer.startDocument(null, Boolean.valueOf(true));
            serializer.startTag(null, TAG_PERMISSION_BACKUP);
            synchronized (this.mPackages) {
                serializeRuntimePermissionGrantsLPr(serializer, userId);
            }
            serializer.endTag(null, TAG_PERMISSION_BACKUP);
            serializer.endDocument();
            serializer.flush();
            return dataStream.toByteArray();
        } catch (Exception e) {
            return null;
        }
    }

    public void restorePermissionGrants(byte[] backup, int userId) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("Only the system may call restorePermissionGrants()");
        }
        try {
            XmlPullParser parser = Xml.newPullParser();
            parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
            restoreFromXml(parser, userId, TAG_PERMISSION_BACKUP, new BlobXmlRestorer() {
                public void apply(XmlPullParser parser, int userId) throws XmlPullParserException, IOException {
                    synchronized (PackageManagerService.this.mPackages) {
                        PackageManagerService.this.processRestoredPermissionGrantsLPr(parser, userId);
                    }
                }
            });
        } catch (Exception e) {
        }
    }

    private void serializeRuntimePermissionGrantsLPr(XmlSerializer serializer, int userId) throws IOException {
        serializer.startTag(null, TAG_ALL_GRANTS);
        int N = this.mSettings.mPackages.size();
        for (int i = 0; i < N; i++) {
            boolean pkgGrantsKnown = false;
            for (PermissionState state : ((PackageSetting) this.mSettings.mPackages.valueAt(i)).getPermissionsState().getRuntimePermissionStates(userId)) {
                int grantFlags = state.getFlags();
                if ((grantFlags & 52) == 0) {
                    boolean isGranted = state.isGranted();
                    if (isGranted || (grantFlags & 11) != 0) {
                        String packageName = (String) this.mSettings.mPackages.keyAt(i);
                        if (!pkgGrantsKnown) {
                            serializer.startTag(null, TAG_GRANT);
                            serializer.attribute(null, ATTR_PACKAGE_NAME, packageName);
                            pkgGrantsKnown = true;
                        }
                        boolean userSet = (grantFlags & 1) != 0;
                        boolean userFixed = (grantFlags & 2) != 0;
                        boolean revoke = (grantFlags & 8) != 0;
                        serializer.startTag(null, TAG_PERMISSION);
                        serializer.attribute(null, ATTR_PERMISSION_NAME, state.getName());
                        if (isGranted) {
                            serializer.attribute(null, ATTR_IS_GRANTED, "true");
                        }
                        if (userSet) {
                            serializer.attribute(null, ATTR_USER_SET, "true");
                        }
                        if (userFixed) {
                            serializer.attribute(null, ATTR_USER_FIXED, "true");
                        }
                        if (revoke) {
                            serializer.attribute(null, ATTR_REVOKE_ON_UPGRADE, "true");
                        }
                        serializer.endTag(null, TAG_PERMISSION);
                    }
                }
            }
            if (pkgGrantsKnown) {
                serializer.endTag(null, TAG_GRANT);
            }
        }
        serializer.endTag(null, TAG_ALL_GRANTS);
    }

    private void processRestoredPermissionGrantsLPr(XmlPullParser parser, int userId) throws XmlPullParserException, IOException {
        String pkgName = null;
        int outerDepth = parser.getDepth();
        while (true) {
            int type = parser.next();
            if (type == 1 || (type == 3 && parser.getDepth() <= outerDepth)) {
                scheduleWriteSettingsLocked();
                this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
            } else if (!(type == 3 || type == 4)) {
                String tagName = parser.getName();
                if (tagName.equals(TAG_GRANT)) {
                    pkgName = parser.getAttributeValue(null, ATTR_PACKAGE_NAME);
                } else if (tagName.equals(TAG_PERMISSION)) {
                    boolean isGranted = "true".equals(parser.getAttributeValue(null, ATTR_IS_GRANTED));
                    String permName = parser.getAttributeValue(null, ATTR_PERMISSION_NAME);
                    int newFlagSet = 0;
                    if ("true".equals(parser.getAttributeValue(null, ATTR_USER_SET))) {
                        newFlagSet = 1;
                    }
                    if ("true".equals(parser.getAttributeValue(null, ATTR_USER_FIXED))) {
                        newFlagSet |= 2;
                    }
                    if ("true".equals(parser.getAttributeValue(null, ATTR_REVOKE_ON_UPGRADE))) {
                        newFlagSet |= 8;
                    }
                    PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(pkgName);
                    if (ps != null) {
                        PermissionsState perms = ps.getPermissionsState();
                        BasePermission bp = (BasePermission) this.mSettings.mPermissions.get(permName);
                        if (bp != null) {
                            if (isGranted) {
                                perms.grantRuntimePermission(bp, userId);
                            }
                            if (newFlagSet != 0) {
                                perms.updatePermissionFlags(bp, userId, 11, newFlagSet);
                            }
                        }
                    } else {
                        this.mSettings.processRestoredPermissionGrantLPr(pkgName, permName, isGranted, newFlagSet, userId);
                    }
                } else {
                    reportSettingsProblem(5, "Unknown element under <perm-grant-backup>: " + tagName);
                    XmlUtils.skipCurrentTag(parser);
                }
            }
        }
        scheduleWriteSettingsLocked();
        this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
    }

    public void addCrossProfileIntentFilter(IntentFilter intentFilter, String ownerPackage, int sourceUserId, int targetUserId, int flags) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        int callingUid = Binder.getCallingUid();
        enforceOwnerRights(ownerPackage, callingUid);
        enforceShellRestriction("no_debugging_features", callingUid, sourceUserId);
        if (intentFilter.countActions() == 0) {
            Slog.w(TAG, "Cannot set a crossProfile intent filter with no filter actions");
            return;
        }
        synchronized (this.mPackages) {
            CrossProfileIntentFilter newFilter = new CrossProfileIntentFilter(intentFilter, ownerPackage, targetUserId, flags);
            CrossProfileIntentResolver resolver = this.mSettings.editCrossProfileIntentResolverLPw(sourceUserId);
            ArrayList<CrossProfileIntentFilter> existing = resolver.findFilters(intentFilter);
            if (existing != null) {
                int size = existing.size();
                for (int i = 0; i < size; i++) {
                    if (newFilter.equalsIgnoreFilter((CrossProfileIntentFilter) existing.get(i))) {
                        return;
                    }
                }
            }
            resolver.addFilter(newFilter);
            scheduleWritePackageRestrictionsLocked(sourceUserId);
        }
    }

    public void clearCrossProfileIntentFilters(int sourceUserId, String ownerPackage) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        int callingUid = Binder.getCallingUid();
        enforceOwnerRights(ownerPackage, callingUid);
        enforceShellRestriction("no_debugging_features", callingUid, sourceUserId);
        synchronized (this.mPackages) {
            CrossProfileIntentResolver resolver = this.mSettings.editCrossProfileIntentResolverLPw(sourceUserId);
            for (CrossProfileIntentFilter filter : new ArraySet(resolver.filterSet())) {
                if (filter.getOwnerPackage().equals(ownerPackage)) {
                    resolver.removeFilter(filter);
                }
            }
            scheduleWritePackageRestrictionsLocked(sourceUserId);
        }
    }

    private void enforceOwnerRights(String pkg, int callingUid) {
        if (UserHandle.getAppId(callingUid) != 1000) {
            int callingUserId = UserHandle.getUserId(callingUid);
            PackageInfo pi = getPackageInfo(pkg, 0, callingUserId);
            if (pi == null) {
                throw new IllegalArgumentException("Unknown package " + pkg + " on user " + callingUserId);
            } else if (!UserHandle.isSameApp(pi.applicationInfo.uid, callingUid)) {
                throw new SecurityException("Calling uid " + callingUid + " does not own package " + pkg);
            }
        }
    }

    public ComponentName getHomeActivities(List<ResolveInfo> allHomeCandidates) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        return getHomeActivitiesAsUser(allHomeCandidates, UserHandle.getCallingUserId());
    }

    public void sendSessionCommitBroadcast(SessionInfo sessionInfo, int userId) {
        UserManagerService ums = UserManagerService.getInstance();
        if (ums != null) {
            UserInfo parent = ums.getProfileParent(userId);
            int launcherUid = parent != null ? parent.id : userId;
            ComponentName launcherComponent = getDefaultHomeActivity(launcherUid);
            if (launcherComponent != null) {
                this.mContext.sendBroadcastAsUser(new Intent("android.content.pm.action.SESSION_COMMITTED").putExtra("android.content.pm.extra.SESSION", sessionInfo).putExtra("android.intent.extra.USER", UserHandle.of(userId)).setPackage(launcherComponent.getPackageName()), UserHandle.of(launcherUid));
            }
        }
    }

    private ComponentName getDefaultHomeActivity(int userId) {
        List<ResolveInfo> allHomeCandidates = new ArrayList();
        ComponentName cn = getHomeActivitiesAsUser(allHomeCandidates, userId);
        if (cn != null) {
            return cn;
        }
        int lastPriority = Integer.MIN_VALUE;
        ComponentName lastComponent = null;
        int size = allHomeCandidates.size();
        for (int i = 0; i < size; i++) {
            ResolveInfo ri = (ResolveInfo) allHomeCandidates.get(i);
            if (ri.priority > lastPriority) {
                lastComponent = ri.activityInfo.getComponentName();
                lastPriority = ri.priority;
            } else if (ri.priority == lastPriority) {
                lastComponent = null;
            }
        }
        return lastComponent;
    }

    private Intent getHomeIntent() {
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory("android.intent.category.HOME");
        intent.addCategory("android.intent.category.DEFAULT");
        return intent;
    }

    private IntentFilter getHomeFilter() {
        IntentFilter filter = new IntentFilter("android.intent.action.MAIN");
        filter.addCategory("android.intent.category.HOME");
        filter.addCategory("android.intent.category.DEFAULT");
        return filter;
    }

    ComponentName getHomeActivitiesAsUser(List<ResolveInfo> allHomeCandidates, int userId) {
        Intent intent = getHomeIntent();
        List<ResolveInfo> list = queryIntentActivitiesInternal(intent, null, 128, userId);
        ResolveInfo preferred = findPreferredActivity(intent, null, 0, list, 0, true, false, false, userId);
        allHomeCandidates.clear();
        if (list != null) {
            for (ResolveInfo ri : list) {
                allHomeCandidates.add(ri);
            }
        }
        if (preferred == null || preferred.activityInfo == null) {
            return null;
        }
        return new ComponentName(preferred.activityInfo.packageName, preferred.activityInfo.name);
    }

    public void setHomeActivity(ComponentName comp, int userId) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            ArrayList<ResolveInfo> homeActivities = new ArrayList();
            getHomeActivitiesAsUser(homeActivities, userId);
            boolean found = false;
            int size = homeActivities.size();
            ComponentName[] set = new ComponentName[size];
            for (int i = 0; i < size; i++) {
                ActivityInfo info = ((ResolveInfo) homeActivities.get(i)).activityInfo;
                ComponentName activityName = new ComponentName(info.packageName, info.name);
                set[i] = activityName;
                if (!found && activityName.equals(comp)) {
                    found = true;
                }
            }
            if (found) {
                replacePreferredActivity(getHomeFilter(), DumpState.DUMP_DEXOPT, set, comp, userId);
                return;
            }
            throw new IllegalArgumentException("Component " + comp + " cannot be home on user " + userId);
        }
    }

    private String getSetupWizardPackageName() {
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory("android.intent.category.SETUP_WIZARD");
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, null, 1835520, UserHandle.myUserId());
        if (matches.size() == 1) {
            return ((ResolveInfo) matches.get(0)).getComponentInfo().packageName;
        }
        Slog.e(TAG, "There should probably be exactly one setup wizard; found " + matches.size() + ": matches=" + matches);
        return null;
    }

    private String getStorageManagerPackageName() {
        List<ResolveInfo> matches = queryIntentActivitiesInternal(new Intent("android.os.storage.action.MANAGE_STORAGE"), null, 1835520, UserHandle.myUserId());
        if (matches.size() == 1) {
            return ((ResolveInfo) matches.get(0)).getComponentInfo().packageName;
        }
        Slog.e(TAG, "There should probably be exactly one storage manager; found " + matches.size() + ": matches=" + matches);
        return null;
    }

    public void setApplicationEnabledSetting(String appPackageName, int newState, int flags, int userId, String callingPackage) {
        if (sUserManager.exists(userId)) {
            if (callingPackage == null) {
                callingPackage = Integer.toString(Binder.getCallingUid());
            }
            setEnabledSetting(appPackageName, null, newState, flags, userId, callingPackage);
        }
    }

    public void setUpdateAvailable(String packageName, boolean updateAvailable) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INSTALL_PACKAGES", null);
        synchronized (this.mPackages) {
            PackageSetting pkgSetting = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (pkgSetting != null) {
                pkgSetting.setUpdateAvailable(updateAvailable);
            }
        }
    }

    public void setComponentEnabledSetting(ComponentName componentName, int newState, int flags, int userId) {
        if (sUserManager.exists(userId)) {
            setEnabledSetting(componentName.getPackageName(), componentName.getClassName(), newState, flags, userId, null);
        }
    }

    /* JADX WARNING: inconsistent code. */
    /* Code decompiled incorrectly, please refer to instructions dump. */
    @OppoHook(level = OppoHookType.CHANGE_CODE, note = "Bin.Wang@Plf.Framework, 2017.02.21: modify for guest mode", property = OppoRomType.ROM)
    private void setEnabledSetting(String packageName, String className, int newState, int flags, int userId, String callingPackage) {
        boolean sendNow;
        PackageSetting pkgSetting;
        long callingId;
        Throwable th;
        if (newState == 0 || newState == 1 || newState == 2 || newState == 3 || newState == 4) {
            int permission;
            String str;
            ArrayList<String> components;
            int callingUid = Binder.getCallingUid();
            int pid = Binder.getCallingPid();
            if (callingUid == 1000) {
                permission = 0;
            } else {
                permission = this.mContext.checkCallingOrSelfPermission("android.permission.CHANGE_COMPONENT_ENABLED_STATE");
            }
            enforceCrossUserPermission(callingUid, userId, false, true, "set enabled");
            boolean allowedByPermission = permission == 0;
            sendNow = false;
            boolean isApp = className == null;
            boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
            String componentName = isApp ? packageName : className;
            synchronized (this.mPackages) {
                pkgSetting = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (pkgSetting != null) {
                } else if (isCallerInstantApp) {
                    StringBuilder append = new StringBuilder().append("Attempt to change component state; pid=").append(Binder.getCallingPid()).append(", uid=").append(callingUid);
                    if (className == null) {
                        str = ", package=" + packageName;
                    } else {
                        str = ", component=" + packageName + "/" + className;
                    }
                    throw new SecurityException(append.append(str).toString());
                } else if (className == null) {
                    throw new IllegalArgumentException("Unknown package: " + packageName);
                } else {
                    throw new IllegalArgumentException("Unknown component: " + packageName + "/" + className);
                }
            }
            if (!UserHandle.isSameApp(callingUid, pkgSetting.appId)) {
                if (!allowedByPermission || filterAppAccessLPr(pkgSetting, callingUid, userId)) {
                    StringBuilder append2 = new StringBuilder().append("Attempt to change component state; pid=").append(Binder.getCallingPid()).append(", uid=").append(callingUid);
                    if (className == null) {
                        str = ", package=" + packageName;
                    } else {
                        str = ", component=" + packageName + "/" + className;
                    }
                    throw new SecurityException(append2.append(str).toString());
                } else if (this.mProtectedPackages.isPackageStateProtected(userId, packageName)) {
                    throw new SecurityException("Cannot disable a protected package: " + packageName);
                }
            }
            synchronized (this.mPackages) {
                if (callingUid == 2000) {
                    if ((pkgSetting.pkgFlags & 256) == 0) {
                        int oldState = pkgSetting.getEnabled(userId);
                        if (!(className == null && ((oldState == 3 || oldState == 0 || oldState == 1) && (newState == 3 || newState == 0 || newState == 1)))) {
                            throw new SecurityException("Shell cannot change component state for " + packageName + "/" + className + " to " + newState);
                        }
                    }
                }
            }
            if (className == null) {
                synchronized (this.mPackages) {
                    if (pkgSetting.getEnabled(userId) == newState) {
                        return;
                    }
                }
            }
            synchronized (this.mPackages) {
                Package pkg = pkgSetting.pkg;
                if (pkg == null || (pkg.hasComponentClassName(className) ^ 1) != 0) {
                    if (pkg == null || pkg.applicationInfo.targetSdkVersion < 16) {
                        Slog.w(TAG, "Failed setComponentEnabledSetting: component class " + className + " does not exist in " + packageName);
                    } else {
                        throw new IllegalArgumentException("Component class " + className + " does not exist in " + packageName);
                    }
                }
                switch (newState) {
                    case 0:
                        if (!pkgSetting.restoreComponentLPw(className, userId)) {
                            return;
                        }
                        break;
                    case 1:
                        if (!pkgSetting.enableComponentLPw(className, userId)) {
                            return;
                        }
                        break;
                    case 2:
                        if (!pkgSetting.disableComponentLPw(className, userId)) {
                            return;
                        }
                        break;
                    default:
                        Slog.e(TAG, "Invalid new component state: " + newState);
                        return;
                }
            }
            synchronized (this.mPackages) {
                immediatelyWritePackageRestrictionsLocked(userId);
                updateSequenceNumberLP(pkgSetting, new int[]{userId});
                callingId = Binder.clearCallingIdentity();
                try {
                    updateInstantAppInstallerLocked(packageName);
                    Binder.restoreCallingIdentity(callingId);
                    components = this.mPendingBroadcasts.get(userId, packageName);
                    boolean newPackage = components == null;
                    if (newPackage) {
                        components = new ArrayList();
                    }
                    if (!components.contains(componentName)) {
                        components.add(componentName);
                    }
                    if ((flags & 1) == 0) {
                        sendNow = true;
                        this.mPendingBroadcasts.remove(userId, packageName);
                    } else {
                        if (newPackage) {
                            this.mPendingBroadcasts.put(userId, packageName, components);
                        }
                        if (!this.mHandler.hasMessages(1)) {
                            this.mHandler.sendEmptyMessageDelayed(1, 10000);
                        }
                    }
                } catch (Throwable th2) {
                    Binder.restoreCallingIdentity(callingId);
                }
            }
            callingId = Binder.clearCallingIdentity();
            if (sendNow) {
                try {
                    sendOppoPackageChangedBroadcast(packageName, (flags & 1) != 0, components, UserHandle.getUid(userId, pkgSetting.appId), pid);
                } catch (Throwable th3) {
                    Binder.restoreCallingIdentity(callingId);
                }
            }
            Binder.restoreCallingIdentity(callingId);
            return;
        }
        throw new IllegalArgumentException("Invalid new component state: " + newState);
        Throwable th4;
        PackageFreezer packageFreezer;
        updatePermissionsLPw(newPkg.packageName, newPkg, 3);
        this.mSettings.writeLPr();
        if (packageFreezer != null) {
            try {
                packageFreezer.close();
            } catch (Throwable th5) {
                th4 = th5;
            }
        }
        if (th4 == null) {
            try {
                throw th4;
            } catch (Throwable e) {
                Slog.w(TAG, "Failed to install compressed system package:" + pkgSetting.name, e);
                removeCodePathLI(codePath);
                th = null;
                packageFreezer = null;
                try {
                    packageFreezer = freezePackage(deletedPkg.packageName, "setEnabledSetting");
                    synchronized (this.mPackages) {
                        enableSystemPackageLPw(deletedPkg);
                        installPackageFromSystemLIF(new File(deletedPkg.codePath), false, null, 0, 0, true);
                        if (packageFreezer != null) {
                            packageFreezer.close();
                        }
                    }
                } catch (Throwable th6) {
                    Throwable th7 = th6;
                    if (packageFreezer != null) {
                        try {
                            packageFreezer.close();
                        } catch (Throwable th8) {
                            if (th == null) {
                                th = th8;
                            } else if (th != th8) {
                                th.addSuppressed(th8);
                            }
                        }
                    }
                    if (th != null) {
                        throw th;
                    } else {
                        throw th7;
                    }
                }
            } catch (Throwable pme) {
                try {
                    Slog.w(TAG, "Failed to restore system package:" + deletedPkg.packageName, pme);
                    synchronized (this.mPackages) {
                        this.mSettings.disableSystemPackageLPw(deletedPkg.packageName, true);
                        this.mSettings.writeLPr();
                        return;
                    }
                } catch (Throwable th9) {
                    synchronized (this.mPackages) {
                        this.mSettings.disableSystemPackageLPw(deletedPkg.packageName, true);
                        this.mSettings.writeLPr();
                    }
                }
            } catch (Throwable th10) {
                th = th10;
            }
        } else {
            clearAppDataLIF(newPkg, -1, UsbTerminalTypes.TERMINAL_IN_PERSONAL_MIC);
            clearAppProfilesLIF(newPkg, -1);
            this.mDexManager.notifyPackageUpdated(newPkg.packageName, newPkg.baseCodePath, newPkg.splitCodePaths);
            if (newState == 0 || newState == 1) {
                callingPackage = null;
            }
            synchronized (this.mPackages) {
                pkgSetting.setEnabled(newState, userId, callingPackage);
            }
            synchronized (this.mPackages) {
                immediatelyWritePackageRestrictionsLocked(userId);
                updateSequenceNumberLP(pkgSetting, new int[]{userId});
                callingId = Binder.clearCallingIdentity();
                try {
                    updateInstantAppInstallerLocked(packageName);
                    Binder.restoreCallingIdentity(callingId);
                    components = this.mPendingBroadcasts.get(userId, packageName);
                    boolean newPackage2 = components == null;
                    if (newPackage2) {
                        components = new ArrayList();
                    }
                    if (!components.contains(componentName)) {
                        components.add(componentName);
                    }
                    if ((flags & 1) == 0) {
                        sendNow = true;
                        this.mPendingBroadcasts.remove(userId, packageName);
                    } else {
                        if (newPackage2) {
                            this.mPendingBroadcasts.put(userId, packageName, components);
                        }
                        if (!this.mHandler.hasMessages(1)) {
                            this.mHandler.sendEmptyMessageDelayed(1, 10000);
                        }
                    }
                } catch (Throwable th22) {
                    Binder.restoreCallingIdentity(callingId);
                }
            }
            callingId = Binder.clearCallingIdentity();
            if (sendNow) {
                try {
                    sendOppoPackageChangedBroadcast(packageName, (flags & 1) != 0, components, UserHandle.getUid(userId, pkgSetting.appId), pid);
                } catch (Throwable th32) {
                    Binder.restoreCallingIdentity(callingId);
                }
            }
            Binder.restoreCallingIdentity(callingId);
            return;
        }
        if (th != null) {
            throw th;
        } else {
            synchronized (this.mPackages) {
                this.mSettings.disableSystemPackageLPw(deletedPkg.packageName, true);
                this.mSettings.writeLPr();
                return;
            }
        }
        if (th4 == null) {
            clearAppDataLIF(newPkg, -1, UsbTerminalTypes.TERMINAL_IN_PERSONAL_MIC);
            clearAppProfilesLIF(newPkg, -1);
            this.mDexManager.notifyPackageUpdated(newPkg.packageName, newPkg.baseCodePath, newPkg.splitCodePaths);
            if (newState == 0 || newState == 1) {
                callingPackage = null;
            }
            synchronized (this.mPackages) {
                pkgSetting.setEnabled(newState, userId, callingPackage);
            }
            synchronized (this.mPackages) {
                immediatelyWritePackageRestrictionsLocked(userId);
                updateSequenceNumberLP(pkgSetting, new int[]{userId});
                callingId = Binder.clearCallingIdentity();
                try {
                    updateInstantAppInstallerLocked(packageName);
                    Binder.restoreCallingIdentity(callingId);
                    components = this.mPendingBroadcasts.get(userId, packageName);
                    boolean newPackage22 = components == null;
                    if (newPackage22) {
                        components = new ArrayList();
                    }
                    if (!components.contains(componentName)) {
                        components.add(componentName);
                    }
                    if ((flags & 1) == 0) {
                        sendNow = true;
                        this.mPendingBroadcasts.remove(userId, packageName);
                    } else {
                        if (newPackage22) {
                            this.mPendingBroadcasts.put(userId, packageName, components);
                        }
                        if (!this.mHandler.hasMessages(1)) {
                            this.mHandler.sendEmptyMessageDelayed(1, 10000);
                        }
                    }
                } catch (Throwable th222) {
                    Binder.restoreCallingIdentity(callingId);
                }
            }
            callingId = Binder.clearCallingIdentity();
            if (sendNow) {
                try {
                    sendOppoPackageChangedBroadcast(packageName, (flags & 1) != 0, components, UserHandle.getUid(userId, pkgSetting.appId), pid);
                } catch (Throwable th322) {
                    Binder.restoreCallingIdentity(callingId);
                }
            }
            Binder.restoreCallingIdentity(callingId);
            return;
        }
        try {
            throw th4;
        } catch (Throwable e2) {
            Slog.w(TAG, "Failed to install compressed system package:" + pkgSetting.name, e2);
            removeCodePathLI(codePath);
            th = null;
            packageFreezer = null;
            try {
                packageFreezer = freezePackage(deletedPkg.packageName, "setEnabledSetting");
                synchronized (this.mPackages) {
                    enableSystemPackageLPw(deletedPkg);
                    installPackageFromSystemLIF(new File(deletedPkg.codePath), false, null, 0, 0, true);
                    if (packageFreezer != null) {
                        packageFreezer.close();
                    }
                }
            } catch (Throwable th62) {
                Throwable th72 = th62;
                if (packageFreezer != null) {
                    try {
                        packageFreezer.close();
                    } catch (Throwable th82) {
                        if (th == null) {
                            th = th82;
                        } else if (th != th82) {
                            th.addSuppressed(th82);
                        }
                    }
                }
                if (th != null) {
                    throw th;
                } else {
                    throw th72;
                }
            }
        } catch (Throwable pme2) {
            try {
                Slog.w(TAG, "Failed to restore system package:" + deletedPkg.packageName, pme2);
                synchronized (this.mPackages) {
                    this.mSettings.disableSystemPackageLPw(deletedPkg.packageName, true);
                    this.mSettings.writeLPr();
                    return;
                }
            } catch (Throwable th92) {
                synchronized (this.mPackages) {
                    this.mSettings.disableSystemPackageLPw(deletedPkg.packageName, true);
                    this.mSettings.writeLPr();
                }
            }
        } catch (Throwable th102) {
            th = th102;
        }
    }

    public void flushPackageRestrictionsAsUser(int userId) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && sUserManager.exists(userId)) {
            enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "flushPackageRestrictions");
            synchronized (this.mPackages) {
                this.mSettings.writePackageRestrictionsLPr(userId);
                this.mDirtyUsers.remove(Integer.valueOf(userId));
                if (this.mDirtyUsers.isEmpty()) {
                    this.mHandler.removeMessages(14);
                }
            }
        }
    }

    private void sendPackageChangedBroadcast(String packageName, boolean killFlag, ArrayList<String> componentNames, int packageUid) {
        if (DEBUG_INSTALL) {
            Log.v(TAG, "Sending package changed: package=" + packageName + " components=" + componentNames);
        }
        Bundle extras = new Bundle(4);
        extras.putString("android.intent.extra.changed_component_name", (String) componentNames.get(0));
        String[] nameList = new String[componentNames.size()];
        componentNames.toArray(nameList);
        extras.putStringArray("android.intent.extra.changed_component_name_list", nameList);
        extras.putBoolean("android.intent.extra.DONT_KILL_APP", killFlag);
        extras.putInt("android.intent.extra.UID", packageUid);
        sendPackageBroadcast("android.intent.action.PACKAGE_CHANGED", packageName, extras, !componentNames.contains(packageName) ? 1073741824 : 0, null, null, new int[]{UserHandle.getUserId(packageUid)});
    }

    public void setPackageStoppedState(String packageName, boolean stopped, int userId) {
        if (sUserManager.exists(userId)) {
            int callingUid = Binder.getCallingUid();
            if (getInstantAppPackageName(callingUid) == null) {
                boolean allowedByPermission = this.mContext.checkCallingOrSelfPermission("android.permission.CHANGE_COMPONENT_ENABLED_STATE") == 0;
                enforceCrossUserPermission(callingUid, userId, true, true, "stop package");
                synchronized (this.mPackages) {
                    if (!filterAppAccessLPr((PackageSetting) this.mSettings.mPackages.get(packageName), callingUid, userId) && this.mSettings.setPackageStoppedStateLPw(this, packageName, stopped, allowedByPermission, callingUid, userId)) {
                        scheduleWritePackageRestrictionsLocked(userId);
                    }
                }
            }
        }
    }

    public String getInstallerPackageName(String packageName) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            if (filterAppAccessLPr((PackageSetting) this.mSettings.mPackages.get(packageName), callingUid, UserHandle.getUserId(callingUid))) {
                return null;
            }
            String installerPackageNameLPr = this.mSettings.getInstallerPackageNameLPr(packageName);
            return installerPackageNameLPr;
        }
    }

    public boolean isOrphaned(String packageName) {
        boolean isOrphaned;
        synchronized (this.mPackages) {
            isOrphaned = this.mSettings.isOrphaned(packageName);
        }
        return isOrphaned;
    }

    public int getApplicationEnabledSetting(String packageName, int userId) {
        if (!sUserManager.exists(userId)) {
            return 2;
        }
        int callingUid = Binder.getCallingUid();
        enforceCrossUserPermission(callingUid, userId, false, false, "get enabled");
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.getPackageLPr(packageName), callingUid, userId)) {
                return 2;
            }
            int applicationEnabledSettingLPr = this.mSettings.getApplicationEnabledSettingLPr(packageName, userId);
            return applicationEnabledSettingLPr;
        }
    }

    public int getComponentEnabledSetting(ComponentName component, int userId) {
        if (!sUserManager.exists(userId)) {
            return 2;
        }
        int callingUid = Binder.getCallingUid();
        enforceCrossUserPermission(callingUid, userId, false, false, "getComponentEnabled");
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.getPackageLPr(component.getPackageName()), callingUid, component, 0, userId)) {
                return 2;
            }
            int componentEnabledSettingLPr = this.mSettings.getComponentEnabledSettingLPr(component, userId);
            return componentEnabledSettingLPr;
        }
    }

    public void enterSafeMode() {
        enforceSystemOrRoot("Only the system can request entering safe mode");
        if (!this.mSystemReady) {
            this.mSafeMode = true;
        }
    }

    public void systemReady() {
        enforceSystemOrRoot("Only the system can claim the system is ready");
        this.mSystemReady = true;
        final ContentResolver contentResolver = this.mContext.getContentResolver();
        ContentObserver co = new ContentObserver(this.mHandler) {
            public void onChange(boolean selfChange) {
                boolean z = true;
                PackageManagerService packageManagerService = PackageManagerService.this;
                if (!(Global.getInt(contentResolver, "enable_ephemeral_feature", 1) == 0 || Secure.getInt(contentResolver, "instant_apps_enabled", 1) == 0)) {
                    z = false;
                }
                packageManagerService.mEphemeralAppsDisabled = z;
            }
        };
        this.mContext.getContentResolver().registerContentObserver(Global.getUriFor("enable_ephemeral_feature"), false, co, 0);
        this.mContext.getContentResolver().registerContentObserver(Global.getUriFor("instant_apps_enabled"), false, co, 0);
        co.onChange(true);
        CarrierAppUtils.disableCarrierAppsUntilPrivileged(this.mContext.getOpPackageName(), this, this.mContext.getContentResolver(), 0);
        boolean compatibilityModeEnabled = Global.getInt(this.mContext.getContentResolver(), "compatibility_mode", 1) == 1;
        PackageParser.setCompatibilityModeEnabled(compatibilityModeEnabled);
        if (DEBUG_SETTINGS) {
            Log.d(TAG, "compatibility mode:" + compatibilityModeEnabled);
        }
        int[] grantPermissionsUserIds = EMPTY_INT_ARRAY;
        synchronized (this.mPackages) {
            ArrayList<PreferredActivity> removed = new ArrayList();
            for (int i = 0; i < this.mSettings.mPreferredActivities.size(); i++) {
                PreferredActivity pa;
                PreferredIntentResolver pir = (PreferredIntentResolver) this.mSettings.mPreferredActivities.valueAt(i);
                removed.clear();
                for (PreferredActivity pa2 : pir.filterSet()) {
                    if (this.mActivities.mActivities.get(pa2.mPref.mComponent) == null) {
                        removed.add(pa2);
                    }
                }
                if (removed.size() > 0) {
                    for (int r = 0; r < removed.size(); r++) {
                        pa2 = (PreferredActivity) removed.get(r);
                        Slog.w(TAG, "Removing dangling preferred activity: " + pa2.mPref.mComponent);
                        pir.removeFilter(pa2);
                    }
                    this.mSettings.writePackageRestrictionsLPr(this.mSettings.mPreferredActivities.keyAt(i));
                }
            }
            for (int userId : UserManagerService.getInstance().getUserIds()) {
                if (!this.mSettings.areDefaultRuntimePermissionsGrantedLPr(userId)) {
                    grantPermissionsUserIds = ArrayUtils.appendInt(grantPermissionsUserIds, userId);
                }
            }
        }
        sUserManager.systemReady();
        for (int userId2 : grantPermissionsUserIds) {
            this.mDefaultPermissionPolicy.grantDefaultPermissions(userId2);
        }
        boolean supportRuntimeAlert = hasSystemFeature("oppo.runtime.permission.alert.support", 0);
        this.mDefaultPermissionPolicy.grantOppoFixRuntimePermssion(0, supportRuntimeAlert);
        if (supportRuntimeAlert) {
            this.mDefaultPermissionPolicy.grantOppoNonFixRuntimePermssion(0, supportRuntimeAlert);
        } else {
            this.mDefaultPermissionPolicy.grantNonFixedPermToOtherSystemApps(0);
        }
        if (supportRuntimeAlert) {
            for (int userId22 : UserManagerService.getInstance().getUserIds()) {
                try {
                    UserInfo info = sUserManager.getUserInfo(userId22);
                    if (info != null && info.isManagedProfile()) {
                        Slog.d(TAG, "PMS start grant runtime for managed profile user " + userId22);
                        this.mDefaultPermissionPolicy.grantOppoFixRuntimePermssion(userId22, supportRuntimeAlert);
                        this.mDefaultPermissionPolicy.grantOppoNonFixRuntimePermssion(userId22, supportRuntimeAlert);
                    }
                } catch (Exception e) {
                }
            }
        }
        if (grantPermissionsUserIds == EMPTY_INT_ARRAY) {
            this.mDefaultPermissionPolicy.scheduleReadDefaultPermissionExceptions();
        }
        if (this.mPostSystemReadyMessages != null) {
            for (Message msg : this.mPostSystemReadyMessages) {
                msg.sendToTarget();
            }
            this.mPostSystemReadyMessages = null;
        }
        this.mOppoAppScaleHelper.initUpdateBroadcastReceiver();
        this.mOppoDPSHelper.initUpdateBroadcastReceiver();
        if (ColorPackageManagerHelper.dataAppContainCtsPkgBySig(this)) {
            this.mIsCtsAppInstall = true;
        }
        if (hasSystemFeature(OPPO_SECURITYPAY_FEATURE, 0)) {
            Slog.i(TAG, "start init SandboxApp ");
            ColorSecurePayManager.getInstance().monitorSecurePay();
        }
        mCompatibilityHelper.initUpdateBroadcastReceiver();
        ((StorageManager) this.mContext.getSystemService(StorageManager.class)).registerListener(this.mStorageListener);
        this.mInstallerService.systemReady();
        this.mPackageDexOptimizer.systemReady();
        ((StorageManagerInternal) LocalServices.getService(StorageManagerInternal.class)).addExternalStoragePolicy(new ExternalStorageMountPolicy() {
            public int getMountMode(int uid, String packageName) {
                if (Process.isIsolated(uid)) {
                    return 0;
                }
                if (PackageManagerService.this.checkUidPermission("android.permission.WRITE_MEDIA_STORAGE", uid) == 0 || PackageManagerService.this.checkUidPermission("android.permission.READ_EXTERNAL_STORAGE", uid) == -1) {
                    return 1;
                }
                if (PackageManagerService.this.checkUidPermission("android.permission.WRITE_EXTERNAL_STORAGE", uid) == -1) {
                    return 2;
                }
                return 3;
            }

            public boolean hasExternalStorage(int uid, String packageName) {
                return true;
            }
        });
        sUserManager.reconcileUsers(StorageManager.UUID_PRIVATE_INTERNAL);
        reconcileApps(StorageManager.UUID_PRIVATE_INTERNAL);
        this.mLowRamFeature = hasSystemFeature(OPPO_LOWRAM_FEATURE, 0);
        this.mHandler.post(this.mReadSystemDefaultApp);
        if (!this.mLowRamFeature) {
            IntentFilter intentFilterSkinChanged = new IntentFilter();
            intentFilterSkinChanged.addAction("oppo.intent.action.SKIN_CHANGED");
            this.mContext.registerReceiver(this.mSkinChangedReceiver, intentFilterSkinChanged);
        }
        if (EXP_VERSION) {
            this.mBlackAppInstallHelper = new BlackAppInstallHelper(this.mContext);
            this.mBlackAppInstallHelper.initUpdateBroadcastReceiver();
        }
        if (this.mPrivappPermissionsViolations != null) {
            Slog.wtf(TAG, "Signature|privileged permissions not in privapp-permissions whitelist: " + this.mPrivappPermissionsViolations);
            this.mPrivappPermissionsViolations = null;
        }
    }

    public void waitForAppDataPrepared() {
        if (this.mPrepareAppDataFuture != null) {
            ConcurrentUtils.waitForFutureNoInterrupt(this.mPrepareAppDataFuture, "wait for prepareAppData");
            this.mPrepareAppDataFuture = null;
        }
    }

    private void onPackageAdded(String packageName) {
        if (!this.mLowRamFeature && !TextUtils.isEmpty(packageName) && !this.mThemeIconsChanged) {
            try {
                Drawable cacheIcon = getApplicationInfo(packageName, 0, this.mContext.getUserId()).loadIcon(this.mContext.getPackageManager());
                int h = (((int) this.mContext.getResources().getDimension(17104896)) * 3) / 4;
                int w = h;
                int width = cacheIcon.getIntrinsicWidth();
                int height = cacheIcon.getIntrinsicHeight();
                int maxCacheNum = ColorPackageManagerHelper.getIconCacheMaxNum();
                Bitmap bitmap = drawableToBitmap(cacheIcon);
                if (bitmap != null) {
                    if (mAppIconsCache.size() < maxCacheNum) {
                        mAppIconsCache.put(packageName, bitmap);
                    }
                    Matrix matrix = new Matrix();
                    matrix.postScale(((float) h) / ((float) width), ((float) h) / ((float) height));
                    Bitmap newbmp = Bitmap.createBitmap(bitmap, 0, 0, width, height, matrix, true);
                    if (mAppIconsCacheCompress.size() < maxCacheNum) {
                        mAppIconsCacheCompress.put(packageName, newbmp);
                    }
                    Log.i(TAG, "add appIconsCache:" + packageName);
                }
                if (mActivityIconsCache.size() < maxCacheNum) {
                    cacheActivityIconsData(packageName);
                }
            } catch (Exception e) {
                Log.e(TAG, "add appIconsCache failed!" + packageName + e.getMessage());
            }
        }
    }

    private void onPackageRemoved(String packageName) {
        if (!TextUtils.isEmpty(packageName)) {
            try {
                if (mAppIconsCache.get(packageName) != null) {
                    mAppIconsCache.remove(packageName);
                }
                if (mAppIconsCacheCompress.get(packageName) != null) {
                    mAppIconsCacheCompress.remove(packageName);
                }
                ArrayList<String> deleteList = new ArrayList();
                for (Entry entry : mActivityIconsCache.entrySet()) {
                    String key = (String) entry.getKey();
                    if (packageName.equals(key.split("/")[0])) {
                        deleteList.add(key);
                    }
                }
                for (String deleteName : deleteList) {
                    mActivityIconsCache.remove(deleteName);
                }
                Log.d(TAG, "remove appIconsCache:" + packageName);
                for (Entry entryObserver : this.mPackageDeleteList.entrySet()) {
                    final IPackageDeleteObserver observer = (IPackageDeleteObserver) entryObserver.getValue();
                    try {
                        new IPackageDeleteObserver.Stub() {
                            public void packageDeleted(String packageName, int returnCode) {
                                if (observer != null) {
                                    try {
                                        observer.packageDeleted(packageName, returnCode);
                                    } catch (RemoteException e) {
                                    }
                                }
                            }
                        }.packageDeleted(packageName, 1);
                    } catch (RemoteException re) {
                        re.printStackTrace();
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    private void cacheAppIconsData() {
        if (!this.mLowRamFeature) {
            if (this.mThemeIconsChanged) {
                Log.d(TAG, "cacheAppIconsData. The theme icons file has changed! Not to cache.");
                return;
            }
            Log.d(TAG, "cacheAppIconsData. start");
            try {
                PackageManager pm = this.mContext.getPackageManager();
                List<PackageInfo> apps = getInstalledPackages(0, this.mContext.getUserId()).getList();
                int h = (((int) this.mContext.getResources().getDimension(17104896)) * 3) / 4;
                int w = h;
                int num = 0;
                int maxCacheNum = ColorPackageManagerHelper.getIconCacheMaxNum();
                if (maxCacheNum != 0) {
                    this.mThemeIconsFileObserver.startWatching();
                    Iterator app$iterator = apps.iterator();
                    while (true) {
                        int num2 = num;
                        if (!app$iterator.hasNext()) {
                            num = num2;
                            break;
                        }
                        PackageInfo app = (PackageInfo) app$iterator.next();
                        if (this.mThemeIconsChanged) {
                            Log.d(TAG, "cacheAppIconsData. The theme icons file has changed!");
                            mAppIconsCache.clear();
                            mAppIconsCacheCompress.clear();
                            num = num2;
                            break;
                        }
                        try {
                            Drawable cacheIcon = app.applicationInfo.loadIcon(pm);
                            int width = cacheIcon.getIntrinsicWidth();
                            int height = cacheIcon.getIntrinsicHeight();
                            Bitmap bitmap = drawableToBitmap(cacheIcon);
                            if (bitmap != null) {
                                mAppIconsCache.put(app.packageName, bitmap);
                                Matrix matrix = new Matrix();
                                matrix.postScale(((float) h) / ((float) width), ((float) h) / ((float) height));
                                mAppIconsCacheCompress.put(app.packageName, Bitmap.createBitmap(bitmap, 0, 0, width, height, matrix, true));
                                num = num2 + 1;
                                if (num2 >= maxCacheNum) {
                                    break;
                                }
                            } else {
                                num = num2;
                            }
                        } catch (Exception e) {
                            Slog.e(TAG, "init appIconsCache!" + e.getMessage());
                            num = num2;
                        }
                    }
                    Slog.d(TAG, "cached appIconsCache num:" + num);
                    this.mThemeIconsFileObserver.stopWatching();
                    Log.d(TAG, "cacheAppIconsData. end");
                }
            } catch (Exception e2) {
                Slog.e(TAG, "init appIconsCache failed!" + e2.getMessage());
                e2.printStackTrace();
            }
        }
    }

    public static Bitmap drawableToBitmap(Drawable drawable) {
        if (!(drawable instanceof BitmapDrawable)) {
            return null;
        }
        BitmapDrawable bitmapDrawable = (BitmapDrawable) drawable;
        if (bitmapDrawable.getBitmap() != null) {
            return bitmapDrawable.getBitmap();
        }
        Bitmap bitmap;
        if (drawable.getIntrinsicWidth() <= 0 || drawable.getIntrinsicHeight() <= 0) {
            bitmap = Bitmap.createBitmap(1, 1, Config.ARGB_8888);
        } else {
            bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), Config.ARGB_8888);
        }
        Canvas canvas = new Canvas(bitmap);
        drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());
        drawable.draw(canvas);
        return bitmap;
    }

    private void cacheActivityIconsData(String packageName) {
        if (!this.mLowRamFeature) {
            if (this.mThemeIconsChanged) {
                Log.d(TAG, "cacheActivityIconsData. The theme icons file has changed! Not to cache.");
                return;
            }
            Log.d(TAG, "cacheActivityIconsData. start");
            try {
                List<LauncherActivityInfo> installApps = ((LauncherApps) this.mContext.getSystemService("launcherapps")).getActivityList(packageName, UserHandle.OWNER);
                int densityDpi = this.mContext.getResources().getDisplayMetrics().densityDpi;
                int count = 0;
                int maxCacheNum = ColorPackageManagerHelper.getIconCacheMaxNum();
                if (maxCacheNum != 0) {
                    this.mThemeIconsFileObserver.startWatching();
                    for (LauncherActivityInfo launcherActivityInfo : installApps) {
                        if (this.mThemeIconsChanged) {
                            Log.d(TAG, "cacheActivityIconsData. The theme icons file has changed!");
                            mActivityIconsCache.clear();
                            break;
                        }
                        try {
                            ComponentName componentName = launcherActivityInfo.getComponentName();
                            String keyName = componentName.getPackageName() + "/" + componentName.getClassName();
                            Bitmap bitmap = drawableToBitmap(launcherActivityInfo.getBadgedIcon(densityDpi));
                            if (bitmap != null) {
                                mActivityIconsCache.put(keyName, bitmap);
                                count++;
                                if (count >= maxCacheNum) {
                                    break;
                                }
                            } else {
                                continue;
                            }
                        } catch (Exception ex) {
                            Slog.e(TAG, "init activityIconsCache!" + ex.getMessage());
                        }
                    }
                    this.mThemeIconsFileObserver.stopWatching();
                    Log.d(TAG, "cacheActivityIconsData. end");
                }
            } catch (Exception e) {
                Slog.e(TAG, "init activityIconsCache failed!" + e.getMessage());
            }
        }
    }

    public boolean isSafeMode() {
        return this.mSafeMode;
    }

    public boolean hasSystemUidErrors() {
        return this.mHasSystemUidErrors;
    }

    static String arrayToString(int[] array) {
        StringBuffer buf = new StringBuffer(128);
        buf.append('[');
        if (array != null) {
            for (int i = 0; i < array.length; i++) {
                if (i > 0) {
                    buf.append(", ");
                }
                buf.append(array[i]);
            }
        }
        buf.append(']');
        return buf.toString();
    }

    public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err, String[] args, ShellCallback callback, ResultReceiver resultReceiver) {
        new PackageManagerShellCommand(this).exec(this, in, out, err, args, callback, resultReceiver);
    }

    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
        BufferedReader in;
        AutoCloseable in2;
        Throwable th;
        if (DumpUtils.checkDumpAndUsageStatsPermission(this.mContext, TAG, pw)) {
            int user;
            DumpState dumpState = new DumpState();
            boolean fullPreferred = false;
            boolean checkin = false;
            String packageName = null;
            ArraySet<String> permissionNames = null;
            int opti = 0;
            while (opti < args.length) {
                String opt = args[opti];
                if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
                    break;
                }
                opti++;
                if (!"-a".equals(opt)) {
                    if ("-h".equals(opt)) {
                        pw.println("Package manager dump options:");
                        pw.println("  [-h] [-f] [--checkin] [cmd] ...");
                        pw.println("    --checkin: dump for a checkin");
                        pw.println("    -f: print details of intent filters");
                        pw.println("    -h: print this help");
                        pw.println("  cmd may be one of:");
                        pw.println("    l[ibraries]: list known shared libraries");
                        pw.println("    f[eatures]: list device features");
                        pw.println("    k[eysets]: print known keysets");
                        pw.println("    r[esolvers] [activity|service|receiver|content]: dump intent resolvers");
                        pw.println("    perm[issions]: dump permissions");
                        pw.println("    permission [name ...]: dump declaration and use of given permission");
                        pw.println("    pref[erred]: print preferred package settings");
                        pw.println("    preferred-xml [--full]: print preferred package settings as xml");
                        pw.println("    prov[iders]: dump content providers");
                        pw.println("    p[ackages]: dump installed packages");
                        pw.println("    s[hared-users]: dump shared user IDs");
                        pw.println("    m[essages]: print collected runtime messages");
                        pw.println("    v[erifiers]: print package verifier info");
                        pw.println("    d[omain-preferred-apps]: print domains preferred apps");
                        pw.println("    i[ntent-filter-verifiers]|ifv: print intent filter verifier info");
                        pw.println("    version: print database version info");
                        pw.println("    write: write current settings now");
                        pw.println("    installs: details about install sessions");
                        pw.println("    check-permission <permission> <package> [<user>]: does pkg hold perm?");
                        pw.println("    dexopt: dump dexopt state");
                        pw.println("    compiler-stats: dump compiler statistics");
                        pw.println("    enabled-overlays: dump list of enabled overlay packages");
                        pw.println("    <package.name>: info about given package");
                        return;
                    } else if ("--checkin".equals(opt)) {
                        checkin = true;
                    } else if ("-f".equals(opt)) {
                        dumpState.setOptionEnabled(1);
                    } else if ("--proto".equals(opt)) {
                        dumpProto(fd);
                        return;
                    } else {
                        pw.println("Unknown argument: " + opt + "; use -h for help");
                    }
                }
            }
            if (opti < args.length) {
                String cmd = args[opti];
                opti++;
                if (!PLATFORM_PACKAGE_NAME.equals(cmd)) {
                    if (!cmd.contains(".")) {
                        if ("check-permission".equals(cmd)) {
                            if (opti >= args.length) {
                                pw.println("Error: check-permission missing permission argument");
                                return;
                            }
                            String perm = args[opti];
                            opti++;
                            if (opti >= args.length) {
                                pw.println("Error: check-permission missing package argument");
                                return;
                            }
                            String pkg = args[opti];
                            opti++;
                            user = UserHandle.getUserId(Binder.getCallingUid());
                            if (opti < args.length) {
                                try {
                                    user = Integer.parseInt(args[opti]);
                                } catch (NumberFormatException e) {
                                    pw.println("Error: check-permission user argument is not a number: " + args[opti]);
                                    return;
                                }
                            }
                            pw.println(checkPermission(perm, resolveInternalPackageNameLPr(pkg, -1), user));
                            return;
                        } else if ("l".equals(cmd) || "libraries".equals(cmd)) {
                            dumpState.setDump(1);
                        } else if (OppoCrashClearManager.FEATURE.equals(cmd) || "features".equals(cmd)) {
                            dumpState.setDump(2);
                        } else if ("r".equals(cmd) || "resolvers".equals(cmd)) {
                            if (opti >= args.length) {
                                dumpState.setDump(60);
                            } else {
                                while (opti < args.length) {
                                    String name = args[opti];
                                    if ("a".equals(name) || OppoAppStartupManager.TYPE_ACTIVITY.equals(name)) {
                                        dumpState.setDump(4);
                                    } else if ("s".equals(name) || "service".equals(name)) {
                                        dumpState.setDump(8);
                                    } else if ("r".equals(name) || "receiver".equals(name)) {
                                        dumpState.setDump(16);
                                    } else if (OppoCrashClearManager.CLEAR_TIME.equals(name) || "content".equals(name)) {
                                        dumpState.setDump(32);
                                    } else {
                                        pw.println("Error: unknown resolver table type: " + name);
                                        return;
                                    }
                                    opti++;
                                }
                            }
                        } else if (TAG_PERMISSION.equals(cmd) || "permissions".equals(cmd)) {
                            dumpState.setDump(64);
                        } else if ("permission".equals(cmd)) {
                            if (opti >= args.length) {
                                pw.println("Error: permission requires permission name");
                                return;
                            }
                            permissionNames = new ArraySet();
                            while (opti < args.length) {
                                permissionNames.add(args[opti]);
                                opti++;
                            }
                            dumpState.setDump(448);
                        } else if ("pref".equals(cmd) || "preferred".equals(cmd)) {
                            dumpState.setDump(4096);
                        } else if ("preferred-xml".equals(cmd)) {
                            dumpState.setDump(8192);
                            if (opti < args.length && "--full".equals(args[opti])) {
                                fullPreferred = true;
                                opti++;
                            }
                        } else if ("d".equals(cmd) || "domain-preferred-apps".equals(cmd)) {
                            dumpState.setDump(262144);
                        } else if (OppoCrashClearManager.CRASH_CLEAR_NAME.equals(cmd) || "packages".equals(cmd)) {
                            dumpState.setDump(128);
                        } else if ("s".equals(cmd) || "shared-users".equals(cmd)) {
                            dumpState.setDump(256);
                        } else if ("prov".equals(cmd) || "providers".equals(cmd)) {
                            dumpState.setDump(1024);
                        } else if ("m".equals(cmd) || "messages".equals(cmd)) {
                            dumpState.setDump(512);
                        } else if ("v".equals(cmd) || "verifiers".equals(cmd)) {
                            dumpState.setDump(2048);
                        } else if ("i".equals(cmd) || "ifv".equals(cmd) || "intent-filter-verifiers".equals(cmd)) {
                            dumpState.setDump(131072);
                        } else if ("version".equals(cmd)) {
                            dumpState.setDump(32768);
                        } else if ("k".equals(cmd) || "keysets".equals(cmd)) {
                            dumpState.setDump(16384);
                        } else if ("installs".equals(cmd)) {
                            dumpState.setDump(65536);
                        } else if ("frozen".equals(cmd)) {
                            dumpState.setDump(524288);
                        } else if ("volumes".equals(cmd)) {
                            dumpState.setDump(DumpState.DUMP_VOLUMES);
                        } else if ("dexopt".equals(cmd)) {
                            dumpState.setDump(DumpState.DUMP_DEXOPT);
                        } else if ("compiler-stats".equals(cmd)) {
                            dumpState.setDump(DumpState.DUMP_COMPILER_STATS);
                        } else if ("changes".equals(cmd)) {
                            dumpState.setDump(DumpState.DUMP_CHANGES);
                        } else if ("write".equals(cmd)) {
                            synchronized (this.mPackages) {
                                this.mSettings.writeLPr();
                                pw.println("Settings written.");
                            }
                            return;
                        } else if ("whitelist".equals(cmd)) {
                            if (args.length == 1) {
                                pw.print(mCompatibilityHelper.dumpToString());
                                return;
                            }
                            mCompatibilityHelper.dump(pw, args, opti);
                            return;
                        } else if ("cpt".equals(cmd)) {
                            mCompatibilityHelper.dumpScheme(pw, args);
                            return;
                        } else if ("log".equals(cmd)) {
                            PackageManagerServiceDynamicLogConfig.dynamicallyConfigLogTag(this, pw, args, opti);
                            return;
                        } else if ("debug_switch".equals(cmd)) {
                            PackageManagerServiceDynamicLogConfig.dumpDynamicallyLogSwitch(this, pw, args, opti);
                            return;
                        }
                    }
                }
                packageName = cmd;
                dumpState.setOptionEnabled(1);
            }
            if (checkin) {
                pw.println("vers,1");
            }
            synchronized (this.mPackages) {
                int i;
                ActivityIntentResolver activityIntentResolver;
                String str;
                IndentingPrintWriter indentingPrintWriter;
                BufferedReader bufferedReader;
                String line;
                if (dumpState.isDumping(32768) && packageName == null && !checkin) {
                    if (dumpState.onTitlePrinted()) {
                        pw.println();
                    }
                    pw.println("Database versions:");
                    this.mSettings.dumpVersionLPr(new IndentingPrintWriter(pw, "  "));
                }
                if (dumpState.isDumping(2048) && packageName == null) {
                    if (!checkin) {
                        if (dumpState.onTitlePrinted()) {
                            pw.println();
                        }
                        pw.println("Verifiers:");
                        pw.print("  Required: ");
                        pw.print(this.mRequiredVerifierPackage);
                        pw.print(" (uid=");
                        pw.print(getPackageUid(this.mRequiredVerifierPackage, 268435456, 0));
                        pw.println(")");
                    } else if (this.mRequiredVerifierPackage != null) {
                        pw.print("vrfy,");
                        pw.print(this.mRequiredVerifierPackage);
                        pw.print(",");
                        pw.println(getPackageUid(this.mRequiredVerifierPackage, 268435456, 0));
                    }
                }
                if (dumpState.isDumping(131072) && packageName == null) {
                    if (this.mIntentFilterVerifierComponent != null) {
                        String verifierPackageName = this.mIntentFilterVerifierComponent.getPackageName();
                        if (!checkin) {
                            if (dumpState.onTitlePrinted()) {
                                pw.println();
                            }
                            pw.println("Intent Filter Verifier:");
                            pw.print("  Using: ");
                            pw.print(verifierPackageName);
                            pw.print(" (uid=");
                            pw.print(getPackageUid(verifierPackageName, 268435456, 0));
                            pw.println(")");
                        } else if (verifierPackageName != null) {
                            pw.print("ifv,");
                            pw.print(verifierPackageName);
                            pw.print(",");
                            pw.println(getPackageUid(verifierPackageName, 268435456, 0));
                        }
                    } else {
                        pw.println();
                        pw.println("No Intent Filter Verifier available!");
                    }
                }
                if (dumpState.isDumping(1) && packageName == null) {
                    boolean printedHeader = false;
                    for (String libName : this.mSharedLibraries.keySet()) {
                        SparseArray<SharedLibraryEntry> versionedLib = (SparseArray) this.mSharedLibraries.get(libName);
                        if (versionedLib != null) {
                            int versionCount = versionedLib.size();
                            for (i = 0; i < versionCount; i++) {
                                SharedLibraryEntry libEntry = (SharedLibraryEntry) versionedLib.valueAt(i);
                                if (checkin) {
                                    pw.print("lib,");
                                } else {
                                    if (!printedHeader) {
                                        if (dumpState.onTitlePrinted()) {
                                            pw.println();
                                        }
                                        pw.println("Libraries:");
                                        printedHeader = true;
                                    }
                                    pw.print("  ");
                                }
                                pw.print(libEntry.info.getName());
                                if (libEntry.info.isStatic()) {
                                    pw.print(" version=" + libEntry.info.getVersion());
                                }
                                if (!checkin) {
                                    pw.print(" -> ");
                                }
                                if (libEntry.path != null) {
                                    pw.print(" (jar) ");
                                    pw.print(libEntry.path);
                                } else {
                                    pw.print(" (apk) ");
                                    pw.print(libEntry.apk);
                                }
                                pw.println();
                            }
                        }
                    }
                }
                if (dumpState.isDumping(2) && packageName == null) {
                    if (dumpState.onTitlePrinted()) {
                        pw.println();
                    }
                    if (!checkin) {
                        pw.println("Features:");
                    }
                    synchronized (this.mAvailableFeatures) {
                        for (FeatureInfo feat : this.mAvailableFeatures.values()) {
                            if (checkin) {
                                pw.print("feat,");
                                pw.print(feat.name);
                                pw.print(",");
                                pw.println(feat.version);
                            } else {
                                pw.print("  ");
                                pw.print(feat.name);
                                if (feat.version > 0) {
                                    pw.print(" version=");
                                    pw.print(feat.version);
                                }
                                pw.println();
                            }
                        }
                    }
                }
                if (!checkin && dumpState.isDumping(4)) {
                    activityIntentResolver = this.mActivities;
                    if (dumpState.getTitlePrinted()) {
                        str = "\nActivity Resolver Table:";
                    } else {
                        str = "Activity Resolver Table:";
                    }
                    if (activityIntentResolver.dump(pw, str, "  ", packageName, dumpState.isOptionEnabled(1), true)) {
                        dumpState.setTitlePrinted(true);
                    }
                }
                if (!checkin && dumpState.isDumping(16)) {
                    activityIntentResolver = this.mReceivers;
                    if (dumpState.getTitlePrinted()) {
                        str = "\nReceiver Resolver Table:";
                    } else {
                        str = "Receiver Resolver Table:";
                    }
                    if (activityIntentResolver.dump(pw, str, "  ", packageName, dumpState.isOptionEnabled(1), true)) {
                        dumpState.setTitlePrinted(true);
                    }
                }
                if (!checkin && dumpState.isDumping(8)) {
                    ServiceIntentResolver serviceIntentResolver = this.mServices;
                    if (dumpState.getTitlePrinted()) {
                        str = "\nService Resolver Table:";
                    } else {
                        str = "Service Resolver Table:";
                    }
                    if (serviceIntentResolver.dump(pw, str, "  ", packageName, dumpState.isOptionEnabled(1), true)) {
                        dumpState.setTitlePrinted(true);
                    }
                }
                if (!checkin && dumpState.isDumping(32)) {
                    ProviderIntentResolver providerIntentResolver = this.mProviders;
                    if (dumpState.getTitlePrinted()) {
                        str = "\nProvider Resolver Table:";
                    } else {
                        str = "Provider Resolver Table:";
                    }
                    if (providerIntentResolver.dump(pw, str, "  ", packageName, dumpState.isOptionEnabled(1), true)) {
                        dumpState.setTitlePrinted(true);
                    }
                }
                if (!checkin && dumpState.isDumping(4096)) {
                    for (i = 0; i < this.mSettings.mPreferredActivities.size(); i++) {
                        PreferredIntentResolver pir = (PreferredIntentResolver) this.mSettings.mPreferredActivities.valueAt(i);
                        user = this.mSettings.mPreferredActivities.keyAt(i);
                        if (dumpState.getTitlePrinted()) {
                            str = "\nPreferred Activities User " + user + ":";
                        } else {
                            str = "Preferred Activities User " + user + ":";
                        }
                        if (pir.dump(pw, str, "  ", packageName, true, false)) {
                            dumpState.setTitlePrinted(true);
                        }
                    }
                }
                if (!checkin && dumpState.isDumping(8192)) {
                    pw.flush();
                    OutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(fd));
                    XmlSerializer serializer = new FastXmlSerializer();
                    try {
                        serializer.setOutput(bufferedOutputStream, StandardCharsets.UTF_8.name());
                        serializer.startDocument(null, Boolean.valueOf(true));
                        serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
                        this.mSettings.writePreferredActivitiesLPr(serializer, 0, fullPreferred);
                        serializer.endDocument();
                        serializer.flush();
                    } catch (IllegalArgumentException e2) {
                        pw.println("Failed writing: " + e2);
                    } catch (IllegalStateException e3) {
                        pw.println("Failed writing: " + e3);
                    } catch (IOException e4) {
                        pw.println("Failed writing: " + e4);
                    }
                }
                if (!checkin) {
                    if (dumpState.isDumping(262144) && packageName == null) {
                        pw.println();
                        if (this.mSettings.mPackages.size() == 0) {
                            pw.println("No applications!");
                            pw.println();
                        } else {
                            String prefix = "  ";
                            Collection<PackageSetting> allPackageSettings = this.mSettings.mPackages.values();
                            if (allPackageSettings.size() == 0) {
                                pw.println("No domain preferred apps!");
                                pw.println();
                            } else {
                                pw.println("App verification status:");
                                pw.println();
                                int count = 0;
                                for (PackageSetting ps : allPackageSettings) {
                                    IntentFilterVerificationInfo ivi = ps.getIntentFilterVerificationInfo();
                                    if (!(ivi == null || ivi.getPackageName() == null)) {
                                        pw.println("  Package: " + ivi.getPackageName());
                                        pw.println("  Domains: " + ivi.getDomainsString());
                                        pw.println("  Status:  " + ivi.getStatusString());
                                        pw.println();
                                        count++;
                                    }
                                }
                                if (count == 0) {
                                    pw.println("  No app verification established.");
                                    pw.println();
                                }
                                for (int userId : sUserManager.getUserIds()) {
                                    pw.println("App linkages for user " + userId + ":");
                                    pw.println();
                                    count = 0;
                                    for (PackageSetting ps2 : allPackageSettings) {
                                        long status = ps2.getDomainVerificationStatusForUser(userId);
                                        if ((status >> 32) != 0) {
                                            pw.println("  Package: " + ps2.name);
                                            pw.println("  Domains: " + dumpDomainString(ps2.name));
                                            pw.println("  Status:  " + IntentFilterVerificationInfo.getStatusStringFromValue(status));
                                            pw.println();
                                            count++;
                                        }
                                    }
                                    if (count == 0) {
                                        pw.println("  No configured app linkages.");
                                        pw.println();
                                    }
                                }
                            }
                        }
                    }
                }
                if (!checkin && dumpState.isDumping(64)) {
                    this.mSettings.dumpPermissionsLPr(pw, packageName, permissionNames, dumpState);
                    if (packageName == null && permissionNames == null) {
                        for (int iperm = 0; iperm < this.mAppOpPermissionPackages.size(); iperm++) {
                            if (iperm == 0) {
                                if (dumpState.onTitlePrinted()) {
                                    pw.println();
                                }
                                pw.println("AppOp Permissions:");
                            }
                            pw.print("  AppOp Permission ");
                            pw.print((String) this.mAppOpPermissionPackages.keyAt(iperm));
                            pw.println(":");
                            ArraySet<String> pkgs = (ArraySet) this.mAppOpPermissionPackages.valueAt(iperm);
                            for (int ipkg = 0; ipkg < pkgs.size(); ipkg++) {
                                pw.print("    ");
                                pw.println((String) pkgs.valueAt(ipkg));
                            }
                        }
                    }
                }
                if (!checkin && dumpState.isDumping(1024)) {
                    Provider p;
                    boolean printedSomething = false;
                    for (Provider p2 : this.mProviders.mProviders.values()) {
                        if (packageName == null || (packageName.equals(p2.info.packageName) ^ 1) == 0) {
                            if (!printedSomething) {
                                if (dumpState.onTitlePrinted()) {
                                    pw.println();
                                }
                                pw.println("Registered ContentProviders:");
                                printedSomething = true;
                            }
                            pw.print("  ");
                            p2.printComponentShortName(pw);
                            pw.println(":");
                            pw.print("    ");
                            pw.println(p2.toString());
                        }
                    }
                    printedSomething = false;
                    for (Entry<String, Provider> entry : this.mProvidersByAuthority.entrySet()) {
                        p2 = (Provider) entry.getValue();
                        if (packageName == null || (packageName.equals(p2.info.packageName) ^ 1) == 0) {
                            if (!printedSomething) {
                                if (dumpState.onTitlePrinted()) {
                                    pw.println();
                                }
                                pw.println("ContentProvider Authorities:");
                                printedSomething = true;
                            }
                            pw.print("  [");
                            pw.print((String) entry.getKey());
                            pw.println("]:");
                            pw.print("    ");
                            pw.println(p2.toString());
                            if (!(p2.info == null || p2.info.applicationInfo == null)) {
                                String appInfo = p2.info.applicationInfo.toString();
                                pw.print("      applicationInfo=");
                                pw.println(appInfo);
                            }
                        }
                    }
                }
                if (!checkin && dumpState.isDumping(16384)) {
                    this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName, dumpState);
                }
                if (dumpState.isDumping(128)) {
                    this.mSettings.dumpPackagesLPr(pw, packageName, permissionNames, dumpState, checkin);
                }
                if (dumpState.isDumping(256)) {
                    this.mSettings.dumpSharedUsersLPr(pw, packageName, permissionNames, dumpState, checkin);
                }
                if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                    if (dumpState.onTitlePrinted()) {
                        pw.println();
                    }
                    pw.println("Package Changes:");
                    pw.print("  Sequence number=");
                    pw.println(this.mChangedPackagesSequenceNumber);
                    int K = this.mChangedPackages.size();
                    for (i = 0; i < K; i++) {
                        SparseArray<String> changes = (SparseArray) this.mChangedPackages.valueAt(i);
                        pw.print("  User ");
                        pw.print(this.mChangedPackages.keyAt(i));
                        pw.println(":");
                        int N = changes.size();
                        if (N == 0) {
                            pw.print("    ");
                            pw.println("No packages changed");
                        } else {
                            for (int j = 0; j < N; j++) {
                                String pkgName = (String) changes.valueAt(j);
                                int sequenceNumber = changes.keyAt(j);
                                pw.print("    ");
                                pw.print("seq=");
                                pw.print(sequenceNumber);
                                pw.print(", package=");
                                pw.println(pkgName);
                            }
                        }
                    }
                }
                if (!checkin && dumpState.isDumping(64) && packageName == null) {
                    this.mSettings.dumpRestoredPermissionGrantsLPr(pw, dumpState);
                }
                if (!checkin && dumpState.isDumping(524288) && packageName == null) {
                    if (dumpState.onTitlePrinted()) {
                        pw.println();
                    }
                    indentingPrintWriter = new IndentingPrintWriter(pw, "  ", 120);
                    indentingPrintWriter.println();
                    indentingPrintWriter.println("Frozen packages:");
                    indentingPrintWriter.increaseIndent();
                    if (this.mFrozenPackages.size() == 0) {
                        indentingPrintWriter.println("(none)");
                    } else {
                        for (i = 0; i < this.mFrozenPackages.size(); i++) {
                            indentingPrintWriter.println((String) this.mFrozenPackages.valueAt(i));
                        }
                    }
                    indentingPrintWriter.decreaseIndent();
                }
                if (!checkin && dumpState.isDumping(DumpState.DUMP_VOLUMES) && packageName == null) {
                    if (dumpState.onTitlePrinted()) {
                        pw.println();
                    }
                    indentingPrintWriter = new IndentingPrintWriter(pw, "  ", 120);
                    indentingPrintWriter.println();
                    indentingPrintWriter.println("Loaded volumes:");
                    indentingPrintWriter.increaseIndent();
                    if (this.mLoadedVolumes.size() == 0) {
                        indentingPrintWriter.println("(none)");
                    } else {
                        for (i = 0; i < this.mLoadedVolumes.size(); i++) {
                            indentingPrintWriter.println((String) this.mLoadedVolumes.valueAt(i));
                        }
                    }
                    indentingPrintWriter.decreaseIndent();
                }
                if (!checkin && dumpState.isDumping(DumpState.DUMP_DEXOPT)) {
                    if (dumpState.onTitlePrinted()) {
                        pw.println();
                    }
                    dumpDexoptStateLPr(pw, packageName);
                }
                if (!checkin && dumpState.isDumping(DumpState.DUMP_COMPILER_STATS)) {
                    if (dumpState.onTitlePrinted()) {
                        pw.println();
                    }
                    dumpCompilerStatsLPr(pw, packageName);
                }
                if (!checkin && dumpState.isDumping(512) && packageName == null) {
                    if (dumpState.onTitlePrinted()) {
                        pw.println();
                    }
                    this.mSettings.dumpReadMessagesLPr(pw, dumpState);
                    pw.println();
                    pw.println("Package warning messages:");
                    in = null;
                    try {
                        bufferedReader = new BufferedReader(new FileReader(getSettingsProblemFile()));
                        while (true) {
                            try {
                                line = bufferedReader.readLine();
                                if (line == null) {
                                    break;
                                }
                                if (!line.contains("ignored: updated version")) {
                                    pw.println(line);
                                }
                            } catch (IOException e5) {
                                in2 = bufferedReader;
                                IoUtils.closeQuietly(in2);
                                in = null;
                                try {
                                    bufferedReader = new BufferedReader(new FileReader(getSettingsProblemFile()));
                                    while (true) {
                                        try {
                                            line = bufferedReader.readLine();
                                            if (line == null) {
                                                break;
                                            }
                                            if (!line.contains("ignored: updated version")) {
                                                pw.print("msg,");
                                                pw.println(line);
                                            }
                                        } catch (IOException e6) {
                                            in2 = bufferedReader;
                                            IoUtils.closeQuietly(in2);
                                            if (dumpState.onTitlePrinted()) {
                                                pw.println();
                                            }
                                            this.mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
                                        } catch (Throwable th2) {
                                            th = th2;
                                            in = bufferedReader;
                                            IoUtils.closeQuietly(in);
                                            throw th;
                                        }
                                    }
                                    IoUtils.closeQuietly(bufferedReader);
                                } catch (IOException e7) {
                                    IoUtils.closeQuietly(in2);
                                    if (dumpState.onTitlePrinted()) {
                                        pw.println();
                                    }
                                    this.mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
                                } catch (Throwable th3) {
                                    th = th3;
                                    IoUtils.closeQuietly(in);
                                    throw th;
                                }
                                if (dumpState.onTitlePrinted()) {
                                    pw.println();
                                }
                                this.mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
                            } catch (Throwable th4) {
                                th = th4;
                                in = bufferedReader;
                                IoUtils.closeQuietly(in);
                                throw th;
                            }
                        }
                        IoUtils.closeQuietly(bufferedReader);
                    } catch (IOException e8) {
                        IoUtils.closeQuietly(in2);
                        in = null;
                        bufferedReader = new BufferedReader(new FileReader(getSettingsProblemFile()));
                        while (true) {
                            try {
                                line = bufferedReader.readLine();
                                if (line == null) {
                                    break;
                                }
                                if (!line.contains("ignored: updated version")) {
                                    pw.print("msg,");
                                    pw.println(line);
                                }
                            } catch (IOException e62) {
                                in2 = bufferedReader;
                                IoUtils.closeQuietly(in2);
                                if (dumpState.onTitlePrinted()) {
                                    pw.println();
                                }
                                this.mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
                            } catch (Throwable th22) {
                                th = th22;
                                in = bufferedReader;
                                IoUtils.closeQuietly(in);
                                throw th;
                            }
                        }
                        IoUtils.closeQuietly(bufferedReader);
                        if (dumpState.onTitlePrinted()) {
                            pw.println();
                        }
                        this.mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
                    } catch (Throwable th5) {
                        th = th5;
                        IoUtils.closeQuietly(in);
                        throw th;
                    }
                }
                if (checkin && dumpState.isDumping(512)) {
                    in = null;
                    bufferedReader = new BufferedReader(new FileReader(getSettingsProblemFile()));
                    while (true) {
                        try {
                            line = bufferedReader.readLine();
                            if (line == null) {
                                break;
                            }
                            if (!line.contains("ignored: updated version")) {
                                pw.print("msg,");
                                pw.println(line);
                            }
                        } catch (IOException e622) {
                            in2 = bufferedReader;
                            IoUtils.closeQuietly(in2);
                            if (dumpState.onTitlePrinted()) {
                                pw.println();
                            }
                            this.mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
                        } catch (Throwable th222) {
                            th = th222;
                            in = bufferedReader;
                            IoUtils.closeQuietly(in);
                            throw th;
                        }
                    }
                    IoUtils.closeQuietly(bufferedReader);
                }
            }
            if (!checkin && dumpState.isDumping(65536) && packageName == null) {
                if (dumpState.onTitlePrinted()) {
                    pw.println();
                }
                this.mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
            }
        }
    }

    private void dumpProto(FileDescriptor fd) {
        ProtoOutputStream proto = new ProtoOutputStream(fd);
        synchronized (this.mPackages) {
            long requiredVerifierPackageToken = proto.start(1172526071809L);
            proto.write(1159641169921L, this.mRequiredVerifierPackage);
            proto.write(1112396529666L, getPackageUid(this.mRequiredVerifierPackage, 268435456, 0));
            proto.end(requiredVerifierPackageToken);
            if (this.mIntentFilterVerifierComponent != null) {
                String verifierPackageName = this.mIntentFilterVerifierComponent.getPackageName();
                long verifierPackageToken = proto.start(1172526071810L);
                proto.write(1159641169921L, verifierPackageName);
                proto.write(1112396529666L, getPackageUid(verifierPackageName, 268435456, 0));
                proto.end(verifierPackageToken);
            }
            dumpSharedLibrariesProto(proto);
            dumpFeaturesProto(proto);
            this.mSettings.dumpPackagesProto(proto);
            this.mSettings.dumpSharedUsersProto(proto);
            dumpMessagesProto(proto);
        }
        proto.flush();
    }

    private void dumpMessagesProto(ProtoOutputStream proto) {
        AutoCloseable in;
        Throwable th;
        BufferedReader in2 = null;
        try {
            BufferedReader in3 = new BufferedReader(new FileReader(getSettingsProblemFile()));
            while (true) {
                try {
                    String line = in3.readLine();
                    if (line == null) {
                        IoUtils.closeQuietly(in3);
                        return;
                    } else if (!line.contains("ignored: updated version")) {
                        proto.write(2259152797703L, line);
                    }
                } catch (IOException e) {
                    in = in3;
                    IoUtils.closeQuietly(in);
                } catch (Throwable th2) {
                    th = th2;
                    in2 = in3;
                    IoUtils.closeQuietly(in2);
                    throw th;
                }
            }
        } catch (IOException e2) {
            IoUtils.closeQuietly(in);
        } catch (Throwable th3) {
            th = th3;
            IoUtils.closeQuietly(in2);
            throw th;
        }
    }

    private void dumpFeaturesProto(ProtoOutputStream proto) {
        synchronized (this.mAvailableFeatures) {
            int count = this.mAvailableFeatures.size();
            for (int i = 0; i < count; i++) {
                FeatureInfo feat = (FeatureInfo) this.mAvailableFeatures.valueAt(i);
                long featureToken = proto.start(2272037699588L);
                proto.write(1159641169921L, feat.name);
                proto.write(1112396529666L, feat.version);
                proto.end(featureToken);
            }
        }
    }

    private void dumpSharedLibrariesProto(ProtoOutputStream proto) {
        int count = this.mSharedLibraries.size();
        for (int i = 0; i < count; i++) {
            SparseArray<SharedLibraryEntry> versionedLib = (SparseArray) this.mSharedLibraries.get((String) this.mSharedLibraries.keyAt(i));
            if (versionedLib != null) {
                int versionCount = versionedLib.size();
                for (int j = 0; j < versionCount; j++) {
                    SharedLibraryEntry libEntry = (SharedLibraryEntry) versionedLib.valueAt(j);
                    long sharedLibraryToken = proto.start(2272037699587L);
                    proto.write(1159641169921L, libEntry.info.getName());
                    boolean isJar = libEntry.path != null;
                    proto.write(1155346202626L, isJar);
                    if (isJar) {
                        proto.write(1159641169923L, libEntry.path);
                    } else {
                        proto.write(1159641169924L, libEntry.apk);
                    }
                    proto.end(sharedLibraryToken);
                }
            }
        }
    }

    private void dumpDexoptStateLPr(PrintWriter pw, String packageName) {
        IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ", 120);
        ipw.println();
        ipw.println("Dexopt state:");
        ipw.increaseIndent();
        Collection<Package> packages;
        if (packageName != null) {
            Package targetPackage = (Package) this.mPackages.get(packageName);
            if (targetPackage != null) {
                packages = Collections.singletonList(targetPackage);
            } else {
                ipw.println("Unable to find package: " + packageName);
                return;
            }
        }
        packages = this.mPackages.values();
        for (Package pkg : packages) {
            ipw.println("[" + pkg.packageName + "]");
            ipw.increaseIndent();
            this.mPackageDexOptimizer.dumpDexoptState(ipw, pkg, this.mDexManager.getPackageUseInfoOrDefault(pkg.packageName));
            ipw.decreaseIndent();
        }
    }

    private void dumpCompilerStatsLPr(PrintWriter pw, String packageName) {
        IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ", 120);
        ipw.println();
        ipw.println("Compiler stats:");
        ipw.increaseIndent();
        Collection<Package> packages;
        if (packageName != null) {
            Package targetPackage = (Package) this.mPackages.get(packageName);
            if (targetPackage != null) {
                packages = Collections.singletonList(targetPackage);
            } else {
                ipw.println("Unable to find package: " + packageName);
                return;
            }
        }
        packages = this.mPackages.values();
        for (Package pkg : packages) {
            ipw.println("[" + pkg.packageName + "]");
            ipw.increaseIndent();
            PackageStats stats = getCompilerPackageStats(pkg.packageName);
            if (stats == null) {
                ipw.println("(No recorded stats)");
            } else {
                stats.dump(ipw);
            }
            ipw.decreaseIndent();
        }
    }

    private String dumpDomainString(String packageName) {
        List<IntentFilterVerificationInfo> iviList = getIntentFilterVerifications(packageName).getList();
        List<IntentFilter> filters = getAllIntentFilters(packageName).getList();
        ArraySet<String> result = new ArraySet();
        if (iviList.size() > 0) {
            for (IntentFilterVerificationInfo ivi : iviList) {
                for (String host : ivi.getDomains()) {
                    result.add(host);
                }
            }
        }
        if (filters != null && filters.size() > 0) {
            for (IntentFilter filter : filters) {
                if (filter.hasCategory("android.intent.category.BROWSABLE") && (filter.hasDataScheme("http") || filter.hasDataScheme("https"))) {
                    result.addAll(filter.getHostsList());
                }
            }
        }
        StringBuilder sb = new StringBuilder(result.size() * 16);
        for (String domain : result) {
            if (sb.length() > 0) {
                sb.append(" ");
            }
            sb.append(domain);
        }
        return sb.toString();
    }

    static String getEncryptKey() {
        try {
            String sdEncKey = SystemKeyStore.getInstance().retrieveKeyHexString(SD_ENCRYPTION_KEYSTORE_NAME);
            if (sdEncKey == null) {
                sdEncKey = SystemKeyStore.getInstance().generateNewKeyHexString(128, SD_ENCRYPTION_ALGORITHM, SD_ENCRYPTION_KEYSTORE_NAME);
                if (sdEncKey == null) {
                    Slog.e(TAG, "Failed to create encryption keys");
                    return null;
                }
            }
            return sdEncKey;
        } catch (NoSuchAlgorithmException nsae) {
            Slog.e(TAG, "Failed to create encryption keys with exception: " + nsae);
            return null;
        } catch (IOException ioe) {
            Slog.e(TAG, "Failed to retrieve encryption keys with exception: " + ioe);
            return null;
        }
    }

    public void updateExternalMediaStatus(final boolean mediaStatus, final boolean reportStatus) {
        enforceSystemOrRoot("Media status can only be updated by the system");
        synchronized (this.mPackages) {
            Log.i(TAG, "Updating external media status from " + (this.mMediaMounted ? "mounted" : "unmounted") + " to " + (mediaStatus ? "mounted" : "unmounted"));
            if (DEBUG_SD_INSTALL) {
                Log.i(TAG, "updateExternalMediaStatus:: mediaStatus=" + mediaStatus + ", mMediaMounted=" + this.mMediaMounted);
            }
            if (mediaStatus == this.mMediaMounted) {
                int i;
                PackageHandler packageHandler = this.mHandler;
                if (reportStatus) {
                    i = 1;
                } else {
                    i = 0;
                }
                this.mHandler.sendMessage(packageHandler.obtainMessage(12, i, -1));
                return;
            }
            this.mMediaMounted = mediaStatus;
            this.mHandler.post(new Runnable() {
                public void run() {
                    PackageManagerService.this.updateExternalMediaStatusInner(mediaStatus, reportStatus, true);
                }
            });
        }
    }

    public void scanAvailableAsecs() {
        updateExternalMediaStatusInner(true, false, false);
    }

    private void updateExternalMediaStatusInner(boolean isMounted, boolean reportStatus, boolean externalStorage) {
        ArrayMap<AsecInstallArgs, String> processCids = new ArrayMap();
        int[] uidArr = EmptyArray.INT;
        String[] list = PackageHelper.getSecureContainerList();
        if (ArrayUtils.isEmpty(list)) {
            Log.i(TAG, "No secure containers found");
        } else {
            synchronized (this.mPackages) {
                for (String cid : list) {
                    if (!PackageInstallerService.isStageName(cid)) {
                        if (DEBUG_SD_INSTALL) {
                            Log.i(TAG, "Processing container " + cid);
                        }
                        String pkgName = getAsecPackageName(cid);
                        if (pkgName == null) {
                            Slog.i(TAG, "Found stale container " + cid + " with no package name");
                        } else {
                            if (DEBUG_SD_INSTALL) {
                                Log.i(TAG, "Looking for pkg : " + pkgName);
                            }
                            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(pkgName);
                            if (ps == null) {
                                Slog.i(TAG, "Found stale container " + cid + " with no matching settings");
                            } else if (!externalStorage || (isMounted ^ 1) == 0 || (isExternal(ps) ^ 1) == 0) {
                                AsecInstallArgs args = new AsecInstallArgs(cid, InstructionSets.getAppDexInstructionSets(ps), ps.isForwardLocked());
                                if (ps.codePathString == null || !ps.codePathString.startsWith(args.getCodePath())) {
                                    Slog.i(TAG, "Found stale container " + cid + ": expected codePath=" + ps.codePathString);
                                } else {
                                    if (DEBUG_SD_INSTALL) {
                                        Log.i(TAG, "Container : " + cid + " corresponds to pkg : " + pkgName + " at code path: " + ps.codePathString);
                                    }
                                    processCids.put(args, ps.codePathString);
                                    int uid = ps.appId;
                                    if (uid != -1) {
                                        uidArr = ArrayUtils.appendInt(uidArr, uid);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            Arrays.sort(uidArr);
        }
        if (isMounted) {
            if (DEBUG_SD_INSTALL) {
                Log.i(TAG, "Loading packages");
            }
            loadMediaPackages(processCids, uidArr, externalStorage);
            startCleaningPackages();
            this.mInstallerService.onSecureContainersAvailable();
            return;
        }
        if (DEBUG_SD_INSTALL) {
            Log.i(TAG, "Unloading packages");
        }
        unloadMediaPackages(processCids, uidArr, reportStatus);
    }

    private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, ArrayList<ApplicationInfo> infos, IIntentReceiver finishedReceiver) {
        int size = infos.size();
        String[] packageNames = new String[size];
        int[] packageUids = new int[size];
        for (int i = 0; i < size; i++) {
            ApplicationInfo info = (ApplicationInfo) infos.get(i);
            packageNames[i] = info.packageName;
            packageUids[i] = info.uid;
        }
        sendResourcesChangedBroadcast(mediaStatus, replacing, packageNames, packageUids, finishedReceiver);
    }

    private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, ArrayList<String> pkgList, int[] uidArr, IIntentReceiver finishedReceiver) {
        sendResourcesChangedBroadcast(mediaStatus, replacing, (String[]) pkgList.toArray(new String[pkgList.size()]), uidArr, finishedReceiver);
    }

    private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, String[] pkgList, int[] uidArr, IIntentReceiver finishedReceiver) {
        if (pkgList.length > 0) {
            String action;
            Bundle extras = new Bundle();
            extras.putStringArray("android.intent.extra.changed_package_list", pkgList);
            if (uidArr != null) {
                extras.putIntArray("android.intent.extra.changed_uid_list", uidArr);
            }
            if (replacing) {
                extras.putBoolean("android.intent.extra.REPLACING", replacing);
            }
            if (mediaStatus) {
                action = "android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE";
            } else {
                action = "android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE";
            }
            sendPackageBroadcast(action, null, extras, 0, null, finishedReceiver, null);
        }
    }

    private void loadMediaPackages(ArrayMap<AsecInstallArgs, String> processCids, int[] uidArr, boolean externalStorage) {
        ArrayList<String> pkgList = new ArrayList();
        for (AsecInstallArgs args : processCids.keySet()) {
            String codePath = (String) processCids.get(args);
            if (DEBUG_SD_INSTALL) {
                Log.i(TAG, "Loading container : " + args.cid);
            }
            int retCode = -18;
            try {
                if (args.doPreInstall(1) != 1) {
                    Slog.e(TAG, "Failed to mount cid : " + args.cid + " when installing from sdcard");
                    Log.w(TAG, "Container " + args.cid + " is stale, retCode=" + -18);
                } else {
                    if (codePath != null) {
                        if ((codePath.startsWith(args.getCodePath()) ^ 1) == 0) {
                            int parseFlags = this.mDefParseFlags;
                            if (args.isExternalAsec()) {
                                parseFlags |= 32;
                            }
                            if (args.isFwdLocked()) {
                                parseFlags |= 16;
                            }
                            synchronized (this.mInstallLock) {
                                Package pkg = null;
                                try {
                                    pkg = scanPackageTracedLI(new File(codePath), parseFlags, 32768, 0, null);
                                } catch (PackageManagerException e) {
                                    Slog.w(TAG, "Failed to scan " + codePath + ": " + e.getMessage());
                                }
                                if (pkg != null) {
                                    synchronized (this.mPackages) {
                                        retCode = 1;
                                        pkgList.add(pkg.packageName);
                                        args.doPostInstall(1, pkg.applicationInfo.uid);
                                    }
                                } else {
                                    Slog.i(TAG, "Failed to install pkg from  " + codePath + " from sdcard");
                                }
                            }
                            if (retCode != 1) {
                                Log.w(TAG, "Container " + args.cid + " is stale, retCode=" + retCode);
                            }
                        }
                    }
                    Slog.e(TAG, "Container " + args.cid + " cachepath " + args.getCodePath() + " does not match one in settings " + codePath);
                    Log.w(TAG, "Container " + args.cid + " is stale, retCode=" + -18);
                }
            } catch (Throwable th) {
                if (retCode != 1) {
                    Log.w(TAG, "Container " + args.cid + " is stale, retCode=" + retCode);
                }
            }
        }
        synchronized (this.mPackages) {
            VersionInfo ver;
            String volumeUuid;
            if (externalStorage) {
                ver = this.mSettings.getExternalVersion();
            } else {
                ver = this.mSettings.getInternalVersion();
            }
            if (externalStorage) {
                volumeUuid = "primary_physical";
            } else {
                volumeUuid = StorageManager.UUID_PRIVATE_INTERNAL;
            }
            int updateFlags = 1;
            if (ver.sdkVersion != this.mSdkVersion) {
                logCriticalInfo(4, "Platform changed from " + ver.sdkVersion + " to " + this.mSdkVersion + "; regranting permissions for external");
                updateFlags = 7;
            }
            updatePermissionsLPw(null, null, volumeUuid, updateFlags);
            ver.forceCurrent();
            this.mSettings.writeLPr();
        }
        if (pkgList.size() > 0) {
            sendResourcesChangedBroadcast(true, false, (ArrayList) pkgList, uidArr, null);
        }
    }

    private void unloadAllContainers(Set<AsecInstallArgs> cidArgs) {
        for (AsecInstallArgs arg : cidArgs) {
            synchronized (this.mInstallLock) {
                arg.doPostDeleteLI(false);
            }
        }
    }

    private void unloadMediaPackages(ArrayMap<AsecInstallArgs, String> processCids, int[] uidArr, boolean reportStatus) {
        PackageFreezer packageFreezer;
        Throwable th;
        Throwable th2;
        if (DEBUG_SD_INSTALL) {
            Log.i(TAG, "unloading media packages");
        }
        ArrayList pkgList = new ArrayList();
        ArrayList<AsecInstallArgs> failedList = new ArrayList();
        Set<AsecInstallArgs> keys = processCids.keySet();
        for (AsecInstallArgs args : keys) {
            String pkgName = args.getPackageName();
            if (DEBUG_SD_INSTALL) {
                Log.i(TAG, "Trying to unload pkg : " + pkgName);
            }
            PackageRemovedInfo outInfo = new PackageRemovedInfo(this);
            synchronized (this.mInstallLock) {
                Throwable th3 = null;
                packageFreezer = null;
                try {
                    packageFreezer = freezePackageForDelete(pkgName, 1, "unloadMediaPackages");
                    boolean res = deletePackageLIF(pkgName, null, false, null, 1, outInfo, false, null);
                    if (packageFreezer != null) {
                        try {
                            packageFreezer.close();
                        } catch (Throwable th4) {
                            th3 = th4;
                        }
                    }
                    if (th3 != null) {
                        throw th3;
                    } else {
                        if (res) {
                            pkgList.add(pkgName);
                        } else {
                            Slog.e(TAG, "Failed to delete pkg from sdcard : " + pkgName);
                            failedList.add(args);
                        }
                    }
                } catch (Throwable th22) {
                    Throwable th5 = th22;
                    th22 = th;
                    th = th5;
                }
            }
        }
        synchronized (this.mPackages) {
            this.mSettings.writeLPr();
        }
        if (pkgList.size() > 0) {
            final boolean z = reportStatus;
            final Set<AsecInstallArgs> set = keys;
            sendResourcesChangedBroadcast(false, false, pkgList, uidArr, new IIntentReceiver.Stub() {
                public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException {
                    PackageManagerService.this.mHandler.sendMessage(PackageManagerService.this.mHandler.obtainMessage(12, z ? 1 : 0, 1, set));
                }
            });
            return;
        }
        this.mHandler.sendMessage(this.mHandler.obtainMessage(12, reportStatus ? 1 : 0, -1, keys));
        return;
        if (packageFreezer != null) {
            try {
                packageFreezer.close();
            } catch (Throwable th6) {
                if (th22 == null) {
                    th22 = th6;
                } else if (th22 != th6) {
                    th22.addSuppressed(th6);
                }
            }
        }
        if (th22 != null) {
            throw th22;
        }
        throw th;
    }

    private void loadPrivatePackages(final VolumeInfo vol) {
        this.mHandler.post(new Runnable() {
            public void run() {
                PackageManagerService.this.loadPrivatePackagesInner(vol);
            }
        });
    }

    private void loadPrivatePackagesInner(VolumeInfo vol) {
        String volumeUuid = vol.fsUuid;
        if (TextUtils.isEmpty(volumeUuid)) {
            Slog.e(TAG, "Loading internal storage is probably a mistake; ignoring");
            return;
        }
        VersionInfo ver;
        ArrayList<PackageFreezer> freezers = new ArrayList();
        ArrayList<ApplicationInfo> loaded = new ArrayList();
        int parseFlags = this.mDefParseFlags | 32;
        synchronized (this.mPackages) {
            ver = this.mSettings.findOrCreateVersion(volumeUuid);
            List<PackageSetting> packages = this.mSettings.getVolumePackagesLPr(volumeUuid);
        }
        for (PackageSetting ps : packages) {
            freezers.add(freezePackage(ps.name, "loadPrivatePackagesInner"));
            synchronized (this.mInstallLock) {
                try {
                    loaded.add(scanPackageTracedLI(ps.codePath, parseFlags, 4096, 0, null).applicationInfo);
                } catch (PackageManagerException e) {
                    Slog.w(TAG, "Failed to scan " + ps.codePath + ": " + e.getMessage());
                }
                if (!Build.FINGERPRINT.equals(ver.fingerprint)) {
                    clearAppDataLIF(ps.pkg, -1, UsbTerminalTypes.TERMINAL_IN_PERSONAL_MIC);
                }
            }
        }
        StorageManager sm = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        UserManager um = (UserManager) this.mContext.getSystemService(UserManager.class);
        UserManagerInternal umInternal = getUserManagerInternal();
        for (UserInfo user : um.getUsers()) {
            int flags;
            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
                flags = 3;
            } else {
                if (umInternal.isUserRunning(user.id)) {
                    flags = 1;
                } else {
                    continue;
                }
            }
            try {
                sm.prepareUserStorage(volumeUuid, user.id, user.serialNumber, flags);
                synchronized (this.mInstallLock) {
                    reconcileAppsDataLI(volumeUuid, user.id, flags, true);
                }
            } catch (IllegalStateException e2) {
                Slog.w(TAG, "Failed to prepare storage: " + e2);
            }
        }
        synchronized (this.mPackages) {
            int updateFlags = 1;
            if (ver.sdkVersion != this.mSdkVersion) {
                logCriticalInfo(4, "Platform changed from " + ver.sdkVersion + " to " + this.mSdkVersion + "; regranting permissions for " + volumeUuid);
                updateFlags = 7;
            }
            updatePermissionsLPw(null, null, volumeUuid, updateFlags);
            ver.forceCurrent();
            this.mSettings.writeLPr();
        }
        for (PackageFreezer freezer : freezers) {
            freezer.close();
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "Loaded packages " + loaded);
        }
        sendResourcesChangedBroadcast(true, false, loaded, null);
        this.mLoadedVolumes.add(vol.getId());
    }

    private void unloadPrivatePackages(final VolumeInfo vol) {
        this.mHandler.post(new Runnable() {
            public void run() {
                PackageManagerService.this.unloadPrivatePackagesInner(vol);
            }
        });
    }

    private void unloadPrivatePackagesInner(VolumeInfo vol) {
        PackageFreezer packageFreezer;
        Throwable th;
        Throwable th2;
        String volumeUuid = vol.fsUuid;
        if (TextUtils.isEmpty(volumeUuid)) {
            Slog.e(TAG, "Unloading internal storage is probably a mistake; ignoring");
            return;
        }
        ArrayList<ApplicationInfo> unloaded = new ArrayList();
        synchronized (this.mInstallLock) {
            synchronized (this.mPackages) {
                for (PackageSetting ps : this.mSettings.getVolumePackagesLPr(volumeUuid)) {
                    if (ps.pkg != null) {
                        ApplicationInfo info = ps.pkg.applicationInfo;
                        PackageRemovedInfo outInfo = new PackageRemovedInfo(this);
                        Throwable th3 = null;
                        packageFreezer = null;
                        try {
                            packageFreezer = freezePackageForDelete(ps.name, 1, "unloadPrivatePackagesInner");
                            if (deletePackageLIF(ps.name, null, false, null, 1, outInfo, false, null)) {
                                unloaded.add(info);
                            } else {
                                Slog.w(TAG, "Failed to unload " + ps.codePath);
                            }
                            if (packageFreezer != null) {
                                try {
                                    packageFreezer.close();
                                } catch (Throwable th4) {
                                    th3 = th4;
                                }
                            }
                            if (th3 != null) {
                                throw th3;
                            } else {
                                AttributeCache.instance().removePackage(ps.name);
                            }
                        } catch (Throwable th22) {
                            Throwable th5 = th22;
                            th22 = th;
                            th = th5;
                        }
                    }
                }
                this.mSettings.writeLPr();
            }
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "Unloaded packages " + unloaded);
        }
        sendResourcesChangedBroadcast(false, false, unloaded, null);
        this.mLoadedVolumes.remove(vol.getId());
        ResourcesManager.getInstance().invalidatePath(vol.getPath().getAbsolutePath());
        for (int i = 0; i < 3; i++) {
            System.gc();
            System.runFinalization();
        }
        return;
        if (packageFreezer != null) {
            try {
                packageFreezer.close();
            } catch (Throwable th6) {
                if (th22 == null) {
                    th22 = th6;
                } else if (th22 != th6) {
                    th22.addSuppressed(th6);
                }
            }
        }
        if (th22 != null) {
            throw th22;
        }
        throw th;
    }

    private void assertPackageKnown(String volumeUuid, String packageName) throws PackageManagerException {
        synchronized (this.mPackages) {
            packageName = normalizePackageNameLPr(packageName);
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                throw new PackageManagerException("Package " + packageName + " is unknown");
            } else if (TextUtils.equals(volumeUuid, ps.volumeUuid)) {
            } else {
                throw new PackageManagerException("Package " + packageName + " found on unknown volume " + volumeUuid + "; expected volume " + ps.volumeUuid);
            }
        }
    }

    private void assertPackageKnownAndInstalled(String volumeUuid, String packageName, int userId) throws PackageManagerException {
        synchronized (this.mPackages) {
            packageName = normalizePackageNameLPr(packageName);
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                throw new PackageManagerException("Package " + packageName + " is unknown");
            } else if (!TextUtils.equals(volumeUuid, ps.volumeUuid)) {
                throw new PackageManagerException("Package " + packageName + " found on unknown volume " + volumeUuid + "; expected volume " + ps.volumeUuid);
            } else if (ps.getInstalled(userId)) {
            } else {
                throw new PackageManagerException("Package " + packageName + " not installed for user " + userId);
            }
        }
    }

    private List<String> collectAbsoluteCodePaths() {
        List<String> codePaths;
        synchronized (this.mPackages) {
            codePaths = new ArrayList();
            int packageCount = this.mSettings.mPackages.size();
            for (int i = 0; i < packageCount; i++) {
                codePaths.add(((PackageSetting) this.mSettings.mPackages.valueAt(i)).codePath.getAbsolutePath());
            }
        }
        return codePaths;
    }

    private void reconcileApps(String volumeUuid) {
        int i;
        List<String> absoluteCodePaths = collectAbsoluteCodePaths();
        List filesToDelete = null;
        for (File file : FileUtils.listFilesOrEmpty(Environment.getDataAppDirectory(volumeUuid))) {
            boolean isPackage;
            if (PackageParser.isApkFile(file) || file.isDirectory()) {
                isPackage = PackageInstallerService.isStageName(file.getName()) ^ 1;
            } else {
                isPackage = false;
            }
            if (isPackage) {
                String absolutePath = file.getAbsolutePath();
                boolean pathValid = false;
                int absoluteCodePathCount = absoluteCodePaths.size();
                for (i = 0; i < absoluteCodePathCount; i++) {
                    if (absolutePath.startsWith((String) absoluteCodePaths.get(i))) {
                        pathValid = true;
                        break;
                    }
                }
                if (!pathValid) {
                    if (filesToDelete == null) {
                        filesToDelete = new ArrayList();
                    }
                    filesToDelete.add(file);
                }
            }
        }
        if (filesToDelete != null) {
            int fileToDeleteCount = filesToDelete.size();
            for (i = 0; i < fileToDeleteCount; i++) {
                File fileToDelete = (File) filesToDelete.get(i);
                logCriticalInfo(5, "Destroying orphaned" + fileToDelete);
                synchronized (this.mInstallLock) {
                    removeCodePathLI(fileToDelete);
                }
            }
        }
    }

    void reconcileAppsData(int userId, int flags, boolean migrateAppsData) {
        for (VolumeInfo vol : ((StorageManager) this.mContext.getSystemService(StorageManager.class)).getWritablePrivateVolumes()) {
            String volumeUuid = vol.getFsUuid();
            synchronized (this.mInstallLock) {
                reconcileAppsDataLI(volumeUuid, userId, flags, migrateAppsData);
            }
        }
    }

    private void reconcileAppsDataLI(String volumeUuid, int userId, int flags, boolean migrateAppData) {
        reconcileAppsDataLI(volumeUuid, userId, flags, migrateAppData, false);
    }

    private List<String> reconcileAppsDataLI(String volumeUuid, int userId, int flags, boolean migrateAppData, boolean onlyCoreApps) {
        File[] files;
        int i;
        int length;
        int i2;
        File file;
        String packageName;
        Slog.v(TAG, "reconcileAppsData for " + volumeUuid + " u" + userId + " 0x" + Integer.toHexString(flags) + " migrateAppData=" + migrateAppData);
        List<String> result = onlyCoreApps ? new ArrayList() : null;
        File ceDir = Environment.getDataUserCeDirectory(volumeUuid, userId);
        File deDir = Environment.getDataUserDeDirectory(volumeUuid, userId);
        if ((flags & 2) != 0) {
            if (!StorageManager.isFileEncryptedNativeOrEmulated() || (StorageManager.isUserKeyUnlocked(userId) ^ 1) == 0) {
                files = FileUtils.listFilesOrEmpty(ceDir);
                i = 0;
                length = files.length;
                while (true) {
                    i2 = i;
                    if (i2 >= length) {
                        break;
                    }
                    file = files[i2];
                    packageName = file.getName();
                    try {
                        assertPackageKnownAndInstalled(volumeUuid, packageName, userId);
                    } catch (PackageManagerException e) {
                        logCriticalInfo(5, "Destroying " + file + " due to: " + e);
                        try {
                            this.mInstaller.destroyAppData(volumeUuid, packageName, userId, 2, 0);
                        } catch (InstallerException e2) {
                            logCriticalInfo(5, "Failed to destroy: " + e2);
                        }
                    }
                    i = i2 + 1;
                }
            } else {
                throw new RuntimeException("Yikes, someone asked us to reconcile CE storage while " + userId + " was still locked; this would have caused massive data loss!");
            }
        }
        if ((flags & 1) != 0) {
            files = FileUtils.listFilesOrEmpty(deDir);
            i = 0;
            length = files.length;
            while (true) {
                i2 = i;
                if (i2 >= length) {
                    break;
                }
                file = files[i2];
                packageName = file.getName();
                try {
                    assertPackageKnownAndInstalled(volumeUuid, packageName, userId);
                } catch (PackageManagerException e3) {
                    logCriticalInfo(5, "Destroying " + file + " due to: " + e3);
                    try {
                        this.mInstaller.destroyAppData(volumeUuid, packageName, userId, 1, 0);
                    } catch (InstallerException e22) {
                        logCriticalInfo(5, "Failed to destroy: " + e22);
                    }
                }
                i = i2 + 1;
            }
        }
        synchronized (this.mPackages) {
            List<PackageSetting> packages = this.mSettings.getVolumePackagesLPr(volumeUuid);
        }
        int preparedCount = 0;
        for (PackageSetting ps : packages) {
            packageName = ps.name;
            if (ps.pkg == null) {
                Slog.w(TAG, "Odd, missing scanned package " + packageName);
            } else if (onlyCoreApps && (ps.pkg.coreApp ^ 1) != 0) {
                result.add(packageName);
            } else if (ps.getInstalled(userId)) {
                prepareAppDataAndMigrateLIF(ps.pkg, userId, flags, migrateAppData);
                preparedCount++;
            }
        }
        Slog.v(TAG, "reconcileAppsData finished " + preparedCount + " packages");
        return result;
    }

    private void prepareAppDataAfterInstallLIF(Package pkg) {
        PackageSetting ps;
        synchronized (this.mPackages) {
            ps = (PackageSetting) this.mSettings.mPackages.get(pkg.packageName);
            this.mSettings.writeKernelMappingLPr(ps);
        }
        UserManager um = (UserManager) this.mContext.getSystemService(UserManager.class);
        UserManagerInternal umInternal = getUserManagerInternal();
        for (UserInfo user : um.getUsers()) {
            int flags;
            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
                flags = 3;
            } else if (umInternal.isUserRunning(user.id)) {
                flags = 1;
            }
            if (ps.getInstalled(user.id)) {
                prepareAppDataLIF(pkg, user.id, flags);
            }
        }
    }

    private void prepareAppDataLIF(Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        prepareAppDataLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            prepareAppDataLeafLIF((Package) pkg.childPackages.get(i), userId, flags);
        }
    }

    private void prepareAppDataAndMigrateLIF(Package pkg, int userId, int flags, boolean maybeMigrateAppData) {
        prepareAppDataLIF(pkg, userId, flags);
        if (maybeMigrateAppData && maybeMigrateAppDataLIF(pkg, userId)) {
            prepareAppDataLIF(pkg, userId, flags);
        }
    }

    private void prepareAppDataLeafLIF(Package pkg, int userId, int flags) {
        String volumeUuid = pkg.volumeUuid;
        String packageName = pkg.packageName;
        ApplicationInfo app = pkg.applicationInfo;
        int appId = UserHandle.getAppId(app.uid);
        Preconditions.checkNotNull(app.seInfo);
        long ceDataInode = -1;
        try {
            ceDataInode = this.mInstaller.createAppData(volumeUuid, packageName, userId, flags, appId, app.seInfo, app.targetSdkVersion);
        } catch (InstallerException e) {
            if (app.isSystemApp()) {
                logCriticalInfo(6, "Failed to create app data for " + packageName + ", but trying to recover: " + e);
                destroyAppDataLeafLIF(pkg, userId, flags);
                try {
                    ceDataInode = this.mInstaller.createAppData(volumeUuid, packageName, userId, flags, appId, app.seInfo, app.targetSdkVersion);
                    logCriticalInfo(3, "Recovery succeeded!");
                } catch (InstallerException e2) {
                    logCriticalInfo(3, "Recovery failed!");
                }
            } else {
                Slog.e(TAG, "Failed to create app data for " + packageName + ": " + e);
            }
        }
        if (!((flags & 2) == 0 || ceDataInode == -1)) {
            synchronized (this.mPackages) {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
                if (ps != null) {
                    ps.setCeDataInode(ceDataInode, userId);
                }
            }
        }
        prepareAppDataContentsLeafLIF(pkg, userId, flags);
    }

    private void prepareAppDataContentsLIF(Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        prepareAppDataContentsLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            prepareAppDataContentsLeafLIF((Package) pkg.childPackages.get(i), userId, flags);
        }
    }

    private void prepareAppDataContentsLeafLIF(Package pkg, int userId, int flags) {
        String volumeUuid = pkg.volumeUuid;
        String packageName = pkg.packageName;
        ApplicationInfo app = pkg.applicationInfo;
        if ((flags & 2) != 0 && app.primaryCpuAbi != null && (VMRuntime.is64BitAbi(app.primaryCpuAbi) ^ 1) != 0) {
            try {
                this.mInstaller.linkNativeLibraryDirectory(volumeUuid, packageName, app.nativeLibraryDir, userId);
            } catch (InstallerException e) {
                Slog.e(TAG, "Failed to link native for " + packageName + ": " + e);
            }
        }
    }

    private boolean maybeMigrateAppDataLIF(Package pkg, int userId) {
        if (!pkg.isSystemApp() || (StorageManager.isFileEncryptedNativeOrEmulated() ^ 1) == 0) {
            return false;
        }
        try {
            this.mInstaller.migrateAppData(pkg.volumeUuid, pkg.packageName, userId, pkg.applicationInfo.isDefaultToDeviceProtectedStorage() ? 1 : 2);
        } catch (InstallerException e) {
            logCriticalInfo(5, "Failed to migrate " + pkg.packageName + ": " + e.getMessage());
        }
        return true;
    }

    public PackageFreezer freezePackage(String packageName, String killReason) {
        return freezePackage(packageName, -1, killReason);
    }

    public PackageFreezer freezePackage(String packageName, int userId, String killReason) {
        return new PackageFreezer(packageName, userId, killReason);
    }

    public PackageFreezer freezePackageForInstall(String packageName, int installFlags, String killReason) {
        return freezePackageForInstall(packageName, -1, installFlags, killReason);
    }

    public PackageFreezer freezePackageForInstall(String packageName, int userId, int installFlags, String killReason) {
        if ((installFlags & 4096) != 0) {
            return new PackageFreezer();
        }
        return freezePackage(packageName, userId, killReason);
    }

    public PackageFreezer freezePackageForDelete(String packageName, int deleteFlags, String killReason) {
        return freezePackageForDelete(packageName, -1, deleteFlags, killReason);
    }

    public PackageFreezer freezePackageForDelete(String packageName, int userId, int deleteFlags, String killReason) {
        if ((deleteFlags & 8) != 0) {
            return new PackageFreezer();
        }
        return freezePackage(packageName, userId, killReason);
    }

    private void checkPackageFrozen(String packageName) {
        synchronized (this.mPackages) {
            if (!this.mFrozenPackages.contains(packageName)) {
                Slog.wtf(TAG, "Expected " + packageName + " to be frozen!", new Throwable());
            }
        }
    }

    public int movePackage(String packageName, String volumeUuid) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOVE_PACKAGE", null);
        final int callingUid = Binder.getCallingUid();
        final UserHandle user = new UserHandle(UserHandle.getUserId(callingUid));
        final int moveId = this.mNextMoveId.getAndIncrement();
        final String str = packageName;
        final String str2 = volumeUuid;
        this.mHandler.post(new Runnable() {
            public void run() {
                try {
                    PackageManagerService.this.movePackageInternal(str, str2, moveId, callingUid, user);
                } catch (PackageManagerException e) {
                    Slog.w(PackageManagerService.TAG, "Failed to move " + str, e);
                    PackageManagerService.this.mMoveCallbacks.notifyStatusChanged(moveId, e.error);
                }
            }
        });
        return moveId;
    }

    private void movePackageInternal(String packageName, String volumeUuid, int moveId, int callingUid, UserHandle user) throws PackageManagerException {
        boolean currentAsec;
        String currentVolumeUuid;
        File file;
        String installerPackageName;
        String packageAbiOverride;
        int appId;
        String seinfo;
        String label;
        int targetSdkVersion;
        PackageFreezer freezer;
        int[] installedUserIds;
        int installFlags;
        boolean moveCompleteApp;
        File measurePath;
        int i;
        long sizeBytes;
        StorageManager storage = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        PackageManager pm = this.mContext.getPackageManager();
        synchronized (this.mPackages) {
            Package pkg = (Package) this.mPackages.get(packageName);
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (!(pkg == null || ps == null)) {
                if (!filterAppAccessLPr(ps, callingUid, user.getIdentifier())) {
                    if (pkg.applicationInfo.isSystemApp()) {
                        throw new PackageManagerException(-3, "Cannot move system application");
                    }
                    boolean isInternalStorage = "private".equals(volumeUuid);
                    boolean allow3rdPartyOnInternal = this.mContext.getResources().getBoolean(17956869);
                    if (!isInternalStorage || (allow3rdPartyOnInternal ^ 1) == 0) {
                        if (pkg.applicationInfo.isExternalAsec()) {
                            currentAsec = true;
                            currentVolumeUuid = "primary_physical";
                        } else if (pkg.applicationInfo.isForwardLocked()) {
                            currentAsec = true;
                            currentVolumeUuid = "forward_locked";
                        } else {
                            currentAsec = false;
                            currentVolumeUuid = ps.volumeUuid;
                            file = new File(pkg.codePath);
                            file = new File(file, "oat");
                            if (!(file.isDirectory() && (file.isDirectory() ^ 1) == 0)) {
                                throw new PackageManagerException(-6, "Move only supported for modern cluster style installs");
                            }
                        }
                        if (Objects.equals(currentVolumeUuid, volumeUuid)) {
                            throw new PackageManagerException(-6, "Package already moved to " + volumeUuid);
                        } else if (pkg.applicationInfo.isInternal() && isPackageDeviceAdminOnAnyUser(packageName)) {
                            throw new PackageManagerException(-8, "Device admin cannot be moved");
                        } else if (this.mFrozenPackages.contains(packageName)) {
                            throw new PackageManagerException(-7, "Failed to move already frozen package");
                        } else {
                            file = new File(pkg.codePath);
                            installerPackageName = ps.installerPackageName;
                            packageAbiOverride = ps.cpuAbiOverrideString;
                            appId = UserHandle.getAppId(pkg.applicationInfo.uid);
                            seinfo = pkg.applicationInfo.seInfo;
                            label = String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
                            targetSdkVersion = pkg.applicationInfo.targetSdkVersion;
                            freezer = freezePackage(packageName, "movePackageInternal");
                            installedUserIds = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                        }
                    } else {
                        throw new PackageManagerException(-9, "3rd party apps are not allowed on internal storage");
                    }
                }
            }
            throw new PackageManagerException(-2, "Missing package");
        }
        Bundle extras = new Bundle();
        extras.putString("android.intent.extra.PACKAGE_NAME", packageName);
        extras.putString("android.intent.extra.TITLE", label);
        this.mMoveCallbacks.notifyCreated(moveId, extras);
        if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, volumeUuid)) {
            installFlags = 16;
            moveCompleteApp = currentAsec ^ 1;
            measurePath = Environment.getDataAppDirectory(volumeUuid);
        } else if (Objects.equals("primary_physical", volumeUuid)) {
            installFlags = 8;
            moveCompleteApp = false;
            measurePath = storage.getPrimaryPhysicalVolume().getPath();
        } else {
            VolumeInfo volume = storage.findVolumeByUuid(volumeUuid);
            if (volume != null && volume.getType() == 1 && (volume.isMountedWritable() ^ 1) == 0) {
                Preconditions.checkState(currentAsec ^ 1);
                installFlags = 16;
                moveCompleteApp = true;
                measurePath = Environment.getDataAppDirectory(volumeUuid);
            } else {
                freezer.close();
                throw new PackageManagerException(-6, "Move location not mounted private volume");
            }
        }
        if (moveCompleteApp) {
            i = 0;
            int length = installedUserIds.length;
            while (i < length) {
                int userId = installedUserIds[i];
                if (!StorageManager.isFileEncryptedNativeOrEmulated() || (StorageManager.isUserKeyUnlocked(userId) ^ 1) == 0) {
                    i++;
                } else {
                    throw new PackageManagerException(-10, "User " + userId + " must be unlocked");
                }
            }
        }
        PackageStats packageStats = new PackageStats(null, -1);
        synchronized (this.mInstaller) {
            i = 0;
            int length2 = installedUserIds.length;
            while (i < length2) {
                if (getPackageSizeInfoLI(packageName, installedUserIds[i], packageStats)) {
                    i++;
                } else {
                    freezer.close();
                    throw new PackageManagerException(-6, "Failed to measure package size");
                }
            }
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "Measured code size " + packageStats.codeSize + ", data size " + packageStats.dataSize);
        }
        final long startFreeBytes = measurePath.getUsableSpace();
        if (moveCompleteApp) {
            sizeBytes = packageStats.codeSize + packageStats.dataSize;
        } else {
            sizeBytes = packageStats.codeSize;
        }
        if (sizeBytes > storage.getStorageBytesUntilLow(measurePath)) {
            freezer.close();
            throw new PackageManagerException(-6, "Not enough free space to move");
        }
        MoveInfo move;
        this.mMoveCallbacks.notifyStatusChanged(moveId, 10);
        final CountDownLatch installedLatch = new CountDownLatch(1);
        final PackageFreezer packageFreezer = freezer;
        final int i2 = moveId;
        IPackageInstallObserver2 anonymousClass32 = new IPackageInstallObserver2.Stub() {
            public void onUserActionRequired(Intent intent) throws RemoteException {
                throw new IllegalStateException();
            }

            public void onPackageInstalled(String basePackageName, int returnCode, String msg, Bundle extras) throws RemoteException {
                if (PackageManagerService.DEBUG_INSTALL) {
                    Slog.d(PackageManagerService.TAG, "Install result for move: " + PackageManager.installStatusToString(returnCode, msg));
                }
                installedLatch.countDown();
                packageFreezer.close();
                switch (PackageManager.installStatusToPublicStatus(returnCode)) {
                    case 0:
                        PackageManagerService.this.mMoveCallbacks.notifyStatusChanged(i2, -100);
                        return;
                    case 6:
                        PackageManagerService.this.mMoveCallbacks.notifyStatusChanged(i2, -1);
                        return;
                    default:
                        PackageManagerService.this.mMoveCallbacks.notifyStatusChanged(i2, -6);
                        return;
                }
            }
        };
        if (moveCompleteApp) {
            final int i3 = moveId;
            new Thread() {
                public void run() {
                    while (!installedLatch.await(1, TimeUnit.SECONDS)) {
                        try {
                        } catch (InterruptedException e) {
                        }
                        PackageManagerService.this.mMoveCallbacks.notifyStatusChanged(i3, ((int) MathUtils.constrain(((startFreeBytes - measurePath.getUsableSpace()) * 80) / sizeBytes, 0, 80)) + 10);
                    }
                }
            }.start();
            move = new MoveInfo(moveId, currentVolumeUuid, volumeUuid, packageName, file.getName(), appId, seinfo, targetSdkVersion);
        } else {
            move = null;
        }
        installFlags |= 2;
        Message msg = this.mHandler.obtainMessage(5);
        InstallParams params = new InstallParams(OriginInfo.fromExistingFile(file), move, anonymousClass32, installFlags, installerPackageName, volumeUuid, null, user, packageAbiOverride, null, null, 0);
        params.setTraceMethod("movePackage").setTraceCookie(System.identityHashCode(params));
        msg.obj = params;
        Trace.asyncTraceBegin(262144, "movePackage", System.identityHashCode(msg.obj));
        Trace.asyncTraceBegin(262144, "queueInstall", System.identityHashCode(msg.obj));
        this.mHandler.sendMessage(msg);
    }

    public int movePrimaryStorage(String volumeUuid) throws RemoteException {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOVE_PACKAGE", null);
        final int realMoveId = this.mNextMoveId.getAndIncrement();
        Bundle extras = new Bundle();
        extras.putString("android.os.storage.extra.FS_UUID", volumeUuid);
        this.mMoveCallbacks.notifyCreated(realMoveId, extras);
        ((StorageManager) this.mContext.getSystemService(StorageManager.class)).setPrimaryStorageUuid(volumeUuid, new IPackageMoveObserver.Stub() {
            public void onCreated(int moveId, Bundle extras) {
            }

            public void onStatusChanged(int moveId, int status, long estMillis) {
                PackageManagerService.this.mMoveCallbacks.notifyStatusChanged(realMoveId, status, estMillis);
            }
        });
        return realMoveId;
    }

    public int getMoveStatus(int moveId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOUNT_UNMOUNT_FILESYSTEMS", null);
        return this.mMoveCallbacks.mLastStatus.get(moveId);
    }

    public void registerMoveCallback(IPackageMoveObserver callback) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOUNT_UNMOUNT_FILESYSTEMS", null);
        this.mMoveCallbacks.register(callback);
    }

    public void unregisterMoveCallback(IPackageMoveObserver callback) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOUNT_UNMOUNT_FILESYSTEMS", null);
        this.mMoveCallbacks.unregister(callback);
    }

    public boolean setInstallLocation(int loc) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.WRITE_SECURE_SETTINGS", null);
        if (getInstallLocation() == loc) {
            return true;
        }
        if (loc == 2 && hasSystemFeature("oppo.app2sd.disabled", 0)) {
            Slog.w(TAG, "if oppo.app2sd.disabled setInstallLocation APP_INSTALL_EXTERNAL do nothing ");
            return true;
        } else if (loc != 0 && loc != 1 && loc != 2) {
            return false;
        } else {
            Global.putInt(this.mContext.getContentResolver(), "default_install_location", loc);
            return true;
        }
    }

    public int getInstallLocation() {
        return Global.getInt(this.mContext.getContentResolver(), "default_install_location", 0);
    }

    void cleanUpUser(UserManagerService userManager, int userHandle) {
        synchronized (this.mPackages) {
            this.mDirtyUsers.remove(Integer.valueOf(userHandle));
            this.mUserNeedsBadging.delete(userHandle);
            this.mSettings.removeUserLPw(userHandle);
            this.mPendingBroadcasts.remove(userHandle);
            this.mInstantAppRegistry.onUserRemovedLPw(userHandle);
            removeUnusedPackagesLPw(userManager, userHandle);
        }
    }

    private void removeUnusedPackagesLPw(UserManagerService userManager, final int userHandle) {
        int[] users = userManager.getUserIds();
        for (PackageSetting ps : this.mSettings.mPackages.values()) {
            if (ps.pkg != null) {
                final String packageName = ps.pkg.packageName;
                if ((ps.pkgFlags & 1) == 0) {
                    boolean keep = shouldKeepUninstalledPackageLPr(packageName);
                    if (!keep) {
                        int i = 0;
                        while (i < users.length) {
                            if (users[i] != userHandle && ps.getInstalled(users[i])) {
                                keep = true;
                                break;
                            }
                            i++;
                        }
                    }
                    if (!keep) {
                        this.mHandler.post(new Runnable() {
                            public void run() {
                                PackageManagerService.this.deletePackageX(packageName, -1, userHandle, 0);
                            }
                        });
                    }
                }
            }
        }
    }

    void createNewUser(int userId, String[] disallowedPackages) {
        synchronized (this.mInstallLock) {
            this.mSettings.createNewUserLI(this, this.mInstaller, userId, disallowedPackages);
        }
        synchronized (this.mPackages) {
            scheduleWritePackageRestrictionsLocked(userId);
            scheduleWritePackageListLocked(userId);
            applyFactoryDefaultBrowserLPw(userId);
            primeDomainVerificationsLPw(userId);
        }
    }

    void onNewUserCreated(int userId) {
        this.mDefaultPermissionPolicy.grantDefaultPermissions(userId);
        boolean supportRuntimeAlert = hasSystemFeature("oppo.runtime.permission.alert.support", 0);
        if (supportRuntimeAlert) {
            try {
                UserInfo createdInfo = sUserManager.getUserInfo(userId);
                if (createdInfo != null && createdInfo.isManagedProfile()) {
                    Slog.d(TAG, "pm.onNewUserCreated isManagedProfile " + userId);
                    this.mDefaultPermissionPolicy.grantOppoFixRuntimePermssion(userId, supportRuntimeAlert);
                    this.mDefaultPermissionPolicy.grantOppoNonFixRuntimePermssion(userId, supportRuntimeAlert);
                }
            } catch (Exception e) {
            }
        }
        if (this.mPermissionReviewRequired) {
            updatePermissionsLPw(null, null, 5);
        }
    }

    public VerifierDeviceIdentity getVerifierDeviceIdentity() throws RemoteException {
        VerifierDeviceIdentity verifierDeviceIdentityLPw;
        this.mContext.enforceCallingOrSelfPermission("android.permission.PACKAGE_VERIFICATION_AGENT", "Only package verification agents can read the verifier device identity");
        synchronized (this.mPackages) {
            verifierDeviceIdentityLPw = this.mSettings.getVerifierDeviceIdentityLPw();
        }
        return verifierDeviceIdentityLPw;
    }

    public void setPermissionEnforced(String permission, boolean enforced) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.GRANT_RUNTIME_PERMISSIONS", "setPermissionEnforced");
        if ("android.permission.READ_EXTERNAL_STORAGE".equals(permission)) {
            synchronized (this.mPackages) {
                if (this.mSettings.mReadExternalStorageEnforced == null || this.mSettings.mReadExternalStorageEnforced.booleanValue() != enforced) {
                    this.mSettings.mReadExternalStorageEnforced = Boolean.valueOf(enforced);
                    this.mSettings.writeLPr();
                }
            }
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                long token = Binder.clearCallingIdentity();
                try {
                    am.killProcessesBelowForeground("setPermissionEnforcement");
                } catch (RemoteException e) {
                } finally {
                    Binder.restoreCallingIdentity(token);
                }
                return;
            }
            return;
        }
        throw new IllegalArgumentException("No selective enforcement for " + permission);
    }

    @Deprecated
    public boolean isPermissionEnforced(String permission) {
        return true;
    }

    public boolean isStorageLow() {
        long token = Binder.clearCallingIdentity();
        try {
            DeviceStorageMonitorInternal dsm = (DeviceStorageMonitorInternal) LocalServices.getService(DeviceStorageMonitorInternal.class);
            if (dsm != null) {
                boolean isMemoryLow = dsm.isMemoryLow();
                return isMemoryLow;
            }
            Binder.restoreCallingIdentity(token);
            return false;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public IPackageInstaller getPackageInstaller() {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        return this.mInstallerService;
    }

    private boolean userNeedsBadging(int userId) {
        int index = this.mUserNeedsBadging.indexOfKey(userId);
        if (index >= 0) {
            return this.mUserNeedsBadging.valueAt(index);
        }
        long token = Binder.clearCallingIdentity();
        try {
            boolean b;
            UserInfo userInfo = sUserManager.getUserInfo(userId);
            if (userInfo == null || !userInfo.isManagedProfile()) {
                b = false;
            } else {
                b = true;
            }
            this.mUserNeedsBadging.put(userId, b);
            return b;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public KeySet getKeySetByAlias(String packageName, String alias) {
        if (packageName == null || alias == null) {
            return null;
        }
        KeySet keySet;
        synchronized (this.mPackages) {
            Package pkg = (Package) this.mPackages.get(packageName);
            if (pkg == null) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            } else if (filterAppAccessLPr(pkg.mExtras, Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                Slog.w(TAG, "KeySet requested for filtered package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            } else {
                keySet = new KeySet(this.mSettings.mKeySetManagerService.getKeySetByAliasAndPackageNameLPr(packageName, alias));
            }
        }
        return keySet;
    }

    public KeySet getSigningKeySet(String packageName) {
        if (packageName == null) {
            return null;
        }
        KeySet keySet;
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            Package pkg = (Package) this.mPackages.get(packageName);
            if (pkg == null) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            } else if (filterAppAccessLPr(pkg.mExtras, callingUid, callingUserId)) {
                Slog.w(TAG, "KeySet requested for filtered package: " + packageName + ", uid:" + callingUid);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            } else if (pkg.applicationInfo.uid == callingUid || 1000 == callingUid) {
                keySet = new KeySet(this.mSettings.mKeySetManagerService.getSigningKeySetByPackageNameLPr(packageName));
            } else {
                throw new SecurityException("May not access signing KeySet of other apps.");
            }
        }
        return keySet;
    }

    public boolean isPackageSignedByKeySet(String packageName, KeySet ks) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null || packageName == null || ks == null) {
            return false;
        }
        synchronized (this.mPackages) {
            Package pkg = (Package) this.mPackages.get(packageName);
            if (pkg == null || filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, UserHandle.getUserId(callingUid))) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
            IBinder ksh = ks.getToken();
            if (ksh instanceof KeySetHandle) {
                boolean packageIsSignedByLPr = this.mSettings.mKeySetManagerService.packageIsSignedByLPr(packageName, (KeySetHandle) ksh);
                return packageIsSignedByLPr;
            }
            return false;
        }
    }

    public boolean isPackageSignedByKeySetExactly(String packageName, KeySet ks) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null || packageName == null || ks == null) {
            return false;
        }
        synchronized (this.mPackages) {
            Package pkg = (Package) this.mPackages.get(packageName);
            if (pkg == null || filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, UserHandle.getUserId(callingUid))) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
            IBinder ksh = ks.getToken();
            if (ksh instanceof KeySetHandle) {
                boolean packageIsSignedByExactlyLPr = this.mSettings.mKeySetManagerService.packageIsSignedByExactlyLPr(packageName, (KeySetHandle) ksh);
                return packageIsSignedByExactlyLPr;
            }
            return false;
        }
    }

    private void deletePackageIfUnusedLPr(final String packageName) {
        PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
        if (!(ps == null || ps.isAnyInstalled(sUserManager.getUserIds()))) {
            this.mHandler.post(new Runnable() {
                public void run() {
                    PackageManagerService.this.deletePackageX(packageName, -1, 0, 2);
                }
            });
        }
    }

    private static void checkDowngrade(Package before, PackageInfoLite after) throws PackageManagerException {
        if (after.versionCode < before.mVersionCode) {
            throw new PackageManagerException(-25, "Update version code " + after.versionCode + " is older than current " + before.mVersionCode);
        } else if (after.versionCode != before.mVersionCode) {
        } else {
            if (after.baseRevisionCode < before.baseRevisionCode) {
                throw new PackageManagerException(-25, "Update base revision code " + after.baseRevisionCode + " is older than current " + before.baseRevisionCode);
            } else if (!ArrayUtils.isEmpty(after.splitNames)) {
                int i = 0;
                while (i < after.splitNames.length) {
                    String splitName = after.splitNames[i];
                    int j = ArrayUtils.indexOf(before.splitNames, splitName);
                    if (j == -1 || after.splitRevisionCodes[i] >= before.splitRevisionCodes[j]) {
                        i++;
                    } else {
                        throw new PackageManagerException(-25, "Update split " + splitName + " revision code " + after.splitRevisionCodes[i] + " is older than current " + before.splitRevisionCodes[j]);
                    }
                }
            }
        }
    }

    public void grantDefaultPermissionsToEnabledCarrierApps(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("grantPermissionsToEnabledCarrierApps");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToEnabledCarrierAppsLPr(packageNames, userId);
                Binder.restoreCallingIdentity(identity);
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public void grantDefaultPermissionsToEnabledImsServices(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("grantDefaultPermissionsToEnabledImsServices");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToEnabledImsServicesLPr(packageNames, userId);
                Binder.restoreCallingIdentity(identity);
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    private static void enforceSystemOrPhoneCaller(String tag) {
        int callingUid = Binder.getCallingUid();
        if (callingUid != 1001 && callingUid != 1000) {
            throw new SecurityException("Cannot call " + tag + " from UID " + callingUid);
        }
    }

    boolean isHistoricalPackageUsageAvailable() {
        return this.mPackageUsage.isHistoricalPackageUsageAvailable();
    }

    Collection<Package> getPackages() {
        Collection arrayList;
        synchronized (this.mPackages) {
            arrayList = new ArrayList(this.mPackages.values());
        }
        return arrayList;
    }

    public void logAppProcessStartIfNeeded(String processName, int uid, String seinfo, String apkFile, int pid) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && SecurityLog.isLoggingEnabled()) {
            Bundle data = new Bundle();
            data.putLong("startTimestamp", System.currentTimeMillis());
            data.putString("processName", processName);
            data.putInt("uid", uid);
            data.putString("seinfo", seinfo);
            data.putString("apkFile", apkFile);
            data.putInt("pid", pid);
            Message msg = this.mProcessLoggingHandler.obtainMessage(1);
            msg.setData(data);
            this.mProcessLoggingHandler.sendMessage(msg);
        }
    }

    @OppoHook(level = OppoHookType.NEW_METHOD, note = "Bin.Wang@Plf.Framework,2017.02.21:modify for guest mode", property = OppoRomType.ROM)
    private void sendOppoPackageChangedBroadcast(String packageName, boolean killFlag, ArrayList<String> componentNames, int packageUid, int callPid) {
        if (DEBUG_INSTALL) {
            Log.v(TAG, "Sending package changed: package=" + packageName + " components=" + componentNames);
        }
        Bundle extras = new Bundle(5);
        extras.putString("android.intent.extra.changed_component_name", (String) componentNames.get(0));
        String[] nameList = new String[componentNames.size()];
        componentNames.toArray(nameList);
        extras.putStringArray("android.intent.extra.changed_component_name_list", nameList);
        extras.putBoolean("android.intent.extra.DONT_KILL_APP", killFlag);
        extras.putInt("android.intent.extra.UID", packageUid);
        extras.putInt("android.intent.action.TRIGGER_PACKAGE", callPid);
        sendPackageBroadcast("android.intent.action.PACKAGE_CHANGED", packageName, extras, !componentNames.contains(packageName) ? 1073741824 : 0, null, null, new int[]{UserHandle.getUserId(packageUid)});
    }

    private boolean isBootFromOTA() {
        String otaFilePath = "/cache/recovery/intent";
        String OTA_UPDATE_OK = "0";
        String OTA_UPDATE_FAILED = "1";
        String RECOVER_UPDATE_OK = "2";
        String RECOVER_UPDATE_FAILED = "3";
        if (new File(otaFilePath).exists()) {
            Slog.i(TAG, "/cache/recovery/intent file is exist!!!");
            String otaResultStr = readOTAUpdateResult(otaFilePath);
            if (OTA_UPDATE_OK.equals(otaResultStr)) {
                if (DEBUG_PMS || DEBUG_PACKAGE_SCANNING) {
                    Slog.i(TAG, "is boot from OTA");
                }
                return true;
            } else if (OTA_UPDATE_FAILED.equals(otaResultStr)) {
                if (DEBUG_PMS || DEBUG_PACKAGE_SCANNING) {
                    Slog.i(TAG, "not boot from OTA,normal boot");
                }
                return false;
            } else if (RECOVER_UPDATE_OK.equals(otaResultStr)) {
                if (DEBUG_PMS || DEBUG_PACKAGE_SCANNING) {
                    Slog.i(TAG, "is boot from recover");
                }
                return true;
            } else if (RECOVER_UPDATE_FAILED.equals(otaResultStr)) {
                if (DEBUG_PMS || DEBUG_PACKAGE_SCANNING) {
                    Slog.i(TAG, "not boot from recover,normal boot");
                }
                return false;
            } else {
                if (DEBUG_PMS || DEBUG_PACKAGE_SCANNING) {
                    Slog.i(TAG, "OTA update file's date is invalid,normal boot");
                }
                return false;
            }
        }
        if (DEBUG_PACKAGE_SCANNING) {
            Slog.i(TAG, "OTA file path is no exist,normal boot");
        }
        return false;
    }

    private static String readOTAUpdateResult(String fileName) {
        IOException e;
        Throwable th;
        String resultStr = null;
        BufferedReader reader = null;
        try {
            BufferedReader reader2 = new BufferedReader(new FileReader(new File(fileName)));
            try {
                resultStr = reader2.readLine();
                if (reader2 != null) {
                    try {
                        reader2.close();
                    } catch (IOException e1) {
                        Slog.e(TAG, "readOTAUpdateResult close the reader failed!!!", e1);
                    }
                }
                reader = reader2;
            } catch (IOException e2) {
                e = e2;
                reader = reader2;
            } catch (Throwable th2) {
                th = th2;
                reader = reader2;
                if (reader != null) {
                    try {
                        reader.close();
                    } catch (IOException e12) {
                        Slog.e(TAG, "readOTAUpdateResult close the reader failed!!!", e12);
                    }
                }
                throw th;
            }
        } catch (IOException e3) {
            e = e3;
            try {
                Slog.e(TAG, "readOTAUpdateResult failed!!!", e);
                if (reader != null) {
                    try {
                        reader.close();
                    } catch (IOException e122) {
                        Slog.e(TAG, "readOTAUpdateResult close the reader failed!!!", e122);
                    }
                }
                return resultStr;
            } catch (Throwable th3) {
                th = th3;
                if (reader != null) {
                    try {
                        reader.close();
                    } catch (IOException e1222) {
                        Slog.e(TAG, "readOTAUpdateResult close the reader failed!!!", e1222);
                    }
                }
                throw th;
            }
        }
        return resultStr;
    }

    public boolean isFullFunctionMode() {
        return this.mIsCtsAppInstall;
    }

    public boolean isClosedSuperFirewall() {
        return this.mIsCtsAppInstall;
    }

    public Bitmap getAppIconBitmap(String packageName) {
        return (Bitmap) mAppIconsCache.get(packageName);
    }

    public Map<String, Bitmap> getAppIconsCache(boolean compress) {
        if (compress) {
            return mAppIconsCacheCompress;
        }
        return mAppIconsCache;
    }

    public boolean isSecurePayApp(String pkg) {
        if (ColorPackageManagerHelper.isSupportSecurePay()) {
            return ColorSecurePayManager.getInstance().isSecurePayApp(pkg);
        }
        Slog.d(TAG, "this is not support securepay");
        return false;
    }

    private boolean isSystemAppCall() {
        boolean isSystemCaller = true;
        if (!hasSystemFeature(OPPO_SECURITYPAY_FEATURE, 0)) {
            return true;
        }
        int callingUid = Binder.getCallingUid();
        String callerName = getNameForUid(callingUid);
        if (callingUid < 10000) {
            isSystemCaller = true;
        } else if (callerName != null) {
            if (callerName.contains(":")) {
                String[] shareName = callerName.split(":");
                if (!(shareName[0] == null || shareName[1] == null)) {
                    Slog.d(TAG, " getInstalledPackages shareName = " + shareName[0]);
                    if (OppoPackageManagerHelper.isShareUid(shareName[0])) {
                        return true;
                    }
                    String[] shareUidPkg = getPackagesForUid(Integer.parseInt(shareName[1]));
                    if (!(shareUidPkg == null || shareUidPkg[0] == null)) {
                        Slog.d(TAG, " getInstalledPackages shareUidPkg = " + shareUidPkg[0]);
                        isSystemCaller = ColorPackageManagerHelper.isOppoApkList(shareUidPkg[0]);
                    }
                }
            } else {
                isSystemCaller = !ColorPackageManagerHelper.isOppoApkList(callerName) ? isSecurePayApp(callerName) : true;
            }
            if (DEBUG_INSTALL) {
                Slog.d(TAG, " getInstalledPackages callerName = " + callerName);
            }
        }
        return isSystemCaller;
    }

    public Map<String, Bitmap> getActivityIconsCache(IPackageDeleteObserver observer) {
        Preconditions.checkNotNull(observer);
        Integer uid = Integer.valueOf(Binder.getCallingUid());
        if (this.mPackageDeleteList.get(uid) != null) {
            this.mPackageDeleteList.remove(uid);
        }
        this.mPackageDeleteList.put(uid, observer);
        return mActivityIconsCache;
    }

    public PackageStats getCompilerPackageStats(String pkgName) {
        return this.mCompilerStats.getPackageStats(pkgName);
    }

    public PackageStats getOrCreateCompilerPackageStats(Package pkg) {
        return getOrCreateCompilerPackageStats(pkg.packageName);
    }

    public PackageStats getOrCreateCompilerPackageStats(String pkgName) {
        return this.mCompilerStats.getOrCreatePackageStats(pkgName);
    }

    public void deleteCompilerPackageStats(String pkgName) {
        this.mCompilerStats.deletePackageStats(pkgName);
    }

    private boolean checkAppInstallPermission(String pkgName) {
        if (pkgName == null) {
            Slog.i(TAG, "pkgname is null!!");
            return false;
        } else if (this.mBlackAppInstallHelper == null) {
            Slog.i(TAG, "mBlackAppInstallHelper is null!!!");
            return false;
        } else if (!this.mBlackAppInstallHelper.getBlackAppList().contains(pkgName)) {
            return true;
        } else {
            Slog.i(TAG, "black install app list contains " + pkgName);
            return false;
        }
    }

    public boolean isSystemDataApp(String packageName) {
        return ColorPackageManagerHelper.isSystemDataApp(packageName);
    }

    private void operatorAppCopy(String operatorDir) {
        File apkPath = new File(Environment.getDataDirectory(), operatorDir);
        if (apkPath.exists()) {
            File[] listFile = apkPath.listFiles();
            if (listFile == null || listFile.length < 1) {
                Slog.d(TAG, "operatorAppCopy no file in " + apkPath);
                return;
            }
            for (File apkFile : listFile) {
                try {
                    Slog.d(TAG, "copy apk to " + this.mAppInstallDir + ":" + apkFile);
                    PackageLite pkg = PackageParser.parsePackageLite(apkFile, 2);
                    if (pkg == null) {
                        Slog.i(TAG, "reserve package null, error!!!");
                    } else if (this.mSettings.mPackages.containsKey(pkg.packageName)) {
                        Slog.i(TAG, "apk:" + pkg.packageName + " has been installed, skip");
                    } else {
                        File destFile = new File(this.mAppInstallDir, apkFile.getName());
                        Slog.i(TAG, "apk:" + pkg.packageName + " has NOT been installed, copy it to " + destFile.getPath() + "......");
                        FileUtils.copyFile(apkFile, destFile);
                        FileUtils.setPermissions(destFile.getPath(), 420, -1, -1);
                    }
                } catch (PackageParserException e) {
                    Slog.e(TAG, "copy file to " + this.mAppInstallDir + " error!!!");
                }
            }
        }
    }

    private List<String> loadCustomizeWhiteList(String path) {
        IOException e;
        NullPointerException e2;
        NumberFormatException e3;
        XmlPullParserException e4;
        IndexOutOfBoundsException e5;
        Throwable th;
        ArrayList<String> emptyList = new ArrayList();
        File file = new File(path);
        if (file.exists()) {
            ArrayList<String> ret = new ArrayList();
            FileInputStream stream = null;
            boolean success = false;
            try {
                FileInputStream stream2 = new FileInputStream(file);
                try {
                    XmlPullParser parser = Xml.newPullParser();
                    parser.setInput(stream2, null);
                    int type;
                    do {
                        type = parser.next();
                        if (type == 2) {
                            if (OppoCrashClearManager.CRASH_CLEAR_NAME.equals(parser.getName())) {
                                String value = parser.getAttributeValue(null, "att");
                                if (value != null) {
                                    ret.add(value);
                                }
                            }
                        }
                    } while (type != 1);
                    success = true;
                    if (stream2 != null) {
                        try {
                            stream2.close();
                        } catch (IOException e6) {
                            e6.printStackTrace();
                        }
                    }
                    stream = stream2;
                } catch (NullPointerException e7) {
                    e2 = e7;
                    stream = stream2;
                    Slog.w(TAG, "failed parsing ", e2);
                    if (stream != null) {
                        try {
                            stream.close();
                        } catch (IOException e62) {
                            e62.printStackTrace();
                        }
                    }
                    if (!success) {
                        return ret;
                    }
                    Slog.w(TAG, path + " file failed parsing!");
                    return emptyList;
                } catch (NumberFormatException e8) {
                    e3 = e8;
                    stream = stream2;
                    Slog.w(TAG, "failed parsing ", e3);
                    if (stream != null) {
                        try {
                            stream.close();
                        } catch (IOException e622) {
                            e622.printStackTrace();
                        }
                    }
                    if (!success) {
                        return ret;
                    }
                    Slog.w(TAG, path + " file failed parsing!");
                    return emptyList;
                } catch (XmlPullParserException e9) {
                    e4 = e9;
                    stream = stream2;
                    Slog.w(TAG, "failed parsing ", e4);
                    if (stream != null) {
                        try {
                            stream.close();
                        } catch (IOException e6222) {
                            e6222.printStackTrace();
                        }
                    }
                    if (!success) {
                        return ret;
                    }
                    Slog.w(TAG, path + " file failed parsing!");
                    return emptyList;
                } catch (IOException e10) {
                    e6222 = e10;
                    stream = stream2;
                    Slog.w(TAG, "failed parsing ", e6222);
                    if (stream != null) {
                        try {
                            stream.close();
                        } catch (IOException e62222) {
                            e62222.printStackTrace();
                        }
                    }
                    if (!success) {
                        return ret;
                    }
                    Slog.w(TAG, path + " file failed parsing!");
                    return emptyList;
                } catch (IndexOutOfBoundsException e11) {
                    e5 = e11;
                    stream = stream2;
                    try {
                        Slog.w(TAG, "failed parsing ", e5);
                        if (stream != null) {
                            try {
                                stream.close();
                            } catch (IOException e622222) {
                                e622222.printStackTrace();
                            }
                        }
                        if (!success) {
                            return ret;
                        }
                        Slog.w(TAG, path + " file failed parsing!");
                        return emptyList;
                    } catch (Throwable th2) {
                        th = th2;
                        if (stream != null) {
                            try {
                                stream.close();
                            } catch (IOException e6222222) {
                                e6222222.printStackTrace();
                            }
                        }
                        throw th;
                    }
                } catch (Throwable th3) {
                    th = th3;
                    stream = stream2;
                    if (stream != null) {
                        try {
                            stream.close();
                        } catch (IOException e62222222) {
                            e62222222.printStackTrace();
                        }
                    }
                    throw th;
                }
            } catch (NullPointerException e12) {
                e2 = e12;
                Slog.w(TAG, "failed parsing ", e2);
                if (stream != null) {
                    try {
                        stream.close();
                    } catch (IOException e622222222) {
                        e622222222.printStackTrace();
                    }
                }
                if (!success) {
                    return ret;
                }
                Slog.w(TAG, path + " file failed parsing!");
                return emptyList;
            } catch (NumberFormatException e13) {
                e3 = e13;
                Slog.w(TAG, "failed parsing ", e3);
                if (stream != null) {
                    try {
                        stream.close();
                    } catch (IOException e6222222222) {
                        e6222222222.printStackTrace();
                    }
                }
                if (!success) {
                    return ret;
                }
                Slog.w(TAG, path + " file failed parsing!");
                return emptyList;
            } catch (XmlPullParserException e14) {
                e4 = e14;
                Slog.w(TAG, "failed parsing ", e4);
                if (stream != null) {
                    try {
                        stream.close();
                    } catch (IOException e62222222222) {
                        e62222222222.printStackTrace();
                    }
                }
                if (!success) {
                    return ret;
                }
                Slog.w(TAG, path + " file failed parsing!");
                return emptyList;
            } catch (IOException e15) {
                e62222222222 = e15;
                Slog.w(TAG, "failed parsing ", e62222222222);
                if (stream != null) {
                    try {
                        stream.close();
                    } catch (IOException e622222222222) {
                        e622222222222.printStackTrace();
                    }
                }
                if (!success) {
                    return ret;
                }
                Slog.w(TAG, path + " file failed parsing!");
                return emptyList;
            } catch (IndexOutOfBoundsException e16) {
                e5 = e16;
                Slog.w(TAG, "failed parsing ", e5);
                if (stream != null) {
                    try {
                        stream.close();
                    } catch (IOException e6222222222222) {
                        e6222222222222.printStackTrace();
                    }
                }
                if (!success) {
                    return ret;
                }
                Slog.w(TAG, path + " file failed parsing!");
                return emptyList;
            }
            if (!success) {
                return ret;
            }
            Slog.w(TAG, path + " file failed parsing!");
            return emptyList;
        }
        Slog.w(TAG, path + " file don't exist!");
        return emptyList;
    }

    private boolean checkWhiteList(String packageName) {
        if (this.mCustomizeList == null || this.mCustomizeList.size() <= 0 || packageName == null) {
            return false;
        }
        try {
            for (String pkg : this.mCustomizeList) {
                if (pkg.equalsIgnoreCase(packageName)) {
                    return true;
                }
            }
            return false;
        } catch (Exception e) {
            Slog.w(TAG, "check white list has exception! ", e);
            return false;
        }
    }

    public boolean isInstallSourceEnable() {
        return SystemProperties.getBoolean("persist.sys.oppo.installsource", false);
    }

    public List<String> getInstallSourceList() {
        return this.mSettings.getInstalledSourceList();
    }

    public void enableInstallSource(boolean enable) {
        if (!hasSystemFeature("oppo.customize.function.control_app_install", 0)) {
            return;
        }
        if (!enable) {
            SystemProperties.set("persist.sys.oppo.installsource", "false");
        } else if (!SystemProperties.getBoolean("persist.sys.oppo.installsource", false)) {
            SystemProperties.set("persist.sys.oppo.installsource", "true");
            this.mSettings.addMarketName("com.ctsi.emm");
        }
    }

    public void addInstallSource(String pkgName) {
        if (hasSystemFeature("oppo.customize.function.control_app_install", 0)) {
            this.mSettings.addMarketName(pkgName);
        }
    }

    public void deleteInstallSource(String pkgName) {
        if (hasSystemFeature("oppo.customize.function.control_app_install", 0)) {
            this.mSettings.deleteMarketName(pkgName);
        }
    }

    public void addDisallowUninstallApps(List<String> packageNames) {
        if (hasSystemFeature("oppo.customize.function.control_app_install", 0)) {
            this.mSettings.addUninstalledAppName(packageNames);
        }
    }

    public void removeDisallowUninstallApps(List<String> packageNames) {
        if (hasSystemFeature("oppo.customize.function.control_app_install", 0)) {
            this.mSettings.deleteUninstalledAppName(packageNames);
        }
    }

    public List<String> getDisallowUninstallApps() {
        return this.mSettings.getUninstalledAppNames();
    }

    private void sendBroadcastForArmy() {
        this.mContext.sendBroadcast(new Intent("android.intent.action.OPPO_INSTALL_FOR_ARMY"));
    }

    public void addInstallPackageWhitelist(int mode, List<String> applist) {
        if (hasSystemFeature("oppo.customize.function.control_app_install", 0)) {
            this.mSettings.addInstallPackageWhitelist(mode, applist);
        }
    }

    public void addInstallPackageBlacklist(int mode, List<String> applist) {
        if (hasSystemFeature("oppo.customize.function.control_app_install", 0)) {
            this.mSettings.addInstallPackageBlacklist(mode, applist);
        }
    }

    public String checkEMMApkRuntimePermission(String packageName) {
        int i = 0;
        if (!hasSystemFeature("oppo.customize.function.checkpermission", 0)) {
            return "Permission Denial: has not com.chinatelecom.permission.security.EMM";
        }
        int uid = Binder.getCallingUid();
        String[] packageNames = getPackagesForUid(uid);
        boolean found = false;
        int length = packageNames.length;
        while (i < length) {
            if (packageNames[i].equals(packageName)) {
                found = true;
                break;
            }
            i++;
        }
        if (!found) {
            return "Can't find package " + packageName;
        }
        if (checkUidPermission("com.chinatelecom.permission.security.EMM", uid) != 0) {
            return "Permission Denial: has not com.chinatelecom.permission.security.EMM";
        }
        Package pkg;
        synchronized (this.mPackages) {
            pkg = (Package) this.mPackages.get(packageName);
        }
        if (pkg == null) {
            return "Can't find package " + packageName;
        }
        return "";
    }

    private boolean getImeiNumber(Context context) {
        String imei = ((TelephonyManager) context.getSystemService("phone")).getDeviceId();
        if (imei == null || imei.equals("")) {
            Slog.d(TAG, "getImeiNumber  false");
            return false;
        }
        Slog.d(TAG, "getImeiNumber  true");
        int len = imei.length();
        if (len < 14) {
            Slog.d(TAG, "getImeiNumber length =" + len);
            return false;
        }
        Slog.d(TAG, "getImeiNumber  =" + imei);
        return true;
    }

    public int adjustBackgroundInstallerParameter(String installerPackageName, int installFlags) {
        if (!EXP_VERSION || installerPackageName == null) {
            return installFlags;
        }
        String pkgName = null;
        ActivityManager am = (ActivityManager) this.mContext.getSystemService(OppoAppStartupManager.TYPE_ACTIVITY);
        if (am == null) {
            return installFlags;
        }
        ComponentName cn = am.getTopAppName();
        if (cn != null) {
            pkgName = cn.getPackageName();
        }
        if (pkgName == null || installerPackageName.equals(pkgName)) {
            return installFlags;
        }
        for (int i = 0; i < this.mPackageInstaller.length; i++) {
            if (this.mPackageInstaller[i].equals(installerPackageName)) {
                installFlags |= Integer.MIN_VALUE;
                Slog.i(TAG, "" + this.mPackageInstaller[i] + " installFlags with INSTALL_SPEED_BACKGROUND");
                return installFlags;
            }
        }
        return installFlags;
    }

    private void sendNonSilentInstallBroadcastExp(String installerPackageName, OriginInfo origin, PackageInstalledInfo res, int childPackageCount, int childPackageIndex) {
        if (installerPackageName != null && installerPackageName.equals("com.google.android.packageinstaller")) {
            String extraInstallerExp;
            synchronized (this.mRunningInstallerPkgName) {
                extraInstallerExp = (String) this.mRunningInstallerPkgName.get(origin);
                if (childPackageCount <= 0 || childPackageIndex + 1 >= childPackageCount) {
                    this.mRunningInstallerPkgName.remove(origin);
                }
            }
            Slog.i(TAG, "origin : " + origin.toString() + " packageName: " + res.pkg.applicationInfo.packageName + " extraInstallerExp: " + extraInstallerExp);
            boolean update = (res.removedInfo == null || res.removedInfo.removedPackage == null) ? false : true;
            if (extraInstallerExp != null && extraInstallerExp.length() > 0) {
                ColorPackageManagerHelper.sendDcsNonSilentInstallBroadcastExp(res.pkg.applicationInfo.packageName, update, extraInstallerExp, 0);
            }
        }
    }

    public int getInstallReason(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        enforceCrossUserPermission(callingUid, userId, true, false, "get install reason");
        synchronized (this.mPackages) {
            PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(packageName);
            if (filterAppAccessLPr(ps, callingUid, userId)) {
                return 0;
            } else if (ps != null) {
                int installReason = ps.getInstallReason(userId);
                return installReason;
            } else {
                return 0;
            }
        }
    }

    public boolean canRequestPackageInstalls(String packageName, int userId) {
        return canRequestPackageInstallsInternal(packageName, 0, userId, true);
    }

    private boolean canRequestPackageInstallsInternal(String packageName, int flags, int userId, boolean throwIfPermNotDeclared) {
        boolean z = true;
        int callingUid = Binder.getCallingUid();
        int uid = getPackageUid(packageName, 0, userId);
        if (callingUid == uid || callingUid == 0 || callingUid == 1000) {
            ApplicationInfo info = getApplicationInfo(packageName, flags, userId);
            if (info == null || info.targetSdkVersion < 26) {
                return false;
            }
            String appOpPermission = "android.permission.REQUEST_INSTALL_PACKAGES";
            if (ArrayUtils.contains(getAppOpPermissionPackages(appOpPermission), packageName)) {
                if (sUserManager.hasUserRestriction("no_install_unknown_sources", userId)) {
                    return false;
                }
                if (this.mExternalSourcesPolicy != null) {
                    int isTrusted = this.mExternalSourcesPolicy.getPackageTrustedToInstallApps(packageName, uid);
                    if (isTrusted != 2) {
                        if (isTrusted != 0) {
                            z = false;
                        }
                        return z;
                    }
                }
                if (checkUidPermission(appOpPermission, uid) != 0) {
                    z = false;
                }
                return z;
            } else if (throwIfPermNotDeclared) {
                throw new SecurityException("Need to declare " + appOpPermission + " to call this api");
            } else {
                Slog.e(TAG, "Need to declare " + appOpPermission + " to call this api");
                return false;
            }
        }
        throw new SecurityException("Caller uid " + callingUid + " does not own package " + packageName);
    }

    public ComponentName getInstantAppResolverSettingsComponent() {
        return this.mInstantAppResolverSettingsComponent;
    }

    public ComponentName getInstantAppInstallerComponent() {
        ComponentName componentName = null;
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        if (this.mInstantAppInstallerActivity != null) {
            componentName = this.mInstantAppInstallerActivity.getComponentName();
        }
        return componentName;
    }

    public String getInstantAppAndroidId(String packageName, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS", "getInstantAppAndroidId");
        enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getInstantAppAndroidId");
        if (!isInstantApp(packageName, userId)) {
            return null;
        }
        String instantAppAndroidIdLPw;
        synchronized (this.mPackages) {
            instantAppAndroidIdLPw = this.mInstantAppRegistry.getInstantAppAndroidIdLPw(packageName, userId);
        }
        return instantAppAndroidIdLPw;
    }

    boolean canHaveOatDir(String packageName) {
        synchronized (this.mPackages) {
            Package p = (Package) this.mPackages.get(packageName);
            if (p == null) {
                return false;
            }
            boolean canHaveOatDir = p.canHaveOatDir();
            return canHaveOatDir;
        }
    }

    private String getOatDir(Package pkg) {
        if (!pkg.canHaveOatDir()) {
            return null;
        }
        File codePath = new File(pkg.codePath);
        if (codePath.isDirectory()) {
            return PackageDexOptimizer.getOatDir(codePath).getAbsolutePath();
        }
        return null;
    }

    void deleteOatArtifactsOfPackage(String packageName) {
        Package pkg;
        synchronized (this.mPackages) {
            pkg = (Package) this.mPackages.get(packageName);
        }
        String[] instructionSets = InstructionSets.getAppDexInstructionSets(pkg.applicationInfo);
        List<String> codePaths = pkg.getAllCodePaths();
        String oatDir = getOatDir(pkg);
        for (String codePath : codePaths) {
            for (String isa : instructionSets) {
                try {
                    this.mInstaller.deleteOdex(codePath, isa, oatDir);
                } catch (InstallerException e) {
                    Log.e(TAG, "Failed deleting oat files for " + codePath, e);
                }
            }
        }
    }

    Set<String> getUnusedPackages(long downgradeTimeThresholdMillis) {
        Set<String> unusedPackages = new HashSet();
        long currentTimeInMillis = System.currentTimeMillis();
        synchronized (this.mPackages) {
            for (Package pkg : this.mPackages.values()) {
                PackageSetting ps = (PackageSetting) this.mSettings.mPackages.get(pkg.packageName);
                if (ps != null) {
                    if (PackageManagerServiceUtils.isUnusedSinceTimeInMillis(ps.firstInstallTime, currentTimeInMillis, downgradeTimeThresholdMillis, getDexManager().getPackageUseInfoOrDefault(pkg.packageName), pkg.getLatestPackageUseTimeInMills(), pkg.getLatestForegroundPackageUseTimeInMills())) {
                        unusedPackages.add(pkg.packageName);
                    }
                }
            }
        }
        return unusedPackages;
    }

    public boolean prohibitChildInstallation(int userId, boolean isInstall) {
        if (!EXP_VERSION || !hasSystemFeature("oppo.childspace.support", 0) || Global.getInt(this.mContext.getContentResolver(), "children_mode_on", 0) != 1) {
            return false;
        }
        UserHandle user = new UserHandle(userId);
        long identity = Binder.clearCallingIdentity();
        if (isInstall) {
            try {
                Slog.w(TAG, "prevent installation in children mode");
                this.mContext.sendBroadcastAsUser(new Intent("com.coloros.childrenspace.action.FORBID_INSTALL_PACKAGES"), user, "oppo.permission.OPPO_COMPONENT_SAFE");
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(identity);
            }
        } else {
            Slog.w(TAG, "prevent uninstallation in children mode");
            this.mContext.sendBroadcastAsUser(new Intent("com.coloros.childrenspace.action.FORBID_DELETE_PACKAGES"), user, "oppo.permission.OPPO_COMPONENT_SAFE");
        }
        Binder.restoreCallingIdentity(identity);
        return true;
    }

    private String getMiniProgramSignature(String miniProgramPkgName) {
        return OppoListManager.getInstance().getMiniProgramSignature(miniProgramPkgName);
    }

    private Signature[] asArray(Signature... s) {
        return s;
    }

    private PackageInfo getMiniProgramPackageInfo(String miniProgramPkgName, String miniProgramSignature) {
        PackageInfo pi = new PackageInfo();
        pi.packageName = miniProgramPkgName;
        pi.applicationInfo = new ApplicationInfo();
        pi.applicationInfo.packageName = miniProgramPkgName;
        pi.signatures = asArray(new Signature(miniProgramSignature));
        return pi;
    }
}
